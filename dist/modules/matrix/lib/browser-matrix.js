(function () { function r(e, n, t) { function o(i, f) { if (!n[i]) {
    if (!e[i]) {
        var c = "function" == typeof require && require;
        if (!f && c)
            return c(i, !0);
        if (u)
            return u(i, !0);
        var a = new Error("Cannot find module '" + i + "'");
        throw a.code = "MODULE_NOT_FOUND", a;
    }
    var p = n[i] = { exports: {} };
    e[i][0].call(p.exports, function (r) { var n = e[i][1][r]; return o(n || r); }, p, p.exports, r, e, n, t);
} return n[i].exports; } for (var u = "function" == typeof require && require, i = 0; i < t.length; i++)
    o(t[i]); return o; } return r; })()({ 1: [function (require, module, exports) {
            function _arrayLikeToArray(arr, len) {
                if (len == null || len > arr.length)
                    len = arr.length;
                for (var i = 0, arr2 = new Array(len); i < len; i++) {
                    arr2[i] = arr[i];
                }
                return arr2;
            }
            module.exports = _arrayLikeToArray;
        }, {}], 2: [function (require, module, exports) {
            function _arrayWithHoles(arr) {
                if (Array.isArray(arr))
                    return arr;
            }
            module.exports = _arrayWithHoles;
        }, {}], 3: [function (require, module, exports) {
            var arrayLikeToArray = require("./arrayLikeToArray");
            function _arrayWithoutHoles(arr) {
                if (Array.isArray(arr))
                    return arrayLikeToArray(arr);
            }
            module.exports = _arrayWithoutHoles;
        }, { "./arrayLikeToArray": 1 }], 4: [function (require, module, exports) {
            function _assertThisInitialized(self) {
                if (self === void 0) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return self;
            }
            module.exports = _assertThisInitialized;
        }, {}], 5: [function (require, module, exports) {
            function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
                try {
                    var info = gen[key](arg);
                    var value = info.value;
                }
                catch (error) {
                    reject(error);
                    return;
                }
                if (info.done) {
                    resolve(value);
                }
                else {
                    Promise.resolve(value).then(_next, _throw);
                }
            }
            function _asyncToGenerator(fn) {
                return function () {
                    var self = this, args = arguments;
                    return new Promise(function (resolve, reject) {
                        var gen = fn.apply(self, args);
                        function _next(value) {
                            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
                        }
                        function _throw(err) {
                            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
                        }
                        _next(undefined);
                    });
                };
            }
            module.exports = _asyncToGenerator;
        }, {}], 6: [function (require, module, exports) {
            function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                }
            }
            module.exports = _classCallCheck;
        }, {}], 7: [function (require, module, exports) {
            var setPrototypeOf = require("./setPrototypeOf");
            var isNativeReflectConstruct = require("./isNativeReflectConstruct");
            function _construct(Parent, args, Class) {
                if (isNativeReflectConstruct()) {
                    module.exports = _construct = Reflect.construct;
                }
                else {
                    module.exports = _construct = function _construct(Parent, args, Class) {
                        var a = [null];
                        a.push.apply(a, args);
                        var Constructor = Function.bind.apply(Parent, a);
                        var instance = new Constructor();
                        if (Class)
                            setPrototypeOf(instance, Class.prototype);
                        return instance;
                    };
                }
                return _construct.apply(null, arguments);
            }
            module.exports = _construct;
        }, { "./isNativeReflectConstruct": 15, "./setPrototypeOf": 21 }], 8: [function (require, module, exports) {
            function _defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                        descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            function _createClass(Constructor, protoProps, staticProps) {
                if (protoProps)
                    _defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                    _defineProperties(Constructor, staticProps);
                return Constructor;
            }
            module.exports = _createClass;
        }, {}], 9: [function (require, module, exports) {
            function _defineProperty(obj, key, value) {
                if (key in obj) {
                    Object.defineProperty(obj, key, {
                        value: value,
                        enumerable: true,
                        configurable: true,
                        writable: true
                    });
                }
                else {
                    obj[key] = value;
                }
                return obj;
            }
            module.exports = _defineProperty;
        }, {}], 10: [function (require, module, exports) {
            function _getPrototypeOf(o) {
                module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
                    return o.__proto__ || Object.getPrototypeOf(o);
                };
                return _getPrototypeOf(o);
            }
            module.exports = _getPrototypeOf;
        }, {}], 11: [function (require, module, exports) {
            var setPrototypeOf = require("./setPrototypeOf");
            function _inherits(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function");
                }
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                        value: subClass,
                        writable: true,
                        configurable: true
                    }
                });
                if (superClass)
                    setPrototypeOf(subClass, superClass);
            }
            module.exports = _inherits;
        }, { "./setPrototypeOf": 21 }], 12: [function (require, module, exports) {
            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                    "default": obj
                };
            }
            module.exports = _interopRequireDefault;
        }, {}], 13: [function (require, module, exports) {
            var _typeof = require("@babel/runtime/helpers/typeof");
            function _getRequireWildcardCache() {
                if (typeof WeakMap !== "function")
                    return null;
                var cache = new WeakMap();
                _getRequireWildcardCache = function _getRequireWildcardCache() {
                    return cache;
                };
                return cache;
            }
            function _interopRequireWildcard(obj) {
                if (obj && obj.__esModule) {
                    return obj;
                }
                if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
                    return {
                        "default": obj
                    };
                }
                var cache = _getRequireWildcardCache();
                if (cache && cache.has(obj)) {
                    return cache.get(obj);
                }
                var newObj = {};
                var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
                for (var key in obj) {
                    if (Object.prototype.hasOwnProperty.call(obj, key)) {
                        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
                        if (desc && (desc.get || desc.set)) {
                            Object.defineProperty(newObj, key, desc);
                        }
                        else {
                            newObj[key] = obj[key];
                        }
                    }
                }
                newObj["default"] = obj;
                if (cache) {
                    cache.set(obj, newObj);
                }
                return newObj;
            }
            module.exports = _interopRequireWildcard;
        }, { "@babel/runtime/helpers/typeof": 24 }], 14: [function (require, module, exports) {
            function _isNativeFunction(fn) {
                return Function.toString.call(fn).indexOf("[native code]") !== -1;
            }
            module.exports = _isNativeFunction;
        }, {}], 15: [function (require, module, exports) {
            function _isNativeReflectConstruct() {
                if (typeof Reflect === "undefined" || !Reflect.construct)
                    return false;
                if (Reflect.construct.sham)
                    return false;
                if (typeof Proxy === "function")
                    return true;
                try {
                    Date.prototype.toString.call(Reflect.construct(Date, [], function () { }));
                    return true;
                }
                catch (e) {
                    return false;
                }
            }
            module.exports = _isNativeReflectConstruct;
        }, {}], 16: [function (require, module, exports) {
            function _iterableToArray(iter) {
                if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
                    return Array.from(iter);
            }
            module.exports = _iterableToArray;
        }, {}], 17: [function (require, module, exports) {
            function _iterableToArrayLimit(arr, i) {
                if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
                    return;
                var _arr = [];
                var _n = true;
                var _d = false;
                var _e = undefined;
                try {
                    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                        _arr.push(_s.value);
                        if (i && _arr.length === i)
                            break;
                    }
                }
                catch (err) {
                    _d = true;
                    _e = err;
                }
                finally {
                    try {
                        if (!_n && _i["return"] != null)
                            _i["return"]();
                    }
                    finally {
                        if (_d)
                            throw _e;
                    }
                }
                return _arr;
            }
            module.exports = _iterableToArrayLimit;
        }, {}], 18: [function (require, module, exports) {
            function _nonIterableRest() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            module.exports = _nonIterableRest;
        }, {}], 19: [function (require, module, exports) {
            function _nonIterableSpread() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            module.exports = _nonIterableSpread;
        }, {}], 20: [function (require, module, exports) {
            var _typeof = require("@babel/runtime/helpers/typeof");
            var assertThisInitialized = require("./assertThisInitialized");
            function _possibleConstructorReturn(self, call) {
                if (call && (_typeof(call) === "object" || typeof call === "function")) {
                    return call;
                }
                return assertThisInitialized(self);
            }
            module.exports = _possibleConstructorReturn;
        }, { "./assertThisInitialized": 4, "@babel/runtime/helpers/typeof": 24 }], 21: [function (require, module, exports) {
            function _setPrototypeOf(o, p) {
                module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
                    o.__proto__ = p;
                    return o;
                };
                return _setPrototypeOf(o, p);
            }
            module.exports = _setPrototypeOf;
        }, {}], 22: [function (require, module, exports) {
            var arrayWithHoles = require("./arrayWithHoles");
            var iterableToArrayLimit = require("./iterableToArrayLimit");
            var unsupportedIterableToArray = require("./unsupportedIterableToArray");
            var nonIterableRest = require("./nonIterableRest");
            function _slicedToArray(arr, i) {
                return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
            }
            module.exports = _slicedToArray;
        }, { "./arrayWithHoles": 2, "./iterableToArrayLimit": 17, "./nonIterableRest": 18, "./unsupportedIterableToArray": 25 }], 23: [function (require, module, exports) {
            var arrayWithoutHoles = require("./arrayWithoutHoles");
            var iterableToArray = require("./iterableToArray");
            var unsupportedIterableToArray = require("./unsupportedIterableToArray");
            var nonIterableSpread = require("./nonIterableSpread");
            function _toConsumableArray(arr) {
                return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
            }
            module.exports = _toConsumableArray;
        }, { "./arrayWithoutHoles": 3, "./iterableToArray": 16, "./nonIterableSpread": 19, "./unsupportedIterableToArray": 25 }], 24: [function (require, module, exports) {
            function _typeof(obj) {
                "@babel/helpers - typeof";
                if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                    module.exports = _typeof = function _typeof(obj) {
                        return typeof obj;
                    };
                }
                else {
                    module.exports = _typeof = function _typeof(obj) {
                        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                    };
                }
                return _typeof(obj);
            }
            module.exports = _typeof;
        }, {}], 25: [function (require, module, exports) {
            var arrayLikeToArray = require("./arrayLikeToArray");
            function _unsupportedIterableToArray(o, minLen) {
                if (!o)
                    return;
                if (typeof o === "string")
                    return arrayLikeToArray(o, minLen);
                var n = Object.prototype.toString.call(o).slice(8, -1);
                if (n === "Object" && o.constructor)
                    n = o.constructor.name;
                if (n === "Map" || n === "Set")
                    return Array.from(o);
                if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                    return arrayLikeToArray(o, minLen);
            }
            module.exports = _unsupportedIterableToArray;
        }, { "./arrayLikeToArray": 1 }], 26: [function (require, module, exports) {
            var getPrototypeOf = require("./getPrototypeOf");
            var setPrototypeOf = require("./setPrototypeOf");
            var isNativeFunction = require("./isNativeFunction");
            var construct = require("./construct");
            function _wrapNativeSuper(Class) {
                var _cache = typeof Map === "function" ? new Map() : undefined;
                module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {
                    if (Class === null || !isNativeFunction(Class))
                        return Class;
                    if (typeof Class !== "function") {
                        throw new TypeError("Super expression must either be null or a function");
                    }
                    if (typeof _cache !== "undefined") {
                        if (_cache.has(Class))
                            return _cache.get(Class);
                        _cache.set(Class, Wrapper);
                    }
                    function Wrapper() {
                        return construct(Class, arguments, getPrototypeOf(this).constructor);
                    }
                    Wrapper.prototype = Object.create(Class.prototype, {
                        constructor: {
                            value: Wrapper,
                            enumerable: false,
                            writable: true,
                            configurable: true
                        }
                    });
                    return setPrototypeOf(Wrapper, Class);
                };
                return _wrapNativeSuper(Class);
            }
            module.exports = _wrapNativeSuper;
        }, { "./construct": 7, "./getPrototypeOf": 10, "./isNativeFunction": 14, "./setPrototypeOf": 21 }], 27: [function (require, module, exports) {
            module.exports = require("regenerator-runtime");
        }, { "regenerator-runtime": 47 }], 28: [function (require, module, exports) {
            'use strict';
            var escaped = /[\\\"\x00-\x1F]/g;
            var escapes = {};
            for (var i = 0; i < 0x20; ++i) {
                escapes[String.fromCharCode(i)] = ('\\U' + ('0000' + i.toString(16)).slice(-4).toUpperCase());
            }
            escapes['\b'] = '\\b';
            escapes['\t'] = '\\t';
            escapes['\n'] = '\\n';
            escapes['\f'] = '\\f';
            escapes['\r'] = '\\r';
            escapes['\"'] = '\\\"';
            escapes['\\'] = '\\\\';
            function escapeString(value) {
                escaped.lastIndex = 0;
                return value.replace(escaped, function (c) { return escapes[c]; });
            }
            function stringify(value) {
                switch (typeof value) {
                    case 'string':
                        return '"' + escapeString(value) + '"';
                    case 'number':
                        return isFinite(value) ? value : 'null';
                    case 'boolean':
                        return value;
                    case 'object':
                        if (value === null) {
                            return 'null';
                        }
                        if (Array.isArray(value)) {
                            return stringifyArray(value);
                        }
                        return stringifyObject(value);
                    default:
                        throw new Error('Cannot stringify: ' + typeof value);
                }
            }
            function stringifyArray(array) {
                var sep = '[';
                var result = '';
                for (var i = 0; i < array.length; ++i) {
                    result += sep;
                    sep = ',';
                    result += stringify(array[i]);
                }
                if (sep != ',') {
                    return '[]';
                }
                else {
                    return result + ']';
                }
            }
            function stringifyObject(object) {
                var sep = '{';
                var result = '';
                var keys = Object.keys(object);
                keys.sort();
                for (var i = 0; i < keys.length; ++i) {
                    var key = keys[i];
                    result += sep + '"' + escapeString(key) + '":';
                    sep = ',';
                    result += stringify(object[key]);
                }
                if (sep != ',') {
                    return '{}';
                }
                else {
                    return result + '}';
                }
            }
            module.exports = { stringify: stringify };
        }, {}], 29: [function (require, module, exports) {
            'use strict';
            var _Buffer = require('safe-buffer').Buffer;
            function base(ALPHABET) {
                if (ALPHABET.length >= 255) {
                    throw new TypeError('Alphabet too long');
                }
                var BASE_MAP = new Uint8Array(256);
                for (var j = 0; j < BASE_MAP.length; j++) {
                    BASE_MAP[j] = 255;
                }
                for (var i = 0; i < ALPHABET.length; i++) {
                    var x = ALPHABET.charAt(i);
                    var xc = x.charCodeAt(0);
                    if (BASE_MAP[xc] !== 255) {
                        throw new TypeError(x + ' is ambiguous');
                    }
                    BASE_MAP[xc] = i;
                }
                var BASE = ALPHABET.length;
                var LEADER = ALPHABET.charAt(0);
                var FACTOR = Math.log(BASE) / Math.log(256);
                var iFACTOR = Math.log(256) / Math.log(BASE);
                function encode(source) {
                    if (Array.isArray(source) || source instanceof Uint8Array) {
                        source = _Buffer.from(source);
                    }
                    if (!_Buffer.isBuffer(source)) {
                        throw new TypeError('Expected Buffer');
                    }
                    if (source.length === 0) {
                        return '';
                    }
                    var zeroes = 0;
                    var length = 0;
                    var pbegin = 0;
                    var pend = source.length;
                    while (pbegin !== pend && source[pbegin] === 0) {
                        pbegin++;
                        zeroes++;
                    }
                    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;
                    var b58 = new Uint8Array(size);
                    while (pbegin !== pend) {
                        var carry = source[pbegin];
                        var i = 0;
                        for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {
                            carry += (256 * b58[it1]) >>> 0;
                            b58[it1] = (carry % BASE) >>> 0;
                            carry = (carry / BASE) >>> 0;
                        }
                        if (carry !== 0) {
                            throw new Error('Non-zero carry');
                        }
                        length = i;
                        pbegin++;
                    }
                    var it2 = size - length;
                    while (it2 !== size && b58[it2] === 0) {
                        it2++;
                    }
                    var str = LEADER.repeat(zeroes);
                    for (; it2 < size; ++it2) {
                        str += ALPHABET.charAt(b58[it2]);
                    }
                    return str;
                }
                function decodeUnsafe(source) {
                    if (typeof source !== 'string') {
                        throw new TypeError('Expected String');
                    }
                    if (source.length === 0) {
                        return _Buffer.alloc(0);
                    }
                    var psz = 0;
                    if (source[psz] === ' ') {
                        return;
                    }
                    var zeroes = 0;
                    var length = 0;
                    while (source[psz] === LEADER) {
                        zeroes++;
                        psz++;
                    }
                    var size = (((source.length - psz) * FACTOR) + 1) >>> 0;
                    var b256 = new Uint8Array(size);
                    while (source[psz]) {
                        var carry = BASE_MAP[source.charCodeAt(psz)];
                        if (carry === 255) {
                            return;
                        }
                        var i = 0;
                        for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {
                            carry += (BASE * b256[it3]) >>> 0;
                            b256[it3] = (carry % 256) >>> 0;
                            carry = (carry / 256) >>> 0;
                        }
                        if (carry !== 0) {
                            throw new Error('Non-zero carry');
                        }
                        length = i;
                        psz++;
                    }
                    if (source[psz] === ' ') {
                        return;
                    }
                    var it4 = size - length;
                    while (it4 !== size && b256[it4] === 0) {
                        it4++;
                    }
                    var vch = _Buffer.allocUnsafe(zeroes + (size - it4));
                    vch.fill(0x00, 0, zeroes);
                    var j = zeroes;
                    while (it4 !== size) {
                        vch[j++] = b256[it4++];
                    }
                    return vch;
                }
                function decode(string) {
                    var buffer = decodeUnsafe(string);
                    if (buffer) {
                        return buffer;
                    }
                    throw new Error('Non-base' + BASE + ' character');
                }
                return {
                    encode: encode,
                    decodeUnsafe: decodeUnsafe,
                    decode: decode
                };
            }
            module.exports = base;
        }, { "safe-buffer": 48 }], 30: [function (require, module, exports) {
            'use strict';
            exports.byteLength = byteLength;
            exports.toByteArray = toByteArray;
            exports.fromByteArray = fromByteArray;
            var lookup = [];
            var revLookup = [];
            var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
            var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
            for (var i = 0, len = code.length; i < len; ++i) {
                lookup[i] = code[i];
                revLookup[code.charCodeAt(i)] = i;
            }
            revLookup['-'.charCodeAt(0)] = 62;
            revLookup['_'.charCodeAt(0)] = 63;
            function getLens(b64) {
                var len = b64.length;
                if (len % 4 > 0) {
                    throw new Error('Invalid string. Length must be a multiple of 4');
                }
                var validLen = b64.indexOf('=');
                if (validLen === -1)
                    validLen = len;
                var placeHoldersLen = validLen === len
                    ? 0
                    : 4 - (validLen % 4);
                return [validLen, placeHoldersLen];
            }
            function byteLength(b64) {
                var lens = getLens(b64);
                var validLen = lens[0];
                var placeHoldersLen = lens[1];
                return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen;
            }
            function _byteLength(b64, validLen, placeHoldersLen) {
                return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen;
            }
            function toByteArray(b64) {
                var tmp;
                var lens = getLens(b64);
                var validLen = lens[0];
                var placeHoldersLen = lens[1];
                var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
                var curByte = 0;
                var len = placeHoldersLen > 0
                    ? validLen - 4
                    : validLen;
                var i;
                for (i = 0; i < len; i += 4) {
                    tmp =
                        (revLookup[b64.charCodeAt(i)] << 18) |
                            (revLookup[b64.charCodeAt(i + 1)] << 12) |
                            (revLookup[b64.charCodeAt(i + 2)] << 6) |
                            revLookup[b64.charCodeAt(i + 3)];
                    arr[curByte++] = (tmp >> 16) & 0xFF;
                    arr[curByte++] = (tmp >> 8) & 0xFF;
                    arr[curByte++] = tmp & 0xFF;
                }
                if (placeHoldersLen === 2) {
                    tmp =
                        (revLookup[b64.charCodeAt(i)] << 2) |
                            (revLookup[b64.charCodeAt(i + 1)] >> 4);
                    arr[curByte++] = tmp & 0xFF;
                }
                if (placeHoldersLen === 1) {
                    tmp =
                        (revLookup[b64.charCodeAt(i)] << 10) |
                            (revLookup[b64.charCodeAt(i + 1)] << 4) |
                            (revLookup[b64.charCodeAt(i + 2)] >> 2);
                    arr[curByte++] = (tmp >> 8) & 0xFF;
                    arr[curByte++] = tmp & 0xFF;
                }
                return arr;
            }
            function tripletToBase64(num) {
                return lookup[num >> 18 & 0x3F] +
                    lookup[num >> 12 & 0x3F] +
                    lookup[num >> 6 & 0x3F] +
                    lookup[num & 0x3F];
            }
            function encodeChunk(uint8, start, end) {
                var tmp;
                var output = [];
                for (var i = start; i < end; i += 3) {
                    tmp =
                        ((uint8[i] << 16) & 0xFF0000) +
                            ((uint8[i + 1] << 8) & 0xFF00) +
                            (uint8[i + 2] & 0xFF);
                    output.push(tripletToBase64(tmp));
                }
                return output.join('');
            }
            function fromByteArray(uint8) {
                var tmp;
                var len = uint8.length;
                var extraBytes = len % 3;
                var parts = [];
                var maxChunkLength = 16383;
                for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
                    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
                }
                if (extraBytes === 1) {
                    tmp = uint8[len - 1];
                    parts.push(lookup[tmp >> 2] +
                        lookup[(tmp << 4) & 0x3F] +
                        '==');
                }
                else if (extraBytes === 2) {
                    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
                    parts.push(lookup[tmp >> 10] +
                        lookup[(tmp >> 4) & 0x3F] +
                        lookup[(tmp << 2) & 0x3F] +
                        '=');
                }
                return parts.join('');
            }
        }, {}], 31: [function (require, module, exports) {
            (function (root, factory) {
                if (typeof define === 'function' && define.amd) {
                    define([], factory);
                }
                else if (typeof exports === 'object') {
                    module.exports = factory();
                }
                else {
                    root.returnExports = factory();
                }
            }(this, function () {
                var XHR = XMLHttpRequest;
                if (!XHR)
                    throw new Error('missing XMLHttpRequest');
                request.log = {
                    'trace': noop, 'debug': noop, 'info': noop, 'warn': noop, 'error': noop
                };
                var DEFAULT_TIMEOUT = 3 * 60 * 1000;
                function request(options, callback) {
                    if (typeof callback !== 'function')
                        throw new Error('Bad callback given: ' + callback);
                    if (!options)
                        throw new Error('No options given');
                    var options_onResponse = options.onResponse;
                    if (typeof options === 'string')
                        options = { 'uri': options };
                    else
                        options = JSON.parse(JSON.stringify(options));
                    options.onResponse = options_onResponse;
                    if (options.verbose)
                        request.log = getLogger();
                    if (options.url) {
                        options.uri = options.url;
                        delete options.url;
                    }
                    if (!options.uri && options.uri !== "")
                        throw new Error("options.uri is a required argument");
                    if (typeof options.uri != "string")
                        throw new Error("options.uri must be a string");
                    var unsupported_options = ['proxy', '_redirectsFollowed', 'maxRedirects', 'followRedirect'];
                    for (var i = 0; i < unsupported_options.length; i++)
                        if (options[unsupported_options[i]])
                            throw new Error("options." + unsupported_options[i] + " is not supported");
                    options.callback = callback;
                    options.method = options.method || 'GET';
                    options.headers = options.headers || {};
                    options.body = options.body || null;
                    options.timeout = options.timeout || request.DEFAULT_TIMEOUT;
                    if (options.headers.host)
                        throw new Error("Options.headers.host is not supported");
                    if (options.json) {
                        options.headers.accept = options.headers.accept || 'application/json';
                        if (options.method !== 'GET')
                            options.headers['content-type'] = 'application/json';
                        if (typeof options.json !== 'boolean')
                            options.body = JSON.stringify(options.json);
                        else if (typeof options.body !== 'string')
                            options.body = JSON.stringify(options.body);
                    }
                    var serialize = function (obj) {
                        var str = [];
                        for (var p in obj)
                            if (obj.hasOwnProperty(p)) {
                                str.push(encodeURIComponent(p) + "=" + encodeURIComponent(obj[p]));
                            }
                        return str.join("&");
                    };
                    if (options.qs) {
                        var qs = (typeof options.qs == 'string') ? options.qs : serialize(options.qs);
                        if (options.uri.indexOf('?') !== -1) {
                            options.uri = options.uri + '&' + qs;
                        }
                        else {
                            options.uri = options.uri + '?' + qs;
                        }
                    }
                    var multipart = function (obj) {
                        var result = {};
                        result.boundry = '-------------------------------' + Math.floor(Math.random() * 1000000000);
                        var lines = [];
                        for (var p in obj) {
                            if (obj.hasOwnProperty(p)) {
                                lines.push('--' + result.boundry + "\n" +
                                    'Content-Disposition: form-data; name="' + p + '"' + "\n" +
                                    "\n" +
                                    obj[p] + "\n");
                            }
                        }
                        lines.push('--' + result.boundry + '--');
                        result.body = lines.join('');
                        result.length = result.body.length;
                        result.type = 'multipart/form-data; boundary=' + result.boundry;
                        return result;
                    };
                    if (options.form) {
                        if (typeof options.form == 'string')
                            throw ('form name unsupported');
                        if (options.method === 'POST') {
                            var encoding = (options.encoding || 'application/x-www-form-urlencoded').toLowerCase();
                            options.headers['content-type'] = encoding;
                            switch (encoding) {
                                case 'application/x-www-form-urlencoded':
                                    options.body = serialize(options.form).replace(/%20/g, "+");
                                    break;
                                case 'multipart/form-data':
                                    var multi = multipart(options.form);
                                    options.body = multi.body;
                                    options.headers['content-type'] = multi.type;
                                    break;
                                default: throw new Error('unsupported encoding:' + encoding);
                            }
                        }
                    }
                    options.onResponse = options.onResponse || noop;
                    if (options.onResponse === true) {
                        options.onResponse = callback;
                        options.callback = noop;
                    }
                    if (!options.headers.authorization && options.auth)
                        options.headers.authorization = 'Basic ' + b64_enc(options.auth.username + ':' + options.auth.password);
                    return run_xhr(options);
                }
                var req_seq = 0;
                function run_xhr(options) {
                    var xhr = new XHR, timed_out = false, is_cors = is_crossDomain(options.uri), supports_cors = ('withCredentials' in xhr);
                    req_seq += 1;
                    xhr.seq_id = req_seq;
                    xhr.id = req_seq + ': ' + options.method + ' ' + options.uri;
                    xhr._id = xhr.id;
                    if (is_cors && !supports_cors) {
                        var cors_err = new Error('Browser does not support cross-origin request: ' + options.uri);
                        cors_err.cors = 'unsupported';
                        return options.callback(cors_err, xhr);
                    }
                    xhr.timeoutTimer = setTimeout(too_late, options.timeout);
                    function too_late() {
                        timed_out = true;
                        var er = new Error('ETIMEDOUT');
                        er.code = 'ETIMEDOUT';
                        er.duration = options.timeout;
                        request.log.error('Timeout', { 'id': xhr._id, 'milliseconds': options.timeout });
                        return options.callback(er, xhr);
                    }
                    var did = { 'response': false, 'loading': false, 'end': false };
                    xhr.onreadystatechange = on_state_change;
                    xhr.open(options.method, options.uri, true);
                    if (is_cors)
                        xhr.withCredentials = !!options.withCredentials;
                    xhr.send(options.body);
                    return xhr;
                    function on_state_change(event) {
                        if (timed_out)
                            return request.log.debug('Ignoring timed out state change', { 'state': xhr.readyState, 'id': xhr.id });
                        request.log.debug('State change', { 'state': xhr.readyState, 'id': xhr.id, 'timed_out': timed_out });
                        if (xhr.readyState === XHR.OPENED) {
                            request.log.debug('Request started', { 'id': xhr.id });
                            for (var key in options.headers)
                                xhr.setRequestHeader(key, options.headers[key]);
                        }
                        else if (xhr.readyState === XHR.HEADERS_RECEIVED)
                            on_response();
                        else if (xhr.readyState === XHR.LOADING) {
                            on_response();
                            on_loading();
                        }
                        else if (xhr.readyState === XHR.DONE) {
                            on_response();
                            on_loading();
                            on_end();
                        }
                    }
                    function on_response() {
                        if (did.response)
                            return;
                        did.response = true;
                        request.log.debug('Got response', { 'id': xhr.id, 'status': xhr.status });
                        clearTimeout(xhr.timeoutTimer);
                        xhr.statusCode = xhr.status;
                        if (is_cors && xhr.statusCode == 0) {
                            var cors_err = new Error('CORS request rejected: ' + options.uri);
                            cors_err.cors = 'rejected';
                            did.loading = true;
                            did.end = true;
                            return options.callback(cors_err, xhr);
                        }
                        options.onResponse(null, xhr);
                    }
                    function on_loading() {
                        if (did.loading)
                            return;
                        did.loading = true;
                        request.log.debug('Response body loading', { 'id': xhr.id });
                    }
                    function on_end() {
                        if (did.end)
                            return;
                        did.end = true;
                        request.log.debug('Request done', { 'id': xhr.id });
                        xhr.body = xhr.responseText;
                        if (options.json) {
                            try {
                                xhr.body = JSON.parse(xhr.responseText);
                            }
                            catch (er) {
                                return options.callback(er, xhr);
                            }
                        }
                        options.callback(null, xhr, xhr.body);
                    }
                }
                request.withCredentials = false;
                request.DEFAULT_TIMEOUT = DEFAULT_TIMEOUT;
                request.defaults = function (options, requester) {
                    var def = function (method) {
                        var d = function (params, callback) {
                            if (typeof params === 'string')
                                params = { 'uri': params };
                            else {
                                params = JSON.parse(JSON.stringify(params));
                            }
                            for (var i in options) {
                                if (params[i] === undefined)
                                    params[i] = options[i];
                            }
                            return method(params, callback);
                        };
                        return d;
                    };
                    var de = def(request);
                    de.get = def(request.get);
                    de.post = def(request.post);
                    de.put = def(request.put);
                    de.head = def(request.head);
                    return de;
                };
                var shortcuts = ['get', 'put', 'post', 'head'];
                shortcuts.forEach(function (shortcut) {
                    var method = shortcut.toUpperCase();
                    var func = shortcut.toLowerCase();
                    request[func] = function (opts) {
                        if (typeof opts === 'string')
                            opts = { 'method': method, 'uri': opts };
                        else {
                            opts = JSON.parse(JSON.stringify(opts));
                            opts.method = method;
                        }
                        var args = [opts].concat(Array.prototype.slice.apply(arguments, [1]));
                        return request.apply(this, args);
                    };
                });
                request.couch = function (options, callback) {
                    if (typeof options === 'string')
                        options = { 'uri': options };
                    options.json = true;
                    if (options.body)
                        options.json = options.body;
                    delete options.body;
                    callback = callback || noop;
                    var xhr = request(options, couch_handler);
                    return xhr;
                    function couch_handler(er, resp, body) {
                        if (er)
                            return callback(er, resp, body);
                        if ((resp.statusCode < 200 || resp.statusCode > 299) && body.error) {
                            er = new Error('CouchDB error: ' + (body.error.reason || body.error.error));
                            for (var key in body)
                                er[key] = body[key];
                            return callback(er, resp, body);
                        }
                        return callback(er, resp, body);
                    }
                };
                function noop() { }
                function getLogger() {
                    var logger = {}, levels = ['trace', 'debug', 'info', 'warn', 'error'], level, i;
                    for (i = 0; i < levels.length; i++) {
                        level = levels[i];
                        logger[level] = noop;
                        if (typeof console !== 'undefined' && console && console[level])
                            logger[level] = formatted(console, level);
                    }
                    return logger;
                }
                function formatted(obj, method) {
                    return formatted_logger;
                    function formatted_logger(str, context) {
                        if (typeof context === 'object')
                            str += ' ' + JSON.stringify(context);
                        return obj[method].call(obj, str);
                    }
                }
                function is_crossDomain(url) {
                    var rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/;
                    var ajaxLocation;
                    try {
                        ajaxLocation = location.href;
                    }
                    catch (e) {
                        ajaxLocation = document.createElement("a");
                        ajaxLocation.href = "";
                        ajaxLocation = ajaxLocation.href;
                    }
                    var ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [], parts = rurl.exec(url.toLowerCase());
                    var result = !!(parts &&
                        (parts[1] != ajaxLocParts[1]
                            || parts[2] != ajaxLocParts[2]
                            || (parts[3] || (parts[1] === "http:" ? 80 : 443)) != (ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? 80 : 443))));
                    return result;
                }
                function b64_enc(data) {
                    var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
                    var o1, o2, o3, h1, h2, h3, h4, bits, i = 0, ac = 0, enc = "", tmp_arr = [];
                    if (!data) {
                        return data;
                    }
                    do {
                        o1 = data.charCodeAt(i++);
                        o2 = data.charCodeAt(i++);
                        o3 = data.charCodeAt(i++);
                        bits = o1 << 16 | o2 << 8 | o3;
                        h1 = bits >> 18 & 0x3f;
                        h2 = bits >> 12 & 0x3f;
                        h3 = bits >> 6 & 0x3f;
                        h4 = bits & 0x3f;
                        tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
                    } while (i < data.length);
                    enc = tmp_arr.join('');
                    switch (data.length % 3) {
                        case 1:
                            enc = enc.slice(0, -2) + '==';
                            break;
                        case 2:
                            enc = enc.slice(0, -1) + '=';
                            break;
                    }
                    return enc;
                }
                return request;
            }));
        }, {}], 32: [function (require, module, exports) {
            (function (global) {
                (function () {
                    ;
                    (function (root) {
                        var freeExports = typeof exports == 'object' && exports &&
                            !exports.nodeType && exports;
                        var freeModule = typeof module == 'object' && module &&
                            !module.nodeType && module;
                        var freeGlobal = typeof global == 'object' && global;
                        if (freeGlobal.global === freeGlobal ||
                            freeGlobal.window === freeGlobal ||
                            freeGlobal.self === freeGlobal) {
                            root = freeGlobal;
                        }
                        var punycode, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = '-', regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
                            'overflow': 'Overflow: input needs wider integers to process',
                            'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
                            'invalid-input': 'Invalid input'
                        }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;
                        function error(type) {
                            throw new RangeError(errors[type]);
                        }
                        function map(array, fn) {
                            var length = array.length;
                            var result = [];
                            while (length--) {
                                result[length] = fn(array[length]);
                            }
                            return result;
                        }
                        function mapDomain(string, fn) {
                            var parts = string.split('@');
                            var result = '';
                            if (parts.length > 1) {
                                result = parts[0] + '@';
                                string = parts[1];
                            }
                            string = string.replace(regexSeparators, '\x2E');
                            var labels = string.split('.');
                            var encoded = map(labels, fn).join('.');
                            return result + encoded;
                        }
                        function ucs2decode(string) {
                            var output = [], counter = 0, length = string.length, value, extra;
                            while (counter < length) {
                                value = string.charCodeAt(counter++);
                                if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
                                    extra = string.charCodeAt(counter++);
                                    if ((extra & 0xFC00) == 0xDC00) {
                                        output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
                                    }
                                    else {
                                        output.push(value);
                                        counter--;
                                    }
                                }
                                else {
                                    output.push(value);
                                }
                            }
                            return output;
                        }
                        function ucs2encode(array) {
                            return map(array, function (value) {
                                var output = '';
                                if (value > 0xFFFF) {
                                    value -= 0x10000;
                                    output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
                                    value = 0xDC00 | value & 0x3FF;
                                }
                                output += stringFromCharCode(value);
                                return output;
                            }).join('');
                        }
                        function basicToDigit(codePoint) {
                            if (codePoint - 48 < 10) {
                                return codePoint - 22;
                            }
                            if (codePoint - 65 < 26) {
                                return codePoint - 65;
                            }
                            if (codePoint - 97 < 26) {
                                return codePoint - 97;
                            }
                            return base;
                        }
                        function digitToBasic(digit, flag) {
                            return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
                        }
                        function adapt(delta, numPoints, firstTime) {
                            var k = 0;
                            delta = firstTime ? floor(delta / damp) : delta >> 1;
                            delta += floor(delta / numPoints);
                            for (; delta > baseMinusTMin * tMax >> 1; k += base) {
                                delta = floor(delta / baseMinusTMin);
                            }
                            return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
                        }
                        function decode(input) {
                            var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias, basic, j, index, oldi, w, k, digit, t, baseMinusT;
                            basic = input.lastIndexOf(delimiter);
                            if (basic < 0) {
                                basic = 0;
                            }
                            for (j = 0; j < basic; ++j) {
                                if (input.charCodeAt(j) >= 0x80) {
                                    error('not-basic');
                                }
                                output.push(input.charCodeAt(j));
                            }
                            for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) {
                                for (oldi = i, w = 1, k = base;; k += base) {
                                    if (index >= inputLength) {
                                        error('invalid-input');
                                    }
                                    digit = basicToDigit(input.charCodeAt(index++));
                                    if (digit >= base || digit > floor((maxInt - i) / w)) {
                                        error('overflow');
                                    }
                                    i += digit * w;
                                    t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
                                    if (digit < t) {
                                        break;
                                    }
                                    baseMinusT = base - t;
                                    if (w > floor(maxInt / baseMinusT)) {
                                        error('overflow');
                                    }
                                    w *= baseMinusT;
                                }
                                out = output.length + 1;
                                bias = adapt(i - oldi, out, oldi == 0);
                                if (floor(i / out) > maxInt - n) {
                                    error('overflow');
                                }
                                n += floor(i / out);
                                i %= out;
                                output.splice(i++, 0, n);
                            }
                            return ucs2encode(output);
                        }
                        function encode(input) {
                            var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
                            input = ucs2decode(input);
                            inputLength = input.length;
                            n = initialN;
                            delta = 0;
                            bias = initialBias;
                            for (j = 0; j < inputLength; ++j) {
                                currentValue = input[j];
                                if (currentValue < 0x80) {
                                    output.push(stringFromCharCode(currentValue));
                                }
                            }
                            handledCPCount = basicLength = output.length;
                            if (basicLength) {
                                output.push(delimiter);
                            }
                            while (handledCPCount < inputLength) {
                                for (m = maxInt, j = 0; j < inputLength; ++j) {
                                    currentValue = input[j];
                                    if (currentValue >= n && currentValue < m) {
                                        m = currentValue;
                                    }
                                }
                                handledCPCountPlusOne = handledCPCount + 1;
                                if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                                    error('overflow');
                                }
                                delta += (m - n) * handledCPCountPlusOne;
                                n = m;
                                for (j = 0; j < inputLength; ++j) {
                                    currentValue = input[j];
                                    if (currentValue < n && ++delta > maxInt) {
                                        error('overflow');
                                    }
                                    if (currentValue == n) {
                                        for (q = delta, k = base;; k += base) {
                                            t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
                                            if (q < t) {
                                                break;
                                            }
                                            qMinusT = q - t;
                                            baseMinusT = base - t;
                                            output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                                            q = floor(qMinusT / baseMinusT);
                                        }
                                        output.push(stringFromCharCode(digitToBasic(q, 0)));
                                        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                                        delta = 0;
                                        ++handledCPCount;
                                    }
                                }
                                ++delta;
                                ++n;
                            }
                            return output.join('');
                        }
                        function toUnicode(input) {
                            return mapDomain(input, function (string) {
                                return regexPunycode.test(string)
                                    ? decode(string.slice(4).toLowerCase())
                                    : string;
                            });
                        }
                        function toASCII(input) {
                            return mapDomain(input, function (string) {
                                return regexNonASCII.test(string)
                                    ? 'xn--' + encode(string)
                                    : string;
                            });
                        }
                        punycode = {
                            'version': '1.4.1',
                            'ucs2': {
                                'decode': ucs2decode,
                                'encode': ucs2encode
                            },
                            'decode': decode,
                            'encode': encode,
                            'toASCII': toASCII,
                            'toUnicode': toUnicode
                        };
                        if (typeof define == 'function' &&
                            typeof define.amd == 'object' &&
                            define.amd) {
                            define('punycode', function () {
                                return punycode;
                            });
                        }
                        else if (freeExports && freeModule) {
                            if (module.exports == freeExports) {
                                freeModule.exports = punycode;
                            }
                            else {
                                for (key in punycode) {
                                    punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
                                }
                            }
                        }
                        else {
                            root.punycode = punycode;
                        }
                    }(this));
                }).call(this);
            }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, {}], 33: [function (require, module, exports) {
            var basex = require('base-x');
            var ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
            module.exports = basex(ALPHABET);
        }, { "base-x": 29 }], 34: [function (require, module, exports) {
            (function (Buffer) {
                (function () {
                    'use strict';
                    var base64 = require('base64-js');
                    var ieee754 = require('ieee754');
                    exports.Buffer = Buffer;
                    exports.SlowBuffer = SlowBuffer;
                    exports.INSPECT_MAX_BYTES = 50;
                    var K_MAX_LENGTH = 0x7fffffff;
                    exports.kMaxLength = K_MAX_LENGTH;
                    Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
                    if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
                        typeof console.error === 'function') {
                        console.error('This browser lacks typed array (Uint8Array) support which is required by ' +
                            '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');
                    }
                    function typedArraySupport() {
                        try {
                            var arr = new Uint8Array(1);
                            arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42; } };
                            return arr.foo() === 42;
                        }
                        catch (e) {
                            return false;
                        }
                    }
                    Object.defineProperty(Buffer.prototype, 'parent', {
                        enumerable: true,
                        get: function () {
                            if (!Buffer.isBuffer(this))
                                return undefined;
                            return this.buffer;
                        }
                    });
                    Object.defineProperty(Buffer.prototype, 'offset', {
                        enumerable: true,
                        get: function () {
                            if (!Buffer.isBuffer(this))
                                return undefined;
                            return this.byteOffset;
                        }
                    });
                    function createBuffer(length) {
                        if (length > K_MAX_LENGTH) {
                            throw new RangeError('The value "' + length + '" is invalid for option "size"');
                        }
                        var buf = new Uint8Array(length);
                        buf.__proto__ = Buffer.prototype;
                        return buf;
                    }
                    function Buffer(arg, encodingOrOffset, length) {
                        if (typeof arg === 'number') {
                            if (typeof encodingOrOffset === 'string') {
                                throw new TypeError('The "string" argument must be of type string. Received type number');
                            }
                            return allocUnsafe(arg);
                        }
                        return from(arg, encodingOrOffset, length);
                    }
                    if (typeof Symbol !== 'undefined' && Symbol.species != null &&
                        Buffer[Symbol.species] === Buffer) {
                        Object.defineProperty(Buffer, Symbol.species, {
                            value: null,
                            configurable: true,
                            enumerable: false,
                            writable: false
                        });
                    }
                    Buffer.poolSize = 8192;
                    function from(value, encodingOrOffset, length) {
                        if (typeof value === 'string') {
                            return fromString(value, encodingOrOffset);
                        }
                        if (ArrayBuffer.isView(value)) {
                            return fromArrayLike(value);
                        }
                        if (value == null) {
                            throw TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
                                'or Array-like Object. Received type ' + (typeof value));
                        }
                        if (isInstance(value, ArrayBuffer) ||
                            (value && isInstance(value.buffer, ArrayBuffer))) {
                            return fromArrayBuffer(value, encodingOrOffset, length);
                        }
                        if (typeof value === 'number') {
                            throw new TypeError('The "value" argument must not be of type number. Received type number');
                        }
                        var valueOf = value.valueOf && value.valueOf();
                        if (valueOf != null && valueOf !== value) {
                            return Buffer.from(valueOf, encodingOrOffset, length);
                        }
                        var b = fromObject(value);
                        if (b)
                            return b;
                        if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
                            typeof value[Symbol.toPrimitive] === 'function') {
                            return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
                        }
                        throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
                            'or Array-like Object. Received type ' + (typeof value));
                    }
                    Buffer.from = function (value, encodingOrOffset, length) {
                        return from(value, encodingOrOffset, length);
                    };
                    Buffer.prototype.__proto__ = Uint8Array.prototype;
                    Buffer.__proto__ = Uint8Array;
                    function assertSize(size) {
                        if (typeof size !== 'number') {
                            throw new TypeError('"size" argument must be of type number');
                        }
                        else if (size < 0) {
                            throw new RangeError('The value "' + size + '" is invalid for option "size"');
                        }
                    }
                    function alloc(size, fill, encoding) {
                        assertSize(size);
                        if (size <= 0) {
                            return createBuffer(size);
                        }
                        if (fill !== undefined) {
                            return typeof encoding === 'string'
                                ? createBuffer(size).fill(fill, encoding)
                                : createBuffer(size).fill(fill);
                        }
                        return createBuffer(size);
                    }
                    Buffer.alloc = function (size, fill, encoding) {
                        return alloc(size, fill, encoding);
                    };
                    function allocUnsafe(size) {
                        assertSize(size);
                        return createBuffer(size < 0 ? 0 : checked(size) | 0);
                    }
                    Buffer.allocUnsafe = function (size) {
                        return allocUnsafe(size);
                    };
                    Buffer.allocUnsafeSlow = function (size) {
                        return allocUnsafe(size);
                    };
                    function fromString(string, encoding) {
                        if (typeof encoding !== 'string' || encoding === '') {
                            encoding = 'utf8';
                        }
                        if (!Buffer.isEncoding(encoding)) {
                            throw new TypeError('Unknown encoding: ' + encoding);
                        }
                        var length = byteLength(string, encoding) | 0;
                        var buf = createBuffer(length);
                        var actual = buf.write(string, encoding);
                        if (actual !== length) {
                            buf = buf.slice(0, actual);
                        }
                        return buf;
                    }
                    function fromArrayLike(array) {
                        var length = array.length < 0 ? 0 : checked(array.length) | 0;
                        var buf = createBuffer(length);
                        for (var i = 0; i < length; i += 1) {
                            buf[i] = array[i] & 255;
                        }
                        return buf;
                    }
                    function fromArrayBuffer(array, byteOffset, length) {
                        if (byteOffset < 0 || array.byteLength < byteOffset) {
                            throw new RangeError('"offset" is outside of buffer bounds');
                        }
                        if (array.byteLength < byteOffset + (length || 0)) {
                            throw new RangeError('"length" is outside of buffer bounds');
                        }
                        var buf;
                        if (byteOffset === undefined && length === undefined) {
                            buf = new Uint8Array(array);
                        }
                        else if (length === undefined) {
                            buf = new Uint8Array(array, byteOffset);
                        }
                        else {
                            buf = new Uint8Array(array, byteOffset, length);
                        }
                        buf.__proto__ = Buffer.prototype;
                        return buf;
                    }
                    function fromObject(obj) {
                        if (Buffer.isBuffer(obj)) {
                            var len = checked(obj.length) | 0;
                            var buf = createBuffer(len);
                            if (buf.length === 0) {
                                return buf;
                            }
                            obj.copy(buf, 0, 0, len);
                            return buf;
                        }
                        if (obj.length !== undefined) {
                            if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
                                return createBuffer(0);
                            }
                            return fromArrayLike(obj);
                        }
                        if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
                            return fromArrayLike(obj.data);
                        }
                    }
                    function checked(length) {
                        if (length >= K_MAX_LENGTH) {
                            throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                                'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');
                        }
                        return length | 0;
                    }
                    function SlowBuffer(length) {
                        if (+length != length) {
                            length = 0;
                        }
                        return Buffer.alloc(+length);
                    }
                    Buffer.isBuffer = function isBuffer(b) {
                        return b != null && b._isBuffer === true &&
                            b !== Buffer.prototype;
                    };
                    Buffer.compare = function compare(a, b) {
                        if (isInstance(a, Uint8Array))
                            a = Buffer.from(a, a.offset, a.byteLength);
                        if (isInstance(b, Uint8Array))
                            b = Buffer.from(b, b.offset, b.byteLength);
                        if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
                            throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
                        }
                        if (a === b)
                            return 0;
                        var x = a.length;
                        var y = b.length;
                        for (var i = 0, len = Math.min(x, y); i < len; ++i) {
                            if (a[i] !== b[i]) {
                                x = a[i];
                                y = b[i];
                                break;
                            }
                        }
                        if (x < y)
                            return -1;
                        if (y < x)
                            return 1;
                        return 0;
                    };
                    Buffer.isEncoding = function isEncoding(encoding) {
                        switch (String(encoding).toLowerCase()) {
                            case 'hex':
                            case 'utf8':
                            case 'utf-8':
                            case 'ascii':
                            case 'latin1':
                            case 'binary':
                            case 'base64':
                            case 'ucs2':
                            case 'ucs-2':
                            case 'utf16le':
                            case 'utf-16le':
                                return true;
                            default:
                                return false;
                        }
                    };
                    Buffer.concat = function concat(list, length) {
                        if (!Array.isArray(list)) {
                            throw new TypeError('"list" argument must be an Array of Buffers');
                        }
                        if (list.length === 0) {
                            return Buffer.alloc(0);
                        }
                        var i;
                        if (length === undefined) {
                            length = 0;
                            for (i = 0; i < list.length; ++i) {
                                length += list[i].length;
                            }
                        }
                        var buffer = Buffer.allocUnsafe(length);
                        var pos = 0;
                        for (i = 0; i < list.length; ++i) {
                            var buf = list[i];
                            if (isInstance(buf, Uint8Array)) {
                                buf = Buffer.from(buf);
                            }
                            if (!Buffer.isBuffer(buf)) {
                                throw new TypeError('"list" argument must be an Array of Buffers');
                            }
                            buf.copy(buffer, pos);
                            pos += buf.length;
                        }
                        return buffer;
                    };
                    function byteLength(string, encoding) {
                        if (Buffer.isBuffer(string)) {
                            return string.length;
                        }
                        if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
                            return string.byteLength;
                        }
                        if (typeof string !== 'string') {
                            throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
                                'Received type ' + typeof string);
                        }
                        var len = string.length;
                        var mustMatch = (arguments.length > 2 && arguments[2] === true);
                        if (!mustMatch && len === 0)
                            return 0;
                        var loweredCase = false;
                        for (;;) {
                            switch (encoding) {
                                case 'ascii':
                                case 'latin1':
                                case 'binary':
                                    return len;
                                case 'utf8':
                                case 'utf-8':
                                    return utf8ToBytes(string).length;
                                case 'ucs2':
                                case 'ucs-2':
                                case 'utf16le':
                                case 'utf-16le':
                                    return len * 2;
                                case 'hex':
                                    return len >>> 1;
                                case 'base64':
                                    return base64ToBytes(string).length;
                                default:
                                    if (loweredCase) {
                                        return mustMatch ? -1 : utf8ToBytes(string).length;
                                    }
                                    encoding = ('' + encoding).toLowerCase();
                                    loweredCase = true;
                            }
                        }
                    }
                    Buffer.byteLength = byteLength;
                    function slowToString(encoding, start, end) {
                        var loweredCase = false;
                        if (start === undefined || start < 0) {
                            start = 0;
                        }
                        if (start > this.length) {
                            return '';
                        }
                        if (end === undefined || end > this.length) {
                            end = this.length;
                        }
                        if (end <= 0) {
                            return '';
                        }
                        end >>>= 0;
                        start >>>= 0;
                        if (end <= start) {
                            return '';
                        }
                        if (!encoding)
                            encoding = 'utf8';
                        while (true) {
                            switch (encoding) {
                                case 'hex':
                                    return hexSlice(this, start, end);
                                case 'utf8':
                                case 'utf-8':
                                    return utf8Slice(this, start, end);
                                case 'ascii':
                                    return asciiSlice(this, start, end);
                                case 'latin1':
                                case 'binary':
                                    return latin1Slice(this, start, end);
                                case 'base64':
                                    return base64Slice(this, start, end);
                                case 'ucs2':
                                case 'ucs-2':
                                case 'utf16le':
                                case 'utf-16le':
                                    return utf16leSlice(this, start, end);
                                default:
                                    if (loweredCase)
                                        throw new TypeError('Unknown encoding: ' + encoding);
                                    encoding = (encoding + '').toLowerCase();
                                    loweredCase = true;
                            }
                        }
                    }
                    Buffer.prototype._isBuffer = true;
                    function swap(b, n, m) {
                        var i = b[n];
                        b[n] = b[m];
                        b[m] = i;
                    }
                    Buffer.prototype.swap16 = function swap16() {
                        var len = this.length;
                        if (len % 2 !== 0) {
                            throw new RangeError('Buffer size must be a multiple of 16-bits');
                        }
                        for (var i = 0; i < len; i += 2) {
                            swap(this, i, i + 1);
                        }
                        return this;
                    };
                    Buffer.prototype.swap32 = function swap32() {
                        var len = this.length;
                        if (len % 4 !== 0) {
                            throw new RangeError('Buffer size must be a multiple of 32-bits');
                        }
                        for (var i = 0; i < len; i += 4) {
                            swap(this, i, i + 3);
                            swap(this, i + 1, i + 2);
                        }
                        return this;
                    };
                    Buffer.prototype.swap64 = function swap64() {
                        var len = this.length;
                        if (len % 8 !== 0) {
                            throw new RangeError('Buffer size must be a multiple of 64-bits');
                        }
                        for (var i = 0; i < len; i += 8) {
                            swap(this, i, i + 7);
                            swap(this, i + 1, i + 6);
                            swap(this, i + 2, i + 5);
                            swap(this, i + 3, i + 4);
                        }
                        return this;
                    };
                    Buffer.prototype.toString = function toString() {
                        var length = this.length;
                        if (length === 0)
                            return '';
                        if (arguments.length === 0)
                            return utf8Slice(this, 0, length);
                        return slowToString.apply(this, arguments);
                    };
                    Buffer.prototype.toLocaleString = Buffer.prototype.toString;
                    Buffer.prototype.equals = function equals(b) {
                        if (!Buffer.isBuffer(b))
                            throw new TypeError('Argument must be a Buffer');
                        if (this === b)
                            return true;
                        return Buffer.compare(this, b) === 0;
                    };
                    Buffer.prototype.inspect = function inspect() {
                        var str = '';
                        var max = exports.INSPECT_MAX_BYTES;
                        str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
                        if (this.length > max)
                            str += ' ... ';
                        return '<Buffer ' + str + '>';
                    };
                    Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
                        if (isInstance(target, Uint8Array)) {
                            target = Buffer.from(target, target.offset, target.byteLength);
                        }
                        if (!Buffer.isBuffer(target)) {
                            throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' +
                                'Received type ' + (typeof target));
                        }
                        if (start === undefined) {
                            start = 0;
                        }
                        if (end === undefined) {
                            end = target ? target.length : 0;
                        }
                        if (thisStart === undefined) {
                            thisStart = 0;
                        }
                        if (thisEnd === undefined) {
                            thisEnd = this.length;
                        }
                        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
                            throw new RangeError('out of range index');
                        }
                        if (thisStart >= thisEnd && start >= end) {
                            return 0;
                        }
                        if (thisStart >= thisEnd) {
                            return -1;
                        }
                        if (start >= end) {
                            return 1;
                        }
                        start >>>= 0;
                        end >>>= 0;
                        thisStart >>>= 0;
                        thisEnd >>>= 0;
                        if (this === target)
                            return 0;
                        var x = thisEnd - thisStart;
                        var y = end - start;
                        var len = Math.min(x, y);
                        var thisCopy = this.slice(thisStart, thisEnd);
                        var targetCopy = target.slice(start, end);
                        for (var i = 0; i < len; ++i) {
                            if (thisCopy[i] !== targetCopy[i]) {
                                x = thisCopy[i];
                                y = targetCopy[i];
                                break;
                            }
                        }
                        if (x < y)
                            return -1;
                        if (y < x)
                            return 1;
                        return 0;
                    };
                    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
                        if (buffer.length === 0)
                            return -1;
                        if (typeof byteOffset === 'string') {
                            encoding = byteOffset;
                            byteOffset = 0;
                        }
                        else if (byteOffset > 0x7fffffff) {
                            byteOffset = 0x7fffffff;
                        }
                        else if (byteOffset < -0x80000000) {
                            byteOffset = -0x80000000;
                        }
                        byteOffset = +byteOffset;
                        if (numberIsNaN(byteOffset)) {
                            byteOffset = dir ? 0 : (buffer.length - 1);
                        }
                        if (byteOffset < 0)
                            byteOffset = buffer.length + byteOffset;
                        if (byteOffset >= buffer.length) {
                            if (dir)
                                return -1;
                            else
                                byteOffset = buffer.length - 1;
                        }
                        else if (byteOffset < 0) {
                            if (dir)
                                byteOffset = 0;
                            else
                                return -1;
                        }
                        if (typeof val === 'string') {
                            val = Buffer.from(val, encoding);
                        }
                        if (Buffer.isBuffer(val)) {
                            if (val.length === 0) {
                                return -1;
                            }
                            return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
                        }
                        else if (typeof val === 'number') {
                            val = val & 0xFF;
                            if (typeof Uint8Array.prototype.indexOf === 'function') {
                                if (dir) {
                                    return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
                                }
                                else {
                                    return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
                                }
                            }
                            return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
                        }
                        throw new TypeError('val must be string, number or Buffer');
                    }
                    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
                        var indexSize = 1;
                        var arrLength = arr.length;
                        var valLength = val.length;
                        if (encoding !== undefined) {
                            encoding = String(encoding).toLowerCase();
                            if (encoding === 'ucs2' || encoding === 'ucs-2' ||
                                encoding === 'utf16le' || encoding === 'utf-16le') {
                                if (arr.length < 2 || val.length < 2) {
                                    return -1;
                                }
                                indexSize = 2;
                                arrLength /= 2;
                                valLength /= 2;
                                byteOffset /= 2;
                            }
                        }
                        function read(buf, i) {
                            if (indexSize === 1) {
                                return buf[i];
                            }
                            else {
                                return buf.readUInt16BE(i * indexSize);
                            }
                        }
                        var i;
                        if (dir) {
                            var foundIndex = -1;
                            for (i = byteOffset; i < arrLength; i++) {
                                if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                                    if (foundIndex === -1)
                                        foundIndex = i;
                                    if (i - foundIndex + 1 === valLength)
                                        return foundIndex * indexSize;
                                }
                                else {
                                    if (foundIndex !== -1)
                                        i -= i - foundIndex;
                                    foundIndex = -1;
                                }
                            }
                        }
                        else {
                            if (byteOffset + valLength > arrLength)
                                byteOffset = arrLength - valLength;
                            for (i = byteOffset; i >= 0; i--) {
                                var found = true;
                                for (var j = 0; j < valLength; j++) {
                                    if (read(arr, i + j) !== read(val, j)) {
                                        found = false;
                                        break;
                                    }
                                }
                                if (found)
                                    return i;
                            }
                        }
                        return -1;
                    }
                    Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
                        return this.indexOf(val, byteOffset, encoding) !== -1;
                    };
                    Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
                        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
                    };
                    Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
                        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
                    };
                    function hexWrite(buf, string, offset, length) {
                        offset = Number(offset) || 0;
                        var remaining = buf.length - offset;
                        if (!length) {
                            length = remaining;
                        }
                        else {
                            length = Number(length);
                            if (length > remaining) {
                                length = remaining;
                            }
                        }
                        var strLen = string.length;
                        if (length > strLen / 2) {
                            length = strLen / 2;
                        }
                        for (var i = 0; i < length; ++i) {
                            var parsed = parseInt(string.substr(i * 2, 2), 16);
                            if (numberIsNaN(parsed))
                                return i;
                            buf[offset + i] = parsed;
                        }
                        return i;
                    }
                    function utf8Write(buf, string, offset, length) {
                        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
                    }
                    function asciiWrite(buf, string, offset, length) {
                        return blitBuffer(asciiToBytes(string), buf, offset, length);
                    }
                    function latin1Write(buf, string, offset, length) {
                        return asciiWrite(buf, string, offset, length);
                    }
                    function base64Write(buf, string, offset, length) {
                        return blitBuffer(base64ToBytes(string), buf, offset, length);
                    }
                    function ucs2Write(buf, string, offset, length) {
                        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
                    }
                    Buffer.prototype.write = function write(string, offset, length, encoding) {
                        if (offset === undefined) {
                            encoding = 'utf8';
                            length = this.length;
                            offset = 0;
                        }
                        else if (length === undefined && typeof offset === 'string') {
                            encoding = offset;
                            length = this.length;
                            offset = 0;
                        }
                        else if (isFinite(offset)) {
                            offset = offset >>> 0;
                            if (isFinite(length)) {
                                length = length >>> 0;
                                if (encoding === undefined)
                                    encoding = 'utf8';
                            }
                            else {
                                encoding = length;
                                length = undefined;
                            }
                        }
                        else {
                            throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
                        }
                        var remaining = this.length - offset;
                        if (length === undefined || length > remaining)
                            length = remaining;
                        if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
                            throw new RangeError('Attempt to write outside buffer bounds');
                        }
                        if (!encoding)
                            encoding = 'utf8';
                        var loweredCase = false;
                        for (;;) {
                            switch (encoding) {
                                case 'hex':
                                    return hexWrite(this, string, offset, length);
                                case 'utf8':
                                case 'utf-8':
                                    return utf8Write(this, string, offset, length);
                                case 'ascii':
                                    return asciiWrite(this, string, offset, length);
                                case 'latin1':
                                case 'binary':
                                    return latin1Write(this, string, offset, length);
                                case 'base64':
                                    return base64Write(this, string, offset, length);
                                case 'ucs2':
                                case 'ucs-2':
                                case 'utf16le':
                                case 'utf-16le':
                                    return ucs2Write(this, string, offset, length);
                                default:
                                    if (loweredCase)
                                        throw new TypeError('Unknown encoding: ' + encoding);
                                    encoding = ('' + encoding).toLowerCase();
                                    loweredCase = true;
                            }
                        }
                    };
                    Buffer.prototype.toJSON = function toJSON() {
                        return {
                            type: 'Buffer',
                            data: Array.prototype.slice.call(this._arr || this, 0)
                        };
                    };
                    function base64Slice(buf, start, end) {
                        if (start === 0 && end === buf.length) {
                            return base64.fromByteArray(buf);
                        }
                        else {
                            return base64.fromByteArray(buf.slice(start, end));
                        }
                    }
                    function utf8Slice(buf, start, end) {
                        end = Math.min(buf.length, end);
                        var res = [];
                        var i = start;
                        while (i < end) {
                            var firstByte = buf[i];
                            var codePoint = null;
                            var bytesPerSequence = (firstByte > 0xEF) ? 4
                                : (firstByte > 0xDF) ? 3
                                    : (firstByte > 0xBF) ? 2
                                        : 1;
                            if (i + bytesPerSequence <= end) {
                                var secondByte, thirdByte, fourthByte, tempCodePoint;
                                switch (bytesPerSequence) {
                                    case 1:
                                        if (firstByte < 0x80) {
                                            codePoint = firstByte;
                                        }
                                        break;
                                    case 2:
                                        secondByte = buf[i + 1];
                                        if ((secondByte & 0xC0) === 0x80) {
                                            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
                                            if (tempCodePoint > 0x7F) {
                                                codePoint = tempCodePoint;
                                            }
                                        }
                                        break;
                                    case 3:
                                        secondByte = buf[i + 1];
                                        thirdByte = buf[i + 2];
                                        if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                                            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
                                            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                                                codePoint = tempCodePoint;
                                            }
                                        }
                                        break;
                                    case 4:
                                        secondByte = buf[i + 1];
                                        thirdByte = buf[i + 2];
                                        fourthByte = buf[i + 3];
                                        if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                                            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
                                            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                                                codePoint = tempCodePoint;
                                            }
                                        }
                                }
                            }
                            if (codePoint === null) {
                                codePoint = 0xFFFD;
                                bytesPerSequence = 1;
                            }
                            else if (codePoint > 0xFFFF) {
                                codePoint -= 0x10000;
                                res.push(codePoint >>> 10 & 0x3FF | 0xD800);
                                codePoint = 0xDC00 | codePoint & 0x3FF;
                            }
                            res.push(codePoint);
                            i += bytesPerSequence;
                        }
                        return decodeCodePointsArray(res);
                    }
                    var MAX_ARGUMENTS_LENGTH = 0x1000;
                    function decodeCodePointsArray(codePoints) {
                        var len = codePoints.length;
                        if (len <= MAX_ARGUMENTS_LENGTH) {
                            return String.fromCharCode.apply(String, codePoints);
                        }
                        var res = '';
                        var i = 0;
                        while (i < len) {
                            res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
                        }
                        return res;
                    }
                    function asciiSlice(buf, start, end) {
                        var ret = '';
                        end = Math.min(buf.length, end);
                        for (var i = start; i < end; ++i) {
                            ret += String.fromCharCode(buf[i] & 0x7F);
                        }
                        return ret;
                    }
                    function latin1Slice(buf, start, end) {
                        var ret = '';
                        end = Math.min(buf.length, end);
                        for (var i = start; i < end; ++i) {
                            ret += String.fromCharCode(buf[i]);
                        }
                        return ret;
                    }
                    function hexSlice(buf, start, end) {
                        var len = buf.length;
                        if (!start || start < 0)
                            start = 0;
                        if (!end || end < 0 || end > len)
                            end = len;
                        var out = '';
                        for (var i = start; i < end; ++i) {
                            out += toHex(buf[i]);
                        }
                        return out;
                    }
                    function utf16leSlice(buf, start, end) {
                        var bytes = buf.slice(start, end);
                        var res = '';
                        for (var i = 0; i < bytes.length; i += 2) {
                            res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256));
                        }
                        return res;
                    }
                    Buffer.prototype.slice = function slice(start, end) {
                        var len = this.length;
                        start = ~~start;
                        end = end === undefined ? len : ~~end;
                        if (start < 0) {
                            start += len;
                            if (start < 0)
                                start = 0;
                        }
                        else if (start > len) {
                            start = len;
                        }
                        if (end < 0) {
                            end += len;
                            if (end < 0)
                                end = 0;
                        }
                        else if (end > len) {
                            end = len;
                        }
                        if (end < start)
                            end = start;
                        var newBuf = this.subarray(start, end);
                        newBuf.__proto__ = Buffer.prototype;
                        return newBuf;
                    };
                    function checkOffset(offset, ext, length) {
                        if ((offset % 1) !== 0 || offset < 0)
                            throw new RangeError('offset is not uint');
                        if (offset + ext > length)
                            throw new RangeError('Trying to access beyond buffer length');
                    }
                    Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
                        offset = offset >>> 0;
                        byteLength = byteLength >>> 0;
                        if (!noAssert)
                            checkOffset(offset, byteLength, this.length);
                        var val = this[offset];
                        var mul = 1;
                        var i = 0;
                        while (++i < byteLength && (mul *= 0x100)) {
                            val += this[offset + i] * mul;
                        }
                        return val;
                    };
                    Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
                        offset = offset >>> 0;
                        byteLength = byteLength >>> 0;
                        if (!noAssert) {
                            checkOffset(offset, byteLength, this.length);
                        }
                        var val = this[offset + --byteLength];
                        var mul = 1;
                        while (byteLength > 0 && (mul *= 0x100)) {
                            val += this[offset + --byteLength] * mul;
                        }
                        return val;
                    };
                    Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
                        offset = offset >>> 0;
                        if (!noAssert)
                            checkOffset(offset, 1, this.length);
                        return this[offset];
                    };
                    Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
                        offset = offset >>> 0;
                        if (!noAssert)
                            checkOffset(offset, 2, this.length);
                        return this[offset] | (this[offset + 1] << 8);
                    };
                    Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
                        offset = offset >>> 0;
                        if (!noAssert)
                            checkOffset(offset, 2, this.length);
                        return (this[offset] << 8) | this[offset + 1];
                    };
                    Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
                        offset = offset >>> 0;
                        if (!noAssert)
                            checkOffset(offset, 4, this.length);
                        return ((this[offset]) |
                            (this[offset + 1] << 8) |
                            (this[offset + 2] << 16)) +
                            (this[offset + 3] * 0x1000000);
                    };
                    Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
                        offset = offset >>> 0;
                        if (!noAssert)
                            checkOffset(offset, 4, this.length);
                        return (this[offset] * 0x1000000) +
                            ((this[offset + 1] << 16) |
                                (this[offset + 2] << 8) |
                                this[offset + 3]);
                    };
                    Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
                        offset = offset >>> 0;
                        byteLength = byteLength >>> 0;
                        if (!noAssert)
                            checkOffset(offset, byteLength, this.length);
                        var val = this[offset];
                        var mul = 1;
                        var i = 0;
                        while (++i < byteLength && (mul *= 0x100)) {
                            val += this[offset + i] * mul;
                        }
                        mul *= 0x80;
                        if (val >= mul)
                            val -= Math.pow(2, 8 * byteLength);
                        return val;
                    };
                    Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
                        offset = offset >>> 0;
                        byteLength = byteLength >>> 0;
                        if (!noAssert)
                            checkOffset(offset, byteLength, this.length);
                        var i = byteLength;
                        var mul = 1;
                        var val = this[offset + --i];
                        while (i > 0 && (mul *= 0x100)) {
                            val += this[offset + --i] * mul;
                        }
                        mul *= 0x80;
                        if (val >= mul)
                            val -= Math.pow(2, 8 * byteLength);
                        return val;
                    };
                    Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
                        offset = offset >>> 0;
                        if (!noAssert)
                            checkOffset(offset, 1, this.length);
                        if (!(this[offset] & 0x80))
                            return (this[offset]);
                        return ((0xff - this[offset] + 1) * -1);
                    };
                    Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
                        offset = offset >>> 0;
                        if (!noAssert)
                            checkOffset(offset, 2, this.length);
                        var val = this[offset] | (this[offset + 1] << 8);
                        return (val & 0x8000) ? val | 0xFFFF0000 : val;
                    };
                    Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
                        offset = offset >>> 0;
                        if (!noAssert)
                            checkOffset(offset, 2, this.length);
                        var val = this[offset + 1] | (this[offset] << 8);
                        return (val & 0x8000) ? val | 0xFFFF0000 : val;
                    };
                    Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
                        offset = offset >>> 0;
                        if (!noAssert)
                            checkOffset(offset, 4, this.length);
                        return (this[offset]) |
                            (this[offset + 1] << 8) |
                            (this[offset + 2] << 16) |
                            (this[offset + 3] << 24);
                    };
                    Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
                        offset = offset >>> 0;
                        if (!noAssert)
                            checkOffset(offset, 4, this.length);
                        return (this[offset] << 24) |
                            (this[offset + 1] << 16) |
                            (this[offset + 2] << 8) |
                            (this[offset + 3]);
                    };
                    Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
                        offset = offset >>> 0;
                        if (!noAssert)
                            checkOffset(offset, 4, this.length);
                        return ieee754.read(this, offset, true, 23, 4);
                    };
                    Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
                        offset = offset >>> 0;
                        if (!noAssert)
                            checkOffset(offset, 4, this.length);
                        return ieee754.read(this, offset, false, 23, 4);
                    };
                    Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
                        offset = offset >>> 0;
                        if (!noAssert)
                            checkOffset(offset, 8, this.length);
                        return ieee754.read(this, offset, true, 52, 8);
                    };
                    Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
                        offset = offset >>> 0;
                        if (!noAssert)
                            checkOffset(offset, 8, this.length);
                        return ieee754.read(this, offset, false, 52, 8);
                    };
                    function checkInt(buf, value, offset, ext, max, min) {
                        if (!Buffer.isBuffer(buf))
                            throw new TypeError('"buffer" argument must be a Buffer instance');
                        if (value > max || value < min)
                            throw new RangeError('"value" argument is out of bounds');
                        if (offset + ext > buf.length)
                            throw new RangeError('Index out of range');
                    }
                    Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
                        value = +value;
                        offset = offset >>> 0;
                        byteLength = byteLength >>> 0;
                        if (!noAssert) {
                            var maxBytes = Math.pow(2, 8 * byteLength) - 1;
                            checkInt(this, value, offset, byteLength, maxBytes, 0);
                        }
                        var mul = 1;
                        var i = 0;
                        this[offset] = value & 0xFF;
                        while (++i < byteLength && (mul *= 0x100)) {
                            this[offset + i] = (value / mul) & 0xFF;
                        }
                        return offset + byteLength;
                    };
                    Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
                        value = +value;
                        offset = offset >>> 0;
                        byteLength = byteLength >>> 0;
                        if (!noAssert) {
                            var maxBytes = Math.pow(2, 8 * byteLength) - 1;
                            checkInt(this, value, offset, byteLength, maxBytes, 0);
                        }
                        var i = byteLength - 1;
                        var mul = 1;
                        this[offset + i] = value & 0xFF;
                        while (--i >= 0 && (mul *= 0x100)) {
                            this[offset + i] = (value / mul) & 0xFF;
                        }
                        return offset + byteLength;
                    };
                    Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
                        value = +value;
                        offset = offset >>> 0;
                        if (!noAssert)
                            checkInt(this, value, offset, 1, 0xff, 0);
                        this[offset] = (value & 0xff);
                        return offset + 1;
                    };
                    Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
                        value = +value;
                        offset = offset >>> 0;
                        if (!noAssert)
                            checkInt(this, value, offset, 2, 0xffff, 0);
                        this[offset] = (value & 0xff);
                        this[offset + 1] = (value >>> 8);
                        return offset + 2;
                    };
                    Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
                        value = +value;
                        offset = offset >>> 0;
                        if (!noAssert)
                            checkInt(this, value, offset, 2, 0xffff, 0);
                        this[offset] = (value >>> 8);
                        this[offset + 1] = (value & 0xff);
                        return offset + 2;
                    };
                    Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
                        value = +value;
                        offset = offset >>> 0;
                        if (!noAssert)
                            checkInt(this, value, offset, 4, 0xffffffff, 0);
                        this[offset + 3] = (value >>> 24);
                        this[offset + 2] = (value >>> 16);
                        this[offset + 1] = (value >>> 8);
                        this[offset] = (value & 0xff);
                        return offset + 4;
                    };
                    Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
                        value = +value;
                        offset = offset >>> 0;
                        if (!noAssert)
                            checkInt(this, value, offset, 4, 0xffffffff, 0);
                        this[offset] = (value >>> 24);
                        this[offset + 1] = (value >>> 16);
                        this[offset + 2] = (value >>> 8);
                        this[offset + 3] = (value & 0xff);
                        return offset + 4;
                    };
                    Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
                        value = +value;
                        offset = offset >>> 0;
                        if (!noAssert) {
                            var limit = Math.pow(2, (8 * byteLength) - 1);
                            checkInt(this, value, offset, byteLength, limit - 1, -limit);
                        }
                        var i = 0;
                        var mul = 1;
                        var sub = 0;
                        this[offset] = value & 0xFF;
                        while (++i < byteLength && (mul *= 0x100)) {
                            if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                                sub = 1;
                            }
                            this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
                        }
                        return offset + byteLength;
                    };
                    Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
                        value = +value;
                        offset = offset >>> 0;
                        if (!noAssert) {
                            var limit = Math.pow(2, (8 * byteLength) - 1);
                            checkInt(this, value, offset, byteLength, limit - 1, -limit);
                        }
                        var i = byteLength - 1;
                        var mul = 1;
                        var sub = 0;
                        this[offset + i] = value & 0xFF;
                        while (--i >= 0 && (mul *= 0x100)) {
                            if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                                sub = 1;
                            }
                            this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
                        }
                        return offset + byteLength;
                    };
                    Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
                        value = +value;
                        offset = offset >>> 0;
                        if (!noAssert)
                            checkInt(this, value, offset, 1, 0x7f, -0x80);
                        if (value < 0)
                            value = 0xff + value + 1;
                        this[offset] = (value & 0xff);
                        return offset + 1;
                    };
                    Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
                        value = +value;
                        offset = offset >>> 0;
                        if (!noAssert)
                            checkInt(this, value, offset, 2, 0x7fff, -0x8000);
                        this[offset] = (value & 0xff);
                        this[offset + 1] = (value >>> 8);
                        return offset + 2;
                    };
                    Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
                        value = +value;
                        offset = offset >>> 0;
                        if (!noAssert)
                            checkInt(this, value, offset, 2, 0x7fff, -0x8000);
                        this[offset] = (value >>> 8);
                        this[offset + 1] = (value & 0xff);
                        return offset + 2;
                    };
                    Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
                        value = +value;
                        offset = offset >>> 0;
                        if (!noAssert)
                            checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
                        this[offset] = (value & 0xff);
                        this[offset + 1] = (value >>> 8);
                        this[offset + 2] = (value >>> 16);
                        this[offset + 3] = (value >>> 24);
                        return offset + 4;
                    };
                    Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
                        value = +value;
                        offset = offset >>> 0;
                        if (!noAssert)
                            checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
                        if (value < 0)
                            value = 0xffffffff + value + 1;
                        this[offset] = (value >>> 24);
                        this[offset + 1] = (value >>> 16);
                        this[offset + 2] = (value >>> 8);
                        this[offset + 3] = (value & 0xff);
                        return offset + 4;
                    };
                    function checkIEEE754(buf, value, offset, ext, max, min) {
                        if (offset + ext > buf.length)
                            throw new RangeError('Index out of range');
                        if (offset < 0)
                            throw new RangeError('Index out of range');
                    }
                    function writeFloat(buf, value, offset, littleEndian, noAssert) {
                        value = +value;
                        offset = offset >>> 0;
                        if (!noAssert) {
                            checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
                        }
                        ieee754.write(buf, value, offset, littleEndian, 23, 4);
                        return offset + 4;
                    }
                    Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
                        return writeFloat(this, value, offset, true, noAssert);
                    };
                    Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
                        return writeFloat(this, value, offset, false, noAssert);
                    };
                    function writeDouble(buf, value, offset, littleEndian, noAssert) {
                        value = +value;
                        offset = offset >>> 0;
                        if (!noAssert) {
                            checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
                        }
                        ieee754.write(buf, value, offset, littleEndian, 52, 8);
                        return offset + 8;
                    }
                    Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
                        return writeDouble(this, value, offset, true, noAssert);
                    };
                    Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
                        return writeDouble(this, value, offset, false, noAssert);
                    };
                    Buffer.prototype.copy = function copy(target, targetStart, start, end) {
                        if (!Buffer.isBuffer(target))
                            throw new TypeError('argument should be a Buffer');
                        if (!start)
                            start = 0;
                        if (!end && end !== 0)
                            end = this.length;
                        if (targetStart >= target.length)
                            targetStart = target.length;
                        if (!targetStart)
                            targetStart = 0;
                        if (end > 0 && end < start)
                            end = start;
                        if (end === start)
                            return 0;
                        if (target.length === 0 || this.length === 0)
                            return 0;
                        if (targetStart < 0) {
                            throw new RangeError('targetStart out of bounds');
                        }
                        if (start < 0 || start >= this.length)
                            throw new RangeError('Index out of range');
                        if (end < 0)
                            throw new RangeError('sourceEnd out of bounds');
                        if (end > this.length)
                            end = this.length;
                        if (target.length - targetStart < end - start) {
                            end = target.length - targetStart + start;
                        }
                        var len = end - start;
                        if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
                            this.copyWithin(targetStart, start, end);
                        }
                        else if (this === target && start < targetStart && targetStart < end) {
                            for (var i = len - 1; i >= 0; --i) {
                                target[i + targetStart] = this[i + start];
                            }
                        }
                        else {
                            Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
                        }
                        return len;
                    };
                    Buffer.prototype.fill = function fill(val, start, end, encoding) {
                        if (typeof val === 'string') {
                            if (typeof start === 'string') {
                                encoding = start;
                                start = 0;
                                end = this.length;
                            }
                            else if (typeof end === 'string') {
                                encoding = end;
                                end = this.length;
                            }
                            if (encoding !== undefined && typeof encoding !== 'string') {
                                throw new TypeError('encoding must be a string');
                            }
                            if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
                                throw new TypeError('Unknown encoding: ' + encoding);
                            }
                            if (val.length === 1) {
                                var code = val.charCodeAt(0);
                                if ((encoding === 'utf8' && code < 128) ||
                                    encoding === 'latin1') {
                                    val = code;
                                }
                            }
                        }
                        else if (typeof val === 'number') {
                            val = val & 255;
                        }
                        if (start < 0 || this.length < start || this.length < end) {
                            throw new RangeError('Out of range index');
                        }
                        if (end <= start) {
                            return this;
                        }
                        start = start >>> 0;
                        end = end === undefined ? this.length : end >>> 0;
                        if (!val)
                            val = 0;
                        var i;
                        if (typeof val === 'number') {
                            for (i = start; i < end; ++i) {
                                this[i] = val;
                            }
                        }
                        else {
                            var bytes = Buffer.isBuffer(val)
                                ? val
                                : Buffer.from(val, encoding);
                            var len = bytes.length;
                            if (len === 0) {
                                throw new TypeError('The value "' + val +
                                    '" is invalid for argument "value"');
                            }
                            for (i = 0; i < end - start; ++i) {
                                this[i + start] = bytes[i % len];
                            }
                        }
                        return this;
                    };
                    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
                    function base64clean(str) {
                        str = str.split('=')[0];
                        str = str.trim().replace(INVALID_BASE64_RE, '');
                        if (str.length < 2)
                            return '';
                        while (str.length % 4 !== 0) {
                            str = str + '=';
                        }
                        return str;
                    }
                    function toHex(n) {
                        if (n < 16)
                            return '0' + n.toString(16);
                        return n.toString(16);
                    }
                    function utf8ToBytes(string, units) {
                        units = units || Infinity;
                        var codePoint;
                        var length = string.length;
                        var leadSurrogate = null;
                        var bytes = [];
                        for (var i = 0; i < length; ++i) {
                            codePoint = string.charCodeAt(i);
                            if (codePoint > 0xD7FF && codePoint < 0xE000) {
                                if (!leadSurrogate) {
                                    if (codePoint > 0xDBFF) {
                                        if ((units -= 3) > -1)
                                            bytes.push(0xEF, 0xBF, 0xBD);
                                        continue;
                                    }
                                    else if (i + 1 === length) {
                                        if ((units -= 3) > -1)
                                            bytes.push(0xEF, 0xBF, 0xBD);
                                        continue;
                                    }
                                    leadSurrogate = codePoint;
                                    continue;
                                }
                                if (codePoint < 0xDC00) {
                                    if ((units -= 3) > -1)
                                        bytes.push(0xEF, 0xBF, 0xBD);
                                    leadSurrogate = codePoint;
                                    continue;
                                }
                                codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
                            }
                            else if (leadSurrogate) {
                                if ((units -= 3) > -1)
                                    bytes.push(0xEF, 0xBF, 0xBD);
                            }
                            leadSurrogate = null;
                            if (codePoint < 0x80) {
                                if ((units -= 1) < 0)
                                    break;
                                bytes.push(codePoint);
                            }
                            else if (codePoint < 0x800) {
                                if ((units -= 2) < 0)
                                    break;
                                bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
                            }
                            else if (codePoint < 0x10000) {
                                if ((units -= 3) < 0)
                                    break;
                                bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
                            }
                            else if (codePoint < 0x110000) {
                                if ((units -= 4) < 0)
                                    break;
                                bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
                            }
                            else {
                                throw new Error('Invalid code point');
                            }
                        }
                        return bytes;
                    }
                    function asciiToBytes(str) {
                        var byteArray = [];
                        for (var i = 0; i < str.length; ++i) {
                            byteArray.push(str.charCodeAt(i) & 0xFF);
                        }
                        return byteArray;
                    }
                    function utf16leToBytes(str, units) {
                        var c, hi, lo;
                        var byteArray = [];
                        for (var i = 0; i < str.length; ++i) {
                            if ((units -= 2) < 0)
                                break;
                            c = str.charCodeAt(i);
                            hi = c >> 8;
                            lo = c % 256;
                            byteArray.push(lo);
                            byteArray.push(hi);
                        }
                        return byteArray;
                    }
                    function base64ToBytes(str) {
                        return base64.toByteArray(base64clean(str));
                    }
                    function blitBuffer(src, dst, offset, length) {
                        for (var i = 0; i < length; ++i) {
                            if ((i + offset >= dst.length) || (i >= src.length))
                                break;
                            dst[i + offset] = src[i];
                        }
                        return i;
                    }
                    function isInstance(obj, type) {
                        return obj instanceof type ||
                            (obj != null && obj.constructor != null && obj.constructor.name != null &&
                                obj.constructor.name === type.name);
                    }
                    function numberIsNaN(obj) {
                        return obj !== obj;
                    }
                }).call(this);
            }).call(this, require("buffer").Buffer);
        }, { "base64-js": 30, "buffer": 34, "ieee754": 37 }], 35: [function (require, module, exports) {
            'use strict';
            var PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g;
            var TEXT_REGEXP = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/;
            var TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
            var QESC_REGEXP = /\\([\u000b\u0020-\u00ff])/g;
            var QUOTE_REGEXP = /([\\"])/g;
            var TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
            exports.format = format;
            exports.parse = parse;
            function format(obj) {
                if (!obj || typeof obj !== 'object') {
                    throw new TypeError('argument obj is required');
                }
                var parameters = obj.parameters;
                var type = obj.type;
                if (!type || !TYPE_REGEXP.test(type)) {
                    throw new TypeError('invalid type');
                }
                var string = type;
                if (parameters && typeof parameters === 'object') {
                    var param;
                    var params = Object.keys(parameters).sort();
                    for (var i = 0; i < params.length; i++) {
                        param = params[i];
                        if (!TOKEN_REGEXP.test(param)) {
                            throw new TypeError('invalid parameter name');
                        }
                        string += '; ' + param + '=' + qstring(parameters[param]);
                    }
                }
                return string;
            }
            function parse(string) {
                if (!string) {
                    throw new TypeError('argument string is required');
                }
                var header = typeof string === 'object'
                    ? getcontenttype(string)
                    : string;
                if (typeof header !== 'string') {
                    throw new TypeError('argument string is required to be a string');
                }
                var index = header.indexOf(';');
                var type = index !== -1
                    ? header.substr(0, index).trim()
                    : header.trim();
                if (!TYPE_REGEXP.test(type)) {
                    throw new TypeError('invalid media type');
                }
                var obj = new ContentType(type.toLowerCase());
                if (index !== -1) {
                    var key;
                    var match;
                    var value;
                    PARAM_REGEXP.lastIndex = index;
                    while ((match = PARAM_REGEXP.exec(header))) {
                        if (match.index !== index) {
                            throw new TypeError('invalid parameter format');
                        }
                        index += match[0].length;
                        key = match[1].toLowerCase();
                        value = match[2];
                        if (value[0] === '"') {
                            value = value
                                .substr(1, value.length - 2)
                                .replace(QESC_REGEXP, '$1');
                        }
                        obj.parameters[key] = value;
                    }
                    if (index !== header.length) {
                        throw new TypeError('invalid parameter format');
                    }
                }
                return obj;
            }
            function getcontenttype(obj) {
                var header;
                if (typeof obj.getHeader === 'function') {
                    header = obj.getHeader('content-type');
                }
                else if (typeof obj.headers === 'object') {
                    header = obj.headers && obj.headers['content-type'];
                }
                if (typeof header !== 'string') {
                    throw new TypeError('content-type header is missing from object');
                }
                return header;
            }
            function qstring(val) {
                var str = String(val);
                if (TOKEN_REGEXP.test(str)) {
                    return str;
                }
                if (str.length > 0 && !TEXT_REGEXP.test(str)) {
                    throw new TypeError('invalid parameter value');
                }
                return '"' + str.replace(QUOTE_REGEXP, '\\$1') + '"';
            }
            function ContentType(type) {
                this.parameters = Object.create(null);
                this.type = type;
            }
        }, {}], 36: [function (require, module, exports) {
            'use strict';
            var R = typeof Reflect === 'object' ? Reflect : null;
            var ReflectApply = R && typeof R.apply === 'function'
                ? R.apply
                : function ReflectApply(target, receiver, args) {
                    return Function.prototype.apply.call(target, receiver, args);
                };
            var ReflectOwnKeys;
            if (R && typeof R.ownKeys === 'function') {
                ReflectOwnKeys = R.ownKeys;
            }
            else if (Object.getOwnPropertySymbols) {
                ReflectOwnKeys = function ReflectOwnKeys(target) {
                    return Object.getOwnPropertyNames(target)
                        .concat(Object.getOwnPropertySymbols(target));
                };
            }
            else {
                ReflectOwnKeys = function ReflectOwnKeys(target) {
                    return Object.getOwnPropertyNames(target);
                };
            }
            function ProcessEmitWarning(warning) {
                if (console && console.warn)
                    console.warn(warning);
            }
            var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
                return value !== value;
            };
            function EventEmitter() {
                EventEmitter.init.call(this);
            }
            module.exports = EventEmitter;
            module.exports.once = once;
            EventEmitter.EventEmitter = EventEmitter;
            EventEmitter.prototype._events = undefined;
            EventEmitter.prototype._eventsCount = 0;
            EventEmitter.prototype._maxListeners = undefined;
            var defaultMaxListeners = 10;
            function checkListener(listener) {
                if (typeof listener !== 'function') {
                    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
                }
            }
            Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
                enumerable: true,
                get: function () {
                    return defaultMaxListeners;
                },
                set: function (arg) {
                    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
                        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
                    }
                    defaultMaxListeners = arg;
                }
            });
            EventEmitter.init = function () {
                if (this._events === undefined ||
                    this._events === Object.getPrototypeOf(this)._events) {
                    this._events = Object.create(null);
                    this._eventsCount = 0;
                }
                this._maxListeners = this._maxListeners || undefined;
            };
            EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
                if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
                    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
                }
                this._maxListeners = n;
                return this;
            };
            function _getMaxListeners(that) {
                if (that._maxListeners === undefined)
                    return EventEmitter.defaultMaxListeners;
                return that._maxListeners;
            }
            EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
                return _getMaxListeners(this);
            };
            EventEmitter.prototype.emit = function emit(type) {
                var args = [];
                for (var i = 1; i < arguments.length; i++)
                    args.push(arguments[i]);
                var doError = (type === 'error');
                var events = this._events;
                if (events !== undefined)
                    doError = (doError && events.error === undefined);
                else if (!doError)
                    return false;
                if (doError) {
                    var er;
                    if (args.length > 0)
                        er = args[0];
                    if (er instanceof Error) {
                        throw er;
                    }
                    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
                    err.context = er;
                    throw err;
                }
                var handler = events[type];
                if (handler === undefined)
                    return false;
                if (typeof handler === 'function') {
                    ReflectApply(handler, this, args);
                }
                else {
                    var len = handler.length;
                    var listeners = arrayClone(handler, len);
                    for (var i = 0; i < len; ++i)
                        ReflectApply(listeners[i], this, args);
                }
                return true;
            };
            function _addListener(target, type, listener, prepend) {
                var m;
                var events;
                var existing;
                checkListener(listener);
                events = target._events;
                if (events === undefined) {
                    events = target._events = Object.create(null);
                    target._eventsCount = 0;
                }
                else {
                    if (events.newListener !== undefined) {
                        target.emit('newListener', type, listener.listener ? listener.listener : listener);
                        events = target._events;
                    }
                    existing = events[type];
                }
                if (existing === undefined) {
                    existing = events[type] = listener;
                    ++target._eventsCount;
                }
                else {
                    if (typeof existing === 'function') {
                        existing = events[type] =
                            prepend ? [listener, existing] : [existing, listener];
                    }
                    else if (prepend) {
                        existing.unshift(listener);
                    }
                    else {
                        existing.push(listener);
                    }
                    m = _getMaxListeners(target);
                    if (m > 0 && existing.length > m && !existing.warned) {
                        existing.warned = true;
                        var w = new Error('Possible EventEmitter memory leak detected. ' +
                            existing.length + ' ' + String(type) + ' listeners ' +
                            'added. Use emitter.setMaxListeners() to ' +
                            'increase limit');
                        w.name = 'MaxListenersExceededWarning';
                        w.emitter = target;
                        w.type = type;
                        w.count = existing.length;
                        ProcessEmitWarning(w);
                    }
                }
                return target;
            }
            EventEmitter.prototype.addListener = function addListener(type, listener) {
                return _addListener(this, type, listener, false);
            };
            EventEmitter.prototype.on = EventEmitter.prototype.addListener;
            EventEmitter.prototype.prependListener =
                function prependListener(type, listener) {
                    return _addListener(this, type, listener, true);
                };
            function onceWrapper() {
                if (!this.fired) {
                    this.target.removeListener(this.type, this.wrapFn);
                    this.fired = true;
                    if (arguments.length === 0)
                        return this.listener.call(this.target);
                    return this.listener.apply(this.target, arguments);
                }
            }
            function _onceWrap(target, type, listener) {
                var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
                var wrapped = onceWrapper.bind(state);
                wrapped.listener = listener;
                state.wrapFn = wrapped;
                return wrapped;
            }
            EventEmitter.prototype.once = function once(type, listener) {
                checkListener(listener);
                this.on(type, _onceWrap(this, type, listener));
                return this;
            };
            EventEmitter.prototype.prependOnceListener =
                function prependOnceListener(type, listener) {
                    checkListener(listener);
                    this.prependListener(type, _onceWrap(this, type, listener));
                    return this;
                };
            EventEmitter.prototype.removeListener =
                function removeListener(type, listener) {
                    var list, events, position, i, originalListener;
                    checkListener(listener);
                    events = this._events;
                    if (events === undefined)
                        return this;
                    list = events[type];
                    if (list === undefined)
                        return this;
                    if (list === listener || list.listener === listener) {
                        if (--this._eventsCount === 0)
                            this._events = Object.create(null);
                        else {
                            delete events[type];
                            if (events.removeListener)
                                this.emit('removeListener', type, list.listener || listener);
                        }
                    }
                    else if (typeof list !== 'function') {
                        position = -1;
                        for (i = list.length - 1; i >= 0; i--) {
                            if (list[i] === listener || list[i].listener === listener) {
                                originalListener = list[i].listener;
                                position = i;
                                break;
                            }
                        }
                        if (position < 0)
                            return this;
                        if (position === 0)
                            list.shift();
                        else {
                            spliceOne(list, position);
                        }
                        if (list.length === 1)
                            events[type] = list[0];
                        if (events.removeListener !== undefined)
                            this.emit('removeListener', type, originalListener || listener);
                    }
                    return this;
                };
            EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
            EventEmitter.prototype.removeAllListeners =
                function removeAllListeners(type) {
                    var listeners, events, i;
                    events = this._events;
                    if (events === undefined)
                        return this;
                    if (events.removeListener === undefined) {
                        if (arguments.length === 0) {
                            this._events = Object.create(null);
                            this._eventsCount = 0;
                        }
                        else if (events[type] !== undefined) {
                            if (--this._eventsCount === 0)
                                this._events = Object.create(null);
                            else
                                delete events[type];
                        }
                        return this;
                    }
                    if (arguments.length === 0) {
                        var keys = Object.keys(events);
                        var key;
                        for (i = 0; i < keys.length; ++i) {
                            key = keys[i];
                            if (key === 'removeListener')
                                continue;
                            this.removeAllListeners(key);
                        }
                        this.removeAllListeners('removeListener');
                        this._events = Object.create(null);
                        this._eventsCount = 0;
                        return this;
                    }
                    listeners = events[type];
                    if (typeof listeners === 'function') {
                        this.removeListener(type, listeners);
                    }
                    else if (listeners !== undefined) {
                        for (i = listeners.length - 1; i >= 0; i--) {
                            this.removeListener(type, listeners[i]);
                        }
                    }
                    return this;
                };
            function _listeners(target, type, unwrap) {
                var events = target._events;
                if (events === undefined)
                    return [];
                var evlistener = events[type];
                if (evlistener === undefined)
                    return [];
                if (typeof evlistener === 'function')
                    return unwrap ? [evlistener.listener || evlistener] : [evlistener];
                return unwrap ?
                    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
            }
            EventEmitter.prototype.listeners = function listeners(type) {
                return _listeners(this, type, true);
            };
            EventEmitter.prototype.rawListeners = function rawListeners(type) {
                return _listeners(this, type, false);
            };
            EventEmitter.listenerCount = function (emitter, type) {
                if (typeof emitter.listenerCount === 'function') {
                    return emitter.listenerCount(type);
                }
                else {
                    return listenerCount.call(emitter, type);
                }
            };
            EventEmitter.prototype.listenerCount = listenerCount;
            function listenerCount(type) {
                var events = this._events;
                if (events !== undefined) {
                    var evlistener = events[type];
                    if (typeof evlistener === 'function') {
                        return 1;
                    }
                    else if (evlistener !== undefined) {
                        return evlistener.length;
                    }
                }
                return 0;
            }
            EventEmitter.prototype.eventNames = function eventNames() {
                return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
            };
            function arrayClone(arr, n) {
                var copy = new Array(n);
                for (var i = 0; i < n; ++i)
                    copy[i] = arr[i];
                return copy;
            }
            function spliceOne(list, index) {
                for (; index + 1 < list.length; index++)
                    list[index] = list[index + 1];
                list.pop();
            }
            function unwrapListeners(arr) {
                var ret = new Array(arr.length);
                for (var i = 0; i < ret.length; ++i) {
                    ret[i] = arr[i].listener || arr[i];
                }
                return ret;
            }
            function once(emitter, name) {
                return new Promise(function (resolve, reject) {
                    function eventListener() {
                        if (errorListener !== undefined) {
                            emitter.removeListener('error', errorListener);
                        }
                        resolve([].slice.call(arguments));
                    }
                    ;
                    var errorListener;
                    if (name !== 'error') {
                        errorListener = function errorListener(err) {
                            emitter.removeListener(name, eventListener);
                            reject(err);
                        };
                        emitter.once('error', errorListener);
                    }
                    emitter.once(name, eventListener);
                });
            }
        }, {}], 37: [function (require, module, exports) {
            exports.read = function (buffer, offset, isLE, mLen, nBytes) {
                var e, m;
                var eLen = (nBytes * 8) - mLen - 1;
                var eMax = (1 << eLen) - 1;
                var eBias = eMax >> 1;
                var nBits = -7;
                var i = isLE ? (nBytes - 1) : 0;
                var d = isLE ? -1 : 1;
                var s = buffer[offset + i];
                i += d;
                e = s & ((1 << (-nBits)) - 1);
                s >>= (-nBits);
                nBits += eLen;
                for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) { }
                m = e & ((1 << (-nBits)) - 1);
                e >>= (-nBits);
                nBits += mLen;
                for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) { }
                if (e === 0) {
                    e = 1 - eBias;
                }
                else if (e === eMax) {
                    return m ? NaN : ((s ? -1 : 1) * Infinity);
                }
                else {
                    m = m + Math.pow(2, mLen);
                    e = e - eBias;
                }
                return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
            };
            exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
                var e, m, c;
                var eLen = (nBytes * 8) - mLen - 1;
                var eMax = (1 << eLen) - 1;
                var eBias = eMax >> 1;
                var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
                var i = isLE ? 0 : (nBytes - 1);
                var d = isLE ? 1 : -1;
                var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;
                value = Math.abs(value);
                if (isNaN(value) || value === Infinity) {
                    m = isNaN(value) ? 1 : 0;
                    e = eMax;
                }
                else {
                    e = Math.floor(Math.log(value) / Math.LN2);
                    if (value * (c = Math.pow(2, -e)) < 1) {
                        e--;
                        c *= 2;
                    }
                    if (e + eBias >= 1) {
                        value += rt / c;
                    }
                    else {
                        value += rt * Math.pow(2, 1 - eBias);
                    }
                    if (value * c >= 2) {
                        e++;
                        c /= 2;
                    }
                    if (e + eBias >= eMax) {
                        m = 0;
                        e = eMax;
                    }
                    else if (e + eBias >= 1) {
                        m = ((value * c) - 1) * Math.pow(2, mLen);
                        e = e + eBias;
                    }
                    else {
                        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                        e = 0;
                    }
                }
                for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) { }
                e = (e << mLen) | m;
                eLen += mLen;
                for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) { }
                buffer[offset + i - d] |= s * 128;
            };
        }, {}], 38: [function (require, module, exports) {
            (function (root, definition) {
                "use strict";
                if (typeof define === 'function' && define.amd) {
                    define(definition);
                }
                else if (typeof module === 'object' && module.exports) {
                    module.exports = definition();
                }
                else {
                    root.log = definition();
                }
            }(this, function () {
                "use strict";
                var noop = function () { };
                var undefinedType = "undefined";
                var isIE = (typeof window !== undefinedType) && (typeof window.navigator !== undefinedType) && (/Trident\/|MSIE /.test(window.navigator.userAgent));
                var logMethods = [
                    "trace",
                    "debug",
                    "info",
                    "warn",
                    "error"
                ];
                function bindMethod(obj, methodName) {
                    var method = obj[methodName];
                    if (typeof method.bind === 'function') {
                        return method.bind(obj);
                    }
                    else {
                        try {
                            return Function.prototype.bind.call(method, obj);
                        }
                        catch (e) {
                            return function () {
                                return Function.prototype.apply.apply(method, [obj, arguments]);
                            };
                        }
                    }
                }
                function traceForIE() {
                    if (console.log) {
                        if (console.log.apply) {
                            console.log.apply(console, arguments);
                        }
                        else {
                            Function.prototype.apply.apply(console.log, [console, arguments]);
                        }
                    }
                    if (console.trace)
                        console.trace();
                }
                function realMethod(methodName) {
                    if (methodName === 'debug') {
                        methodName = 'log';
                    }
                    if (typeof console === undefinedType) {
                        return false;
                    }
                    else if (methodName === 'trace' && isIE) {
                        return traceForIE;
                    }
                    else if (console[methodName] !== undefined) {
                        return bindMethod(console, methodName);
                    }
                    else if (console.log !== undefined) {
                        return bindMethod(console, 'log');
                    }
                    else {
                        return noop;
                    }
                }
                function replaceLoggingMethods(level, loggerName) {
                    for (var i = 0; i < logMethods.length; i++) {
                        var methodName = logMethods[i];
                        this[methodName] = (i < level) ?
                            noop :
                            this.methodFactory(methodName, level, loggerName);
                    }
                    this.log = this.debug;
                }
                function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
                    return function () {
                        if (typeof console !== undefinedType) {
                            replaceLoggingMethods.call(this, level, loggerName);
                            this[methodName].apply(this, arguments);
                        }
                    };
                }
                function defaultMethodFactory(methodName, level, loggerName) {
                    return realMethod(methodName) ||
                        enableLoggingWhenConsoleArrives.apply(this, arguments);
                }
                function Logger(name, defaultLevel, factory) {
                    var self = this;
                    var currentLevel;
                    var storageKey = "loglevel";
                    if (typeof name === "string") {
                        storageKey += ":" + name;
                    }
                    else if (typeof name === "symbol") {
                        storageKey = undefined;
                    }
                    function persistLevelIfPossible(levelNum) {
                        var levelName = (logMethods[levelNum] || 'silent').toUpperCase();
                        if (typeof window === undefinedType || !storageKey)
                            return;
                        try {
                            window.localStorage[storageKey] = levelName;
                            return;
                        }
                        catch (ignore) { }
                        try {
                            window.document.cookie =
                                encodeURIComponent(storageKey) + "=" + levelName + ";";
                        }
                        catch (ignore) { }
                    }
                    function getPersistedLevel() {
                        var storedLevel;
                        if (typeof window === undefinedType || !storageKey)
                            return;
                        try {
                            storedLevel = window.localStorage[storageKey];
                        }
                        catch (ignore) { }
                        if (typeof storedLevel === undefinedType) {
                            try {
                                var cookie = window.document.cookie;
                                var location = cookie.indexOf(encodeURIComponent(storageKey) + "=");
                                if (location !== -1) {
                                    storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
                                }
                            }
                            catch (ignore) { }
                        }
                        if (self.levels[storedLevel] === undefined) {
                            storedLevel = undefined;
                        }
                        return storedLevel;
                    }
                    self.name = name;
                    self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
                        "ERROR": 4, "SILENT": 5 };
                    self.methodFactory = factory || defaultMethodFactory;
                    self.getLevel = function () {
                        return currentLevel;
                    };
                    self.setLevel = function (level, persist) {
                        if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
                            level = self.levels[level.toUpperCase()];
                        }
                        if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
                            currentLevel = level;
                            if (persist !== false) {
                                persistLevelIfPossible(level);
                            }
                            replaceLoggingMethods.call(self, level, name);
                            if (typeof console === undefinedType && level < self.levels.SILENT) {
                                return "No console available for logging";
                            }
                        }
                        else {
                            throw "log.setLevel() called with invalid level: " + level;
                        }
                    };
                    self.setDefaultLevel = function (level) {
                        if (!getPersistedLevel()) {
                            self.setLevel(level, false);
                        }
                    };
                    self.enableAll = function (persist) {
                        self.setLevel(self.levels.TRACE, persist);
                    };
                    self.disableAll = function (persist) {
                        self.setLevel(self.levels.SILENT, persist);
                    };
                    var initialLevel = getPersistedLevel();
                    if (initialLevel == null) {
                        initialLevel = defaultLevel == null ? "WARN" : defaultLevel;
                    }
                    self.setLevel(initialLevel, false);
                }
                var defaultLogger = new Logger();
                var _loggersByName = {};
                defaultLogger.getLogger = function getLogger(name) {
                    if ((typeof name !== "symbol" && typeof name !== "string") || name === "") {
                        throw new TypeError("You must supply a name when creating a logger.");
                    }
                    var logger = _loggersByName[name];
                    if (!logger) {
                        logger = _loggersByName[name] = new Logger(name, defaultLogger.getLevel(), defaultLogger.methodFactory);
                    }
                    return logger;
                };
                var _log = (typeof window !== undefinedType) ? window.log : undefined;
                defaultLogger.noConflict = function () {
                    if (typeof window !== undefinedType &&
                        window.log === defaultLogger) {
                        window.log = _log;
                    }
                    return defaultLogger;
                };
                defaultLogger.getLoggers = function getLoggers() {
                    return _loggersByName;
                };
                defaultLogger['default'] = defaultLogger;
                return defaultLogger;
            }));
        }, {}], 39: [function (require, module, exports) {
            'use strict';
            var replace = String.prototype.replace;
            var percentTwenties = /%20/g;
            var Format = {
                RFC1738: 'RFC1738',
                RFC3986: 'RFC3986'
            };
            module.exports = {
                'default': Format.RFC3986,
                formatters: {
                    RFC1738: function (value) {
                        return replace.call(value, percentTwenties, '+');
                    },
                    RFC3986: function (value) {
                        return String(value);
                    }
                },
                RFC1738: Format.RFC1738,
                RFC3986: Format.RFC3986
            };
        }, {}], 40: [function (require, module, exports) {
            'use strict';
            var stringify = require('./stringify');
            var parse = require('./parse');
            var formats = require('./formats');
            module.exports = {
                formats: formats,
                parse: parse,
                stringify: stringify
            };
        }, { "./formats": 39, "./parse": 41, "./stringify": 42 }], 41: [function (require, module, exports) {
            'use strict';
            var utils = require('./utils');
            var has = Object.prototype.hasOwnProperty;
            var isArray = Array.isArray;
            var defaults = {
                allowDots: false,
                allowPrototypes: false,
                arrayLimit: 20,
                charset: 'utf-8',
                charsetSentinel: false,
                comma: false,
                decoder: utils.decode,
                delimiter: '&',
                depth: 5,
                ignoreQueryPrefix: false,
                interpretNumericEntities: false,
                parameterLimit: 1000,
                parseArrays: true,
                plainObjects: false,
                strictNullHandling: false
            };
            var interpretNumericEntities = function (str) {
                return str.replace(/&#(\d+);/g, function ($0, numberStr) {
                    return String.fromCharCode(parseInt(numberStr, 10));
                });
            };
            var parseArrayValue = function (val, options) {
                if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
                    return val.split(',');
                }
                return val;
            };
            var isoSentinel = 'utf8=%26%2310003%3B';
            var charsetSentinel = 'utf8=%E2%9C%93';
            var parseValues = function parseQueryStringValues(str, options) {
                var obj = {};
                var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
                var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
                var parts = cleanStr.split(options.delimiter, limit);
                var skipIndex = -1;
                var i;
                var charset = options.charset;
                if (options.charsetSentinel) {
                    for (i = 0; i < parts.length; ++i) {
                        if (parts[i].indexOf('utf8=') === 0) {
                            if (parts[i] === charsetSentinel) {
                                charset = 'utf-8';
                            }
                            else if (parts[i] === isoSentinel) {
                                charset = 'iso-8859-1';
                            }
                            skipIndex = i;
                            i = parts.length;
                        }
                    }
                }
                for (i = 0; i < parts.length; ++i) {
                    if (i === skipIndex) {
                        continue;
                    }
                    var part = parts[i];
                    var bracketEqualsPos = part.indexOf(']=');
                    var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;
                    var key, val;
                    if (pos === -1) {
                        key = options.decoder(part, defaults.decoder, charset, 'key');
                        val = options.strictNullHandling ? null : '';
                    }
                    else {
                        key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');
                        val = utils.maybeMap(parseArrayValue(part.slice(pos + 1), options), function (encodedVal) {
                            return options.decoder(encodedVal, defaults.decoder, charset, 'value');
                        });
                    }
                    if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
                        val = interpretNumericEntities(val);
                    }
                    if (part.indexOf('[]=') > -1) {
                        val = isArray(val) ? [val] : val;
                    }
                    if (has.call(obj, key)) {
                        obj[key] = utils.combine(obj[key], val);
                    }
                    else {
                        obj[key] = val;
                    }
                }
                return obj;
            };
            var parseObject = function (chain, val, options, valuesParsed) {
                var leaf = valuesParsed ? val : parseArrayValue(val, options);
                for (var i = chain.length - 1; i >= 0; --i) {
                    var obj;
                    var root = chain[i];
                    if (root === '[]' && options.parseArrays) {
                        obj = [].concat(leaf);
                    }
                    else {
                        obj = options.plainObjects ? Object.create(null) : {};
                        var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
                        var index = parseInt(cleanRoot, 10);
                        if (!options.parseArrays && cleanRoot === '') {
                            obj = { 0: leaf };
                        }
                        else if (!isNaN(index)
                            && root !== cleanRoot
                            && String(index) === cleanRoot
                            && index >= 0
                            && (options.parseArrays && index <= options.arrayLimit)) {
                            obj = [];
                            obj[index] = leaf;
                        }
                        else {
                            obj[cleanRoot] = leaf;
                        }
                    }
                    leaf = obj;
                }
                return leaf;
            };
            var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
                if (!givenKey) {
                    return;
                }
                var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;
                var brackets = /(\[[^[\]]*])/;
                var child = /(\[[^[\]]*])/g;
                var segment = options.depth > 0 && brackets.exec(key);
                var parent = segment ? key.slice(0, segment.index) : key;
                var keys = [];
                if (parent) {
                    if (!options.plainObjects && has.call(Object.prototype, parent)) {
                        if (!options.allowPrototypes) {
                            return;
                        }
                    }
                    keys.push(parent);
                }
                var i = 0;
                while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
                    i += 1;
                    if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
                        if (!options.allowPrototypes) {
                            return;
                        }
                    }
                    keys.push(segment[1]);
                }
                if (segment) {
                    keys.push('[' + key.slice(segment.index) + ']');
                }
                return parseObject(keys, val, options, valuesParsed);
            };
            var normalizeParseOptions = function normalizeParseOptions(opts) {
                if (!opts) {
                    return defaults;
                }
                if (opts.decoder !== null && opts.decoder !== undefined && typeof opts.decoder !== 'function') {
                    throw new TypeError('Decoder has to be a function.');
                }
                if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
                    throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
                }
                var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;
                return {
                    allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
                    allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
                    arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
                    charset: charset,
                    charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
                    comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
                    decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
                    delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
                    depth: (typeof opts.depth === 'number' || opts.depth === false) ? +opts.depth : defaults.depth,
                    ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
                    interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
                    parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
                    parseArrays: opts.parseArrays !== false,
                    plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
                    strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
                };
            };
            module.exports = function (str, opts) {
                var options = normalizeParseOptions(opts);
                if (str === '' || str === null || typeof str === 'undefined') {
                    return options.plainObjects ? Object.create(null) : {};
                }
                var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
                var obj = options.plainObjects ? Object.create(null) : {};
                var keys = Object.keys(tempObj);
                for (var i = 0; i < keys.length; ++i) {
                    var key = keys[i];
                    var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');
                    obj = utils.merge(obj, newObj, options);
                }
                return utils.compact(obj);
            };
        }, { "./utils": 43 }], 42: [function (require, module, exports) {
            'use strict';
            var utils = require('./utils');
            var formats = require('./formats');
            var has = Object.prototype.hasOwnProperty;
            var arrayPrefixGenerators = {
                brackets: function brackets(prefix) {
                    return prefix + '[]';
                },
                comma: 'comma',
                indices: function indices(prefix, key) {
                    return prefix + '[' + key + ']';
                },
                repeat: function repeat(prefix) {
                    return prefix;
                }
            };
            var isArray = Array.isArray;
            var push = Array.prototype.push;
            var pushToArray = function (arr, valueOrArray) {
                push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
            };
            var toISO = Date.prototype.toISOString;
            var defaultFormat = formats['default'];
            var defaults = {
                addQueryPrefix: false,
                allowDots: false,
                charset: 'utf-8',
                charsetSentinel: false,
                delimiter: '&',
                encode: true,
                encoder: utils.encode,
                encodeValuesOnly: false,
                format: defaultFormat,
                formatter: formats.formatters[defaultFormat],
                indices: false,
                serializeDate: function serializeDate(date) {
                    return toISO.call(date);
                },
                skipNulls: false,
                strictNullHandling: false
            };
            var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
                return typeof v === 'string'
                    || typeof v === 'number'
                    || typeof v === 'boolean'
                    || typeof v === 'symbol'
                    || typeof v === 'bigint';
            };
            var stringify = function stringify(object, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset) {
                var obj = object;
                if (typeof filter === 'function') {
                    obj = filter(prefix, obj);
                }
                else if (obj instanceof Date) {
                    obj = serializeDate(obj);
                }
                else if (generateArrayPrefix === 'comma' && isArray(obj)) {
                    obj = utils.maybeMap(obj, function (value) {
                        if (value instanceof Date) {
                            return serializeDate(value);
                        }
                        return value;
                    });
                }
                if (obj === null) {
                    if (strictNullHandling) {
                        return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key', format) : prefix;
                    }
                    obj = '';
                }
                if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
                    if (encoder) {
                        var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key', format);
                        return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value', format))];
                    }
                    return [formatter(prefix) + '=' + formatter(String(obj))];
                }
                var values = [];
                if (typeof obj === 'undefined') {
                    return values;
                }
                var objKeys;
                if (generateArrayPrefix === 'comma' && isArray(obj)) {
                    objKeys = [{ value: obj.length > 0 ? obj.join(',') || null : undefined }];
                }
                else if (isArray(filter)) {
                    objKeys = filter;
                }
                else {
                    var keys = Object.keys(obj);
                    objKeys = sort ? keys.sort(sort) : keys;
                }
                for (var i = 0; i < objKeys.length; ++i) {
                    var key = objKeys[i];
                    var value = typeof key === 'object' && key.value !== undefined ? key.value : obj[key];
                    if (skipNulls && value === null) {
                        continue;
                    }
                    var keyPrefix = isArray(obj)
                        ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(prefix, key) : prefix
                        : prefix + (allowDots ? '.' + key : '[' + key + ']');
                    pushToArray(values, stringify(value, keyPrefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset));
                }
                return values;
            };
            var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
                if (!opts) {
                    return defaults;
                }
                if (opts.encoder !== null && opts.encoder !== undefined && typeof opts.encoder !== 'function') {
                    throw new TypeError('Encoder has to be a function.');
                }
                var charset = opts.charset || defaults.charset;
                if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
                    throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
                }
                var format = formats['default'];
                if (typeof opts.format !== 'undefined') {
                    if (!has.call(formats.formatters, opts.format)) {
                        throw new TypeError('Unknown format option provided.');
                    }
                    format = opts.format;
                }
                var formatter = formats.formatters[format];
                var filter = defaults.filter;
                if (typeof opts.filter === 'function' || isArray(opts.filter)) {
                    filter = opts.filter;
                }
                return {
                    addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
                    allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
                    charset: charset,
                    charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
                    delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
                    encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
                    encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
                    encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
                    filter: filter,
                    format: format,
                    formatter: formatter,
                    serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
                    skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
                    sort: typeof opts.sort === 'function' ? opts.sort : null,
                    strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
                };
            };
            module.exports = function (object, opts) {
                var obj = object;
                var options = normalizeStringifyOptions(opts);
                var objKeys;
                var filter;
                if (typeof options.filter === 'function') {
                    filter = options.filter;
                    obj = filter('', obj);
                }
                else if (isArray(options.filter)) {
                    filter = options.filter;
                    objKeys = filter;
                }
                var keys = [];
                if (typeof obj !== 'object' || obj === null) {
                    return '';
                }
                var arrayFormat;
                if (opts && opts.arrayFormat in arrayPrefixGenerators) {
                    arrayFormat = opts.arrayFormat;
                }
                else if (opts && 'indices' in opts) {
                    arrayFormat = opts.indices ? 'indices' : 'repeat';
                }
                else {
                    arrayFormat = 'indices';
                }
                var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
                if (!objKeys) {
                    objKeys = Object.keys(obj);
                }
                if (options.sort) {
                    objKeys.sort(options.sort);
                }
                for (var i = 0; i < objKeys.length; ++i) {
                    var key = objKeys[i];
                    if (options.skipNulls && obj[key] === null) {
                        continue;
                    }
                    pushToArray(keys, stringify(obj[key], key, generateArrayPrefix, options.strictNullHandling, options.skipNulls, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.format, options.formatter, options.encodeValuesOnly, options.charset));
                }
                var joined = keys.join(options.delimiter);
                var prefix = options.addQueryPrefix === true ? '?' : '';
                if (options.charsetSentinel) {
                    if (options.charset === 'iso-8859-1') {
                        prefix += 'utf8=%26%2310003%3B&';
                    }
                    else {
                        prefix += 'utf8=%E2%9C%93&';
                    }
                }
                return joined.length > 0 ? prefix + joined : '';
            };
        }, { "./formats": 39, "./utils": 43 }], 43: [function (require, module, exports) {
            'use strict';
            var formats = require('./formats');
            var has = Object.prototype.hasOwnProperty;
            var isArray = Array.isArray;
            var hexTable = (function () {
                var array = [];
                for (var i = 0; i < 256; ++i) {
                    array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
                }
                return array;
            }());
            var compactQueue = function compactQueue(queue) {
                while (queue.length > 1) {
                    var item = queue.pop();
                    var obj = item.obj[item.prop];
                    if (isArray(obj)) {
                        var compacted = [];
                        for (var j = 0; j < obj.length; ++j) {
                            if (typeof obj[j] !== 'undefined') {
                                compacted.push(obj[j]);
                            }
                        }
                        item.obj[item.prop] = compacted;
                    }
                }
            };
            var arrayToObject = function arrayToObject(source, options) {
                var obj = options && options.plainObjects ? Object.create(null) : {};
                for (var i = 0; i < source.length; ++i) {
                    if (typeof source[i] !== 'undefined') {
                        obj[i] = source[i];
                    }
                }
                return obj;
            };
            var merge = function merge(target, source, options) {
                if (!source) {
                    return target;
                }
                if (typeof source !== 'object') {
                    if (isArray(target)) {
                        target.push(source);
                    }
                    else if (target && typeof target === 'object') {
                        if ((options && (options.plainObjects || options.allowPrototypes)) || !has.call(Object.prototype, source)) {
                            target[source] = true;
                        }
                    }
                    else {
                        return [target, source];
                    }
                    return target;
                }
                if (!target || typeof target !== 'object') {
                    return [target].concat(source);
                }
                var mergeTarget = target;
                if (isArray(target) && !isArray(source)) {
                    mergeTarget = arrayToObject(target, options);
                }
                if (isArray(target) && isArray(source)) {
                    source.forEach(function (item, i) {
                        if (has.call(target, i)) {
                            var targetItem = target[i];
                            if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
                                target[i] = merge(targetItem, item, options);
                            }
                            else {
                                target.push(item);
                            }
                        }
                        else {
                            target[i] = item;
                        }
                    });
                    return target;
                }
                return Object.keys(source).reduce(function (acc, key) {
                    var value = source[key];
                    if (has.call(acc, key)) {
                        acc[key] = merge(acc[key], value, options);
                    }
                    else {
                        acc[key] = value;
                    }
                    return acc;
                }, mergeTarget);
            };
            var assign = function assignSingleSource(target, source) {
                return Object.keys(source).reduce(function (acc, key) {
                    acc[key] = source[key];
                    return acc;
                }, target);
            };
            var decode = function (str, decoder, charset) {
                var strWithoutPlus = str.replace(/\+/g, ' ');
                if (charset === 'iso-8859-1') {
                    return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
                }
                try {
                    return decodeURIComponent(strWithoutPlus);
                }
                catch (e) {
                    return strWithoutPlus;
                }
            };
            var encode = function encode(str, defaultEncoder, charset, kind, format) {
                if (str.length === 0) {
                    return str;
                }
                var string = str;
                if (typeof str === 'symbol') {
                    string = Symbol.prototype.toString.call(str);
                }
                else if (typeof str !== 'string') {
                    string = String(str);
                }
                if (charset === 'iso-8859-1') {
                    return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
                        return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
                    });
                }
                var out = '';
                for (var i = 0; i < string.length; ++i) {
                    var c = string.charCodeAt(i);
                    if (c === 0x2D
                        || c === 0x2E
                        || c === 0x5F
                        || c === 0x7E
                        || (c >= 0x30 && c <= 0x39)
                        || (c >= 0x41 && c <= 0x5A)
                        || (c >= 0x61 && c <= 0x7A)
                        || (format === formats.RFC1738 && (c === 0x28 || c === 0x29))) {
                        out += string.charAt(i);
                        continue;
                    }
                    if (c < 0x80) {
                        out = out + hexTable[c];
                        continue;
                    }
                    if (c < 0x800) {
                        out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);
                        continue;
                    }
                    if (c < 0xD800 || c >= 0xE000) {
                        out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
                        continue;
                    }
                    i += 1;
                    c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
                    out += hexTable[0xF0 | (c >> 18)]
                        + hexTable[0x80 | ((c >> 12) & 0x3F)]
                        + hexTable[0x80 | ((c >> 6) & 0x3F)]
                        + hexTable[0x80 | (c & 0x3F)];
                }
                return out;
            };
            var compact = function compact(value) {
                var queue = [{ obj: { o: value }, prop: 'o' }];
                var refs = [];
                for (var i = 0; i < queue.length; ++i) {
                    var item = queue[i];
                    var obj = item.obj[item.prop];
                    var keys = Object.keys(obj);
                    for (var j = 0; j < keys.length; ++j) {
                        var key = keys[j];
                        var val = obj[key];
                        if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                            queue.push({ obj: obj, prop: key });
                            refs.push(val);
                        }
                    }
                }
                compactQueue(queue);
                return value;
            };
            var isRegExp = function isRegExp(obj) {
                return Object.prototype.toString.call(obj) === '[object RegExp]';
            };
            var isBuffer = function isBuffer(obj) {
                if (!obj || typeof obj !== 'object') {
                    return false;
                }
                return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
            };
            var combine = function combine(a, b) {
                return [].concat(a, b);
            };
            var maybeMap = function maybeMap(val, fn) {
                if (isArray(val)) {
                    var mapped = [];
                    for (var i = 0; i < val.length; i += 1) {
                        mapped.push(fn(val[i]));
                    }
                    return mapped;
                }
                return fn(val);
            };
            module.exports = {
                arrayToObject: arrayToObject,
                assign: assign,
                combine: combine,
                compact: compact,
                decode: decode,
                encode: encode,
                isBuffer: isBuffer,
                isRegExp: isRegExp,
                maybeMap: maybeMap,
                merge: merge
            };
        }, { "./formats": 39 }], 44: [function (require, module, exports) {
            'use strict';
            function hasOwnProperty(obj, prop) {
                return Object.prototype.hasOwnProperty.call(obj, prop);
            }
            module.exports = function (qs, sep, eq, options) {
                sep = sep || '&';
                eq = eq || '=';
                var obj = {};
                if (typeof qs !== 'string' || qs.length === 0) {
                    return obj;
                }
                var regexp = /\+/g;
                qs = qs.split(sep);
                var maxKeys = 1000;
                if (options && typeof options.maxKeys === 'number') {
                    maxKeys = options.maxKeys;
                }
                var len = qs.length;
                if (maxKeys > 0 && len > maxKeys) {
                    len = maxKeys;
                }
                for (var i = 0; i < len; ++i) {
                    var x = qs[i].replace(regexp, '%20'), idx = x.indexOf(eq), kstr, vstr, k, v;
                    if (idx >= 0) {
                        kstr = x.substr(0, idx);
                        vstr = x.substr(idx + 1);
                    }
                    else {
                        kstr = x;
                        vstr = '';
                    }
                    k = decodeURIComponent(kstr);
                    v = decodeURIComponent(vstr);
                    if (!hasOwnProperty(obj, k)) {
                        obj[k] = v;
                    }
                    else if (isArray(obj[k])) {
                        obj[k].push(v);
                    }
                    else {
                        obj[k] = [obj[k], v];
                    }
                }
                return obj;
            };
            var isArray = Array.isArray || function (xs) {
                return Object.prototype.toString.call(xs) === '[object Array]';
            };
        }, {}], 45: [function (require, module, exports) {
            'use strict';
            var stringifyPrimitive = function (v) {
                switch (typeof v) {
                    case 'string':
                        return v;
                    case 'boolean':
                        return v ? 'true' : 'false';
                    case 'number':
                        return isFinite(v) ? v : '';
                    default:
                        return '';
                }
            };
            module.exports = function (obj, sep, eq, name) {
                sep = sep || '&';
                eq = eq || '=';
                if (obj === null) {
                    obj = undefined;
                }
                if (typeof obj === 'object') {
                    return map(objectKeys(obj), function (k) {
                        var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
                        if (isArray(obj[k])) {
                            return map(obj[k], function (v) {
                                return ks + encodeURIComponent(stringifyPrimitive(v));
                            }).join(sep);
                        }
                        else {
                            return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
                        }
                    }).join(sep);
                }
                if (!name)
                    return '';
                return encodeURIComponent(stringifyPrimitive(name)) + eq +
                    encodeURIComponent(stringifyPrimitive(obj));
            };
            var isArray = Array.isArray || function (xs) {
                return Object.prototype.toString.call(xs) === '[object Array]';
            };
            function map(xs, f) {
                if (xs.map)
                    return xs.map(f);
                var res = [];
                for (var i = 0; i < xs.length; i++) {
                    res.push(f(xs[i], i));
                }
                return res;
            }
            var objectKeys = Object.keys || function (obj) {
                var res = [];
                for (var key in obj) {
                    if (Object.prototype.hasOwnProperty.call(obj, key))
                        res.push(key);
                }
                return res;
            };
        }, {}], 46: [function (require, module, exports) {
            'use strict';
            exports.decode = exports.parse = require('./decode');
            exports.encode = exports.stringify = require('./encode');
        }, { "./decode": 44, "./encode": 45 }], 47: [function (require, module, exports) {
            var runtime = (function (exports) {
                "use strict";
                var Op = Object.prototype;
                var hasOwn = Op.hasOwnProperty;
                var undefined;
                var $Symbol = typeof Symbol === "function" ? Symbol : {};
                var iteratorSymbol = $Symbol.iterator || "@@iterator";
                var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
                var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
                function define(obj, key, value) {
                    Object.defineProperty(obj, key, {
                        value: value,
                        enumerable: true,
                        configurable: true,
                        writable: true
                    });
                    return obj[key];
                }
                try {
                    define({}, "");
                }
                catch (err) {
                    define = function (obj, key, value) {
                        return obj[key] = value;
                    };
                }
                function wrap(innerFn, outerFn, self, tryLocsList) {
                    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
                    var generator = Object.create(protoGenerator.prototype);
                    var context = new Context(tryLocsList || []);
                    generator._invoke = makeInvokeMethod(innerFn, self, context);
                    return generator;
                }
                exports.wrap = wrap;
                function tryCatch(fn, obj, arg) {
                    try {
                        return { type: "normal", arg: fn.call(obj, arg) };
                    }
                    catch (err) {
                        return { type: "throw", arg: err };
                    }
                }
                var GenStateSuspendedStart = "suspendedStart";
                var GenStateSuspendedYield = "suspendedYield";
                var GenStateExecuting = "executing";
                var GenStateCompleted = "completed";
                var ContinueSentinel = {};
                function Generator() { }
                function GeneratorFunction() { }
                function GeneratorFunctionPrototype() { }
                var IteratorPrototype = {};
                IteratorPrototype[iteratorSymbol] = function () {
                    return this;
                };
                var getProto = Object.getPrototypeOf;
                var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
                if (NativeIteratorPrototype &&
                    NativeIteratorPrototype !== Op &&
                    hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
                    IteratorPrototype = NativeIteratorPrototype;
                }
                var Gp = GeneratorFunctionPrototype.prototype =
                    Generator.prototype = Object.create(IteratorPrototype);
                GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
                GeneratorFunctionPrototype.constructor = GeneratorFunction;
                GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction");
                function defineIteratorMethods(prototype) {
                    ["next", "throw", "return"].forEach(function (method) {
                        define(prototype, method, function (arg) {
                            return this._invoke(method, arg);
                        });
                    });
                }
                exports.isGeneratorFunction = function (genFun) {
                    var ctor = typeof genFun === "function" && genFun.constructor;
                    return ctor
                        ? ctor === GeneratorFunction ||
                            (ctor.displayName || ctor.name) === "GeneratorFunction"
                        : false;
                };
                exports.mark = function (genFun) {
                    if (Object.setPrototypeOf) {
                        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
                    }
                    else {
                        genFun.__proto__ = GeneratorFunctionPrototype;
                        define(genFun, toStringTagSymbol, "GeneratorFunction");
                    }
                    genFun.prototype = Object.create(Gp);
                    return genFun;
                };
                exports.awrap = function (arg) {
                    return { __await: arg };
                };
                function AsyncIterator(generator, PromiseImpl) {
                    function invoke(method, arg, resolve, reject) {
                        var record = tryCatch(generator[method], generator, arg);
                        if (record.type === "throw") {
                            reject(record.arg);
                        }
                        else {
                            var result = record.arg;
                            var value = result.value;
                            if (value &&
                                typeof value === "object" &&
                                hasOwn.call(value, "__await")) {
                                return PromiseImpl.resolve(value.__await).then(function (value) {
                                    invoke("next", value, resolve, reject);
                                }, function (err) {
                                    invoke("throw", err, resolve, reject);
                                });
                            }
                            return PromiseImpl.resolve(value).then(function (unwrapped) {
                                result.value = unwrapped;
                                resolve(result);
                            }, function (error) {
                                return invoke("throw", error, resolve, reject);
                            });
                        }
                    }
                    var previousPromise;
                    function enqueue(method, arg) {
                        function callInvokeWithMethodAndArg() {
                            return new PromiseImpl(function (resolve, reject) {
                                invoke(method, arg, resolve, reject);
                            });
                        }
                        return previousPromise =
                            previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
                    }
                    this._invoke = enqueue;
                }
                defineIteratorMethods(AsyncIterator.prototype);
                AsyncIterator.prototype[asyncIteratorSymbol] = function () {
                    return this;
                };
                exports.AsyncIterator = AsyncIterator;
                exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
                    if (PromiseImpl === void 0)
                        PromiseImpl = Promise;
                    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
                    return exports.isGeneratorFunction(outerFn)
                        ? iter
                        : iter.next().then(function (result) {
                            return result.done ? result.value : iter.next();
                        });
                };
                function makeInvokeMethod(innerFn, self, context) {
                    var state = GenStateSuspendedStart;
                    return function invoke(method, arg) {
                        if (state === GenStateExecuting) {
                            throw new Error("Generator is already running");
                        }
                        if (state === GenStateCompleted) {
                            if (method === "throw") {
                                throw arg;
                            }
                            return doneResult();
                        }
                        context.method = method;
                        context.arg = arg;
                        while (true) {
                            var delegate = context.delegate;
                            if (delegate) {
                                var delegateResult = maybeInvokeDelegate(delegate, context);
                                if (delegateResult) {
                                    if (delegateResult === ContinueSentinel)
                                        continue;
                                    return delegateResult;
                                }
                            }
                            if (context.method === "next") {
                                context.sent = context._sent = context.arg;
                            }
                            else if (context.method === "throw") {
                                if (state === GenStateSuspendedStart) {
                                    state = GenStateCompleted;
                                    throw context.arg;
                                }
                                context.dispatchException(context.arg);
                            }
                            else if (context.method === "return") {
                                context.abrupt("return", context.arg);
                            }
                            state = GenStateExecuting;
                            var record = tryCatch(innerFn, self, context);
                            if (record.type === "normal") {
                                state = context.done
                                    ? GenStateCompleted
                                    : GenStateSuspendedYield;
                                if (record.arg === ContinueSentinel) {
                                    continue;
                                }
                                return {
                                    value: record.arg,
                                    done: context.done
                                };
                            }
                            else if (record.type === "throw") {
                                state = GenStateCompleted;
                                context.method = "throw";
                                context.arg = record.arg;
                            }
                        }
                    };
                }
                function maybeInvokeDelegate(delegate, context) {
                    var method = delegate.iterator[context.method];
                    if (method === undefined) {
                        context.delegate = null;
                        if (context.method === "throw") {
                            if (delegate.iterator["return"]) {
                                context.method = "return";
                                context.arg = undefined;
                                maybeInvokeDelegate(delegate, context);
                                if (context.method === "throw") {
                                    return ContinueSentinel;
                                }
                            }
                            context.method = "throw";
                            context.arg = new TypeError("The iterator does not provide a 'throw' method");
                        }
                        return ContinueSentinel;
                    }
                    var record = tryCatch(method, delegate.iterator, context.arg);
                    if (record.type === "throw") {
                        context.method = "throw";
                        context.arg = record.arg;
                        context.delegate = null;
                        return ContinueSentinel;
                    }
                    var info = record.arg;
                    if (!info) {
                        context.method = "throw";
                        context.arg = new TypeError("iterator result is not an object");
                        context.delegate = null;
                        return ContinueSentinel;
                    }
                    if (info.done) {
                        context[delegate.resultName] = info.value;
                        context.next = delegate.nextLoc;
                        if (context.method !== "return") {
                            context.method = "next";
                            context.arg = undefined;
                        }
                    }
                    else {
                        return info;
                    }
                    context.delegate = null;
                    return ContinueSentinel;
                }
                defineIteratorMethods(Gp);
                define(Gp, toStringTagSymbol, "Generator");
                Gp[iteratorSymbol] = function () {
                    return this;
                };
                Gp.toString = function () {
                    return "[object Generator]";
                };
                function pushTryEntry(locs) {
                    var entry = { tryLoc: locs[0] };
                    if (1 in locs) {
                        entry.catchLoc = locs[1];
                    }
                    if (2 in locs) {
                        entry.finallyLoc = locs[2];
                        entry.afterLoc = locs[3];
                    }
                    this.tryEntries.push(entry);
                }
                function resetTryEntry(entry) {
                    var record = entry.completion || {};
                    record.type = "normal";
                    delete record.arg;
                    entry.completion = record;
                }
                function Context(tryLocsList) {
                    this.tryEntries = [{ tryLoc: "root" }];
                    tryLocsList.forEach(pushTryEntry, this);
                    this.reset(true);
                }
                exports.keys = function (object) {
                    var keys = [];
                    for (var key in object) {
                        keys.push(key);
                    }
                    keys.reverse();
                    return function next() {
                        while (keys.length) {
                            var key = keys.pop();
                            if (key in object) {
                                next.value = key;
                                next.done = false;
                                return next;
                            }
                        }
                        next.done = true;
                        return next;
                    };
                };
                function values(iterable) {
                    if (iterable) {
                        var iteratorMethod = iterable[iteratorSymbol];
                        if (iteratorMethod) {
                            return iteratorMethod.call(iterable);
                        }
                        if (typeof iterable.next === "function") {
                            return iterable;
                        }
                        if (!isNaN(iterable.length)) {
                            var i = -1, next = function next() {
                                while (++i < iterable.length) {
                                    if (hasOwn.call(iterable, i)) {
                                        next.value = iterable[i];
                                        next.done = false;
                                        return next;
                                    }
                                }
                                next.value = undefined;
                                next.done = true;
                                return next;
                            };
                            return next.next = next;
                        }
                    }
                    return { next: doneResult };
                }
                exports.values = values;
                function doneResult() {
                    return { value: undefined, done: true };
                }
                Context.prototype = {
                    constructor: Context,
                    reset: function (skipTempReset) {
                        this.prev = 0;
                        this.next = 0;
                        this.sent = this._sent = undefined;
                        this.done = false;
                        this.delegate = null;
                        this.method = "next";
                        this.arg = undefined;
                        this.tryEntries.forEach(resetTryEntry);
                        if (!skipTempReset) {
                            for (var name in this) {
                                if (name.charAt(0) === "t" &&
                                    hasOwn.call(this, name) &&
                                    !isNaN(+name.slice(1))) {
                                    this[name] = undefined;
                                }
                            }
                        }
                    },
                    stop: function () {
                        this.done = true;
                        var rootEntry = this.tryEntries[0];
                        var rootRecord = rootEntry.completion;
                        if (rootRecord.type === "throw") {
                            throw rootRecord.arg;
                        }
                        return this.rval;
                    },
                    dispatchException: function (exception) {
                        if (this.done) {
                            throw exception;
                        }
                        var context = this;
                        function handle(loc, caught) {
                            record.type = "throw";
                            record.arg = exception;
                            context.next = loc;
                            if (caught) {
                                context.method = "next";
                                context.arg = undefined;
                            }
                            return !!caught;
                        }
                        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                            var entry = this.tryEntries[i];
                            var record = entry.completion;
                            if (entry.tryLoc === "root") {
                                return handle("end");
                            }
                            if (entry.tryLoc <= this.prev) {
                                var hasCatch = hasOwn.call(entry, "catchLoc");
                                var hasFinally = hasOwn.call(entry, "finallyLoc");
                                if (hasCatch && hasFinally) {
                                    if (this.prev < entry.catchLoc) {
                                        return handle(entry.catchLoc, true);
                                    }
                                    else if (this.prev < entry.finallyLoc) {
                                        return handle(entry.finallyLoc);
                                    }
                                }
                                else if (hasCatch) {
                                    if (this.prev < entry.catchLoc) {
                                        return handle(entry.catchLoc, true);
                                    }
                                }
                                else if (hasFinally) {
                                    if (this.prev < entry.finallyLoc) {
                                        return handle(entry.finallyLoc);
                                    }
                                }
                                else {
                                    throw new Error("try statement without catch or finally");
                                }
                            }
                        }
                    },
                    abrupt: function (type, arg) {
                        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                            var entry = this.tryEntries[i];
                            if (entry.tryLoc <= this.prev &&
                                hasOwn.call(entry, "finallyLoc") &&
                                this.prev < entry.finallyLoc) {
                                var finallyEntry = entry;
                                break;
                            }
                        }
                        if (finallyEntry &&
                            (type === "break" ||
                                type === "continue") &&
                            finallyEntry.tryLoc <= arg &&
                            arg <= finallyEntry.finallyLoc) {
                            finallyEntry = null;
                        }
                        var record = finallyEntry ? finallyEntry.completion : {};
                        record.type = type;
                        record.arg = arg;
                        if (finallyEntry) {
                            this.method = "next";
                            this.next = finallyEntry.finallyLoc;
                            return ContinueSentinel;
                        }
                        return this.complete(record);
                    },
                    complete: function (record, afterLoc) {
                        if (record.type === "throw") {
                            throw record.arg;
                        }
                        if (record.type === "break" ||
                            record.type === "continue") {
                            this.next = record.arg;
                        }
                        else if (record.type === "return") {
                            this.rval = this.arg = record.arg;
                            this.method = "return";
                            this.next = "end";
                        }
                        else if (record.type === "normal" && afterLoc) {
                            this.next = afterLoc;
                        }
                        return ContinueSentinel;
                    },
                    finish: function (finallyLoc) {
                        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                            var entry = this.tryEntries[i];
                            if (entry.finallyLoc === finallyLoc) {
                                this.complete(entry.completion, entry.afterLoc);
                                resetTryEntry(entry);
                                return ContinueSentinel;
                            }
                        }
                    },
                    "catch": function (tryLoc) {
                        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                            var entry = this.tryEntries[i];
                            if (entry.tryLoc === tryLoc) {
                                var record = entry.completion;
                                if (record.type === "throw") {
                                    var thrown = record.arg;
                                    resetTryEntry(entry);
                                }
                                return thrown;
                            }
                        }
                        throw new Error("illegal catch attempt");
                    },
                    delegateYield: function (iterable, resultName, nextLoc) {
                        this.delegate = {
                            iterator: values(iterable),
                            resultName: resultName,
                            nextLoc: nextLoc
                        };
                        if (this.method === "next") {
                            this.arg = undefined;
                        }
                        return ContinueSentinel;
                    }
                };
                return exports;
            }(typeof module === "object" ? module.exports : {}));
            try {
                regeneratorRuntime = runtime;
            }
            catch (accidentalStrictMode) {
                Function("r", "regeneratorRuntime = r")(runtime);
            }
        }, {}], 48: [function (require, module, exports) {
            var buffer = require('buffer');
            var Buffer = buffer.Buffer;
            function copyProps(src, dst) {
                for (var key in src) {
                    dst[key] = src[key];
                }
            }
            if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
                module.exports = buffer;
            }
            else {
                copyProps(buffer, exports);
                exports.Buffer = SafeBuffer;
            }
            function SafeBuffer(arg, encodingOrOffset, length) {
                return Buffer(arg, encodingOrOffset, length);
            }
            SafeBuffer.prototype = Object.create(Buffer.prototype);
            copyProps(Buffer, SafeBuffer);
            SafeBuffer.from = function (arg, encodingOrOffset, length) {
                if (typeof arg === 'number') {
                    throw new TypeError('Argument must not be a number');
                }
                return Buffer(arg, encodingOrOffset, length);
            };
            SafeBuffer.alloc = function (size, fill, encoding) {
                if (typeof size !== 'number') {
                    throw new TypeError('Argument must be a number');
                }
                var buf = Buffer(size);
                if (fill !== undefined) {
                    if (typeof encoding === 'string') {
                        buf.fill(fill, encoding);
                    }
                    else {
                        buf.fill(fill);
                    }
                }
                else {
                    buf.fill(0);
                }
                return buf;
            };
            SafeBuffer.allocUnsafe = function (size) {
                if (typeof size !== 'number') {
                    throw new TypeError('Argument must be a number');
                }
                return Buffer(size);
            };
            SafeBuffer.allocUnsafeSlow = function (size) {
                if (typeof size !== 'number') {
                    throw new TypeError('Argument must be a number');
                }
                return buffer.SlowBuffer(size);
            };
        }, { "buffer": 34 }], 49: [function (require, module, exports) {
            module.exports = {
                "0": "O",
                "1": "l",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "\u2028": " ",
                "\u2029": " ",
                "": " ",
                "": " ",
                "": " ",
                "": " ",
                "": " ",
                "": " ",
                "": " ",
                "": " ",
                "": " ",
                "": " ",
                "": " ",
                "": " ",
                "": " ",
                "": " ",
                "": " ",
                "": "_",
                "": "_",
                "": "_",
                "": "_",
                "": "-",
                "": "-",
                "": "-",
                "": "-",
                "": "-",
                "": "-",
                "": "-",
                "": "-",
                "": "-",
                "": "-",
                "": "-",
                "": "-",
                "": "-",
                "": "-",
                "": "-",
                "": "-",
                "": "-.",
                "": "",
                "": ",",
                "": ",",
                "": ",",
                "": ",",
                "": ",",
                "": "",
                "": "",
                "": ";",
                "": "",
                "": ":",
                "": ":",
                "": ":",
                "": ":",
                "": ":",
                "": ":",
                "": ":",
                "": ":",
                "": ":",
                "": ":",
                "": ":",
                "": ":",
                "": ":",
                "": ":",
                "": ":",
                "": ":",
                "": ":",
                "": "::=",
                "": ":",
                "": "!",
                "": "!",
                "": "!",
                "": "!!",
                "": "!?",
                "": "?",
                "": "?",
                "": "?",
                "": "?",
                "": "?",
                "": "?!",
                "": "??",
                "": "",
                "": ".",
                "": ".",
                "": ".",
                "": ".",
                "": ".",
                "": ".",
                "": ".",
                "": ".",
                "": ".",
                "": ".,",
                "": "..",
                "": "..",
                "": "...",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "<",
                "": ">",
                "": ">",
                "": ">",
                "": "4",
                "": "b",
                "": "b",
                "": "d",
                "": "J",
                "": "L",
                "": "P",
                "": "U",
                "": "V",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "'",
                "": "'",
                "": "'",
                "": "'",
                "": "'",
                "": "'",
                "": "'",
                "": "'",
                "": "'",
                "`": "'",
                "": "'",
                "": "'",
                "": "'",
                "": "'",
                "": "'",
                "": "'",
                "": "'",
                "": "'",
                "": "'",
                "": "'",
                "": "'",
                "": "'",
                "": "'",
                "": "'",
                "": "'",
                "": "'",
                "": "'",
                "": "'",
                "": "'",
                "": "'",
                "": "'",
                "": "'",
                "": "'",
                "": "'",
                "": "'",
                "": "'",
                "": "''",
                "\"": "''",
                "": "''",
                "": "''",
                "": "''",
                "": "''",
                "": "''",
                "": "''",
                "": "''",
                "": "''",
                "": "''",
                "": "''",
                "": "''",
                "": "''",
                "": "''",
                "": "'''",
                "": "'''",
                "": "''''",
                "": "'B",
                "": "'D",
                "": "'n",
                "": "'P",
                "": "'T",
                "": "'Y",
                "": "(",
                "": "(",
                "": "(",
                "": "(",
                "": "(",
                "": "((",
                "": "()",
                "": "(2)",
                "": "(2O)",
                "": "(3)",
                "": "(4)",
                "": "(5)",
                "": "(6)",
                "": "(7)",
                "": "(8)",
                "": "(9)",
                "": "(a)",
                "": "(A)",
                "": "(b)",
                "": "(B)",
                "": "(c)",
                "": "(C)",
                "": "(d)",
                "": "(D)",
                "": "(e)",
                "": "(E)",
                "": "(f)",
                "": "(F)",
                "": "(g)",
                "": "(G)",
                "": "(h)",
                "": "(H)",
                "": "(i)",
                "": "(j)",
                "": "(J)",
                "": "(k)",
                "": "(K)",
                "": "(l)",
                "": "(l)",
                "": "(l)",
                "": "(L)",
                "": "(l2)",
                "": "(l3)",
                "": "(l4)",
                "": "(l5)",
                "": "(l6)",
                "": "(l7)",
                "": "(l8)",
                "": "(l9)",
                "": "(ll)",
                "": "(lO)",
                "": "(M)",
                "": "(n)",
                "": "(N)",
                "": "(o)",
                "": "(O)",
                "": "(p)",
                "": "(P)",
                "": "(q)",
                "": "(Q)",
                "": "(r)",
                "": "(R)",
                "": "(rn)",
                "": "(s)",
                "": "(S)",
                "": "(S)",
                "": "(t)",
                "": "(T)",
                "": "(u)",
                "": "(U)",
                "": "(v)",
                "": "(V)",
                "": "(w)",
                "": "(W)",
                "": "(x)",
                "": "(X)",
                "": "(y)",
                "": "(Y)",
                "": "(z)",
                "": "(Z)",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": "()",
                "": ")",
                "": ")",
                "": ")",
                "": ")",
                "": ")",
                "": "))",
                "": "{",
                "": "{",
                "": "}",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "*",
                "": "*",
                "": "*",
                "": "*",
                "": "/",
                "": "/",
                "": "/",
                "": "/",
                "": "/",
                "": "/",
                "": "/",
                "": "/",
                "": "/",
                "": "/",
                "": "/",
                "": "/",
                "": "/",
                "": "/",
                "": "/",
                "": "//",
                "": "///",
                "": "\\",
                "": "\\",
                "": "\\",
                "": "\\",
                "": "\\",
                "": "\\",
                "": "\\",
                "": "\\",
                "": "\\",
                "": "\\",
                "": "\\",
                "": "\\\\",
                "": "\\\\",
                "": "\\",
                "": "&",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "^",
                "": "^",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "b",
                "": "bi",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "C",
                "": "F",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "+",
                "": "+",
                "": "+",
                "": "+",
                "": "+",
                "": "+",
                "": "+",
                "": "+",
                "": "+",
                "": "+",
                "": "",
                "": "<",
                "": "<",
                "": "<",
                "": "<",
                "": "<",
                "": "<",
                "": "<",
                "": "<",
                "": "<",
                "": "<<",
                "": "<<<",
                "": "=",
                "": "=",
                "": "=",
                "": "=",
                "": "=",
                "": "=",
                "": "=",
                "": "=",
                "": "=",
                "": "=",
                "": "==",
                "": "===",
                "": "=",
                "": ">",
                "": ">",
                "": ">",
                "": ">",
                "": ">",
                "": ">",
                "": ">",
                "": "><",
                "": ">>",
                "": ">>",
                "": ">>>",
                "": "~",
                "": "~",
                "": "~",
                "": "~",
                "": "~",
                "": "~",
                "": "~",
                "": "~",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "$",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "2",
                "": "2",
                "": "2",
                "": "2",
                "": "2",
                "": "2",
                "": "2",
                "": "2",
                "": "2",
                "": "2",
                "": "2",
                "": "2",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "2",
                "": "2,",
                "": "2.",
                "": "22",
                "": "22",
                "": "23",
                "": "23",
                "": "24",
                "": "24",
                "": "25",
                "": "26",
                "": "27",
                "": "28",
                "": "29",
                "": "2l",
                "": "2l",
                "": "2O.",
                "": "2O",
                "": "2O",
                "": "",
                "": "",
                "": "2",
                "": "2",
                "": "2",
                "": "3",
                "": "3",
                "": "3",
                "": "3",
                "": "3",
                "": "3",
                "": "3",
                "": "3",
                "": "3",
                "": "3",
                "": "3",
                "": "3",
                "": "3",
                "": "3",
                "": "3",
                "": "3",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "3",
                "": "3,",
                "": "3.",
                "": "3l",
                "": "3O",
                "": "3",
                "": "3",
                "": "3",
                "": "4",
                "": "4",
                "": "4",
                "": "4",
                "": "4",
                "": "4",
                "": "4",
                "": "4",
                "": "",
                "": "",
                "": "",
                "": "4,",
                "": "4.",
                "": "4",
                "": "4",
                "": "4",
                "": "4",
                "": "5",
                "": "5",
                "": "5",
                "": "5",
                "": "5",
                "": "5",
                "": "5",
                "": "5",
                "": "",
                "": "5,",
                "": "5.",
                "": "5",
                "": "5",
                "": "5",
                "": "6",
                "": "6",
                "": "6",
                "": "6",
                "": "6",
                "": "6",
                "": "6",
                "": "6",
                "": "6",
                "": "6",
                "": "",
                "": "",
                "": "",
                "": "6,",
                "": "6.",
                "": "6",
                "": "6",
                "": "6",
                "": "7",
                "": "7",
                "": "7",
                "": "7",
                "": "7",
                "": "7",
                "": "7",
                "": "7",
                "": "7",
                "": "",
                "": "7,",
                "": "7.",
                "": "7",
                "": "7",
                "": "7",
                "": "8",
                "": "8",
                "": "8",
                "": "8",
                "": "8",
                "": "8",
                "": "8",
                "": "8",
                "": "8",
                "": "8",
                "": "8",
                "": "8",
                "": "8",
                "": "",
                "": "",
                "": "8,",
                "": "8.",
                "": "8",
                "": "8",
                "": "8",
                "": "9",
                "": "9",
                "": "9",
                "": "9",
                "": "9",
                "": "9",
                "": "9",
                "": "9",
                "": "9",
                "": "9",
                "": "9",
                "": "9",
                "": "9",
                "": "9",
                "": "9",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "9,",
                "": "9.",
                "": "9",
                "": "9",
                "": "9",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "a",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "a/c",
                "": "a/s",
                "": "aa",
                "": "AA",
                "": "ae",
                "": "ae",
                "": "AE",
                "": "AE",
                "": "ao",
                "": "AO",
                "": "AR",
                "": "au",
                "": "AU",
                "": "av",
                "": "av",
                "": "AV",
                "": "AV",
                "": "ay",
                "": "AY",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "b",
                "": "b",
                "": "b",
                "": "b",
                "": "b",
                "": "b",
                "": "b",
                "": "b",
                "": "b",
                "": "b",
                "": "b",
                "": "b",
                "": "b",
                "": "b",
                "": "b",
                "": "b",
                "": "b",
                "": "b",
                "": "B",
                "": "B",
                "": "B",
                "": "B",
                "": "B",
                "": "B",
                "": "B",
                "": "B",
                "": "B",
                "": "B",
                "": "B",
                "": "B",
                "": "B",
                "": "B",
                "": "B",
                "": "B",
                "": "B",
                "": "B",
                "": "B",
                "": "B",
                "": "B",
                "": "B",
                "": "B",
                "": "B",
                "": "B",
                "": "B",
                "": "B",
                "": "B",
                "": "b",
                "": "b",
                "": "b",
                "": "b",
                "": "b",
                "": "b",
                "": "b",
                "": "b",
                "": "b",
                "": "b",
                "": "b",
                "": "b",
                "": "b'",
                "": "bl",
                "": "",
                "": "",
                "": "c",
                "": "c",
                "": "c",
                "": "c",
                "": "c",
                "": "c",
                "": "c",
                "": "c",
                "": "c",
                "": "c",
                "": "c",
                "": "c",
                "": "c",
                "": "c",
                "": "c",
                "": "c",
                "": "c",
                "": "c",
                "": "c",
                "": "c",
                "": "c",
                "": "",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "c",
                "": "c",
                "": "C",
                "": "C",
                "": "c",
                "": "c",
                "": "C",
                "": "C",
                "": "C'",
                "": "c/o",
                "": "c/u",
                "": "\t",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "d",
                "": "d",
                "": "d",
                "": "d",
                "": "d",
                "": "d",
                "": "d",
                "": "d",
                "": "d",
                "": "d",
                "": "d",
                "": "d",
                "": "d",
                "": "d",
                "": "d",
                "": "d",
                "": "d",
                "": "d",
                "": "d",
                "": "D",
                "": "D",
                "": "D",
                "": "D",
                "": "D",
                "": "D",
                "": "D",
                "": "D",
                "": "D",
                "": "D",
                "": "D",
                "": "D",
                "": "D",
                "": "D",
                "": "D",
                "": "D",
                "": "D",
                "": "D",
                "": "D",
                "": "d",
                "": "d",
                "": "d",
                "": "d",
                "": "D",
                "": "D",
                "": "D",
                "": "d",
                "": "",
                "": "d",
                "": "d'",
                "": "d",
                "": "dz",
                "": "dz",
                "": "Dz",
                "": "DZ",
                "": "d",
                "": "D",
                "": "D",
                "": "d",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "",
                "": "",
                "": "e",
                "": "E",
                "": "e",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "o",
                "": "o",
                "": "o",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "f",
                "": "f",
                "": "f",
                "": "f",
                "": "f",
                "": "f",
                "": "f",
                "": "f",
                "": "f",
                "": "f",
                "": "f",
                "": "f",
                "": "f",
                "": "f",
                "": "f",
                "": "f",
                "": "f",
                "": "f",
                "": "F",
                "": "F",
                "": "F",
                "": "F",
                "": "F",
                "": "F",
                "": "F",
                "": "F",
                "": "F",
                "": "F",
                "": "F",
                "": "F",
                "": "F",
                "": "F",
                "": "F",
                "": "F",
                "": "F",
                "": "F",
                "": "F",
                "": "F",
                "": "F",
                "": "F",
                "": "F",
                "": "F",
                "": "f",
                "": "F",
                "": "f",
                "": "FAX",
                "": "ff",
                "": "ffi",
                "": "ffl",
                "": "fi",
                "": "fl",
                "": "f",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "G",
                "": "G",
                "": "G",
                "": "G",
                "": "G",
                "": "G",
                "": "G",
                "": "G",
                "": "G",
                "": "G",
                "": "G",
                "": "G",
                "": "G",
                "": "G",
                "": "G",
                "": "G",
                "": "G",
                "": "",
                "": "g",
                "": "",
                "": "",
                "": "",
                "": "g",
                "": "G",
                "": "G'",
                "": "",
                "": "",
                "": "",
                "": "h",
                "": "h",
                "": "h",
                "": "h",
                "": "h",
                "": "h",
                "": "h",
                "": "h",
                "": "h",
                "": "h",
                "": "h",
                "": "h",
                "": "h",
                "": "h",
                "": "h",
                "": "h",
                "": "h",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "",
                "": "h",
                "": "h",
                "": "h",
                "": "H",
                "": "H",
                "": "h",
                "": "h",
                "": "h",
                "": "H",
                "": "H",
                "": "H",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "",
                "": "i",
                "": "",
                "": "",
                "": "i",
                "": "i",
                "": "i",
                "": "ii",
                "": "iii",
                "": "ij",
                "": "iv",
                "": "ix",
                "": "j",
                "": "j",
                "": "j",
                "": "j",
                "": "j",
                "": "j",
                "": "j",
                "": "j",
                "": "j",
                "": "j",
                "": "j",
                "": "j",
                "": "j",
                "": "j",
                "": "j",
                "": "j",
                "": "j",
                "": "J",
                "": "J",
                "": "J",
                "": "J",
                "": "J",
                "": "J",
                "": "J",
                "": "J",
                "": "J",
                "": "J",
                "": "J",
                "": "J",
                "": "J",
                "": "J",
                "": "J",
                "": "J",
                "": "J",
                "": "J",
                "": "J",
                "": "J",
                "": "j",
                "": "J",
                "": "J",
                "": "",
                "": "",
                "": "",
                "": "k",
                "": "k",
                "": "k",
                "": "k",
                "": "k",
                "": "k",
                "": "k",
                "": "k",
                "": "k",
                "": "k",
                "": "k",
                "": "k",
                "": "k",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "k",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "K'",
                "": "l",
                "|": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "I": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "l",
                "": "l",
                "": "l",
                "": "L",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l,",
                "": "l.",
                "": "l'",
                "": "l2.",
                "": "l2",
                "": "l2",
                "": "l2",
                "": "l3.",
                "": "l3",
                "": "l3",
                "": "l4.",
                "": "l4",
                "": "l4",
                "": "l5.",
                "": "l5",
                "": "l5",
                "": "l6.",
                "": "l6",
                "": "l6",
                "": "l7.",
                "": "l7",
                "": "l7",
                "": "l8.",
                "": "l8",
                "": "l8",
                "": "l9.",
                "": "l9",
                "": "l9",
                "": "lj",
                "": "lJ",
                "": "Lj",
                "": "LJ",
                "": "ll",
                "": "ll",
                "": "ll",
                "": "ll",
                "": "ll",
                "": "ll",
                "": "ll.",
                "": "lll",
                "": "llS",
                "": "ll",
                "": "ll",
                "": "ll",
                "": "lO",
                "": "lO.",
                "": "lO",
                "": "lO",
                "": "lO",
                "": "ls",
                "": "lt",
                "": "lV",
                "": "lX",
                "": "l",
                "": "lz",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "lo",
                "": "l",
                "": "l",
                "": "l",
                "": "",
                "": "",
                "": "",
                "": "M",
                "": "M",
                "": "M",
                "": "M",
                "": "M",
                "": "M",
                "": "M",
                "": "M",
                "": "M",
                "": "M",
                "": "M",
                "": "M",
                "": "M",
                "": "M",
                "": "M",
                "": "M",
                "": "M",
                "": "M",
                "": "M",
                "": "M",
                "": "M",
                "": "M",
                "": "M",
                "": "M",
                "": "M",
                "": "M",
                "": "M",
                "": "M",
                "": "M",
                "": "M",
                "": "M",
                "": "MB",
                "": "",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "N",
                "": "n",
                "": "nj",
                "": "Nj",
                "": "NJ",
                "": "No",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "o",
                "": "",
                "": "o",
                "": "o",
                "": "O",
                "": "O",
                "": "O",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "o",
                "": "o",
                "": "O,",
                "": "O.",
                "": "o'",
                "": "O'",
                "": "O'",
                "%": "/",
                "": "/",
                "": "/",
                "": "/",
                "": "/",
                "": "/",
                "": "/",
                "": "oe",
                "": "OE",
                "": "o",
                "": "oo",
                "": "oo",
                "": "oo",
                "": "OO",
                "": "OO",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "oo",
                "": "o",
                "": "O",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "e",
                "": "",
                "": "p",
                "": "p",
                "": "p",
                "": "p",
                "": "p",
                "": "p",
                "": "p",
                "": "p",
                "": "p",
                "": "p",
                "": "p",
                "": "p",
                "": "p",
                "": "p",
                "": "p",
                "": "p",
                "": "p",
                "": "p",
                "": "p",
                "": "p",
                "": "p",
                "": "p",
                "": "p",
                "": "p",
                "": "p",
                "": "p",
                "": "p",
                "": "p",
                "": "p",
                "": "P",
                "": "P",
                "": "P",
                "": "P",
                "": "P",
                "": "P",
                "": "P",
                "": "P",
                "": "P",
                "": "P",
                "": "P",
                "": "P",
                "": "P",
                "": "P",
                "": "P",
                "": "P",
                "": "P",
                "": "P",
                "": "P",
                "": "P",
                "": "P",
                "": "P",
                "": "P",
                "": "P",
                "": "P",
                "": "P",
                "": "p",
                "": "p",
                "": "p",
                "": "P'",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "q",
                "": "q",
                "": "q",
                "": "q",
                "": "q",
                "": "q",
                "": "q",
                "": "q",
                "": "q",
                "": "q",
                "": "q",
                "": "q",
                "": "q",
                "": "q",
                "": "q",
                "": "q",
                "": "Q",
                "": "Q",
                "": "Q",
                "": "Q",
                "": "Q",
                "": "Q",
                "": "Q",
                "": "Q",
                "": "Q",
                "": "Q",
                "": "Q",
                "": "Q",
                "": "Q",
                "": "Q",
                "": "q",
                "": "QE",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r'",
                "": "rn",
                "m": "rn",
                "": "rn",
                "": "rn",
                "": "rn",
                "": "rn",
                "": "rn",
                "": "rn",
                "": "rn",
                "": "rn",
                "": "rn",
                "": "rn",
                "": "rn",
                "": "rn",
                "": "rn",
                "": "rn",
                "": "rn",
                "": "rn",
                "": "rn",
                "": "rn",
                "": "Rs",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "s",
                "": "s",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "sss",
                "": "st",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "t",
                "": "t",
                "": "t",
                "": "t",
                "": "t",
                "": "t",
                "": "t",
                "": "t",
                "": "t",
                "": "t",
                "": "t",
                "": "t",
                "": "t",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "t",
                "": "T",
                "": "T",
                "": "",
                "": "T",
                "": "T",
                "": "T",
                "": "t",
                "": "T",
                "": "t",
                "": "",
                "": "T3",
                "": "t",
                "": "TEL",
                "": "tf",
                "": "ts",
                "": "t",
                "": "t",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "",
                "": "",
                "": "u",
                "": "u",
                "": "U",
                "": "U",
                "": "U",
                "": "U'",
                "": "ue",
                "": "uo",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "v",
                "": "v",
                "": "v",
                "": "v",
                "": "v",
                "": "v",
                "": "v",
                "": "v",
                "": "v",
                "": "v",
                "": "v",
                "": "v",
                "": "v",
                "": "v",
                "": "v",
                "": "v",
                "": "v",
                "": "v",
                "": "v",
                "": "v",
                "": "v",
                "": "v",
                "": "v",
                "": "v",
                "": "v",
                "": "v",
                "": "v",
                "": "v",
                "": "v",
                "": "V",
                "": "V",
                "": "V",
                "": "V",
                "": "V",
                "": "V",
                "": "V",
                "": "V",
                "": "V",
                "": "V",
                "": "V",
                "": "V",
                "": "V",
                "": "V",
                "": "V",
                "": "V",
                "": "V",
                "": "V",
                "": "V",
                "": "V",
                "": "V",
                "": "V",
                "": "V",
                "": "V",
                "": "V",
                "": "V",
                "": "V",
                "": "V",
                "": "VB",
                "": "vi",
                "": "vii",
                "": "viii",
                "": "Vl",
                "": "Vll",
                "": "Vlll",
                "": "V",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "w",
                "": "w",
                "": "w",
                "": "w",
                "": "w",
                "": "w",
                "": "w",
                "": "w",
                "": "w",
                "": "w",
                "": "w",
                "": "w",
                "": "w",
                "": "w",
                "": "w",
                "": "w",
                "": "w",
                "": "w",
                "": "w",
                "": "w",
                "": "w",
                "": "w",
                "": "W",
                "": "W",
                "": "W",
                "": "W",
                "": "W",
                "": "W",
                "": "W",
                "": "W",
                "": "W",
                "": "W",
                "": "W",
                "": "W",
                "": "W",
                "": "W",
                "": "W",
                "": "W",
                "": "W",
                "": "W",
                "": "W",
                "": "w",
                "": "w",
                "": "W",
                "": "w",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "x",
                "": "x",
                "": "x",
                "": "x",
                "": "x",
                "": "x",
                "": "x",
                "": "x",
                "": "x",
                "": "x",
                "": "x",
                "": "x",
                "": "x",
                "": "x",
                "": "x",
                "": "x",
                "": "x",
                "": "x",
                "": "x",
                "": "x",
                "": "x",
                "": "x",
                "": "x",
                "": "",
                "": "X",
                "": "X",
                "": "X",
                "": "X",
                "": "X",
                "": "X",
                "": "X",
                "": "X",
                "": "X",
                "": "X",
                "": "X",
                "": "X",
                "": "X",
                "": "X",
                "": "X",
                "": "X",
                "": "X",
                "": "X",
                "": "X",
                "": "X",
                "": "X",
                "": "X",
                "": "X",
                "": "X",
                "": "X",
                "": "X",
                "": "X",
                "": "X",
                "": "X",
                "": "X",
                "": "X",
                "": "X",
                "": "X",
                "": "X",
                "": "X",
                "": "x",
                "": "X",
                "": "X",
                "": "xi",
                "": "xii",
                "": "Xl",
                "": "Xll",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "y",
                "": "y",
                "": "y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "z",
                "": "z",
                "": "z",
                "": "z",
                "": "z",
                "": "z",
                "": "z",
                "": "z",
                "": "z",
                "": "z",
                "": "z",
                "": "z",
                "": "z",
                "": "z",
                "": "z",
                "": "z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "z",
                "": "z",
                "": "Z",
                "": "z",
                "": "Z",
                "": "z",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "i",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "'",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "l",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "'",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "o",
                "": "o",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "o",
                "": "o",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": " lo",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "l",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": " lo o ",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "o",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "l",
                "": "l",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "o",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "l",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "o",
                "": "o",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "o",
                "": "o",
                "": "o",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "l",
                "": "l",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "'",
                "": "/",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "'",
                "": "",
                "": "",
                "": "'",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "<",
                "": "b",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "b",
                "": "b",
                "": "d",
                "": "P",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "J",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "J",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": ""
            };
        }, {}], 50: [function (require, module, exports) {
            'use strict';
            var data = require('./data.json');
            function escapeRegexp(str) {
                return str.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
            }
            var REPLACE_RE = RegExp(Object.keys(data).map(escapeRegexp).join('|'), 'g');
            function replace_fn(match) {
                return data[match];
            }
            function unhomoglyph(str) {
                return str.replace(REPLACE_RE, replace_fn);
            }
            module.exports = unhomoglyph;
        }, { "./data.json": 49 }], 51: [function (require, module, exports) {
            'use strict';
            var punycode = require('punycode');
            var util = require('./util');
            exports.parse = urlParse;
            exports.resolve = urlResolve;
            exports.resolveObject = urlResolveObject;
            exports.format = urlFormat;
            exports.Url = Url;
            function Url() {
                this.protocol = null;
                this.slashes = null;
                this.auth = null;
                this.host = null;
                this.port = null;
                this.hostname = null;
                this.hash = null;
                this.search = null;
                this.query = null;
                this.pathname = null;
                this.path = null;
                this.href = null;
            }
            var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'], unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims), autoEscape = ['\''].concat(unwise), nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape), hostEndingChars = ['/', '?', '#'], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, unsafeProtocol = {
                'javascript': true,
                'javascript:': true
            }, hostlessProtocol = {
                'javascript': true,
                'javascript:': true
            }, slashedProtocol = {
                'http': true,
                'https': true,
                'ftp': true,
                'gopher': true,
                'file': true,
                'http:': true,
                'https:': true,
                'ftp:': true,
                'gopher:': true,
                'file:': true
            }, querystring = require('querystring');
            function urlParse(url, parseQueryString, slashesDenoteHost) {
                if (url && util.isObject(url) && url instanceof Url)
                    return url;
                var u = new Url;
                u.parse(url, parseQueryString, slashesDenoteHost);
                return u;
            }
            Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
                if (!util.isString(url)) {
                    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
                }
                var queryIndex = url.indexOf('?'), splitter = (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#', uSplit = url.split(splitter), slashRegex = /\\/g;
                uSplit[0] = uSplit[0].replace(slashRegex, '/');
                url = uSplit.join(splitter);
                var rest = url;
                rest = rest.trim();
                if (!slashesDenoteHost && url.split('#').length === 1) {
                    var simplePath = simplePathPattern.exec(rest);
                    if (simplePath) {
                        this.path = rest;
                        this.href = rest;
                        this.pathname = simplePath[1];
                        if (simplePath[2]) {
                            this.search = simplePath[2];
                            if (parseQueryString) {
                                this.query = querystring.parse(this.search.substr(1));
                            }
                            else {
                                this.query = this.search.substr(1);
                            }
                        }
                        else if (parseQueryString) {
                            this.search = '';
                            this.query = {};
                        }
                        return this;
                    }
                }
                var proto = protocolPattern.exec(rest);
                if (proto) {
                    proto = proto[0];
                    var lowerProto = proto.toLowerCase();
                    this.protocol = lowerProto;
                    rest = rest.substr(proto.length);
                }
                if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
                    var slashes = rest.substr(0, 2) === '//';
                    if (slashes && !(proto && hostlessProtocol[proto])) {
                        rest = rest.substr(2);
                        this.slashes = true;
                    }
                }
                if (!hostlessProtocol[proto] &&
                    (slashes || (proto && !slashedProtocol[proto]))) {
                    var hostEnd = -1;
                    for (var i = 0; i < hostEndingChars.length; i++) {
                        var hec = rest.indexOf(hostEndingChars[i]);
                        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                            hostEnd = hec;
                    }
                    var auth, atSign;
                    if (hostEnd === -1) {
                        atSign = rest.lastIndexOf('@');
                    }
                    else {
                        atSign = rest.lastIndexOf('@', hostEnd);
                    }
                    if (atSign !== -1) {
                        auth = rest.slice(0, atSign);
                        rest = rest.slice(atSign + 1);
                        this.auth = decodeURIComponent(auth);
                    }
                    hostEnd = -1;
                    for (var i = 0; i < nonHostChars.length; i++) {
                        var hec = rest.indexOf(nonHostChars[i]);
                        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                            hostEnd = hec;
                    }
                    if (hostEnd === -1)
                        hostEnd = rest.length;
                    this.host = rest.slice(0, hostEnd);
                    rest = rest.slice(hostEnd);
                    this.parseHost();
                    this.hostname = this.hostname || '';
                    var ipv6Hostname = this.hostname[0] === '[' &&
                        this.hostname[this.hostname.length - 1] === ']';
                    if (!ipv6Hostname) {
                        var hostparts = this.hostname.split(/\./);
                        for (var i = 0, l = hostparts.length; i < l; i++) {
                            var part = hostparts[i];
                            if (!part)
                                continue;
                            if (!part.match(hostnamePartPattern)) {
                                var newpart = '';
                                for (var j = 0, k = part.length; j < k; j++) {
                                    if (part.charCodeAt(j) > 127) {
                                        newpart += 'x';
                                    }
                                    else {
                                        newpart += part[j];
                                    }
                                }
                                if (!newpart.match(hostnamePartPattern)) {
                                    var validParts = hostparts.slice(0, i);
                                    var notHost = hostparts.slice(i + 1);
                                    var bit = part.match(hostnamePartStart);
                                    if (bit) {
                                        validParts.push(bit[1]);
                                        notHost.unshift(bit[2]);
                                    }
                                    if (notHost.length) {
                                        rest = '/' + notHost.join('.') + rest;
                                    }
                                    this.hostname = validParts.join('.');
                                    break;
                                }
                            }
                        }
                    }
                    if (this.hostname.length > hostnameMaxLen) {
                        this.hostname = '';
                    }
                    else {
                        this.hostname = this.hostname.toLowerCase();
                    }
                    if (!ipv6Hostname) {
                        this.hostname = punycode.toASCII(this.hostname);
                    }
                    var p = this.port ? ':' + this.port : '';
                    var h = this.hostname || '';
                    this.host = h + p;
                    this.href += this.host;
                    if (ipv6Hostname) {
                        this.hostname = this.hostname.substr(1, this.hostname.length - 2);
                        if (rest[0] !== '/') {
                            rest = '/' + rest;
                        }
                    }
                }
                if (!unsafeProtocol[lowerProto]) {
                    for (var i = 0, l = autoEscape.length; i < l; i++) {
                        var ae = autoEscape[i];
                        if (rest.indexOf(ae) === -1)
                            continue;
                        var esc = encodeURIComponent(ae);
                        if (esc === ae) {
                            esc = escape(ae);
                        }
                        rest = rest.split(ae).join(esc);
                    }
                }
                var hash = rest.indexOf('#');
                if (hash !== -1) {
                    this.hash = rest.substr(hash);
                    rest = rest.slice(0, hash);
                }
                var qm = rest.indexOf('?');
                if (qm !== -1) {
                    this.search = rest.substr(qm);
                    this.query = rest.substr(qm + 1);
                    if (parseQueryString) {
                        this.query = querystring.parse(this.query);
                    }
                    rest = rest.slice(0, qm);
                }
                else if (parseQueryString) {
                    this.search = '';
                    this.query = {};
                }
                if (rest)
                    this.pathname = rest;
                if (slashedProtocol[lowerProto] &&
                    this.hostname && !this.pathname) {
                    this.pathname = '/';
                }
                if (this.pathname || this.search) {
                    var p = this.pathname || '';
                    var s = this.search || '';
                    this.path = p + s;
                }
                this.href = this.format();
                return this;
            };
            function urlFormat(obj) {
                if (util.isString(obj))
                    obj = urlParse(obj);
                if (!(obj instanceof Url))
                    return Url.prototype.format.call(obj);
                return obj.format();
            }
            Url.prototype.format = function () {
                var auth = this.auth || '';
                if (auth) {
                    auth = encodeURIComponent(auth);
                    auth = auth.replace(/%3A/i, ':');
                    auth += '@';
                }
                var protocol = this.protocol || '', pathname = this.pathname || '', hash = this.hash || '', host = false, query = '';
                if (this.host) {
                    host = auth + this.host;
                }
                else if (this.hostname) {
                    host = auth + (this.hostname.indexOf(':') === -1 ?
                        this.hostname :
                        '[' + this.hostname + ']');
                    if (this.port) {
                        host += ':' + this.port;
                    }
                }
                if (this.query &&
                    util.isObject(this.query) &&
                    Object.keys(this.query).length) {
                    query = querystring.stringify(this.query);
                }
                var search = this.search || (query && ('?' + query)) || '';
                if (protocol && protocol.substr(-1) !== ':')
                    protocol += ':';
                if (this.slashes ||
                    (!protocol || slashedProtocol[protocol]) && host !== false) {
                    host = '//' + (host || '');
                    if (pathname && pathname.charAt(0) !== '/')
                        pathname = '/' + pathname;
                }
                else if (!host) {
                    host = '';
                }
                if (hash && hash.charAt(0) !== '#')
                    hash = '#' + hash;
                if (search && search.charAt(0) !== '?')
                    search = '?' + search;
                pathname = pathname.replace(/[?#]/g, function (match) {
                    return encodeURIComponent(match);
                });
                search = search.replace('#', '%23');
                return protocol + host + pathname + search + hash;
            };
            function urlResolve(source, relative) {
                return urlParse(source, false, true).resolve(relative);
            }
            Url.prototype.resolve = function (relative) {
                return this.resolveObject(urlParse(relative, false, true)).format();
            };
            function urlResolveObject(source, relative) {
                if (!source)
                    return relative;
                return urlParse(source, false, true).resolveObject(relative);
            }
            Url.prototype.resolveObject = function (relative) {
                if (util.isString(relative)) {
                    var rel = new Url();
                    rel.parse(relative, false, true);
                    relative = rel;
                }
                var result = new Url();
                var tkeys = Object.keys(this);
                for (var tk = 0; tk < tkeys.length; tk++) {
                    var tkey = tkeys[tk];
                    result[tkey] = this[tkey];
                }
                result.hash = relative.hash;
                if (relative.href === '') {
                    result.href = result.format();
                    return result;
                }
                if (relative.slashes && !relative.protocol) {
                    var rkeys = Object.keys(relative);
                    for (var rk = 0; rk < rkeys.length; rk++) {
                        var rkey = rkeys[rk];
                        if (rkey !== 'protocol')
                            result[rkey] = relative[rkey];
                    }
                    if (slashedProtocol[result.protocol] &&
                        result.hostname && !result.pathname) {
                        result.path = result.pathname = '/';
                    }
                    result.href = result.format();
                    return result;
                }
                if (relative.protocol && relative.protocol !== result.protocol) {
                    if (!slashedProtocol[relative.protocol]) {
                        var keys = Object.keys(relative);
                        for (var v = 0; v < keys.length; v++) {
                            var k = keys[v];
                            result[k] = relative[k];
                        }
                        result.href = result.format();
                        return result;
                    }
                    result.protocol = relative.protocol;
                    if (!relative.host && !hostlessProtocol[relative.protocol]) {
                        var relPath = (relative.pathname || '').split('/');
                        while (relPath.length && !(relative.host = relPath.shift()))
                            ;
                        if (!relative.host)
                            relative.host = '';
                        if (!relative.hostname)
                            relative.hostname = '';
                        if (relPath[0] !== '')
                            relPath.unshift('');
                        if (relPath.length < 2)
                            relPath.unshift('');
                        result.pathname = relPath.join('/');
                    }
                    else {
                        result.pathname = relative.pathname;
                    }
                    result.search = relative.search;
                    result.query = relative.query;
                    result.host = relative.host || '';
                    result.auth = relative.auth;
                    result.hostname = relative.hostname || relative.host;
                    result.port = relative.port;
                    if (result.pathname || result.search) {
                        var p = result.pathname || '';
                        var s = result.search || '';
                        result.path = p + s;
                    }
                    result.slashes = result.slashes || relative.slashes;
                    result.href = result.format();
                    return result;
                }
                var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'), isRelAbs = (relative.host ||
                    relative.pathname && relative.pathname.charAt(0) === '/'), mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)), removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split('/') || [], relPath = relative.pathname && relative.pathname.split('/') || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
                if (psychotic) {
                    result.hostname = '';
                    result.port = null;
                    if (result.host) {
                        if (srcPath[0] === '')
                            srcPath[0] = result.host;
                        else
                            srcPath.unshift(result.host);
                    }
                    result.host = '';
                    if (relative.protocol) {
                        relative.hostname = null;
                        relative.port = null;
                        if (relative.host) {
                            if (relPath[0] === '')
                                relPath[0] = relative.host;
                            else
                                relPath.unshift(relative.host);
                        }
                        relative.host = null;
                    }
                    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
                }
                if (isRelAbs) {
                    result.host = (relative.host || relative.host === '') ?
                        relative.host : result.host;
                    result.hostname = (relative.hostname || relative.hostname === '') ?
                        relative.hostname : result.hostname;
                    result.search = relative.search;
                    result.query = relative.query;
                    srcPath = relPath;
                }
                else if (relPath.length) {
                    if (!srcPath)
                        srcPath = [];
                    srcPath.pop();
                    srcPath = srcPath.concat(relPath);
                    result.search = relative.search;
                    result.query = relative.query;
                }
                else if (!util.isNullOrUndefined(relative.search)) {
                    if (psychotic) {
                        result.hostname = result.host = srcPath.shift();
                        var authInHost = result.host && result.host.indexOf('@') > 0 ?
                            result.host.split('@') : false;
                        if (authInHost) {
                            result.auth = authInHost.shift();
                            result.host = result.hostname = authInHost.shift();
                        }
                    }
                    result.search = relative.search;
                    result.query = relative.query;
                    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
                        result.path = (result.pathname ? result.pathname : '') +
                            (result.search ? result.search : '');
                    }
                    result.href = result.format();
                    return result;
                }
                if (!srcPath.length) {
                    result.pathname = null;
                    if (result.search) {
                        result.path = '/' + result.search;
                    }
                    else {
                        result.path = null;
                    }
                    result.href = result.format();
                    return result;
                }
                var last = srcPath.slice(-1)[0];
                var hasTrailingSlash = ((result.host || relative.host || srcPath.length > 1) &&
                    (last === '.' || last === '..') || last === '');
                var up = 0;
                for (var i = srcPath.length; i >= 0; i--) {
                    last = srcPath[i];
                    if (last === '.') {
                        srcPath.splice(i, 1);
                    }
                    else if (last === '..') {
                        srcPath.splice(i, 1);
                        up++;
                    }
                    else if (up) {
                        srcPath.splice(i, 1);
                        up--;
                    }
                }
                if (!mustEndAbs && !removeAllDots) {
                    for (; up--; up) {
                        srcPath.unshift('..');
                    }
                }
                if (mustEndAbs && srcPath[0] !== '' &&
                    (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
                    srcPath.unshift('');
                }
                if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
                    srcPath.push('');
                }
                var isAbsolute = srcPath[0] === '' ||
                    (srcPath[0] && srcPath[0].charAt(0) === '/');
                if (psychotic) {
                    result.hostname = result.host = isAbsolute ? '' :
                        srcPath.length ? srcPath.shift() : '';
                    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                        result.host.split('@') : false;
                    if (authInHost) {
                        result.auth = authInHost.shift();
                        result.host = result.hostname = authInHost.shift();
                    }
                }
                mustEndAbs = mustEndAbs || (result.host && srcPath.length);
                if (mustEndAbs && !isAbsolute) {
                    srcPath.unshift('');
                }
                if (!srcPath.length) {
                    result.pathname = null;
                    result.path = null;
                }
                else {
                    result.pathname = srcPath.join('/');
                }
                if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
                    result.path = (result.pathname ? result.pathname : '') +
                        (result.search ? result.search : '');
                }
                result.auth = relative.auth || result.auth;
                result.slashes = result.slashes || relative.slashes;
                result.href = result.format();
                return result;
            };
            Url.prototype.parseHost = function () {
                var host = this.host;
                var port = portPattern.exec(host);
                if (port) {
                    port = port[0];
                    if (port !== ':') {
                        this.port = port.substr(1);
                    }
                    host = host.substr(0, host.length - port.length);
                }
                if (host)
                    this.hostname = host;
            };
        }, { "./util": 52, "punycode": 32, "querystring": 46 }], 52: [function (require, module, exports) {
            'use strict';
            module.exports = {
                isString: function (arg) {
                    return typeof (arg) === 'string';
                },
                isObject: function (arg) {
                    return typeof (arg) === 'object' && arg !== null;
                },
                isNull: function (arg) {
                    return arg === null;
                },
                isNullOrUndefined: function (arg) {
                    return arg == null;
                }
            };
        }, {}], 53: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", { value: true });
            exports.RoomType = exports.RoomCreateTypeField = exports.MsgType = exports.EventType = void 0;
            var EventType;
            (function (EventType) {
                EventType["RoomCanonicalAlias"] = "m.room.canonical_alias";
                EventType["RoomCreate"] = "m.room.create";
                EventType["RoomJoinRules"] = "m.room.join_rules";
                EventType["RoomMember"] = "m.room.member";
                EventType["RoomThirdPartyInvite"] = "m.room.third_party_invite";
                EventType["RoomPowerLevels"] = "m.room.power_levels";
                EventType["RoomName"] = "m.room.name";
                EventType["RoomTopic"] = "m.room.topic";
                EventType["RoomAvatar"] = "m.room.avatar";
                EventType["RoomPinnedEvents"] = "m.room.pinned_events";
                EventType["RoomEncryption"] = "m.room.encryption";
                EventType["RoomHistoryVisibility"] = "m.room.history_visibility";
                EventType["RoomGuestAccess"] = "m.room.guest_access";
                EventType["RoomServerAcl"] = "m.room.server_acl";
                EventType["RoomTombstone"] = "m.room.tombstone";
                EventType["RoomAliases"] = "m.room.aliases";
                EventType["SpaceChild"] = "org.matrix.msc1772.space.child";
                EventType["SpaceParent"] = "org.matrix.msc1772.space.parent";
                EventType["RoomRedaction"] = "m.room.redaction";
                EventType["RoomMessage"] = "m.room.message";
                EventType["RoomMessageEncrypted"] = "m.room.encrypted";
                EventType["Sticker"] = "m.sticker";
                EventType["CallInvite"] = "m.call.invite";
                EventType["CallCandidates"] = "m.call.candidates";
                EventType["CallAnswer"] = "m.call.answer";
                EventType["CallHangup"] = "m.call.hangup";
                EventType["CallReject"] = "m.call.reject";
                EventType["CallSelectAnswer"] = "m.call.select_answer";
                EventType["CallNegotiate"] = "m.call.negotiate";
                EventType["CallReplaces"] = "m.call.replaces";
                EventType["KeyVerificationRequest"] = "m.key.verification.request";
                EventType["KeyVerificationStart"] = "m.key.verification.start";
                EventType["KeyVerificationCancel"] = "m.key.verification.cancel";
                EventType["KeyVerificationMac"] = "m.key.verification.mac";
                EventType["RoomMessageFeedback"] = "m.room.message.feedback";
                EventType["Typing"] = "m.typing";
                EventType["Receipt"] = "m.receipt";
                EventType["Presence"] = "m.presence";
                EventType["FullyRead"] = "m.fully_read";
                EventType["Tag"] = "m.tag";
                EventType["PushRules"] = "m.push_rules";
                EventType["Direct"] = "m.direct";
                EventType["IgnoredUserList"] = "m.ignored_user_list";
                EventType["RoomKey"] = "m.room_key";
                EventType["RoomKeyRequest"] = "m.room_key_request";
                EventType["ForwardedRoomKey"] = "m.forwarded_room_key";
                EventType["Dummy"] = "m.dummy";
            })(EventType = exports.EventType || (exports.EventType = {}));
            var MsgType;
            (function (MsgType) {
                MsgType["Text"] = "m.text";
                MsgType["Emote"] = "m.emote";
                MsgType["Notice"] = "m.notice";
                MsgType["Image"] = "m.image";
                MsgType["File"] = "m.file";
                MsgType["Audio"] = "m.audio";
                MsgType["Location"] = "m.location";
                MsgType["Video"] = "m.video";
            })(MsgType = exports.MsgType || (exports.MsgType = {}));
            exports.RoomCreateTypeField = "org.matrix.msc1772.type";
            var RoomType;
            (function (RoomType) {
                RoomType["Space"] = "org.matrix.msc1772.space";
            })(RoomType = exports.RoomType || (exports.RoomType = {}));
        }, {}], 54: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", { value: true });
            exports.ReEmitter = void 0;
            class ReEmitter {
                constructor(target) {
                    this.target = target;
                }
                reEmit(source, eventNames) {
                    for (const eventName of eventNames) {
                        const forSource = (...args) => {
                            if (eventName === 'error' && this.target.listenerCount('error') === 0)
                                return;
                            this.target.emit(eventName, ...args, source);
                        };
                        source.on(eventName, forSource);
                    }
                }
            }
            exports.ReEmitter = ReEmitter;
        }, {}], 55: [function (require, module, exports) {
            "use strict";
            var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.AutoDiscovery = void 0;
            var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
            var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
            var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
            var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
            var _logger = require("./logger");
            var _url = require("url");
            var DiscoveredClientConfig = function DiscoveredClientConfig() {
                (0, _classCallCheck2["default"])(this, DiscoveredClientConfig);
                this["m.homeserver"] = {
                    state: AutoDiscovery.PROMPT,
                    error: "Something went wrong",
                    base_url: "https://matrix.org"
                };
                this["m.identity_server"] = {
                    state: AutoDiscovery.PROMPT,
                    base_url: "https://vector.im"
                };
            };
            var AutoDiscovery = function () {
                function AutoDiscovery() {
                    (0, _classCallCheck2["default"])(this, AutoDiscovery);
                }
                (0, _createClass2["default"])(AutoDiscovery, null, [{
                        key: "fromDiscoveryConfig",
                        value: function () {
                            var _fromDiscoveryConfig = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee(wellknown) {
                                var clientConfig, hsUrl, hsVersions, isUrl, failingClientConfig, isResponse;
                                return _regenerator["default"].wrap(function _callee$(_context) {
                                    while (1) {
                                        switch (_context.prev = _context.next) {
                                            case 0:
                                                clientConfig = {
                                                    "m.homeserver": {
                                                        state: AutoDiscovery.FAIL_ERROR,
                                                        error: AutoDiscovery.ERROR_INVALID,
                                                        base_url: null
                                                    },
                                                    "m.identity_server": {
                                                        state: AutoDiscovery.PROMPT,
                                                        error: null,
                                                        base_url: null
                                                    }
                                                };
                                                if (!(!wellknown || !wellknown["m.homeserver"])) {
                                                    _context.next = 6;
                                                    break;
                                                }
                                                _logger.logger.error("No m.homeserver key in config");
                                                clientConfig["m.homeserver"].state = AutoDiscovery.FAIL_PROMPT;
                                                clientConfig["m.homeserver"].error = AutoDiscovery.ERROR_INVALID;
                                                return _context.abrupt("return", Promise.resolve(clientConfig));
                                            case 6:
                                                if (wellknown["m.homeserver"]["base_url"]) {
                                                    _context.next = 11;
                                                    break;
                                                }
                                                _logger.logger.error("No m.homeserver base_url in config");
                                                clientConfig["m.homeserver"].state = AutoDiscovery.FAIL_PROMPT;
                                                clientConfig["m.homeserver"].error = AutoDiscovery.ERROR_INVALID_HS_BASE_URL;
                                                return _context.abrupt("return", Promise.resolve(clientConfig));
                                            case 11:
                                                hsUrl = this._sanitizeWellKnownUrl(wellknown["m.homeserver"]["base_url"]);
                                                if (hsUrl) {
                                                    _context.next = 16;
                                                    break;
                                                }
                                                _logger.logger.error("Invalid base_url for m.homeserver");
                                                clientConfig["m.homeserver"].error = AutoDiscovery.ERROR_INVALID_HS_BASE_URL;
                                                return _context.abrupt("return", Promise.resolve(clientConfig));
                                            case 16:
                                                _context.next = 18;
                                                return this._fetchWellKnownObject("".concat(hsUrl, "/_matrix/client/versions"));
                                            case 18:
                                                hsVersions = _context.sent;
                                                if (!(!hsVersions || !hsVersions.raw["versions"])) {
                                                    _context.next = 24;
                                                    break;
                                                }
                                                _logger.logger.error("Invalid /versions response");
                                                clientConfig["m.homeserver"].error = AutoDiscovery.ERROR_INVALID_HOMESERVER;
                                                clientConfig["m.homeserver"].base_url = hsUrl;
                                                return _context.abrupt("return", Promise.resolve(clientConfig));
                                            case 24:
                                                clientConfig["m.homeserver"] = {
                                                    state: AutoDiscovery.SUCCESS,
                                                    error: null,
                                                    base_url: hsUrl
                                                };
                                                isUrl = "";
                                                if (!wellknown["m.identity_server"]) {
                                                    _context.next = 41;
                                                    break;
                                                }
                                                failingClientConfig = {
                                                    "m.homeserver": clientConfig["m.homeserver"],
                                                    "m.identity_server": {
                                                        state: AutoDiscovery.FAIL_PROMPT,
                                                        error: AutoDiscovery.ERROR_INVALID_IS,
                                                        base_url: null
                                                    }
                                                };
                                                isUrl = this._sanitizeWellKnownUrl(wellknown["m.identity_server"]["base_url"]);
                                                if (isUrl) {
                                                    _context.next = 33;
                                                    break;
                                                }
                                                _logger.logger.error("Invalid base_url for m.identity_server");
                                                failingClientConfig["m.identity_server"].error = AutoDiscovery.ERROR_INVALID_IS_BASE_URL;
                                                return _context.abrupt("return", Promise.resolve(failingClientConfig));
                                            case 33:
                                                _context.next = 35;
                                                return this._fetchWellKnownObject("".concat(isUrl, "/_matrix/identity/api/v1"));
                                            case 35:
                                                isResponse = _context.sent;
                                                if (!(!isResponse || !isResponse.raw || isResponse.action !== "SUCCESS")) {
                                                    _context.next = 41;
                                                    break;
                                                }
                                                _logger.logger.error("Invalid /api/v1 response");
                                                failingClientConfig["m.identity_server"].error = AutoDiscovery.ERROR_INVALID_IDENTITY_SERVER;
                                                failingClientConfig["m.identity_server"].base_url = isUrl;
                                                return _context.abrupt("return", Promise.resolve(failingClientConfig));
                                            case 41:
                                                if (isUrl && isUrl.length > 0) {
                                                    clientConfig["m.identity_server"] = {
                                                        state: AutoDiscovery.SUCCESS,
                                                        error: null,
                                                        base_url: isUrl
                                                    };
                                                }
                                                Object.keys(wellknown).map(function (k) {
                                                    if (k === "m.homeserver" || k === "m.identity_server") {
                                                        var notProps = ["error", "state", "base_url"];
                                                        for (var _i = 0, _Object$keys = Object.keys(wellknown[k]); _i < _Object$keys.length; _i++) {
                                                            var prop = _Object$keys[_i];
                                                            if (notProps.includes(prop))
                                                                continue;
                                                            clientConfig[k][prop] = wellknown[k][prop];
                                                        }
                                                    }
                                                    else {
                                                        clientConfig[k] = wellknown[k];
                                                    }
                                                });
                                                return _context.abrupt("return", Promise.resolve(clientConfig));
                                            case 44:
                                            case "end":
                                                return _context.stop();
                                        }
                                    }
                                }, _callee, this);
                            }));
                            function fromDiscoveryConfig(_x) {
                                return _fromDiscoveryConfig.apply(this, arguments);
                            }
                            return fromDiscoveryConfig;
                        }()
                    }, {
                        key: "findClientConfig",
                        value: function () {
                            var _findClientConfig = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee2(domain) {
                                var clientConfig, wellknown;
                                return _regenerator["default"].wrap(function _callee2$(_context2) {
                                    while (1) {
                                        switch (_context2.prev = _context2.next) {
                                            case 0:
                                                if (!(!domain || typeof domain !== "string" || domain.length === 0)) {
                                                    _context2.next = 2;
                                                    break;
                                                }
                                                throw new Error("'domain' must be a string of non-zero length");
                                            case 2:
                                                clientConfig = {
                                                    "m.homeserver": {
                                                        state: AutoDiscovery.FAIL_ERROR,
                                                        error: AutoDiscovery.ERROR_INVALID,
                                                        base_url: null
                                                    },
                                                    "m.identity_server": {
                                                        state: AutoDiscovery.PROMPT,
                                                        error: null,
                                                        base_url: null
                                                    }
                                                };
                                                _context2.next = 5;
                                                return this._fetchWellKnownObject("https://".concat(domain, "/.well-known/matrix/client"));
                                            case 5:
                                                wellknown = _context2.sent;
                                                if (!(!wellknown || wellknown.action !== "SUCCESS")) {
                                                    _context2.next = 11;
                                                    break;
                                                }
                                                _logger.logger.error("No response or error when parsing .well-known");
                                                if (wellknown.reason)
                                                    _logger.logger.error(wellknown.reason);
                                                if (wellknown.action === "IGNORE") {
                                                    clientConfig["m.homeserver"] = {
                                                        state: AutoDiscovery.PROMPT,
                                                        error: null,
                                                        base_url: null
                                                    };
                                                }
                                                else {
                                                    clientConfig["m.homeserver"].state = AutoDiscovery.FAIL_PROMPT;
                                                    clientConfig["m.homeserver"].error = AutoDiscovery.ERROR_INVALID;
                                                }
                                                return _context2.abrupt("return", Promise.resolve(clientConfig));
                                            case 11:
                                                return _context2.abrupt("return", AutoDiscovery.fromDiscoveryConfig(wellknown.raw));
                                            case 12:
                                            case "end":
                                                return _context2.stop();
                                        }
                                    }
                                }, _callee2, this);
                            }));
                            function findClientConfig(_x2) {
                                return _findClientConfig.apply(this, arguments);
                            }
                            return findClientConfig;
                        }()
                    }, {
                        key: "getRawClientConfig",
                        value: function () {
                            var _getRawClientConfig = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee3(domain) {
                                var response;
                                return _regenerator["default"].wrap(function _callee3$(_context3) {
                                    while (1) {
                                        switch (_context3.prev = _context3.next) {
                                            case 0:
                                                if (!(!domain || typeof domain !== "string" || domain.length === 0)) {
                                                    _context3.next = 2;
                                                    break;
                                                }
                                                throw new Error("'domain' must be a string of non-zero length");
                                            case 2:
                                                _context3.next = 4;
                                                return this._fetchWellKnownObject("https://".concat(domain, "/.well-known/matrix/client"));
                                            case 4:
                                                response = _context3.sent;
                                                if (response) {
                                                    _context3.next = 7;
                                                    break;
                                                }
                                                return _context3.abrupt("return", {});
                                            case 7:
                                                return _context3.abrupt("return", response.raw || {});
                                            case 8:
                                            case "end":
                                                return _context3.stop();
                                        }
                                    }
                                }, _callee3, this);
                            }));
                            function getRawClientConfig(_x3) {
                                return _getRawClientConfig.apply(this, arguments);
                            }
                            return getRawClientConfig;
                        }()
                    }, {
                        key: "_sanitizeWellKnownUrl",
                        value: function _sanitizeWellKnownUrl(url) {
                            if (!url)
                                return false;
                            try {
                                var parsed = null;
                                try {
                                    if (_url.URL)
                                        parsed = new _url.URL(url);
                                    else
                                        parsed = new URL(url);
                                }
                                catch (e) {
                                    parsed = new URL(url);
                                }
                                if (!parsed || !parsed.hostname)
                                    return false;
                                if (parsed.protocol !== "http:" && parsed.protocol !== "https:")
                                    return false;
                                var port = parsed.port ? ":".concat(parsed.port) : "";
                                var path = parsed.pathname ? parsed.pathname : "";
                                var saferUrl = "".concat(parsed.protocol, "//").concat(parsed.hostname).concat(port).concat(path);
                                if (saferUrl.endsWith("/")) {
                                    saferUrl = saferUrl.substring(0, saferUrl.length - 1);
                                }
                                return saferUrl;
                            }
                            catch (e) {
                                _logger.logger.error(e);
                                return false;
                            }
                        }
                    }, {
                        key: "_fetchWellKnownObject",
                        value: function () {
                            var _fetchWellKnownObject2 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee4(url) {
                                return _regenerator["default"].wrap(function _callee4$(_context4) {
                                    while (1) {
                                        switch (_context4.prev = _context4.next) {
                                            case 0:
                                                return _context4.abrupt("return", new Promise(function (resolve, reject) {
                                                    var request = require("./matrix").getRequest();
                                                    if (!request)
                                                        throw new Error("No request library available");
                                                    request({
                                                        method: "GET",
                                                        uri: url,
                                                        timeout: 5000
                                                    }, function (err, response, body) {
                                                        if (err || response && (response.statusCode < 200 || response.statusCode >= 300)) {
                                                            var action = "FAIL_PROMPT";
                                                            var reason = (err ? err.message : null) || "General failure";
                                                            if (response && response.statusCode === 404) {
                                                                action = "IGNORE";
                                                                reason = AutoDiscovery.ERROR_MISSING_WELLKNOWN;
                                                            }
                                                            resolve({
                                                                raw: {},
                                                                action: action,
                                                                reason: reason,
                                                                error: err
                                                            });
                                                            return;
                                                        }
                                                        try {
                                                            resolve({
                                                                raw: JSON.parse(body),
                                                                action: "SUCCESS"
                                                            });
                                                        }
                                                        catch (e) {
                                                            var _reason = AutoDiscovery.ERROR_INVALID;
                                                            if (e.name === "SyntaxError") {
                                                                _reason = AutoDiscovery.ERROR_INVALID_JSON;
                                                            }
                                                            resolve({
                                                                raw: {},
                                                                action: "FAIL_PROMPT",
                                                                reason: _reason,
                                                                error: e
                                                            });
                                                        }
                                                    });
                                                }));
                                            case 1:
                                            case "end":
                                                return _context4.stop();
                                        }
                                    }
                                }, _callee4);
                            }));
                            function _fetchWellKnownObject(_x4) {
                                return _fetchWellKnownObject2.apply(this, arguments);
                            }
                            return _fetchWellKnownObject;
                        }()
                    }, {
                        key: "ERROR_INVALID",
                        get: function get() {
                            return "Invalid homeserver discovery response";
                        }
                    }, {
                        key: "ERROR_GENERIC_FAILURE",
                        get: function get() {
                            return "Failed to get autodiscovery configuration from server";
                        }
                    }, {
                        key: "ERROR_INVALID_HS_BASE_URL",
                        get: function get() {
                            return "Invalid base_url for m.homeserver";
                        }
                    }, {
                        key: "ERROR_INVALID_HOMESERVER",
                        get: function get() {
                            return "Homeserver URL does not appear to be a valid Matrix homeserver";
                        }
                    }, {
                        key: "ERROR_INVALID_IS_BASE_URL",
                        get: function get() {
                            return "Invalid base_url for m.identity_server";
                        }
                    }, {
                        key: "ERROR_INVALID_IDENTITY_SERVER",
                        get: function get() {
                            return "Identity server URL does not appear to be a valid identity server";
                        }
                    }, {
                        key: "ERROR_INVALID_IS",
                        get: function get() {
                            return "Invalid identity server discovery response";
                        }
                    }, {
                        key: "ERROR_MISSING_WELLKNOWN",
                        get: function get() {
                            return "No .well-known JSON file found";
                        }
                    }, {
                        key: "ERROR_INVALID_JSON",
                        get: function get() {
                            return "Invalid JSON";
                        }
                    }, {
                        key: "ALL_ERRORS",
                        get: function get() {
                            return [AutoDiscovery.ERROR_INVALID, AutoDiscovery.ERROR_GENERIC_FAILURE, AutoDiscovery.ERROR_INVALID_HS_BASE_URL, AutoDiscovery.ERROR_INVALID_HOMESERVER, AutoDiscovery.ERROR_INVALID_IS_BASE_URL, AutoDiscovery.ERROR_INVALID_IDENTITY_SERVER, AutoDiscovery.ERROR_INVALID_IS, AutoDiscovery.ERROR_MISSING_WELLKNOWN, AutoDiscovery.ERROR_INVALID_JSON];
                        }
                    }, {
                        key: "FAIL_ERROR",
                        get: function get() {
                            return "FAIL_ERROR";
                        }
                    }, {
                        key: "FAIL_PROMPT",
                        get: function get() {
                            return "FAIL_PROMPT";
                        }
                    }, {
                        key: "PROMPT",
                        get: function get() {
                            return "PROMPT";
                        }
                    }, {
                        key: "SUCCESS",
                        get: function get() {
                            return "SUCCESS";
                        }
                    }]);
                return AutoDiscovery;
            }();
            exports.AutoDiscovery = AutoDiscovery;
        }, { "./logger": 97, "./matrix": 98, "@babel/runtime/helpers/asyncToGenerator": 5, "@babel/runtime/helpers/classCallCheck": 6, "@babel/runtime/helpers/createClass": 8, "@babel/runtime/helpers/interopRequireDefault": 12, "@babel/runtime/regenerator": 27, "url": 51 }], 56: [function (require, module, exports) {
            (function (global) {
                (function () {
                    "use strict";
                    var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
                    var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
                    Object.defineProperty(exports, "__esModule", {
                        value: true
                    });
                    exports.MatrixBaseApis = MatrixBaseApis;
                    var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
                    var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
                    var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
                    var _serviceTypes = require("./service-types");
                    var _logger = require("./logger");
                    var _pushprocessor = require("./pushprocessor");
                    var utils = _interopRequireWildcard(require("./utils"));
                    var _httpApi = require("./http-api");
                    function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
                        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                            if (it)
                                o = it;
                            var i = 0;
                            var F = function F() { };
                            return { s: F, n: function n() { if (i >= o.length)
                                    return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F };
                        }
                        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                    } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try {
                            if (!normalCompletion && it["return"] != null)
                                it["return"]();
                        }
                        finally {
                            if (didErr)
                                throw err;
                        } } }; }
                    function _unsupportedIterableToArray(o, minLen) { if (!o)
                        return; if (typeof o === "string")
                        return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor)
                        n = o.constructor.name; if (n === "Map" || n === "Set")
                        return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                        return _arrayLikeToArray(o, minLen); }
                    function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length)
                        len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) {
                        arr2[i] = arr[i];
                    } return arr2; }
                    function termsUrlForService(serviceType, baseUrl) {
                        switch (serviceType) {
                            case _serviceTypes.SERVICE_TYPES.IS:
                                return baseUrl + _httpApi.PREFIX_IDENTITY_V2 + '/terms';
                            case _serviceTypes.SERVICE_TYPES.IM:
                                return baseUrl + '/_matrix/integrations/v1/terms';
                            default:
                                throw new Error('Unsupported service type');
                        }
                    }
                    function MatrixBaseApis(opts) {
                        utils.checkObjectHasKeys(opts, ["baseUrl", "request"]);
                        this.baseUrl = opts.baseUrl;
                        this.idBaseUrl = opts.idBaseUrl;
                        this.identityServer = opts.identityServer;
                        var httpOpts = {
                            baseUrl: opts.baseUrl,
                            idBaseUrl: opts.idBaseUrl,
                            accessToken: opts.accessToken,
                            request: opts.request,
                            prefix: _httpApi.PREFIX_R0,
                            onlyData: true,
                            extraParams: opts.queryParams,
                            localTimeoutMs: opts.localTimeoutMs,
                            useAuthorizationHeader: opts.useAuthorizationHeader
                        };
                        this._http = new _httpApi.MatrixHttpApi(this, httpOpts);
                        this._txnCtr = 0;
                    }
                    MatrixBaseApis.prototype.getHomeserverUrl = function () {
                        return this.baseUrl;
                    };
                    MatrixBaseApis.prototype.getIdentityServerUrl = function () {
                        var stripProto = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
                        if (stripProto && (this.idBaseUrl.startsWith("http://") || this.idBaseUrl.startsWith("https://"))) {
                            return this.idBaseUrl.split("://")[1];
                        }
                        return this.idBaseUrl;
                    };
                    MatrixBaseApis.prototype.setIdentityServerUrl = function (url) {
                        this.idBaseUrl = utils.ensureNoTrailingSlash(url);
                        this._http.setIdBaseUrl(this.idBaseUrl);
                    };
                    MatrixBaseApis.prototype.getAccessToken = function () {
                        return this._http.opts.accessToken || null;
                    };
                    MatrixBaseApis.prototype.isLoggedIn = function () {
                        return this._http.opts.accessToken !== undefined;
                    };
                    MatrixBaseApis.prototype.makeTxnId = function () {
                        return "m" + new Date().getTime() + "." + this._txnCtr++;
                    };
                    MatrixBaseApis.prototype.isUsernameAvailable = function (username) {
                        return this._http.authedRequest(undefined, "GET", '/register/available', {
                            username: username
                        }).then(function (response) {
                            return response.available;
                        });
                    };
                    MatrixBaseApis.prototype.register = function (username, password, sessionId, auth, bindThreepids, guestAccessToken, inhibitLogin, callback) {
                        if (bindThreepids === true) {
                            bindThreepids = {
                                email: true
                            };
                        }
                        else if (bindThreepids === null || bindThreepids === undefined) {
                            bindThreepids = {};
                        }
                        if (typeof inhibitLogin === 'function') {
                            callback = inhibitLogin;
                            inhibitLogin = undefined;
                        }
                        if (sessionId) {
                            auth.session = sessionId;
                        }
                        var params = {
                            auth: auth
                        };
                        if (username !== undefined && username !== null) {
                            params.username = username;
                        }
                        if (password !== undefined && password !== null) {
                            params.password = password;
                        }
                        if (bindThreepids.email) {
                            params.bind_email = true;
                        }
                        if (bindThreepids.msisdn) {
                            params.bind_msisdn = true;
                        }
                        if (guestAccessToken !== undefined && guestAccessToken !== null) {
                            params.guest_access_token = guestAccessToken;
                        }
                        if (inhibitLogin !== undefined && inhibitLogin !== null) {
                            params.inhibit_login = inhibitLogin;
                        }
                        if (password !== undefined && password !== null) {
                            params.x_show_msisdn = true;
                        }
                        return this.registerRequest(params, undefined, callback);
                    };
                    MatrixBaseApis.prototype.registerGuest = function (opts, callback) {
                        opts = opts || {};
                        opts.body = opts.body || {};
                        return this.registerRequest(opts.body, "guest", callback);
                    };
                    MatrixBaseApis.prototype.registerRequest = function (data, kind, callback) {
                        var params = {};
                        if (kind) {
                            params.kind = kind;
                        }
                        return this._http.request(callback, "POST", "/register", params, data);
                    };
                    MatrixBaseApis.prototype.loginFlows = function (callback) {
                        return this._http.request(callback, "GET", "/login");
                    };
                    MatrixBaseApis.prototype.login = function (loginType, data, callback) {
                        var _this = this;
                        var login_data = {
                            type: loginType
                        };
                        utils.extend(login_data, data);
                        return this._http.authedRequest(function (error, response) {
                            if (response && response.access_token && response.user_id) {
                                _this._http.opts.accessToken = response.access_token;
                                _this.credentials = {
                                    userId: response.user_id
                                };
                            }
                            if (callback) {
                                callback(error, response);
                            }
                        }, "POST", "/login", undefined, login_data);
                    };
                    MatrixBaseApis.prototype.loginWithPassword = function (user, password, callback) {
                        return this.login("m.login.password", {
                            user: user,
                            password: password
                        }, callback);
                    };
                    MatrixBaseApis.prototype.loginWithSAML2 = function (relayState, callback) {
                        return this.login("m.login.saml2", {
                            relay_state: relayState
                        }, callback);
                    };
                    MatrixBaseApis.prototype.getCasLoginUrl = function (redirectUrl) {
                        return this.getSsoLoginUrl(redirectUrl, "cas");
                    };
                    MatrixBaseApis.prototype.getSsoLoginUrl = function (redirectUrl, loginType, idpId) {
                        if (loginType === undefined) {
                            loginType = "sso";
                        }
                        var prefix = _httpApi.PREFIX_R0;
                        var url = "/login/" + loginType + "/redirect";
                        if (idpId) {
                            url += "/" + idpId;
                            prefix = "/_matrix/client/unstable/org.matrix.msc2858";
                        }
                        return this._http.getUrl(url, {
                            redirectUrl: redirectUrl
                        }, prefix);
                    };
                    MatrixBaseApis.prototype.loginWithToken = function (token, callback) {
                        return this.login("m.login.token", {
                            token: token
                        }, callback);
                    };
                    MatrixBaseApis.prototype.logout = function (callback) {
                        return this._http.authedRequest(callback, "POST", '/logout');
                    };
                    MatrixBaseApis.prototype.deactivateAccount = function (auth, erase) {
                        if (typeof erase === 'function') {
                            throw new Error('deactivateAccount no longer accepts a callback parameter');
                        }
                        var body = {};
                        if (auth) {
                            body.auth = auth;
                        }
                        if (erase !== undefined) {
                            body.erase = erase;
                        }
                        return this._http.authedRequest(undefined, "POST", '/account/deactivate', undefined, body);
                    };
                    MatrixBaseApis.prototype.getFallbackAuthUrl = function (loginType, authSessionId) {
                        var path = utils.encodeUri("/auth/$loginType/fallback/web", {
                            $loginType: loginType
                        });
                        return this._http.getUrl(path, {
                            session: authSessionId
                        }, _httpApi.PREFIX_R0);
                    };
                    MatrixBaseApis.prototype.createRoom = function () {
                        var _ref = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee(options, callback) {
                            var invitesNeedingToken, identityAccessToken, _iterator, _step, invite;
                            return _regenerator["default"].wrap(function _callee$(_context) {
                                while (1) {
                                    switch (_context.prev = _context.next) {
                                        case 0:
                                            invitesNeedingToken = (options.invite_3pid || []).filter(function (i) {
                                                return !i.id_access_token;
                                            });
                                            _context.t0 = invitesNeedingToken.length > 0 && this.identityServer && this.identityServer.getAccessToken;
                                            if (!_context.t0) {
                                                _context.next = 6;
                                                break;
                                            }
                                            _context.next = 5;
                                            return this.doesServerAcceptIdentityAccessToken();
                                        case 5:
                                            _context.t0 = _context.sent;
                                        case 6:
                                            if (!_context.t0) {
                                                _context.next = 11;
                                                break;
                                            }
                                            _context.next = 9;
                                            return this.identityServer.getAccessToken();
                                        case 9:
                                            identityAccessToken = _context.sent;
                                            if (identityAccessToken) {
                                                _iterator = _createForOfIteratorHelper(invitesNeedingToken);
                                                try {
                                                    for (_iterator.s(); !(_step = _iterator.n()).done;) {
                                                        invite = _step.value;
                                                        invite.id_access_token = identityAccessToken;
                                                    }
                                                }
                                                catch (err) {
                                                    _iterator.e(err);
                                                }
                                                finally {
                                                    _iterator.f();
                                                }
                                            }
                                        case 11:
                                            return _context.abrupt("return", this._http.authedRequest(callback, "POST", "/createRoom", undefined, options));
                                        case 12:
                                        case "end":
                                            return _context.stop();
                                    }
                                }
                            }, _callee, this);
                        }));
                        return function (_x, _x2) {
                            return _ref.apply(this, arguments);
                        };
                    }();
                    MatrixBaseApis.prototype.fetchRelations = function () {
                        var _ref2 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee2(roomId, eventId, relationType, eventType, opts) {
                            var queryParams, queryString, path, response;
                            return _regenerator["default"].wrap(function _callee2$(_context2) {
                                while (1) {
                                    switch (_context2.prev = _context2.next) {
                                        case 0:
                                            queryParams = {};
                                            if (opts.from) {
                                                queryParams.from = opts.from;
                                            }
                                            queryString = utils.encodeParams(queryParams);
                                            path = utils.encodeUri("/rooms/$roomId/relations/$eventId/$relationType/$eventType?" + queryString, {
                                                $roomId: roomId,
                                                $eventId: eventId,
                                                $relationType: relationType,
                                                $eventType: eventType
                                            });
                                            _context2.next = 6;
                                            return this._http.authedRequest(undefined, "GET", path, null, null, {
                                                prefix: _httpApi.PREFIX_UNSTABLE
                                            });
                                        case 6:
                                            response = _context2.sent;
                                            return _context2.abrupt("return", response);
                                        case 8:
                                        case "end":
                                            return _context2.stop();
                                    }
                                }
                            }, _callee2, this);
                        }));
                        return function (_x3, _x4, _x5, _x6, _x7) {
                            return _ref2.apply(this, arguments);
                        };
                    }();
                    MatrixBaseApis.prototype.roomState = function (roomId, callback) {
                        var path = utils.encodeUri("/rooms/$roomId/state", {
                            $roomId: roomId
                        });
                        return this._http.authedRequest(callback, "GET", path);
                    };
                    MatrixBaseApis.prototype.fetchRoomEvent = function (roomId, eventId, callback) {
                        var path = utils.encodeUri("/rooms/$roomId/event/$eventId", {
                            $roomId: roomId,
                            $eventId: eventId
                        });
                        return this._http.authedRequest(callback, "GET", path);
                    };
                    MatrixBaseApis.prototype.members = function (roomId, includeMembership, excludeMembership, atEventId, callback) {
                        var queryParams = {};
                        if (includeMembership) {
                            queryParams.membership = includeMembership;
                        }
                        if (excludeMembership) {
                            queryParams.not_membership = excludeMembership;
                        }
                        if (atEventId) {
                            queryParams.at = atEventId;
                        }
                        var queryString = utils.encodeParams(queryParams);
                        var path = utils.encodeUri("/rooms/$roomId/members?" + queryString, {
                            $roomId: roomId
                        });
                        return this._http.authedRequest(callback, "GET", path);
                    };
                    MatrixBaseApis.prototype.upgradeRoom = function (roomId, newVersion) {
                        var path = utils.encodeUri("/rooms/$roomId/upgrade", {
                            $roomId: roomId
                        });
                        return this._http.authedRequest(undefined, "POST", path, undefined, {
                            new_version: newVersion
                        });
                    };
                    MatrixBaseApis.prototype.getGroupSummary = function (groupId) {
                        var path = utils.encodeUri("/groups/$groupId/summary", {
                            $groupId: groupId
                        });
                        return this._http.authedRequest(undefined, "GET", path);
                    };
                    MatrixBaseApis.prototype.getGroupProfile = function (groupId) {
                        var path = utils.encodeUri("/groups/$groupId/profile", {
                            $groupId: groupId
                        });
                        return this._http.authedRequest(undefined, "GET", path);
                    };
                    MatrixBaseApis.prototype.setGroupProfile = function (groupId, profile) {
                        var path = utils.encodeUri("/groups/$groupId/profile", {
                            $groupId: groupId
                        });
                        return this._http.authedRequest(undefined, "POST", path, undefined, profile);
                    };
                    MatrixBaseApis.prototype.setGroupJoinPolicy = function (groupId, policy) {
                        var path = utils.encodeUri("/groups/$groupId/settings/m.join_policy", {
                            $groupId: groupId
                        });
                        return this._http.authedRequest(undefined, "PUT", path, undefined, {
                            'm.join_policy': policy
                        });
                    };
                    MatrixBaseApis.prototype.getGroupUsers = function (groupId) {
                        var path = utils.encodeUri("/groups/$groupId/users", {
                            $groupId: groupId
                        });
                        return this._http.authedRequest(undefined, "GET", path);
                    };
                    MatrixBaseApis.prototype.getGroupInvitedUsers = function (groupId) {
                        var path = utils.encodeUri("/groups/$groupId/invited_users", {
                            $groupId: groupId
                        });
                        return this._http.authedRequest(undefined, "GET", path);
                    };
                    MatrixBaseApis.prototype.getGroupRooms = function (groupId) {
                        var path = utils.encodeUri("/groups/$groupId/rooms", {
                            $groupId: groupId
                        });
                        return this._http.authedRequest(undefined, "GET", path);
                    };
                    MatrixBaseApis.prototype.inviteUserToGroup = function (groupId, userId) {
                        var path = utils.encodeUri("/groups/$groupId/admin/users/invite/$userId", {
                            $groupId: groupId,
                            $userId: userId
                        });
                        return this._http.authedRequest(undefined, "PUT", path, undefined, {});
                    };
                    MatrixBaseApis.prototype.removeUserFromGroup = function (groupId, userId) {
                        var path = utils.encodeUri("/groups/$groupId/admin/users/remove/$userId", {
                            $groupId: groupId,
                            $userId: userId
                        });
                        return this._http.authedRequest(undefined, "PUT", path, undefined, {});
                    };
                    MatrixBaseApis.prototype.addUserToGroupSummary = function (groupId, userId, roleId) {
                        var path = utils.encodeUri(roleId ? "/groups/$groupId/summary/$roleId/users/$userId" : "/groups/$groupId/summary/users/$userId", {
                            $groupId: groupId,
                            $roleId: roleId,
                            $userId: userId
                        });
                        return this._http.authedRequest(undefined, "PUT", path, undefined, {});
                    };
                    MatrixBaseApis.prototype.removeUserFromGroupSummary = function (groupId, userId) {
                        var path = utils.encodeUri("/groups/$groupId/summary/users/$userId", {
                            $groupId: groupId,
                            $userId: userId
                        });
                        return this._http.authedRequest(undefined, "DELETE", path, undefined, {});
                    };
                    MatrixBaseApis.prototype.addRoomToGroupSummary = function (groupId, roomId, categoryId) {
                        var path = utils.encodeUri(categoryId ? "/groups/$groupId/summary/$categoryId/rooms/$roomId" : "/groups/$groupId/summary/rooms/$roomId", {
                            $groupId: groupId,
                            $categoryId: categoryId,
                            $roomId: roomId
                        });
                        return this._http.authedRequest(undefined, "PUT", path, undefined, {});
                    };
                    MatrixBaseApis.prototype.removeRoomFromGroupSummary = function (groupId, roomId) {
                        var path = utils.encodeUri("/groups/$groupId/summary/rooms/$roomId", {
                            $groupId: groupId,
                            $roomId: roomId
                        });
                        return this._http.authedRequest(undefined, "DELETE", path, undefined, {});
                    };
                    MatrixBaseApis.prototype.addRoomToGroup = function (groupId, roomId, isPublic) {
                        if (isPublic === undefined) {
                            isPublic = true;
                        }
                        var path = utils.encodeUri("/groups/$groupId/admin/rooms/$roomId", {
                            $groupId: groupId,
                            $roomId: roomId
                        });
                        return this._http.authedRequest(undefined, "PUT", path, undefined, {
                            "m.visibility": {
                                type: isPublic ? "public" : "private"
                            }
                        });
                    };
                    MatrixBaseApis.prototype.updateGroupRoomVisibility = function (groupId, roomId, isPublic) {
                        var path = utils.encodeUri("/groups/$groupId/admin/rooms/$roomId/config/m.visibility", {
                            $groupId: groupId,
                            $roomId: roomId
                        });
                        return this._http.authedRequest(undefined, "PUT", path, undefined, {
                            type: isPublic ? "public" : "private"
                        });
                    };
                    MatrixBaseApis.prototype.removeRoomFromGroup = function (groupId, roomId) {
                        var path = utils.encodeUri("/groups/$groupId/admin/rooms/$roomId", {
                            $groupId: groupId,
                            $roomId: roomId
                        });
                        return this._http.authedRequest(undefined, "DELETE", path, undefined, {});
                    };
                    MatrixBaseApis.prototype.acceptGroupInvite = function (groupId) {
                        var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                        var path = utils.encodeUri("/groups/$groupId/self/accept_invite", {
                            $groupId: groupId
                        });
                        return this._http.authedRequest(undefined, "PUT", path, undefined, opts || {});
                    };
                    MatrixBaseApis.prototype.joinGroup = function (groupId) {
                        var path = utils.encodeUri("/groups/$groupId/self/join", {
                            $groupId: groupId
                        });
                        return this._http.authedRequest(undefined, "PUT", path, undefined, {});
                    };
                    MatrixBaseApis.prototype.leaveGroup = function (groupId) {
                        var path = utils.encodeUri("/groups/$groupId/self/leave", {
                            $groupId: groupId
                        });
                        return this._http.authedRequest(undefined, "PUT", path, undefined, {});
                    };
                    MatrixBaseApis.prototype.getJoinedGroups = function () {
                        var path = utils.encodeUri("/joined_groups");
                        return this._http.authedRequest(undefined, "GET", path);
                    };
                    MatrixBaseApis.prototype.createGroup = function (content) {
                        var path = utils.encodeUri("/create_group");
                        return this._http.authedRequest(undefined, "POST", path, undefined, content);
                    };
                    MatrixBaseApis.prototype.getPublicisedGroups = function (userIds) {
                        var path = utils.encodeUri("/publicised_groups");
                        return this._http.authedRequest(undefined, "POST", path, undefined, {
                            user_ids: userIds
                        });
                    };
                    MatrixBaseApis.prototype.setGroupPublicity = function (groupId, isPublic) {
                        var path = utils.encodeUri("/groups/$groupId/self/update_publicity", {
                            $groupId: groupId
                        });
                        return this._http.authedRequest(undefined, "PUT", path, undefined, {
                            publicise: isPublic
                        });
                    };
                    MatrixBaseApis.prototype.getStateEvent = function (roomId, eventType, stateKey, callback) {
                        var pathParams = {
                            $roomId: roomId,
                            $eventType: eventType,
                            $stateKey: stateKey
                        };
                        var path = utils.encodeUri("/rooms/$roomId/state/$eventType", pathParams);
                        if (stateKey !== undefined) {
                            path = utils.encodeUri(path + "/$stateKey", pathParams);
                        }
                        return this._http.authedRequest(callback, "GET", path);
                    };
                    MatrixBaseApis.prototype.sendStateEvent = function (roomId, eventType, content, stateKey, callback) {
                        var pathParams = {
                            $roomId: roomId,
                            $eventType: eventType,
                            $stateKey: stateKey
                        };
                        var path = utils.encodeUri("/rooms/$roomId/state/$eventType", pathParams);
                        if (stateKey !== undefined) {
                            path = utils.encodeUri(path + "/$stateKey", pathParams);
                        }
                        return this._http.authedRequest(callback, "PUT", path, undefined, content);
                    };
                    MatrixBaseApis.prototype.roomInitialSync = function (roomId, limit, callback) {
                        if (utils.isFunction(limit)) {
                            callback = limit;
                            limit = undefined;
                        }
                        var path = utils.encodeUri("/rooms/$roomId/initialSync", {
                            $roomId: roomId
                        });
                        if (!limit) {
                            limit = 30;
                        }
                        return this._http.authedRequest(callback, "GET", path, {
                            limit: limit
                        });
                    };
                    MatrixBaseApis.prototype.setRoomReadMarkersHttpRequest = function (roomId, rmEventId, rrEventId, opts) {
                        var path = utils.encodeUri("/rooms/$roomId/read_markers", {
                            $roomId: roomId
                        });
                        var content = {
                            "m.fully_read": rmEventId,
                            "m.read": rrEventId,
                            "m.hidden": Boolean(opts ? opts.hidden : false)
                        };
                        return this._http.authedRequest(undefined, "POST", path, undefined, content);
                    };
                    MatrixBaseApis.prototype.getJoinedRooms = function () {
                        var path = utils.encodeUri("/joined_rooms");
                        return this._http.authedRequest(undefined, "GET", path);
                    };
                    MatrixBaseApis.prototype.getJoinedRoomMembers = function (roomId) {
                        var path = utils.encodeUri("/rooms/$roomId/joined_members", {
                            $roomId: roomId
                        });
                        return this._http.authedRequest(undefined, "GET", path);
                    };
                    MatrixBaseApis.prototype.publicRooms = function (options, callback) {
                        if (typeof options == 'function') {
                            callback = options;
                            options = {};
                        }
                        if (options === undefined) {
                            options = {};
                        }
                        var query_params = {};
                        if (options.server) {
                            query_params.server = options.server;
                            delete options.server;
                        }
                        if (Object.keys(options).length === 0 && Object.keys(query_params).length === 0) {
                            return this._http.authedRequest(callback, "GET", "/publicRooms");
                        }
                        else {
                            return this._http.authedRequest(callback, "POST", "/publicRooms", query_params, options);
                        }
                    };
                    MatrixBaseApis.prototype.createAlias = function (alias, roomId, callback) {
                        var path = utils.encodeUri("/directory/room/$alias", {
                            $alias: alias
                        });
                        var data = {
                            room_id: roomId
                        };
                        return this._http.authedRequest(callback, "PUT", path, undefined, data);
                    };
                    MatrixBaseApis.prototype.deleteAlias = function (alias, callback) {
                        var path = utils.encodeUri("/directory/room/$alias", {
                            $alias: alias
                        });
                        return this._http.authedRequest(callback, "DELETE", path, undefined, undefined);
                    };
                    MatrixBaseApis.prototype.unstableGetLocalAliases = function (roomId, callback) {
                        var path = utils.encodeUri("/rooms/$roomId/aliases", {
                            $roomId: roomId
                        });
                        var prefix = _httpApi.PREFIX_UNSTABLE + "/org.matrix.msc2432";
                        return this._http.authedRequest(callback, "GET", path, null, null, {
                            prefix: prefix
                        });
                    };
                    MatrixBaseApis.prototype.getRoomIdForAlias = function (alias, callback) {
                        var path = utils.encodeUri("/directory/room/$alias", {
                            $alias: alias
                        });
                        return this._http.authedRequest(callback, "GET", path);
                    };
                    MatrixBaseApis.prototype.resolveRoomAlias = function (roomAlias, callback) {
                        var path = utils.encodeUri("/directory/room/$alias", {
                            $alias: roomAlias
                        });
                        return this._http.request(callback, "GET", path);
                    };
                    MatrixBaseApis.prototype.getRoomDirectoryVisibility = function (roomId, callback) {
                        var path = utils.encodeUri("/directory/list/room/$roomId", {
                            $roomId: roomId
                        });
                        return this._http.authedRequest(callback, "GET", path);
                    };
                    MatrixBaseApis.prototype.setRoomDirectoryVisibility = function (roomId, visibility, callback) {
                        var path = utils.encodeUri("/directory/list/room/$roomId", {
                            $roomId: roomId
                        });
                        return this._http.authedRequest(callback, "PUT", path, undefined, {
                            "visibility": visibility
                        });
                    };
                    MatrixBaseApis.prototype.setRoomDirectoryVisibilityAppService = function (networkId, roomId, visibility, callback) {
                        var path = utils.encodeUri("/directory/list/appservice/$networkId/$roomId", {
                            $networkId: networkId,
                            $roomId: roomId
                        });
                        return this._http.authedRequest(callback, "PUT", path, undefined, {
                            "visibility": visibility
                        });
                    };
                    MatrixBaseApis.prototype.searchUserDirectory = function (opts) {
                        var body = {
                            search_term: opts.term
                        };
                        if (opts.limit !== undefined) {
                            body.limit = opts.limit;
                        }
                        return this._http.authedRequest(undefined, "POST", "/user_directory/search", undefined, body);
                    };
                    MatrixBaseApis.prototype.uploadContent = function (file, opts) {
                        return this._http.uploadContent(file, opts);
                    };
                    MatrixBaseApis.prototype.cancelUpload = function (promise) {
                        return this._http.cancelUpload(promise);
                    };
                    MatrixBaseApis.prototype.getCurrentUploads = function () {
                        return this._http.getCurrentUploads();
                    };
                    MatrixBaseApis.prototype.getProfileInfo = function (userId, info, callback) {
                        if (utils.isFunction(info)) {
                            callback = info;
                            info = undefined;
                        }
                        var path = info ? utils.encodeUri("/profile/$userId/$info", {
                            $userId: userId,
                            $info: info
                        }) : utils.encodeUri("/profile/$userId", {
                            $userId: userId
                        });
                        return this._http.authedRequest(callback, "GET", path);
                    };
                    MatrixBaseApis.prototype.getThreePids = function (callback) {
                        var path = "/account/3pid";
                        return this._http.authedRequest(callback, "GET", path, undefined, undefined);
                    };
                    MatrixBaseApis.prototype.addThreePid = function (creds, bind, callback) {
                        var path = "/account/3pid";
                        var data = {
                            'threePidCreds': creds,
                            'bind': bind
                        };
                        return this._http.authedRequest(callback, "POST", path, null, data);
                    };
                    MatrixBaseApis.prototype.addThreePidOnly = function () {
                        var _ref3 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee3(data) {
                            var path, prefix;
                            return _regenerator["default"].wrap(function _callee3$(_context3) {
                                while (1) {
                                    switch (_context3.prev = _context3.next) {
                                        case 0:
                                            path = "/account/3pid/add";
                                            _context3.next = 3;
                                            return this.isVersionSupported("r0.6.0");
                                        case 3:
                                            if (!_context3.sent) {
                                                _context3.next = 7;
                                                break;
                                            }
                                            _context3.t0 = _httpApi.PREFIX_R0;
                                            _context3.next = 8;
                                            break;
                                        case 7:
                                            _context3.t0 = _httpApi.PREFIX_UNSTABLE;
                                        case 8:
                                            prefix = _context3.t0;
                                            return _context3.abrupt("return", this._http.authedRequest(undefined, "POST", path, null, data, {
                                                prefix: prefix
                                            }));
                                        case 10:
                                        case "end":
                                            return _context3.stop();
                                    }
                                }
                            }, _callee3, this);
                        }));
                        return function (_x8) {
                            return _ref3.apply(this, arguments);
                        };
                    }();
                    MatrixBaseApis.prototype.bindThreePid = function () {
                        var _ref4 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee4(data) {
                            var path, prefix;
                            return _regenerator["default"].wrap(function _callee4$(_context4) {
                                while (1) {
                                    switch (_context4.prev = _context4.next) {
                                        case 0:
                                            path = "/account/3pid/bind";
                                            _context4.next = 3;
                                            return this.isVersionSupported("r0.6.0");
                                        case 3:
                                            if (!_context4.sent) {
                                                _context4.next = 7;
                                                break;
                                            }
                                            _context4.t0 = _httpApi.PREFIX_R0;
                                            _context4.next = 8;
                                            break;
                                        case 7:
                                            _context4.t0 = _httpApi.PREFIX_UNSTABLE;
                                        case 8:
                                            prefix = _context4.t0;
                                            return _context4.abrupt("return", this._http.authedRequest(undefined, "POST", path, null, data, {
                                                prefix: prefix
                                            }));
                                        case 10:
                                        case "end":
                                            return _context4.stop();
                                    }
                                }
                            }, _callee4, this);
                        }));
                        return function (_x9) {
                            return _ref4.apply(this, arguments);
                        };
                    }();
                    MatrixBaseApis.prototype.unbindThreePid = function () {
                        var _ref5 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee5(medium, address) {
                            var path, data, prefix;
                            return _regenerator["default"].wrap(function _callee5$(_context5) {
                                while (1) {
                                    switch (_context5.prev = _context5.next) {
                                        case 0:
                                            path = "/account/3pid/unbind";
                                            data = {
                                                medium: medium,
                                                address: address,
                                                id_server: this.getIdentityServerUrl(true)
                                            };
                                            _context5.next = 4;
                                            return this.isVersionSupported("r0.6.0");
                                        case 4:
                                            if (!_context5.sent) {
                                                _context5.next = 8;
                                                break;
                                            }
                                            _context5.t0 = _httpApi.PREFIX_R0;
                                            _context5.next = 9;
                                            break;
                                        case 8:
                                            _context5.t0 = _httpApi.PREFIX_UNSTABLE;
                                        case 9:
                                            prefix = _context5.t0;
                                            return _context5.abrupt("return", this._http.authedRequest(undefined, "POST", path, null, data, {
                                                prefix: prefix
                                            }));
                                        case 11:
                                        case "end":
                                            return _context5.stop();
                                    }
                                }
                            }, _callee5, this);
                        }));
                        return function (_x10, _x11) {
                            return _ref5.apply(this, arguments);
                        };
                    }();
                    MatrixBaseApis.prototype.deleteThreePid = function (medium, address) {
                        var path = "/account/3pid/delete";
                        var data = {
                            'medium': medium,
                            'address': address
                        };
                        return this._http.authedRequest(undefined, "POST", path, null, data);
                    };
                    MatrixBaseApis.prototype.setPassword = function (authDict, newPassword, callback) {
                        var path = "/account/password";
                        var data = {
                            'auth': authDict,
                            'new_password': newPassword
                        };
                        return this._http.authedRequest(callback, "POST", path, null, data);
                    };
                    MatrixBaseApis.prototype.getDevices = function () {
                        return this._http.authedRequest(undefined, 'GET', "/devices", undefined, undefined);
                    };
                    MatrixBaseApis.prototype.setDeviceDetails = function (device_id, body) {
                        var path = utils.encodeUri("/devices/$device_id", {
                            $device_id: device_id
                        });
                        return this._http.authedRequest(undefined, "PUT", path, undefined, body);
                    };
                    MatrixBaseApis.prototype.deleteDevice = function (device_id, auth) {
                        var path = utils.encodeUri("/devices/$device_id", {
                            $device_id: device_id
                        });
                        var body = {};
                        if (auth) {
                            body.auth = auth;
                        }
                        return this._http.authedRequest(undefined, "DELETE", path, undefined, body);
                    };
                    MatrixBaseApis.prototype.deleteMultipleDevices = function (devices, auth) {
                        var body = {
                            devices: devices
                        };
                        if (auth) {
                            body.auth = auth;
                        }
                        var path = "/delete_devices";
                        return this._http.authedRequest(undefined, "POST", path, undefined, body);
                    };
                    MatrixBaseApis.prototype.getPushers = function (callback) {
                        var path = "/pushers";
                        return this._http.authedRequest(callback, "GET", path, undefined, undefined);
                    };
                    MatrixBaseApis.prototype.setPusher = function (pusher, callback) {
                        var path = "/pushers/set";
                        return this._http.authedRequest(callback, "POST", path, null, pusher);
                    };
                    MatrixBaseApis.prototype.getPushRules = function (callback) {
                        return this._http.authedRequest(callback, "GET", "/pushrules/").then(function (rules) {
                            return _pushprocessor.PushProcessor.rewriteDefaultRules(rules);
                        });
                    };
                    MatrixBaseApis.prototype.addPushRule = function (scope, kind, ruleId, body, callback) {
                        var path = utils.encodeUri("/pushrules/" + scope + "/$kind/$ruleId", {
                            $kind: kind,
                            $ruleId: ruleId
                        });
                        return this._http.authedRequest(callback, "PUT", path, undefined, body);
                    };
                    MatrixBaseApis.prototype.deletePushRule = function (scope, kind, ruleId, callback) {
                        var path = utils.encodeUri("/pushrules/" + scope + "/$kind/$ruleId", {
                            $kind: kind,
                            $ruleId: ruleId
                        });
                        return this._http.authedRequest(callback, "DELETE", path);
                    };
                    MatrixBaseApis.prototype.setPushRuleEnabled = function (scope, kind, ruleId, enabled, callback) {
                        var path = utils.encodeUri("/pushrules/" + scope + "/$kind/$ruleId/enabled", {
                            $kind: kind,
                            $ruleId: ruleId
                        });
                        return this._http.authedRequest(callback, "PUT", path, undefined, {
                            "enabled": enabled
                        });
                    };
                    MatrixBaseApis.prototype.setPushRuleActions = function (scope, kind, ruleId, actions, callback) {
                        var path = utils.encodeUri("/pushrules/" + scope + "/$kind/$ruleId/actions", {
                            $kind: kind,
                            $ruleId: ruleId
                        });
                        return this._http.authedRequest(callback, "PUT", path, undefined, {
                            "actions": actions
                        });
                    };
                    MatrixBaseApis.prototype.search = function (opts, callback) {
                        var queryparams = {};
                        if (opts.next_batch) {
                            queryparams.next_batch = opts.next_batch;
                        }
                        return this._http.authedRequest(callback, "POST", "/search", queryparams, opts.body);
                    };
                    MatrixBaseApis.prototype.uploadKeysRequest = function (content, opts, callback) {
                        return this._http.authedRequest(callback, "POST", "/keys/upload", undefined, content);
                    };
                    MatrixBaseApis.prototype.uploadKeySignatures = function (content) {
                        return this._http.authedRequest(undefined, "POST", '/keys/signatures/upload', undefined, content, {
                            prefix: _httpApi.PREFIX_UNSTABLE
                        });
                    };
                    MatrixBaseApis.prototype.downloadKeysForUsers = function (userIds, opts) {
                        if (utils.isFunction(opts)) {
                            throw new Error('downloadKeysForUsers no longer accepts a callback parameter');
                        }
                        opts = opts || {};
                        var content = {
                            device_keys: {}
                        };
                        if ('token' in opts) {
                            content.token = opts.token;
                        }
                        userIds.forEach(function (u) {
                            content.device_keys[u] = [];
                        });
                        return this._http.authedRequest(undefined, "POST", "/keys/query", undefined, content);
                    };
                    MatrixBaseApis.prototype.claimOneTimeKeys = function (devices, key_algorithm, timeout) {
                        var queries = {};
                        if (key_algorithm === undefined) {
                            key_algorithm = "signed_curve25519";
                        }
                        for (var i = 0; i < devices.length; ++i) {
                            var userId = devices[i][0];
                            var deviceId = devices[i][1];
                            var query = queries[userId] || {};
                            queries[userId] = query;
                            query[deviceId] = key_algorithm;
                        }
                        var content = {
                            one_time_keys: queries
                        };
                        if (timeout) {
                            content.timeout = timeout;
                        }
                        var path = "/keys/claim";
                        return this._http.authedRequest(undefined, "POST", path, undefined, content);
                    };
                    MatrixBaseApis.prototype.getKeyChanges = function (oldToken, newToken) {
                        var qps = {
                            from: oldToken,
                            to: newToken
                        };
                        var path = "/keys/changes";
                        return this._http.authedRequest(undefined, "GET", path, qps, undefined);
                    };
                    MatrixBaseApis.prototype.uploadDeviceSigningKeys = function (auth, keys) {
                        var data = Object.assign({}, keys);
                        if (auth)
                            Object.assign(data, {
                                auth: auth
                            });
                        return this._http.authedRequest(undefined, "POST", "/keys/device_signing/upload", undefined, data, {
                            prefix: _httpApi.PREFIX_UNSTABLE
                        });
                    };
                    MatrixBaseApis.prototype.registerWithIdentityServer = function (hsOpenIdToken) {
                        if (!this.idBaseUrl) {
                            throw new Error("No Identity Server base URL set");
                        }
                        var uri = this.idBaseUrl + _httpApi.PREFIX_IDENTITY_V2 + "/account/register";
                        return this._http.requestOtherUrl(undefined, "POST", uri, null, hsOpenIdToken);
                    };
                    MatrixBaseApis.prototype.requestEmailToken = function () {
                        var _ref6 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee6(email, clientSecret, sendAttempt, nextLink, callback, identityAccessToken) {
                            var params;
                            return _regenerator["default"].wrap(function _callee6$(_context6) {
                                while (1) {
                                    switch (_context6.prev = _context6.next) {
                                        case 0:
                                            params = {
                                                client_secret: clientSecret,
                                                email: email,
                                                send_attempt: sendAttempt,
                                                next_link: nextLink
                                            };
                                            _context6.next = 3;
                                            return this._http.idServerRequest(callback, "POST", "/validate/email/requestToken", params, _httpApi.PREFIX_IDENTITY_V2, identityAccessToken);
                                        case 3:
                                            return _context6.abrupt("return", _context6.sent);
                                        case 4:
                                        case "end":
                                            return _context6.stop();
                                    }
                                }
                            }, _callee6, this);
                        }));
                        return function (_x12, _x13, _x14, _x15, _x16, _x17) {
                            return _ref6.apply(this, arguments);
                        };
                    }();
                    MatrixBaseApis.prototype.requestMsisdnToken = function () {
                        var _ref7 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee7(phoneCountry, phoneNumber, clientSecret, sendAttempt, nextLink, callback, identityAccessToken) {
                            var params;
                            return _regenerator["default"].wrap(function _callee7$(_context7) {
                                while (1) {
                                    switch (_context7.prev = _context7.next) {
                                        case 0:
                                            params = {
                                                client_secret: clientSecret,
                                                country: phoneCountry,
                                                phone_number: phoneNumber,
                                                send_attempt: sendAttempt,
                                                next_link: nextLink
                                            };
                                            _context7.next = 3;
                                            return this._http.idServerRequest(callback, "POST", "/validate/msisdn/requestToken", params, _httpApi.PREFIX_IDENTITY_V2, identityAccessToken);
                                        case 3:
                                            return _context7.abrupt("return", _context7.sent);
                                        case 4:
                                        case "end":
                                            return _context7.stop();
                                    }
                                }
                            }, _callee7, this);
                        }));
                        return function (_x18, _x19, _x20, _x21, _x22, _x23, _x24) {
                            return _ref7.apply(this, arguments);
                        };
                    }();
                    MatrixBaseApis.prototype.submitMsisdnToken = function () {
                        var _ref8 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee8(sid, clientSecret, msisdnToken, identityAccessToken) {
                            var params;
                            return _regenerator["default"].wrap(function _callee8$(_context8) {
                                while (1) {
                                    switch (_context8.prev = _context8.next) {
                                        case 0:
                                            params = {
                                                sid: sid,
                                                client_secret: clientSecret,
                                                token: msisdnToken
                                            };
                                            _context8.next = 3;
                                            return this._http.idServerRequest(undefined, "POST", "/validate/msisdn/submitToken", params, _httpApi.PREFIX_IDENTITY_V2, identityAccessToken);
                                        case 3:
                                            return _context8.abrupt("return", _context8.sent);
                                        case 4:
                                        case "end":
                                            return _context8.stop();
                                    }
                                }
                            }, _callee8, this);
                        }));
                        return function (_x25, _x26, _x27, _x28) {
                            return _ref8.apply(this, arguments);
                        };
                    }();
                    MatrixBaseApis.prototype.submitMsisdnTokenOtherUrl = function (url, sid, clientSecret, msisdnToken) {
                        var params = {
                            sid: sid,
                            client_secret: clientSecret,
                            token: msisdnToken
                        };
                        return this._http.requestOtherUrl(undefined, "POST", url, undefined, params);
                    };
                    MatrixBaseApis.prototype.getIdentityHashDetails = function (identityAccessToken) {
                        return this._http.idServerRequest(undefined, "GET", "/hash_details", null, _httpApi.PREFIX_IDENTITY_V2, identityAccessToken);
                    };
                    MatrixBaseApis.prototype.identityHashedLookup = function () {
                        var _ref9 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee9(addressPairs, identityAccessToken) {
                            var params, hashes, localMapping, olmutil, response, foundAddresses, _i, _Object$keys, hashed, mxid, plainAddress;
                            return _regenerator["default"].wrap(function _callee9$(_context9) {
                                while (1) {
                                    switch (_context9.prev = _context9.next) {
                                        case 0:
                                            params = {};
                                            _context9.next = 3;
                                            return this.getIdentityHashDetails(identityAccessToken);
                                        case 3:
                                            hashes = _context9.sent;
                                            if (!(!hashes || !hashes['lookup_pepper'] || !hashes['algorithms'])) {
                                                _context9.next = 6;
                                                break;
                                            }
                                            throw new Error("Unsupported identity server: bad response");
                                        case 6:
                                            params['pepper'] = hashes['lookup_pepper'];
                                            localMapping = {};
                                            if (!hashes['algorithms'].includes('sha256')) {
                                                _context9.next = 14;
                                                break;
                                            }
                                            olmutil = new global.Olm.Utility();
                                            params["addresses"] = addressPairs.map(function (p) {
                                                var addr = p[0].toLowerCase();
                                                var med = p[1].toLowerCase();
                                                var hashed = olmutil.sha256("".concat(addr, " ").concat(med, " ").concat(params['pepper'])).replace(/\+/g, '-').replace(/\//g, '_');
                                                localMapping[hashed] = p[0];
                                                return hashed;
                                            });
                                            params["algorithm"] = "sha256";
                                            _context9.next = 20;
                                            break;
                                        case 14:
                                            if (!hashes['algorithms'].includes('none')) {
                                                _context9.next = 19;
                                                break;
                                            }
                                            params["addresses"] = addressPairs.map(function (p) {
                                                var addr = p[0].toLowerCase();
                                                var med = p[1].toLowerCase();
                                                var unhashed = "".concat(addr, " ").concat(med);
                                                localMapping[unhashed] = p[0];
                                                return unhashed;
                                            });
                                            params["algorithm"] = "none";
                                            _context9.next = 20;
                                            break;
                                        case 19:
                                            throw new Error("Unsupported identity server: unknown hash algorithm");
                                        case 20:
                                            _context9.next = 22;
                                            return this._http.idServerRequest(undefined, "POST", "/lookup", params, _httpApi.PREFIX_IDENTITY_V2, identityAccessToken);
                                        case 22:
                                            response = _context9.sent;
                                            if (!(!response || !response['mappings'])) {
                                                _context9.next = 25;
                                                break;
                                            }
                                            return _context9.abrupt("return", []);
                                        case 25:
                                            foundAddresses = [];
                                            _i = 0, _Object$keys = Object.keys(response['mappings']);
                                        case 27:
                                            if (!(_i < _Object$keys.length)) {
                                                _context9.next = 37;
                                                break;
                                            }
                                            hashed = _Object$keys[_i];
                                            mxid = response['mappings'][hashed];
                                            plainAddress = localMapping[hashed];
                                            if (plainAddress) {
                                                _context9.next = 33;
                                                break;
                                            }
                                            throw new Error("Identity server returned more results than expected");
                                        case 33:
                                            foundAddresses.push({
                                                address: plainAddress,
                                                mxid: mxid
                                            });
                                        case 34:
                                            _i++;
                                            _context9.next = 27;
                                            break;
                                        case 37:
                                            return _context9.abrupt("return", foundAddresses);
                                        case 38:
                                        case "end":
                                            return _context9.stop();
                                    }
                                }
                            }, _callee9, this);
                        }));
                        return function (_x29, _x30) {
                            return _ref9.apply(this, arguments);
                        };
                    }();
                    MatrixBaseApis.prototype.lookupThreePid = function () {
                        var _ref10 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee10(medium, address, callback, identityAccessToken) {
                            var response, result, mapping;
                            return _regenerator["default"].wrap(function _callee10$(_context10) {
                                while (1) {
                                    switch (_context10.prev = _context10.next) {
                                        case 0:
                                            _context10.next = 2;
                                            return this.identityHashedLookup([[address, medium]], identityAccessToken);
                                        case 2:
                                            response = _context10.sent;
                                            result = response.find(function (p) {
                                                return p.address === address;
                                            });
                                            if (result) {
                                                _context10.next = 7;
                                                break;
                                            }
                                            if (callback)
                                                callback(null, {});
                                            return _context10.abrupt("return", {});
                                        case 7:
                                            mapping = {
                                                address: address,
                                                medium: medium,
                                                mxid: result.mxid
                                            };
                                            if (callback)
                                                callback(null, mapping);
                                            return _context10.abrupt("return", mapping);
                                        case 10:
                                        case "end":
                                            return _context10.stop();
                                    }
                                }
                            }, _callee10, this);
                        }));
                        return function (_x31, _x32, _x33, _x34) {
                            return _ref10.apply(this, arguments);
                        };
                    }();
                    MatrixBaseApis.prototype.bulkLookupThreePids = function () {
                        var _ref11 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee11(query, identityAccessToken) {
                            var response, v1results, _iterator2, _step2, _loop;
                            return _regenerator["default"].wrap(function _callee11$(_context11) {
                                while (1) {
                                    switch (_context11.prev = _context11.next) {
                                        case 0:
                                            _context11.next = 2;
                                            return this.identityHashedLookup(query.map(function (p) {
                                                return [p[1], p[0]];
                                            }), identityAccessToken);
                                        case 2:
                                            response = _context11.sent;
                                            v1results = [];
                                            _iterator2 = _createForOfIteratorHelper(response);
                                            try {
                                                _loop = function _loop() {
                                                    var mapping = _step2.value;
                                                    var originalQuery = query.find(function (p) {
                                                        return p[1] === mapping.address;
                                                    });
                                                    if (!originalQuery) {
                                                        throw new Error("Identity sever returned unexpected results");
                                                    }
                                                    v1results.push([originalQuery[0],
                                                        mapping.address, mapping.mxid]);
                                                };
                                                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                                                    _loop();
                                                }
                                            }
                                            catch (err) {
                                                _iterator2.e(err);
                                            }
                                            finally {
                                                _iterator2.f();
                                            }
                                            return _context11.abrupt("return", {
                                                threepids: v1results
                                            });
                                        case 7:
                                        case "end":
                                            return _context11.stop();
                                    }
                                }
                            }, _callee11, this);
                        }));
                        return function (_x35, _x36) {
                            return _ref11.apply(this, arguments);
                        };
                    }();
                    MatrixBaseApis.prototype.getIdentityAccount = function (identityAccessToken) {
                        return this._http.idServerRequest(undefined, "GET", "/account", undefined, _httpApi.PREFIX_IDENTITY_V2, identityAccessToken);
                    };
                    MatrixBaseApis.prototype.sendToDevice = function (eventType, contentMap, txnId) {
                        var path = utils.encodeUri("/sendToDevice/$eventType/$txnId", {
                            $eventType: eventType,
                            $txnId: txnId ? txnId : this.makeTxnId()
                        });
                        var body = {
                            messages: contentMap
                        };
                        var targets = Object.keys(contentMap).reduce(function (obj, key) {
                            obj[key] = Object.keys(contentMap[key]);
                            return obj;
                        }, {});
                        _logger.logger.log("PUT ".concat(path), targets);
                        return this._http.authedRequest(undefined, "PUT", path, undefined, body);
                    };
                    MatrixBaseApis.prototype.getThirdpartyProtocols = function () {
                        return this._http.authedRequest(undefined, "GET", "/thirdparty/protocols", undefined, undefined).then(function (response) {
                            if (!response || (0, _typeof2["default"])(response) !== 'object') {
                                throw new Error("/thirdparty/protocols did not return an object: ".concat(response));
                            }
                            return response;
                        });
                    };
                    MatrixBaseApis.prototype.getThirdpartyLocation = function (protocol, params) {
                        var path = utils.encodeUri("/thirdparty/location/$protocol", {
                            $protocol: protocol
                        });
                        return this._http.authedRequest(undefined, "GET", path, params, undefined);
                    };
                    MatrixBaseApis.prototype.getThirdpartyUser = function (protocol, params) {
                        var path = utils.encodeUri("/thirdparty/user/$protocol", {
                            $protocol: protocol
                        });
                        return this._http.authedRequest(undefined, "GET", path, params, undefined);
                    };
                    MatrixBaseApis.prototype.getTerms = function (serviceType, baseUrl) {
                        var url = termsUrlForService(serviceType, baseUrl);
                        return this._http.requestOtherUrl(undefined, 'GET', url);
                    };
                    MatrixBaseApis.prototype.agreeToTerms = function (serviceType, baseUrl, accessToken, termsUrls) {
                        var url = termsUrlForService(serviceType, baseUrl);
                        var headers = {
                            Authorization: "Bearer " + accessToken
                        };
                        return this._http.requestOtherUrl(undefined, 'POST', url, null, {
                            user_accepts: termsUrls
                        }, {
                            headers: headers
                        });
                    };
                    MatrixBaseApis.prototype.reportEvent = function (roomId, eventId, score, reason) {
                        var path = utils.encodeUri("/rooms/$roomId/report/$eventId", {
                            $roomId: roomId,
                            $eventId: eventId
                        });
                        return this._http.authedRequest(undefined, "POST", path, null, {
                            score: score,
                            reason: reason
                        });
                    };
                    MatrixBaseApis.prototype.getSpaceSummary = function (roomId, maxRoomsPerSpace, suggestedOnly, autoJoinOnly, limit, batch) {
                        var path = utils.encodeUri("/rooms/$roomId/spaces", {
                            $roomId: roomId
                        });
                        return this._http.authedRequest(undefined, "POST", path, null, {
                            max_rooms_per_space: maxRoomsPerSpace,
                            suggested_only: suggestedOnly,
                            auto_join_only: autoJoinOnly,
                            limit: limit,
                            batch: batch
                        }, {
                            prefix: "/_matrix/client/unstable/org.matrix.msc2946"
                        });
                    };
                }).call(this);
            }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, { "./http-api": 94, "./logger": 97, "./pushprocessor": 111, "./service-types": 115, "./utils": 125, "@babel/runtime/helpers/asyncToGenerator": 5, "@babel/runtime/helpers/interopRequireDefault": 12, "@babel/runtime/helpers/interopRequireWildcard": 13, "@babel/runtime/helpers/typeof": 24, "@babel/runtime/regenerator": 27 }], 57: [function (require, module, exports) {
            (function (global) {
                (function () {
                    "use strict";
                    var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
                    var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
                    Object.defineProperty(exports, "__esModule", {
                        value: true
                    });
                    var _exportNames = {};
                    exports["default"] = void 0;
                    var matrixcs = _interopRequireWildcard(require("./matrix"));
                    Object.keys(matrixcs).forEach(function (key) {
                        if (key === "default" || key === "__esModule")
                            return;
                        if (Object.prototype.hasOwnProperty.call(_exportNames, key))
                            return;
                        if (key in exports && exports[key] === matrixcs[key])
                            return;
                        Object.defineProperty(exports, key, {
                            enumerable: true,
                            get: function get() {
                                return matrixcs[key];
                            }
                        });
                    });
                    var _browserRequest = _interopRequireDefault(require("browser-request"));
                    var _qs = _interopRequireDefault(require("qs"));
                    matrixcs.request(function (opts, fn) {
                        opts.qs = _qs["default"].stringify(opts.qs || {}, opts.qsStringifyOptions);
                        return (0, _browserRequest["default"])(opts, fn);
                    });
                    var indexedDB;
                    try {
                        indexedDB = global.indexedDB;
                    }
                    catch (e) { }
                    if (indexedDB) {
                        matrixcs.setCryptoStoreFactory(function () {
                            return new matrixcs.IndexedDBCryptoStore(indexedDB, "matrix-js-sdk:crypto");
                        });
                    }
                    var _default = matrixcs;
                    exports["default"] = _default;
                    global.matrixcs = matrixcs;
                }).call(this);
            }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, { "./matrix": 98, "@babel/runtime/helpers/interopRequireDefault": 12, "@babel/runtime/helpers/interopRequireWildcard": 13, "browser-request": 31, "qs": 40 }], 58: [function (require, module, exports) {
            (function (global) {
                (function () {
                    "use strict";
                    var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
                    var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
                    Object.defineProperty(exports, "__esModule", {
                        value: true
                    });
                    exports.MatrixClient = MatrixClient;
                    exports.CRYPTO_ENABLED = void 0;
                    var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
                    var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
                    var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
                    var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
                    var _url = _interopRequireDefault(require("url"));
                    var _events = require("events");
                    var _baseApis = require("./base-apis");
                    var _filter = require("./filter");
                    var _sync = require("./sync");
                    var _event2 = require("./models/event");
                    var _eventTimeline = require("./models/event-timeline");
                    var _searchResult = require("./models/search-result");
                    var _stub = require("./store/stub");
                    var _call = require("./webrtc/call");
                    var _callEventHandler = require("./webrtc/callEventHandler");
                    var utils = _interopRequireWildcard(require("./utils"));
                    var _httpApi = require("./http-api");
                    var _contentRepo = require("./content-repo");
                    var ContentHelpers = _interopRequireWildcard(require("./content-helpers"));
                    var olmlib = _interopRequireWildcard(require("./crypto/olmlib"));
                    var _ReEmitter = require("./ReEmitter");
                    var _RoomList = require("./crypto/RoomList");
                    var _logger = require("./logger");
                    var _crypto = require("./crypto");
                    var _recoverykey = require("./crypto/recoverykey");
                    var _key_passphrase = require("./crypto/key_passphrase");
                    var _randomstring = require("./randomstring");
                    var _pushprocessor = require("./pushprocessor");
                    var _user = require("./models/user");
                    var _autodiscovery = require("./autodiscovery");
                    var _dehydration = require("./crypto/dehydration");
                    function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
                        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                            if (it)
                                o = it;
                            var i = 0;
                            var F = function F() { };
                            return { s: F, n: function n() { if (i >= o.length)
                                    return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F };
                        }
                        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                    } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try {
                            if (!normalCompletion && it["return"] != null)
                                it["return"]();
                        }
                        finally {
                            if (didErr)
                                throw err;
                        } } }; }
                    function _unsupportedIterableToArray(o, minLen) { if (!o)
                        return; if (typeof o === "string")
                        return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor)
                        n = o.constructor.name; if (n === "Map" || n === "Set")
                        return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                        return _arrayLikeToArray(o, minLen); }
                    function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length)
                        len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) {
                        arr2[i] = arr[i];
                    } return arr2; }
                    var SCROLLBACK_DELAY_MS = 3000;
                    var CRYPTO_ENABLED = (0, _crypto.isCryptoAvailable)();
                    exports.CRYPTO_ENABLED = CRYPTO_ENABLED;
                    var CAPABILITIES_CACHE_MS = 21600000;
                    var TURN_CHECK_INTERVAL = 10 * 60 * 1000;
                    function keysFromRecoverySession(sessions, decryptionKey, roomId) {
                        var keys = [];
                        for (var _i = 0, _Object$entries = Object.entries(sessions); _i < _Object$entries.length; _i++) {
                            var _Object$entries$_i = (0, _slicedToArray2["default"])(_Object$entries[_i], 2), sessionId = _Object$entries$_i[0], sessionData = _Object$entries$_i[1];
                            try {
                                var decrypted = keyFromRecoverySession(sessionData, decryptionKey);
                                decrypted.session_id = sessionId;
                                decrypted.room_id = roomId;
                                keys.push(decrypted);
                            }
                            catch (e) {
                                _logger.logger.log("Failed to decrypt megolm session from backup", e);
                            }
                        }
                        return keys;
                    }
                    function keyFromRecoverySession(session, decryptionKey) {
                        return JSON.parse(decryptionKey.decrypt(session.session_data.ephemeral, session.session_data.mac, session.session_data.ciphertext));
                    }
                    function MatrixClient(opts) {
                        var _this = this;
                        opts.baseUrl = utils.ensureNoTrailingSlash(opts.baseUrl);
                        opts.idBaseUrl = utils.ensureNoTrailingSlash(opts.idBaseUrl);
                        _baseApis.MatrixBaseApis.call(this, opts);
                        this.olmVersion = null;
                        this.reEmitter = new _ReEmitter.ReEmitter(this);
                        this.usingExternalCrypto = opts.usingExternalCrypto;
                        this.store = opts.store || new _stub.StubStore();
                        this.deviceId = opts.deviceId || null;
                        var userId = opts.userId || null;
                        this.credentials = {
                            userId: userId
                        };
                        if (opts.deviceToImport) {
                            if (this.deviceId) {
                                _logger.logger.warn('not importing device because' + ' device ID is provided to constructor' + ' independently of exported data');
                            }
                            else if (this.credentials.userId) {
                                _logger.logger.warn('not importing device because' + ' user ID is provided to constructor' + ' independently of exported data');
                            }
                            else if (!opts.deviceToImport.deviceId) {
                                _logger.logger.warn('not importing device because no device ID in exported data');
                            }
                            else {
                                this.deviceId = opts.deviceToImport.deviceId;
                                this.credentials.userId = opts.deviceToImport.userId;
                                this._exportedOlmDeviceToImport = opts.deviceToImport.olmDevice;
                            }
                        }
                        else if (opts.pickleKey) {
                            this.pickleKey = opts.pickleKey;
                        }
                        this.scheduler = opts.scheduler;
                        if (this.scheduler) {
                            var self = this;
                            this.scheduler.setProcessFunction(function () {
                                var _ref = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee(eventToSend) {
                                    var room, res;
                                    return _regenerator["default"].wrap(function _callee$(_context) {
                                        while (1) {
                                            switch (_context.prev = _context.next) {
                                                case 0:
                                                    room = self.getRoom(eventToSend.getRoomId());
                                                    if (eventToSend.status !== _event2.EventStatus.SENDING) {
                                                        _updatePendingEventStatus(room, eventToSend, _event2.EventStatus.SENDING);
                                                    }
                                                    _context.next = 4;
                                                    return _sendEventHttpRequest(self, eventToSend);
                                                case 4:
                                                    res = _context.sent;
                                                    if (room) {
                                                        room.updatePendingEvent(eventToSend, _event2.EventStatus.SENT, res.event_id);
                                                    }
                                                    return _context.abrupt("return", res);
                                                case 7:
                                                case "end":
                                                    return _context.stop();
                                            }
                                        }
                                    }, _callee);
                                }));
                                return function (_x) {
                                    return _ref.apply(this, arguments);
                                };
                            }());
                        }
                        this.clientRunning = false;
                        var call = (0, _call.createNewMatrixCall)(this);
                        this._supportsVoip = false;
                        if (call) {
                            this._callEventHandler = new _callEventHandler.CallEventHandler(this);
                            this._supportsVoip = true;
                        }
                        else {
                            this._callEventHandler = null;
                        }
                        this._syncingRetry = null;
                        this._syncApi = null;
                        this._peekSync = null;
                        this._isGuest = false;
                        this._ongoingScrollbacks = {};
                        this.timelineSupport = Boolean(opts.timelineSupport);
                        this.urlPreviewCache = {};
                        this._notifTimelineSet = null;
                        this.unstableClientRelationAggregation = !!opts.unstableClientRelationAggregation;
                        this._crypto = null;
                        this._cryptoStore = opts.cryptoStore;
                        this._sessionStore = opts.sessionStore;
                        this._verificationMethods = opts.verificationMethods;
                        this._cryptoCallbacks = opts.cryptoCallbacks || {};
                        this._forceTURN = opts.forceTURN || false;
                        this._iceCandidatePoolSize = opts.iceCandidatePoolSize === undefined ? 0 : opts.iceCandidatePoolSize;
                        this._supportsCallTransfer = opts.supportsCallTransfer || false;
                        this._fallbackICEServerAllowed = opts.fallbackICEServerAllowed || false;
                        this._roomList = new _RoomList.RoomList(this._cryptoStore);
                        this._pushProcessor = new _pushprocessor.PushProcessor(this);
                        this._serverVersionsPromise = null;
                        this._cachedCapabilities = null;
                        this._clientWellKnown = undefined;
                        this._clientWellKnownPromise = undefined;
                        this._turnServers = [];
                        this._turnServersExpiry = 0;
                        this._checkTurnServersIntervalID = null;
                        this.on("Event.decrypted", function (event) {
                            var oldActions = event.getPushActions();
                            var actions = _this._pushProcessor.actionsForEvent(event);
                            event.setPushActions(actions);
                            var room = _this.getRoom(event.getRoomId());
                            if (!room)
                                return;
                            var currentCount = room.getUnreadNotificationCount("highlight");
                            var oldHighlight = oldActions && oldActions.tweaks ? !!oldActions.tweaks.highlight : false;
                            var newHighlight = actions && actions.tweaks ? !!actions.tweaks.highlight : false;
                            if (oldHighlight !== newHighlight || currentCount > 0) {
                                if (!room.hasUserReadEvent(_this.getUserId(), event.getId())) {
                                    var newCount = currentCount;
                                    if (newHighlight && !oldHighlight)
                                        newCount++;
                                    if (!newHighlight && oldHighlight)
                                        newCount--;
                                    room.setUnreadNotificationCount("highlight", newCount);
                                    var totalCount = room.getUnreadNotificationCount('total');
                                    if (totalCount < newCount) {
                                        room.setUnreadNotificationCount('total', newCount);
                                    }
                                }
                            }
                        });
                        this.on("Room.receipt", function (event, room) {
                            if (room && _this.isRoomEncrypted(room.roomId)) {
                                var content = event.getContent();
                                var isSelf = Object.keys(content).filter(function (eid) {
                                    return Object.keys(content[eid]['m.read']).includes(_this.getUserId());
                                }).length > 0;
                                if (!isSelf)
                                    return;
                                var maxHistory = 20;
                                var events = room.getLiveTimeline().getEvents();
                                var highlightCount = 0;
                                for (var i = events.length - 1; i >= 0; i--) {
                                    if (i === events.length - maxHistory)
                                        return;
                                    var _event = events[i];
                                    if (room.hasUserReadEvent(_this.getUserId(), _event.getId())) {
                                        break;
                                    }
                                    var pushActions = _this.getPushActionsForEvent(_event);
                                    highlightCount += pushActions.tweaks && pushActions.tweaks.highlight ? 1 : 0;
                                }
                                room.setUnreadNotificationCount("highlight", highlightCount);
                            }
                        });
                    }
                    utils.inherits(MatrixClient, _events.EventEmitter);
                    utils.extend(MatrixClient.prototype, _baseApis.MatrixBaseApis.prototype);
                    MatrixClient.prototype.rehydrateDevice = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee2() {
                        var getDeviceResult, account, deviceData, key, rehydrateResult, pickleKey;
                        return _regenerator["default"].wrap(function _callee2$(_context2) {
                            while (1) {
                                switch (_context2.prev = _context2.next) {
                                    case 0:
                                        if (!this._crypto) {
                                            _context2.next = 2;
                                            break;
                                        }
                                        throw new Error("Cannot rehydrate device after crypto is initialized");
                                    case 2:
                                        if (this._cryptoCallbacks.getDehydrationKey) {
                                            _context2.next = 4;
                                            break;
                                        }
                                        return _context2.abrupt("return");
                                    case 4:
                                        _context2.prev = 4;
                                        _context2.next = 7;
                                        return this._http.authedRequest(undefined, "GET", "/dehydrated_device", undefined, undefined, {
                                            prefix: "/_matrix/client/unstable/org.matrix.msc2697.v2"
                                        });
                                    case 7:
                                        getDeviceResult = _context2.sent;
                                        _context2.next = 14;
                                        break;
                                    case 10:
                                        _context2.prev = 10;
                                        _context2.t0 = _context2["catch"](4);
                                        _logger.logger.info("could not get dehydrated device", _context2.t0.toString());
                                        return _context2.abrupt("return");
                                    case 14:
                                        if (!(!getDeviceResult.device_data || !getDeviceResult.device_id)) {
                                            _context2.next = 17;
                                            break;
                                        }
                                        _logger.logger.info("no dehydrated device found");
                                        return _context2.abrupt("return");
                                    case 17:
                                        account = new global.Olm.Account();
                                        _context2.prev = 18;
                                        deviceData = getDeviceResult.device_data;
                                        if (!(deviceData.algorithm !== _dehydration.DEHYDRATION_ALGORITHM)) {
                                            _context2.next = 23;
                                            break;
                                        }
                                        _logger.logger.warn("Wrong algorithm for dehydrated device");
                                        return _context2.abrupt("return");
                                    case 23:
                                        _logger.logger.log("unpickling dehydrated device");
                                        _context2.next = 26;
                                        return this._cryptoCallbacks.getDehydrationKey(deviceData, function (k) {
                                            account.unpickle(new Uint8Array(k), deviceData.account);
                                        });
                                    case 26:
                                        key = _context2.sent;
                                        account.unpickle(key, deviceData.account);
                                        _logger.logger.log("unpickled device");
                                        _context2.next = 31;
                                        return this._http.authedRequest(undefined, "POST", "/dehydrated_device/claim", undefined, {
                                            device_id: getDeviceResult.device_id
                                        }, {
                                            prefix: "/_matrix/client/unstable/org.matrix.msc2697.v2"
                                        });
                                    case 31:
                                        rehydrateResult = _context2.sent;
                                        if (!(rehydrateResult.success === true)) {
                                            _context2.next = 41;
                                            break;
                                        }
                                        this.deviceId = getDeviceResult.device_id;
                                        _logger.logger.info("using dehydrated device");
                                        pickleKey = this.pickleKey || "DEFAULT_KEY";
                                        this._exportedOlmDeviceToImport = {
                                            pickledAccount: account.pickle(pickleKey),
                                            sessions: [],
                                            pickleKey: pickleKey
                                        };
                                        account.free();
                                        return _context2.abrupt("return", this.deviceId);
                                    case 41:
                                        account.free();
                                        _logger.logger.info("not using dehydrated device");
                                        return _context2.abrupt("return");
                                    case 44:
                                        _context2.next = 50;
                                        break;
                                    case 46:
                                        _context2.prev = 46;
                                        _context2.t1 = _context2["catch"](18);
                                        account.free();
                                        _logger.logger.warn("could not unpickle", _context2.t1);
                                    case 50:
                                    case "end":
                                        return _context2.stop();
                                }
                            }
                        }, _callee2, this, [[4, 10], [18, 46]]);
                    }));
                    MatrixClient.prototype.setDehydrationKey = function () {
                        var _ref3 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee3(key) {
                            var keyInfo, deviceDisplayName, _args3 = arguments;
                            return _regenerator["default"].wrap(function _callee3$(_context3) {
                                while (1) {
                                    switch (_context3.prev = _context3.next) {
                                        case 0:
                                            keyInfo = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {};
                                            deviceDisplayName = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : undefined;
                                            if (this._crypto) {
                                                _context3.next = 5;
                                                break;
                                            }
                                            _logger.logger.warn('not dehydrating device if crypto is not enabled');
                                            return _context3.abrupt("return");
                                        case 5:
                                            _context3.next = 7;
                                            return this._crypto._dehydrationManager.setKeyAndQueueDehydration(key, keyInfo, deviceDisplayName);
                                        case 7:
                                            return _context3.abrupt("return", _context3.sent);
                                        case 8:
                                        case "end":
                                            return _context3.stop();
                                    }
                                }
                            }, _callee3, this);
                        }));
                        return function (_x2) {
                            return _ref3.apply(this, arguments);
                        };
                    }();
                    MatrixClient.prototype.createDehydratedDevice = function () {
                        var _ref4 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee4(key) {
                            var keyInfo, deviceDisplayName, _args4 = arguments;
                            return _regenerator["default"].wrap(function _callee4$(_context4) {
                                while (1) {
                                    switch (_context4.prev = _context4.next) {
                                        case 0:
                                            keyInfo = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : {};
                                            deviceDisplayName = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : undefined;
                                            if (this._crypto) {
                                                _context4.next = 5;
                                                break;
                                            }
                                            _logger.logger.warn('not dehydrating device if crypto is not enabled');
                                            return _context4.abrupt("return");
                                        case 5:
                                            _context4.next = 7;
                                            return this._crypto._dehydrationManager.setKey(key, keyInfo, deviceDisplayName);
                                        case 7:
                                            _context4.next = 9;
                                            return this._crypto._dehydrationManager.dehydrateDevice();
                                        case 9:
                                            return _context4.abrupt("return", _context4.sent);
                                        case 10:
                                        case "end":
                                            return _context4.stop();
                                    }
                                }
                            }, _callee4, this);
                        }));
                        return function (_x3) {
                            return _ref4.apply(this, arguments);
                        };
                    }();
                    MatrixClient.prototype.exportDevice = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee5() {
                        return _regenerator["default"].wrap(function _callee5$(_context5) {
                            while (1) {
                                switch (_context5.prev = _context5.next) {
                                    case 0:
                                        if (this._crypto) {
                                            _context5.next = 3;
                                            break;
                                        }
                                        _logger.logger.warn('not exporting device if crypto is not enabled');
                                        return _context5.abrupt("return");
                                    case 3:
                                        _context5.t0 = this.credentials.userId;
                                        _context5.t1 = this.deviceId;
                                        _context5.next = 7;
                                        return this._crypto._olmDevice["export"]();
                                    case 7:
                                        _context5.t2 = _context5.sent;
                                        return _context5.abrupt("return", {
                                            userId: _context5.t0,
                                            deviceId: _context5.t1,
                                            olmDevice: _context5.t2
                                        });
                                    case 9:
                                    case "end":
                                        return _context5.stop();
                                }
                            }
                        }, _callee5, this);
                    }));
                    MatrixClient.prototype.clearStores = function () {
                        if (this._clientRunning) {
                            throw new Error("Cannot clear stores while client is running");
                        }
                        var promises = [];
                        promises.push(this.store.deleteAllData());
                        if (this._cryptoStore) {
                            promises.push(this._cryptoStore.deleteAllData());
                        }
                        return Promise.all(promises);
                    };
                    MatrixClient.prototype.getUserId = function () {
                        if (this.credentials && this.credentials.userId) {
                            return this.credentials.userId;
                        }
                        return null;
                    };
                    MatrixClient.prototype.getDomain = function () {
                        if (this.credentials && this.credentials.userId) {
                            return this.credentials.userId.replace(/^.*?:/, '');
                        }
                        return null;
                    };
                    MatrixClient.prototype.getUserIdLocalpart = function () {
                        if (this.credentials && this.credentials.userId) {
                            return this.credentials.userId.split(":")[0].substring(1);
                        }
                        return null;
                    };
                    MatrixClient.prototype.getDeviceId = function () {
                        return this.deviceId;
                    };
                    MatrixClient.prototype.supportsVoip = function () {
                        return this._supportsVoip;
                    };
                    MatrixClient.prototype.setForceTURN = function (forceTURN) {
                        this._forceTURN = forceTURN;
                    };
                    MatrixClient.prototype.setSupportsCallTransfer = function (supportsCallTransfer) {
                        this._supportsCallTransfer = supportsCallTransfer;
                    };
                    MatrixClient.prototype.getSyncState = function () {
                        if (!this._syncApi) {
                            return null;
                        }
                        return this._syncApi.getSyncState();
                    };
                    MatrixClient.prototype.getSyncStateData = function () {
                        if (!this._syncApi) {
                            return null;
                        }
                        return this._syncApi.getSyncStateData();
                    };
                    MatrixClient.prototype.isInitialSyncComplete = function () {
                        var state = this.getSyncState();
                        if (!state) {
                            return false;
                        }
                        return state === "PREPARED" || state === "SYNCING";
                    };
                    MatrixClient.prototype.isGuest = function () {
                        return this._isGuest;
                    };
                    MatrixClient.prototype.getScheduler = function () {
                        return this.scheduler;
                    };
                    MatrixClient.prototype.setGuest = function (isGuest) {
                        this._isGuest = isGuest;
                    };
                    MatrixClient.prototype.retryImmediately = function () {
                        return this._syncApi.retryImmediately();
                    };
                    MatrixClient.prototype.getNotifTimelineSet = function () {
                        return this._notifTimelineSet;
                    };
                    MatrixClient.prototype.setNotifTimelineSet = function (notifTimelineSet) {
                        this._notifTimelineSet = notifTimelineSet;
                    };
                    MatrixClient.prototype.getCapabilities = function () {
                        var _this2 = this;
                        var fresh = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
                        var now = new Date().getTime();
                        if (this._cachedCapabilities && !fresh) {
                            if (now < this._cachedCapabilities.expiration) {
                                _logger.logger.log("Returning cached capabilities");
                                return Promise.resolve(this._cachedCapabilities.capabilities);
                            }
                        }
                        return this._http.authedRequest(undefined, "GET", "/capabilities")["catch"](function (e) {
                            _logger.logger.error(e);
                            return null;
                        }).then(function (r) {
                            if (!r)
                                r = {};
                            var capabilities = r["capabilities"] || {};
                            var cacheMs = Object.keys(capabilities).length ? CAPABILITIES_CACHE_MS : 60000 + Math.random() * 5000;
                            _this2._cachedCapabilities = {
                                capabilities: capabilities,
                                expiration: now + cacheMs
                            };
                            _logger.logger.log("Caching capabilities: ", capabilities);
                            return capabilities;
                        });
                    };
                    MatrixClient.prototype.initCrypto = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee6() {
                        var userId, crypto;
                        return _regenerator["default"].wrap(function _callee6$(_context6) {
                            while (1) {
                                switch (_context6.prev = _context6.next) {
                                    case 0:
                                        if ((0, _crypto.isCryptoAvailable)()) {
                                            _context6.next = 2;
                                            break;
                                        }
                                        throw new Error("End-to-end encryption not supported in this js-sdk build: did " + "you remember to load the olm library?");
                                    case 2:
                                        if (!this._crypto) {
                                            _context6.next = 5;
                                            break;
                                        }
                                        _logger.logger.warn("Attempt to re-initialise e2e encryption on MatrixClient");
                                        return _context6.abrupt("return");
                                    case 5:
                                        if (this._sessionStore) {
                                            _context6.next = 7;
                                            break;
                                        }
                                        throw new Error("Cannot enable encryption: no sessionStore provided");
                                    case 7:
                                        if (this._cryptoStore) {
                                            _context6.next = 9;
                                            break;
                                        }
                                        throw new Error("Cannot enable encryption: no cryptoStore provided");
                                    case 9:
                                        _logger.logger.log("Crypto: Starting up crypto store...");
                                        _context6.next = 12;
                                        return this._cryptoStore.startup();
                                    case 12:
                                        _logger.logger.log("Crypto: initialising roomlist...");
                                        _context6.next = 15;
                                        return this._roomList.init();
                                    case 15:
                                        userId = this.getUserId();
                                        if (!(userId === null)) {
                                            _context6.next = 18;
                                            break;
                                        }
                                        throw new Error("Cannot enable encryption on MatrixClient with unknown userId: " + "ensure userId is passed in createClient().");
                                    case 18:
                                        if (!(this.deviceId === null)) {
                                            _context6.next = 20;
                                            break;
                                        }
                                        throw new Error("Cannot enable encryption on MatrixClient with unknown deviceId: " + "ensure deviceId is passed in createClient().");
                                    case 20:
                                        crypto = new _crypto.Crypto(this, this._sessionStore, userId, this.deviceId, this.store, this._cryptoStore, this._roomList, this._verificationMethods);
                                        this.reEmitter.reEmit(crypto, ["crypto.keyBackupFailed", "crypto.keyBackupSessionsRemaining", "crypto.roomKeyRequest", "crypto.roomKeyRequestCancellation", "crypto.warning", "crypto.devicesUpdated", "crypto.willUpdateDevices", "deviceVerificationChanged", "userTrustStatusChanged", "crossSigning.keysChanged"]);
                                        _logger.logger.log("Crypto: initialising crypto object...");
                                        _context6.next = 25;
                                        return crypto.init({
                                            exportedOlmDevice: this._exportedOlmDeviceToImport,
                                            pickleKey: this.pickleKey
                                        });
                                    case 25:
                                        delete this._exportedOlmDeviceToImport;
                                        this.olmVersion = _crypto.Crypto.getOlmVersion();
                                        crypto.registerEventHandlers(this);
                                        this._crypto = crypto;
                                    case 29:
                                    case "end":
                                        return _context6.stop();
                                }
                            }
                        }, _callee6, this);
                    }));
                    MatrixClient.prototype.isCryptoEnabled = function () {
                        return this._crypto !== null;
                    };
                    MatrixClient.prototype.getDeviceEd25519Key = function () {
                        if (!this._crypto) {
                            return null;
                        }
                        return this._crypto.getDeviceEd25519Key();
                    };
                    MatrixClient.prototype.getDeviceCurve25519Key = function () {
                        if (!this._crypto) {
                            return null;
                        }
                        return this._crypto.getDeviceCurve25519Key();
                    };
                    MatrixClient.prototype.uploadKeys = function () {
                        if (this._crypto === null) {
                            throw new Error("End-to-end encryption disabled");
                        }
                        return this._crypto.uploadDeviceKeys();
                    };
                    MatrixClient.prototype.downloadKeys = function (userIds, forceDownload) {
                        if (this._crypto === null) {
                            return Promise.reject(new Error("End-to-end encryption disabled"));
                        }
                        return this._crypto.downloadKeys(userIds, forceDownload);
                    };
                    MatrixClient.prototype.getStoredDevicesForUser = function (userId) {
                        if (this._crypto === null) {
                            throw new Error("End-to-end encryption disabled");
                        }
                        return this._crypto.getStoredDevicesForUser(userId) || [];
                    };
                    MatrixClient.prototype.getStoredDevice = function (userId, deviceId) {
                        if (this._crypto === null) {
                            throw new Error("End-to-end encryption disabled");
                        }
                        return this._crypto.getStoredDevice(userId, deviceId) || null;
                    };
                    MatrixClient.prototype.setDeviceVerified = function (userId, deviceId, verified) {
                        if (verified === undefined) {
                            verified = true;
                        }
                        var prom = _setDeviceVerification(this, userId, deviceId, verified, null);
                        if (userId == this.credentials.userId) {
                            this._crypto.checkKeyBackup();
                        }
                        return prom;
                    };
                    MatrixClient.prototype.setDeviceBlocked = function (userId, deviceId, blocked) {
                        if (blocked === undefined) {
                            blocked = true;
                        }
                        return _setDeviceVerification(this, userId, deviceId, null, blocked);
                    };
                    MatrixClient.prototype.setDeviceKnown = function (userId, deviceId, known) {
                        if (known === undefined) {
                            known = true;
                        }
                        return _setDeviceVerification(this, userId, deviceId, null, null, known);
                    };
                    function _setDeviceVerification(_x4, _x5, _x6, _x7, _x8, _x9) {
                        return _setDeviceVerification2.apply(this, arguments);
                    }
                    function _setDeviceVerification2() {
                        _setDeviceVerification2 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee36(client, userId, deviceId, verified, blocked, known) {
                            return _regenerator["default"].wrap(function _callee36$(_context36) {
                                while (1) {
                                    switch (_context36.prev = _context36.next) {
                                        case 0:
                                            if (client._crypto) {
                                                _context36.next = 2;
                                                break;
                                            }
                                            throw new Error("End-to-End encryption disabled");
                                        case 2:
                                            _context36.next = 4;
                                            return client._crypto.setDeviceVerification(userId, deviceId, verified, blocked, known);
                                        case 4:
                                        case "end":
                                            return _context36.stop();
                                    }
                                }
                            }, _callee36);
                        }));
                        return _setDeviceVerification2.apply(this, arguments);
                    }
                    MatrixClient.prototype.requestVerificationDM = function (userId, roomId) {
                        if (this._crypto === null) {
                            throw new Error("End-to-end encryption disabled");
                        }
                        return this._crypto.requestVerificationDM(userId, roomId);
                    };
                    MatrixClient.prototype.findVerificationRequestDMInProgress = function (roomId) {
                        if (this._crypto === null) {
                            throw new Error("End-to-end encryption disabled");
                        }
                        return this._crypto.findVerificationRequestDMInProgress(roomId);
                    };
                    MatrixClient.prototype.getVerificationRequestsToDeviceInProgress = function (userId) {
                        if (this._crypto === null) {
                            throw new Error("End-to-end encryption disabled");
                        }
                        return this._crypto.getVerificationRequestsToDeviceInProgress(userId);
                    };
                    MatrixClient.prototype.requestVerification = function (userId, devices) {
                        if (this._crypto === null) {
                            throw new Error("End-to-end encryption disabled");
                        }
                        return this._crypto.requestVerification(userId, devices);
                    };
                    MatrixClient.prototype.beginKeyVerification = function (method, userId, deviceId) {
                        if (this._crypto === null) {
                            throw new Error("End-to-end encryption disabled");
                        }
                        return this._crypto.beginKeyVerification(method, userId, deviceId);
                    };
                    MatrixClient.prototype.setGlobalBlacklistUnverifiedDevices = function (value) {
                        if (this._crypto === null) {
                            throw new Error("End-to-end encryption disabled");
                        }
                        this._crypto.setGlobalBlacklistUnverifiedDevices(value);
                    };
                    MatrixClient.prototype.getGlobalBlacklistUnverifiedDevices = function () {
                        if (this._crypto === null) {
                            throw new Error("End-to-end encryption disabled");
                        }
                        return this._crypto.getGlobalBlacklistUnverifiedDevices();
                    };
                    MatrixClient.prototype.setGlobalErrorOnUnknownDevices = function (value) {
                        if (this._crypto === null) {
                            throw new Error("End-to-end encryption disabled");
                        }
                        this._crypto.setGlobalErrorOnUnknownDevices(value);
                    };
                    MatrixClient.prototype.getGlobalErrorOnUnknownDevices = function () {
                        if (this._crypto === null) {
                            throw new Error("End-to-end encryption disabled");
                        }
                        return this._crypto.getGlobalErrorOnUnknownDevices();
                    };
                    function wrapCryptoFuncs(MatrixClient, names) {
                        var _iterator = _createForOfIteratorHelper(names), _step;
                        try {
                            var _loop = function _loop() {
                                var name = _step.value;
                                MatrixClient.prototype[name] = function () {
                                    var _this$_crypto;
                                    if (!this._crypto) {
                                        throw new Error("End-to-end encryption disabled");
                                    }
                                    return (_this$_crypto = this._crypto)[name].apply(_this$_crypto, arguments);
                                };
                            };
                            for (_iterator.s(); !(_step = _iterator.n()).done;) {
                                _loop();
                            }
                        }
                        catch (err) {
                            _iterator.e(err);
                        }
                        finally {
                            _iterator.f();
                        }
                    }
                    wrapCryptoFuncs(MatrixClient, ["getCrossSigningId", "getStoredCrossSigningForUser", "checkUserTrust", "checkDeviceTrust", "checkOwnCrossSigningTrust", "checkCrossSigningPrivateKey", "legacyDeviceVerification", "prepareToEncrypt", "isCrossSigningReady", "bootstrapCrossSigning", "getCryptoTrustCrossSignedDevices", "setCryptoTrustCrossSignedDevices", "countSessionsNeedingBackup"]);
                    wrapCryptoFuncs(MatrixClient, ["getEventEncryptionInfo", "createRecoveryKeyFromPassphrase", "isSecretStorageReady", "bootstrapSecretStorage", "addSecretStorageKey", "hasSecretStorageKey", "storeSecret", "getSecret", "isSecretStored", "requestSecret", "getDefaultSecretStorageKeyId", "setDefaultSecretStorageKeyId", "checkSecretStorageKey", "checkSecretStoragePrivateKey"]);
                    MatrixClient.prototype.getEventSenderDeviceInfo = function () {
                        var _ref7 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee7(event) {
                            return _regenerator["default"].wrap(function _callee7$(_context7) {
                                while (1) {
                                    switch (_context7.prev = _context7.next) {
                                        case 0:
                                            if (this._crypto) {
                                                _context7.next = 2;
                                                break;
                                            }
                                            return _context7.abrupt("return", null);
                                        case 2:
                                            return _context7.abrupt("return", this._crypto.getEventSenderDeviceInfo(event));
                                        case 3:
                                        case "end":
                                            return _context7.stop();
                                    }
                                }
                            }, _callee7, this);
                        }));
                        return function (_x10) {
                            return _ref7.apply(this, arguments);
                        };
                    }();
                    MatrixClient.prototype.isEventSenderVerified = function () {
                        var _ref8 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee8(event) {
                            var device;
                            return _regenerator["default"].wrap(function _callee8$(_context8) {
                                while (1) {
                                    switch (_context8.prev = _context8.next) {
                                        case 0:
                                            _context8.next = 2;
                                            return this.getEventSenderDeviceInfo(event);
                                        case 2:
                                            device = _context8.sent;
                                            if (device) {
                                                _context8.next = 5;
                                                break;
                                            }
                                            return _context8.abrupt("return", false);
                                        case 5:
                                            return _context8.abrupt("return", device.isVerified());
                                        case 6:
                                        case "end":
                                            return _context8.stop();
                                    }
                                }
                            }, _callee8, this);
                        }));
                        return function (_x11) {
                            return _ref8.apply(this, arguments);
                        };
                    }();
                    MatrixClient.prototype.cancelAndResendEventRoomKeyRequest = function (event) {
                        return event.cancelAndResendKeyRequest(this._crypto, this.getUserId());
                    };
                    MatrixClient.prototype.setRoomEncryption = function (roomId, config) {
                        if (!this._crypto) {
                            throw new Error("End-to-End encryption disabled");
                        }
                        return this._crypto.setRoomEncryption(roomId, config);
                    };
                    MatrixClient.prototype.isRoomEncrypted = function (roomId) {
                        var room = this.getRoom(roomId);
                        if (!room) {
                            return false;
                        }
                        var ev = room.currentState.getStateEvents("m.room.encryption", "");
                        if (ev) {
                            return true;
                        }
                        return this._roomList.isRoomEncrypted(roomId);
                    };
                    MatrixClient.prototype.forceDiscardSession = function (roomId) {
                        if (!this._crypto) {
                            throw new Error("End-to-End encryption disabled");
                        }
                        this._crypto.forceDiscardSession(roomId);
                    };
                    MatrixClient.prototype.exportRoomKeys = function () {
                        if (!this._crypto) {
                            return Promise.reject(new Error("End-to-end encryption disabled"));
                        }
                        return this._crypto.exportRoomKeys();
                    };
                    MatrixClient.prototype.importRoomKeys = function (keys, opts) {
                        if (!this._crypto) {
                            throw new Error("End-to-end encryption disabled");
                        }
                        return this._crypto.importRoomKeys(keys, opts);
                    };
                    MatrixClient.prototype.checkKeyBackup = function () {
                        return this._crypto.checkKeyBackup();
                    };
                    MatrixClient.prototype.getKeyBackupVersion = function () {
                        return this._http.authedRequest(undefined, "GET", "/room_keys/version", undefined, undefined, {
                            prefix: _httpApi.PREFIX_UNSTABLE
                        }).then(function (res) {
                            if (res.algorithm !== olmlib.MEGOLM_BACKUP_ALGORITHM) {
                                var _err = "Unknown backup algorithm: " + res.algorithm;
                                return Promise.reject(_err);
                            }
                            else if (!((0, _typeof2["default"])(res.auth_data) === "object") || !res.auth_data.public_key) {
                                var _err2 = "Invalid backup data returned";
                                return Promise.reject(_err2);
                            }
                            else {
                                return res;
                            }
                        })["catch"](function (e) {
                            if (e.errcode === 'M_NOT_FOUND') {
                                return null;
                            }
                            else {
                                throw e;
                            }
                        });
                    };
                    MatrixClient.prototype.isKeyBackupTrusted = function (info) {
                        return this._crypto.isKeyBackupTrusted(info);
                    };
                    MatrixClient.prototype.getKeyBackupEnabled = function () {
                        if (this._crypto === null) {
                            throw new Error("End-to-end encryption disabled");
                        }
                        if (!this._crypto._checkedForBackup) {
                            return null;
                        }
                        return Boolean(this._crypto.backupKey);
                    };
                    MatrixClient.prototype.enableKeyBackup = function (info) {
                        if (this._crypto === null) {
                            throw new Error("End-to-end encryption disabled");
                        }
                        this._crypto.backupInfo = info;
                        if (this._crypto.backupKey)
                            this._crypto.backupKey.free();
                        this._crypto.backupKey = new global.Olm.PkEncryption();
                        this._crypto.backupKey.set_recipient_key(info.auth_data.public_key);
                        this.emit('crypto.keyBackupStatus', true);
                        this._crypto.scheduleKeyBackupSend();
                    };
                    MatrixClient.prototype.disableKeyBackup = function () {
                        if (this._crypto === null) {
                            throw new Error("End-to-end encryption disabled");
                        }
                        this._crypto.backupInfo = null;
                        if (this._crypto.backupKey)
                            this._crypto.backupKey.free();
                        this._crypto.backupKey = null;
                        this.emit('crypto.keyBackupStatus', false);
                    };
                    MatrixClient.prototype.prepareKeyBackupVersion = function () {
                        var _ref9 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee9(password) {
                            var _ref10, _ref10$secureSecretSt, secureSecretStorage, _yield$this$createRec, keyInfo, encodedPrivateKey, privateKey, authData, _args9 = arguments;
                            return _regenerator["default"].wrap(function _callee9$(_context9) {
                                while (1) {
                                    switch (_context9.prev = _context9.next) {
                                        case 0:
                                            _ref10 = _args9.length > 1 && _args9[1] !== undefined ? _args9[1] : {}, _ref10$secureSecretSt = _ref10.secureSecretStorage, secureSecretStorage = _ref10$secureSecretSt === void 0 ? false : _ref10$secureSecretSt;
                                            if (!(this._crypto === null)) {
                                                _context9.next = 3;
                                                break;
                                            }
                                            throw new Error("End-to-end encryption disabled");
                                        case 3:
                                            _context9.next = 5;
                                            return this.createRecoveryKeyFromPassphrase(password);
                                        case 5:
                                            _yield$this$createRec = _context9.sent;
                                            keyInfo = _yield$this$createRec.keyInfo;
                                            encodedPrivateKey = _yield$this$createRec.encodedPrivateKey;
                                            privateKey = _yield$this$createRec.privateKey;
                                            if (!secureSecretStorage) {
                                                _context9.next = 13;
                                                break;
                                            }
                                            _context9.next = 12;
                                            return this.storeSecret("m.megolm_backup.v1", (0, olmlib.encodeBase64)(privateKey));
                                        case 12:
                                            _logger.logger.info("Key backup private key stored in secret storage");
                                        case 13:
                                            authData = {
                                                public_key: keyInfo.pubkey
                                            };
                                            if (keyInfo.passphrase) {
                                                authData.private_key_salt = keyInfo.passphrase.salt;
                                                authData.private_key_iterations = keyInfo.passphrase.iterations;
                                            }
                                            return _context9.abrupt("return", {
                                                algorithm: olmlib.MEGOLM_BACKUP_ALGORITHM,
                                                auth_data: authData,
                                                recovery_key: encodedPrivateKey
                                            });
                                        case 16:
                                        case "end":
                                            return _context9.stop();
                                    }
                                }
                            }, _callee9, this);
                        }));
                        return function (_x12) {
                            return _ref9.apply(this, arguments);
                        };
                    }();
                    MatrixClient.prototype.isKeyBackupKeyStored = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee10() {
                        return _regenerator["default"].wrap(function _callee10$(_context10) {
                            while (1) {
                                switch (_context10.prev = _context10.next) {
                                    case 0:
                                        return _context10.abrupt("return", this.isSecretStored("m.megolm_backup.v1", false));
                                    case 1:
                                    case "end":
                                        return _context10.stop();
                                }
                            }
                        }, _callee10, this);
                    }));
                    MatrixClient.prototype.createKeyBackupVersion = function () {
                        var _ref12 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee11(info) {
                            var data, res;
                            return _regenerator["default"].wrap(function _callee11$(_context11) {
                                while (1) {
                                    switch (_context11.prev = _context11.next) {
                                        case 0:
                                            if (!(this._crypto === null)) {
                                                _context11.next = 2;
                                                break;
                                            }
                                            throw new Error("End-to-end encryption disabled");
                                        case 2:
                                            data = {
                                                algorithm: info.algorithm,
                                                auth_data: info.auth_data
                                            };
                                            _context11.next = 5;
                                            return this._crypto._signObject(data.auth_data);
                                        case 5:
                                            if (!(this._cryptoCallbacks.getCrossSigningKey && this._crypto._crossSigningInfo.getId())) {
                                                _context11.next = 8;
                                                break;
                                            }
                                            _context11.next = 8;
                                            return this._crypto._crossSigningInfo.signObject(data.auth_data, "master");
                                        case 8:
                                            _context11.next = 10;
                                            return this._http.authedRequest(undefined, "POST", "/room_keys/version", undefined, data, {
                                                prefix: _httpApi.PREFIX_UNSTABLE
                                            });
                                        case 10:
                                            res = _context11.sent;
                                            _context11.next = 13;
                                            return this.checkKeyBackup();
                                        case 13:
                                            if (!this.getKeyBackupEnabled()) {
                                                _logger.logger.error("Key backup not usable even though we just created it");
                                            }
                                            return _context11.abrupt("return", res);
                                        case 15:
                                        case "end":
                                            return _context11.stop();
                                    }
                                }
                            }, _callee11, this);
                        }));
                        return function (_x13) {
                            return _ref12.apply(this, arguments);
                        };
                    }();
                    MatrixClient.prototype.deleteKeyBackupVersion = function (version) {
                        if (this._crypto === null) {
                            throw new Error("End-to-end encryption disabled");
                        }
                        if (this._crypto.backupInfo && this._crypto.backupInfo.version === version) {
                            this.disableKeyBackup();
                        }
                        var path = utils.encodeUri("/room_keys/version/$version", {
                            $version: version
                        });
                        return this._http.authedRequest(undefined, "DELETE", path, undefined, undefined, {
                            prefix: _httpApi.PREFIX_UNSTABLE
                        });
                    };
                    MatrixClient.prototype._makeKeyBackupPath = function (roomId, sessionId, version) {
                        var path;
                        if (sessionId !== undefined) {
                            path = utils.encodeUri("/room_keys/keys/$roomId/$sessionId", {
                                $roomId: roomId,
                                $sessionId: sessionId
                            });
                        }
                        else if (roomId !== undefined) {
                            path = utils.encodeUri("/room_keys/keys/$roomId", {
                                $roomId: roomId
                            });
                        }
                        else {
                            path = "/room_keys/keys";
                        }
                        var queryData = version === undefined ? undefined : {
                            version: version
                        };
                        return {
                            path: path,
                            queryData: queryData
                        };
                    };
                    MatrixClient.prototype.sendKeyBackup = function (roomId, sessionId, version, data) {
                        if (this._crypto === null) {
                            throw new Error("End-to-end encryption disabled");
                        }
                        var path = this._makeKeyBackupPath(roomId, sessionId, version);
                        return this._http.authedRequest(undefined, "PUT", path.path, path.queryData, data, {
                            prefix: _httpApi.PREFIX_UNSTABLE
                        });
                    };
                    MatrixClient.prototype.scheduleAllGroupSessionsForBackup = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee12() {
                        return _regenerator["default"].wrap(function _callee12$(_context12) {
                            while (1) {
                                switch (_context12.prev = _context12.next) {
                                    case 0:
                                        if (!(this._crypto === null)) {
                                            _context12.next = 2;
                                            break;
                                        }
                                        throw new Error("End-to-end encryption disabled");
                                    case 2:
                                        _context12.next = 4;
                                        return this._crypto.scheduleAllGroupSessionsForBackup();
                                    case 4:
                                    case "end":
                                        return _context12.stop();
                                }
                            }
                        }, _callee12, this);
                    }));
                    MatrixClient.prototype.flagAllGroupSessionsForBackup = function () {
                        if (this._crypto === null) {
                            throw new Error("End-to-end encryption disabled");
                        }
                        return this._crypto.flagAllGroupSessionsForBackup();
                    };
                    MatrixClient.prototype.isValidRecoveryKey = function (recoveryKey) {
                        try {
                            (0, _recoverykey.decodeRecoveryKey)(recoveryKey);
                            return true;
                        }
                        catch (e) {
                            return false;
                        }
                    };
                    MatrixClient.prototype.keyBackupKeyFromPassword = function (password, backupInfo) {
                        return (0, _key_passphrase.keyFromAuthData)(backupInfo.auth_data, password);
                    };
                    MatrixClient.prototype.keyBackupKeyFromRecoveryKey = function (recoveryKey) {
                        return (0, _recoverykey.decodeRecoveryKey)(recoveryKey);
                    };
                    MatrixClient.RESTORE_BACKUP_ERROR_BAD_KEY = 'RESTORE_BACKUP_ERROR_BAD_KEY';
                    MatrixClient.prototype.restoreKeyBackupWithPassword = function () {
                        var _ref14 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee13(password, targetRoomId, targetSessionId, backupInfo, opts) {
                            var privKey;
                            return _regenerator["default"].wrap(function _callee13$(_context13) {
                                while (1) {
                                    switch (_context13.prev = _context13.next) {
                                        case 0:
                                            _context13.next = 2;
                                            return (0, _key_passphrase.keyFromAuthData)(backupInfo.auth_data, password);
                                        case 2:
                                            privKey = _context13.sent;
                                            return _context13.abrupt("return", this._restoreKeyBackup(privKey, targetRoomId, targetSessionId, backupInfo, opts));
                                        case 4:
                                        case "end":
                                            return _context13.stop();
                                    }
                                }
                            }, _callee13, this);
                        }));
                        return function (_x14, _x15, _x16, _x17, _x18) {
                            return _ref14.apply(this, arguments);
                        };
                    }();
                    MatrixClient.prototype.restoreKeyBackupWithSecretStorage = function () {
                        var _ref15 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee14(backupInfo, targetRoomId, targetSessionId, opts) {
                            var storedKey, fixedKey, _yield$this$_crypto$g, _yield$this$_crypto$g2, keyId, privKey;
                            return _regenerator["default"].wrap(function _callee14$(_context14) {
                                while (1) {
                                    switch (_context14.prev = _context14.next) {
                                        case 0:
                                            _context14.next = 2;
                                            return this.getSecret("m.megolm_backup.v1");
                                        case 2:
                                            storedKey = _context14.sent;
                                            fixedKey = (0, _crypto.fixBackupKey)(storedKey);
                                            if (!fixedKey) {
                                                _context14.next = 12;
                                                break;
                                            }
                                            _context14.next = 7;
                                            return this._crypto.getSecretStorageKey();
                                        case 7:
                                            _yield$this$_crypto$g = _context14.sent;
                                            _yield$this$_crypto$g2 = (0, _slicedToArray2["default"])(_yield$this$_crypto$g, 1);
                                            keyId = _yield$this$_crypto$g2[0];
                                            _context14.next = 12;
                                            return this.storeSecret("m.megolm_backup.v1", fixedKey, [keyId]);
                                        case 12:
                                            privKey = (0, olmlib.decodeBase64)(fixedKey || storedKey);
                                            return _context14.abrupt("return", this._restoreKeyBackup(privKey, targetRoomId, targetSessionId, backupInfo, opts));
                                        case 14:
                                        case "end":
                                            return _context14.stop();
                                    }
                                }
                            }, _callee14, this);
                        }));
                        return function (_x19, _x20, _x21, _x22) {
                            return _ref15.apply(this, arguments);
                        };
                    }();
                    MatrixClient.prototype.restoreKeyBackupWithRecoveryKey = function (recoveryKey, targetRoomId, targetSessionId, backupInfo, opts) {
                        var privKey = (0, _recoverykey.decodeRecoveryKey)(recoveryKey);
                        return this._restoreKeyBackup(privKey, targetRoomId, targetSessionId, backupInfo, opts);
                    };
                    MatrixClient.prototype.restoreKeyBackupWithCache = function () {
                        var _ref16 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee15(targetRoomId, targetSessionId, backupInfo, opts) {
                            var privKey;
                            return _regenerator["default"].wrap(function _callee15$(_context15) {
                                while (1) {
                                    switch (_context15.prev = _context15.next) {
                                        case 0:
                                            _context15.next = 2;
                                            return this._crypto.getSessionBackupPrivateKey();
                                        case 2:
                                            privKey = _context15.sent;
                                            if (privKey) {
                                                _context15.next = 5;
                                                break;
                                            }
                                            throw new Error("Couldn't get key");
                                        case 5:
                                            return _context15.abrupt("return", this._restoreKeyBackup(privKey, targetRoomId, targetSessionId, backupInfo, opts));
                                        case 6:
                                        case "end":
                                            return _context15.stop();
                                    }
                                }
                            }, _callee15, this);
                        }));
                        return function (_x23, _x24, _x25, _x26) {
                            return _ref16.apply(this, arguments);
                        };
                    }();
                    MatrixClient.prototype._restoreKeyBackup = function (privKey, targetRoomId, targetSessionId, backupInfo) {
                        var _this3 = this;
                        var _ref17 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {}, cacheCompleteCallback = _ref17.cacheCompleteCallback, progressCallback = _ref17.progressCallback;
                        if (this._crypto === null) {
                            throw new Error("End-to-end encryption disabled");
                        }
                        var totalKeyCount = 0;
                        var keys = [];
                        var path = this._makeKeyBackupPath(targetRoomId, targetSessionId, backupInfo.version);
                        var decryption = new global.Olm.PkDecryption();
                        var backupPubKey;
                        try {
                            backupPubKey = decryption.init_with_private_key(privKey);
                        }
                        catch (e) {
                            decryption.free();
                            throw e;
                        }
                        if (backupPubKey !== backupInfo.auth_data.public_key) {
                            return Promise.reject({
                                errcode: MatrixClient.RESTORE_BACKUP_ERROR_BAD_KEY
                            });
                        }
                        this._crypto.storeSessionBackupPrivateKey(privKey)["catch"](function (e) {
                            _logger.logger.warn("Error caching session backup key:", e);
                        }).then(cacheCompleteCallback);
                        if (progressCallback) {
                            progressCallback({
                                stage: "fetch"
                            });
                        }
                        return this._http.authedRequest(undefined, "GET", path.path, path.queryData, undefined, {
                            prefix: _httpApi.PREFIX_UNSTABLE
                        }).then(function (res) {
                            if (res.rooms) {
                                for (var _i2 = 0, _Object$entries2 = Object.entries(res.rooms); _i2 < _Object$entries2.length; _i2++) {
                                    var _Object$entries2$_i = (0, _slicedToArray2["default"])(_Object$entries2[_i2], 2), roomId = _Object$entries2$_i[0], roomData = _Object$entries2$_i[1];
                                    if (!roomData.sessions)
                                        continue;
                                    totalKeyCount += Object.keys(roomData.sessions).length;
                                    var roomKeys = keysFromRecoverySession(roomData.sessions, decryption, roomId);
                                    var _iterator2 = _createForOfIteratorHelper(roomKeys), _step2;
                                    try {
                                        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                                            var k = _step2.value;
                                            k.room_id = roomId;
                                            keys.push(k);
                                        }
                                    }
                                    catch (err) {
                                        _iterator2.e(err);
                                    }
                                    finally {
                                        _iterator2.f();
                                    }
                                }
                            }
                            else if (res.sessions) {
                                totalKeyCount = Object.keys(res.sessions).length;
                                keys = keysFromRecoverySession(res.sessions, decryption, targetRoomId, keys);
                            }
                            else {
                                totalKeyCount = 1;
                                try {
                                    var key = keyFromRecoverySession(res, decryption);
                                    key.room_id = targetRoomId;
                                    key.session_id = targetSessionId;
                                    keys.push(key);
                                }
                                catch (e) {
                                    _logger.logger.log("Failed to decrypt megolm session from backup", e);
                                }
                            }
                            return _this3.importRoomKeys(keys, {
                                progressCallback: progressCallback,
                                untrusted: true,
                                source: "backup"
                            });
                        }).then(function () {
                            return _this3._crypto.setTrustedBackupPubKey(backupPubKey);
                        }).then(function () {
                            return {
                                total: totalKeyCount,
                                imported: keys.length
                            };
                        })["finally"](function () {
                            decryption.free();
                        });
                    };
                    MatrixClient.prototype.deleteKeysFromBackup = function (roomId, sessionId, version) {
                        if (this._crypto === null) {
                            throw new Error("End-to-end encryption disabled");
                        }
                        var path = this._makeKeyBackupPath(roomId, sessionId, version);
                        return this._http.authedRequest(undefined, "DELETE", path.path, path.queryData, undefined, {
                            prefix: _httpApi.PREFIX_UNSTABLE
                        });
                    };
                    MatrixClient.prototype.getGroup = function (groupId) {
                        return this.store.getGroup(groupId);
                    };
                    MatrixClient.prototype.getGroups = function () {
                        return this.store.getGroups();
                    };
                    MatrixClient.prototype.getMediaConfig = function (callback) {
                        return this._http.authedRequest(callback, "GET", "/config", undefined, undefined, {
                            prefix: _httpApi.PREFIX_MEDIA_R0
                        });
                    };
                    MatrixClient.prototype.getRoom = function (roomId) {
                        return this.store.getRoom(roomId);
                    };
                    MatrixClient.prototype.getRooms = function () {
                        return this.store.getRooms();
                    };
                    MatrixClient.prototype.getVisibleRooms = function () {
                        var allRooms = this.store.getRooms();
                        var replacedRooms = new Set();
                        var _iterator3 = _createForOfIteratorHelper(allRooms), _step3;
                        try {
                            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                                var r = _step3.value;
                                var createEvent = r.currentState.getStateEvents('m.room.create', '');
                                if (createEvent) {
                                    var predecessor = createEvent.getContent()['predecessor'];
                                    if (predecessor && predecessor['room_id']) {
                                        replacedRooms.add(predecessor['room_id']);
                                    }
                                }
                            }
                        }
                        catch (err) {
                            _iterator3.e(err);
                        }
                        finally {
                            _iterator3.f();
                        }
                        return allRooms.filter(function (r) {
                            var tombstone = r.currentState.getStateEvents('m.room.tombstone', '');
                            if (tombstone && replacedRooms.has(r.roomId)) {
                                return false;
                            }
                            return true;
                        });
                    };
                    MatrixClient.prototype.getUser = function (userId) {
                        return this.store.getUser(userId);
                    };
                    MatrixClient.prototype.getUsers = function () {
                        return this.store.getUsers();
                    };
                    MatrixClient.prototype.setAccountData = function (eventType, contents, callback) {
                        var _this4 = this;
                        var path = utils.encodeUri("/user/$userId/account_data/$type", {
                            $userId: this.credentials.userId,
                            $type: eventType
                        });
                        var promise = (0, _httpApi.retryNetworkOperation)(5, function () {
                            return _this4._http.authedRequest(undefined, "PUT", path, undefined, contents);
                        });
                        if (callback) {
                            promise.then(function (result) {
                                return callback(null, result);
                            }, callback);
                        }
                        return promise;
                    };
                    MatrixClient.prototype.getAccountData = function (eventType) {
                        return this.store.getAccountData(eventType);
                    };
                    MatrixClient.prototype.getAccountDataFromServer = function () {
                        var _ref18 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee16(eventType) {
                            var event, path, result;
                            return _regenerator["default"].wrap(function _callee16$(_context16) {
                                while (1) {
                                    switch (_context16.prev = _context16.next) {
                                        case 0:
                                            if (!this.isInitialSyncComplete()) {
                                                _context16.next = 5;
                                                break;
                                            }
                                            event = this.store.getAccountData(eventType);
                                            if (event) {
                                                _context16.next = 4;
                                                break;
                                            }
                                            return _context16.abrupt("return", null);
                                        case 4:
                                            return _context16.abrupt("return", event.getContent());
                                        case 5:
                                            path = utils.encodeUri("/user/$userId/account_data/$type", {
                                                $userId: this.credentials.userId,
                                                $type: eventType
                                            });
                                            _context16.prev = 6;
                                            _context16.next = 9;
                                            return this._http.authedRequest(undefined, "GET", path, undefined);
                                        case 9:
                                            result = _context16.sent;
                                            return _context16.abrupt("return", result);
                                        case 13:
                                            _context16.prev = 13;
                                            _context16.t0 = _context16["catch"](6);
                                            if (!(_context16.t0.data && _context16.t0.data.errcode === 'M_NOT_FOUND')) {
                                                _context16.next = 17;
                                                break;
                                            }
                                            return _context16.abrupt("return", null);
                                        case 17:
                                            throw _context16.t0;
                                        case 18:
                                        case "end":
                                            return _context16.stop();
                                    }
                                }
                            }, _callee16, this, [[6, 13]]);
                        }));
                        return function (_x27) {
                            return _ref18.apply(this, arguments);
                        };
                    }();
                    MatrixClient.prototype.getIgnoredUsers = function () {
                        var event = this.getAccountData("m.ignored_user_list");
                        if (!event || !event.getContent() || !event.getContent()["ignored_users"])
                            return [];
                        return Object.keys(event.getContent()["ignored_users"]);
                    };
                    MatrixClient.prototype.setIgnoredUsers = function (userIds, callback) {
                        var content = {
                            ignored_users: {}
                        };
                        userIds.map(function (u) {
                            return content.ignored_users[u] = {};
                        });
                        return this.setAccountData("m.ignored_user_list", content, callback);
                    };
                    MatrixClient.prototype.isUserIgnored = function (userId) {
                        return this.getIgnoredUsers().indexOf(userId) !== -1;
                    };
                    MatrixClient.prototype.joinRoom = function (roomIdOrAlias, opts, callback) {
                        if (utils.isFunction(opts)) {
                            throw new Error("Expected 'opts' object, got function.");
                        }
                        opts = opts || {};
                        if (opts.syncRoom === undefined) {
                            opts.syncRoom = true;
                        }
                        var room = this.getRoom(roomIdOrAlias);
                        if (room && room.hasMembershipState(this.credentials.userId, "join")) {
                            return Promise.resolve(room);
                        }
                        var sign_promise = Promise.resolve();
                        if (opts.inviteSignUrl) {
                            sign_promise = this._http.requestOtherUrl(undefined, 'POST', opts.inviteSignUrl, {
                                mxid: this.credentials.userId
                            });
                        }
                        var queryString = {};
                        if (opts.viaServers) {
                            queryString["server_name"] = opts.viaServers;
                        }
                        var reqOpts = {
                            qsStringifyOptions: {
                                arrayFormat: 'repeat'
                            }
                        };
                        var self = this;
                        var prom = new Promise(function (resolve, reject) {
                            sign_promise.then(function (signed_invite_object) {
                                var data = {};
                                if (signed_invite_object) {
                                    data.third_party_signed = signed_invite_object;
                                }
                                var path = utils.encodeUri("/join/$roomid", {
                                    $roomid: roomIdOrAlias
                                });
                                return self._http.authedRequest(undefined, "POST", path, queryString, data, reqOpts);
                            }).then(function (res) {
                                var roomId = res.room_id;
                                var syncApi = new _sync.SyncApi(self, self._clientOpts);
                                var room = syncApi.createRoom(roomId);
                                if (opts.syncRoom) {
                                }
                                return Promise.resolve(room);
                            }).then(function (room) {
                                _resolve(callback, resolve, room);
                            }, function (err) {
                                _reject(callback, reject, err);
                            });
                        });
                        return prom;
                    };
                    MatrixClient.prototype.resendEvent = function (event, room) {
                        _updatePendingEventStatus(room, event, _event2.EventStatus.SENDING);
                        return _sendEvent(this, room, event);
                    };
                    MatrixClient.prototype.cancelPendingEvent = function (event) {
                        if ([_event2.EventStatus.QUEUED, _event2.EventStatus.NOT_SENT].indexOf(event.status) < 0) {
                            throw new Error("cannot cancel an event with status " + event.status);
                        }
                        if (this.scheduler) {
                            this.scheduler.removeEventFromQueue(event);
                        }
                        var room = this.getRoom(event.getRoomId());
                        _updatePendingEventStatus(room, event, _event2.EventStatus.CANCELLED);
                    };
                    MatrixClient.prototype.setRoomName = function (roomId, name, callback) {
                        return this.sendStateEvent(roomId, "m.room.name", {
                            name: name
                        }, undefined, callback);
                    };
                    MatrixClient.prototype.setRoomTopic = function (roomId, topic, callback) {
                        return this.sendStateEvent(roomId, "m.room.topic", {
                            topic: topic
                        }, undefined, callback);
                    };
                    MatrixClient.prototype.getRoomTags = function (roomId, callback) {
                        var path = utils.encodeUri("/user/$userId/rooms/$roomId/tags/", {
                            $userId: this.credentials.userId,
                            $roomId: roomId
                        });
                        return this._http.authedRequest(callback, "GET", path, undefined);
                    };
                    MatrixClient.prototype.setRoomTag = function (roomId, tagName, metadata, callback) {
                        var path = utils.encodeUri("/user/$userId/rooms/$roomId/tags/$tag", {
                            $userId: this.credentials.userId,
                            $roomId: roomId,
                            $tag: tagName
                        });
                        return this._http.authedRequest(callback, "PUT", path, undefined, metadata);
                    };
                    MatrixClient.prototype.deleteRoomTag = function (roomId, tagName, callback) {
                        var path = utils.encodeUri("/user/$userId/rooms/$roomId/tags/$tag", {
                            $userId: this.credentials.userId,
                            $roomId: roomId,
                            $tag: tagName
                        });
                        return this._http.authedRequest(callback, "DELETE", path, undefined, undefined);
                    };
                    MatrixClient.prototype.setRoomAccountData = function (roomId, eventType, content, callback) {
                        var path = utils.encodeUri("/user/$userId/rooms/$roomId/account_data/$type", {
                            $userId: this.credentials.userId,
                            $roomId: roomId,
                            $type: eventType
                        });
                        return this._http.authedRequest(callback, "PUT", path, undefined, content);
                    };
                    MatrixClient.prototype.setPowerLevel = function (roomId, userId, powerLevel, event, callback) {
                        var content = {
                            users: {}
                        };
                        if (event && event.getType() === "m.room.power_levels") {
                            content = utils.deepCopy(event.getContent());
                        }
                        content.users[userId] = powerLevel;
                        var path = utils.encodeUri("/rooms/$roomId/state/m.room.power_levels", {
                            $roomId: roomId
                        });
                        return this._http.authedRequest(callback, "PUT", path, undefined, content);
                    };
                    MatrixClient.prototype.sendEvent = function (roomId, eventType, content, txnId, callback) {
                        return this._sendCompleteEvent(roomId, {
                            type: eventType,
                            content: content
                        }, txnId, callback);
                    };
                    MatrixClient.prototype._sendCompleteEvent = function (roomId, eventObject, txnId, callback) {
                        if (utils.isFunction(txnId)) {
                            callback = txnId;
                            txnId = undefined;
                        }
                        if (!txnId) {
                            txnId = this.makeTxnId();
                        }
                        var localEvent = new _event2.MatrixEvent(Object.assign(eventObject, {
                            event_id: "~" + roomId + ":" + txnId,
                            user_id: this.credentials.userId,
                            sender: this.credentials.userId,
                            room_id: roomId,
                            origin_server_ts: new Date().getTime()
                        }));
                        var room = this.getRoom(roomId);
                        var targetId = localEvent.getAssociatedId();
                        if (targetId && targetId.startsWith("~")) {
                            var target = room.getPendingEvents().find(function (e) {
                                return e.getId() === targetId;
                            });
                            target.once("Event.localEventIdReplaced", function () {
                                localEvent.updateAssociatedId(target.getId());
                            });
                        }
                        var type = localEvent.getType();
                        _logger.logger.log("sendEvent of type ".concat(type, " in ").concat(roomId, " with txnId ").concat(txnId));
                        localEvent.setTxnId(txnId);
                        localEvent.setStatus(_event2.EventStatus.SENDING);
                        if (room) {
                            room.addPendingEvent(localEvent, txnId);
                        }
                        if (localEvent.status === _event2.EventStatus.NOT_SENT) {
                            return Promise.reject(new Error("Event blocked by other events not yet sent"));
                        }
                        return _sendEvent(this, room, localEvent, callback);
                    };
                    function _sendEvent(client, room, event, callback) {
                        return Promise.resolve().then(function () {
                            var encryptionPromise = _encryptEventIfNeeded(client, event, room);
                            if (!encryptionPromise) {
                                return null;
                            }
                            _updatePendingEventStatus(room, event, _event2.EventStatus.ENCRYPTING);
                            return encryptionPromise.then(function () {
                                _updatePendingEventStatus(room, event, _event2.EventStatus.SENDING);
                            });
                        }).then(function () {
                            var promise;
                            if (client.scheduler) {
                                promise = client.scheduler.queueEvent(event);
                                if (promise && client.scheduler.getQueueForEvent(event).length > 1) {
                                    _updatePendingEventStatus(room, event, _event2.EventStatus.QUEUED);
                                }
                            }
                            if (!promise) {
                                promise = _sendEventHttpRequest(client, event);
                                if (room) {
                                    promise = promise.then(function (res) {
                                        room.updatePendingEvent(event, _event2.EventStatus.SENT, res.event_id);
                                        return res;
                                    });
                                }
                            }
                            return promise;
                        }).then(function (res) {
                            if (callback) {
                                callback(null, res);
                            }
                            return res;
                        }, function (err) {
                            _logger.logger.error("Error sending event", err.stack || err);
                            try {
                                event.error = err;
                                _updatePendingEventStatus(room, event, _event2.EventStatus.NOT_SENT);
                                err.event = event;
                                if (callback) {
                                    callback(err);
                                }
                            }
                            catch (err2) {
                                _logger.logger.error("Exception in error handler!", err2.stack || err);
                            }
                            throw err;
                        });
                    }
                    function _encryptEventIfNeeded(client, event, room) {
                        if (event.isEncrypted()) {
                            return null;
                        }
                        if (!client.isRoomEncrypted(event.getRoomId())) {
                            return null;
                        }
                        if (!client._crypto && client.usingExternalCrypto) {
                            return null;
                        }
                        if (event.getType() === "m.reaction") {
                            return null;
                        }
                        if (!client._crypto) {
                            throw new Error("This room is configured to use encryption, but your client does " + "not support encryption.");
                        }
                        return client._crypto.encryptEvent(event, room);
                    }
                    function _getEncryptedIfNeededEventType(client, roomId, eventType) {
                        if (eventType === "m.reaction") {
                            return eventType;
                        }
                        var isEncrypted = client.isRoomEncrypted(roomId);
                        return isEncrypted ? "m.room.encrypted" : eventType;
                    }
                    function _updatePendingEventStatus(room, event, newStatus) {
                        if (room) {
                            room.updatePendingEvent(event, newStatus);
                        }
                        else {
                            event.setStatus(newStatus);
                        }
                    }
                    function _sendEventHttpRequest(client, event) {
                        var txnId = event.getTxnId();
                        if (!txnId) {
                            txnId = client.makeTxnId();
                            event.setTxnId(txnId);
                        }
                        var pathParams = {
                            $roomId: event.getRoomId(),
                            $eventType: event.getWireType(),
                            $stateKey: event.getStateKey(),
                            $txnId: txnId
                        };
                        var path;
                        if (event.isState()) {
                            var pathTemplate = "/rooms/$roomId/state/$eventType";
                            if (event.getStateKey() && event.getStateKey().length > 0) {
                                pathTemplate = "/rooms/$roomId/state/$eventType/$stateKey";
                            }
                            path = utils.encodeUri(pathTemplate, pathParams);
                        }
                        else if (event.isRedaction()) {
                            var _pathTemplate = "/rooms/$roomId/redact/$redactsEventId/$txnId";
                            path = utils.encodeUri(_pathTemplate, Object.assign({
                                $redactsEventId: event.event.redacts
                            }, pathParams));
                        }
                        else {
                            path = utils.encodeUri("/rooms/$roomId/send/$eventType/$txnId", pathParams);
                        }
                        return client._http.authedRequest(undefined, "PUT", path, undefined, event.getWireContent()).then(function (res) {
                            _logger.logger.log("Event sent to ".concat(event.getRoomId(), " with event id ").concat(res.event_id));
                            return res;
                        });
                    }
                    MatrixClient.prototype.redactEvent = function (roomId, eventId, txnId, callbackOrOpts) {
                        var opts = (0, _typeof2["default"])(callbackOrOpts) === 'object' ? callbackOrOpts : {};
                        var reason = opts.reason;
                        var callback = typeof callbackOrOpts === 'function' ? callbackOrOpts : undefined;
                        return this._sendCompleteEvent(roomId, {
                            type: "m.room.redaction",
                            content: {
                                reason: reason
                            },
                            redacts: eventId
                        }, txnId, callback);
                    };
                    MatrixClient.prototype.sendMessage = function (roomId, content, txnId, callback) {
                        if (utils.isFunction(txnId)) {
                            callback = txnId;
                            txnId = undefined;
                        }
                        return this.sendEvent(roomId, "m.room.message", content, txnId, callback);
                    };
                    MatrixClient.prototype.sendTextMessage = function (roomId, body, txnId, callback) {
                        var content = ContentHelpers.makeTextMessage(body);
                        return this.sendMessage(roomId, content, txnId, callback);
                    };
                    MatrixClient.prototype.sendNotice = function (roomId, body, txnId, callback) {
                        var content = ContentHelpers.makeNotice(body);
                        return this.sendMessage(roomId, content, txnId, callback);
                    };
                    MatrixClient.prototype.sendEmoteMessage = function (roomId, body, txnId, callback) {
                        var content = ContentHelpers.makeEmoteMessage(body);
                        return this.sendMessage(roomId, content, txnId, callback);
                    };
                    MatrixClient.prototype.sendImageMessage = function (roomId, url, info, text, callback) {
                        if (utils.isFunction(text)) {
                            callback = text;
                            text = undefined;
                        }
                        if (!text) {
                            text = "Image";
                        }
                        var content = {
                            msgtype: "m.image",
                            url: url,
                            info: info,
                            body: text
                        };
                        return this.sendMessage(roomId, content, callback);
                    };
                    MatrixClient.prototype.sendStickerMessage = function (roomId, url, info, text, callback) {
                        if (utils.isFunction(text)) {
                            callback = text;
                            text = undefined;
                        }
                        if (!text) {
                            text = "Sticker";
                        }
                        var content = {
                            url: url,
                            info: info,
                            body: text
                        };
                        return this.sendEvent(roomId, "m.sticker", content, callback, undefined);
                    };
                    MatrixClient.prototype.sendHtmlMessage = function (roomId, body, htmlBody, callback) {
                        var content = ContentHelpers.makeHtmlMessage(body, htmlBody);
                        return this.sendMessage(roomId, content, callback);
                    };
                    MatrixClient.prototype.sendHtmlNotice = function (roomId, body, htmlBody, callback) {
                        var content = ContentHelpers.makeHtmlNotice(body, htmlBody);
                        return this.sendMessage(roomId, content, callback);
                    };
                    MatrixClient.prototype.sendHtmlEmote = function (roomId, body, htmlBody, callback) {
                        var content = ContentHelpers.makeHtmlEmote(body, htmlBody);
                        return this.sendMessage(roomId, content, callback);
                    };
                    MatrixClient.prototype.sendReceipt = function (event, receiptType, opts, callback) {
                        if (typeof opts === 'function') {
                            callback = opts;
                            opts = {};
                        }
                        if (this.isGuest()) {
                            return Promise.resolve({});
                        }
                        var path = utils.encodeUri("/rooms/$roomId/receipt/$receiptType/$eventId", {
                            $roomId: event.getRoomId(),
                            $receiptType: receiptType,
                            $eventId: event.getId()
                        });
                        var promise = this._http.authedRequest(callback, "POST", path, undefined, opts || {});
                        var room = this.getRoom(event.getRoomId());
                        if (room) {
                            room._addLocalEchoReceipt(this.credentials.userId, event, receiptType);
                        }
                        return promise;
                    };
                    MatrixClient.prototype.sendReadReceipt = function () {
                        var _ref19 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee17(event, opts, callback) {
                            var eventId, room, addlContent;
                            return _regenerator["default"].wrap(function _callee17$(_context17) {
                                while (1) {
                                    switch (_context17.prev = _context17.next) {
                                        case 0:
                                            if (typeof opts === 'function') {
                                                callback = opts;
                                                opts = {};
                                            }
                                            if (!opts)
                                                opts = {};
                                            eventId = event.getId();
                                            room = this.getRoom(event.getRoomId());
                                            if (!(room && room.hasPendingEvent(eventId))) {
                                                _context17.next = 6;
                                                break;
                                            }
                                            throw new Error("Cannot set read receipt to a pending event (".concat(eventId, ")"));
                                        case 6:
                                            addlContent = {
                                                "m.hidden": Boolean(opts.hidden)
                                            };
                                            return _context17.abrupt("return", this.sendReceipt(event, "m.read", addlContent, callback));
                                        case 8:
                                        case "end":
                                            return _context17.stop();
                                    }
                                }
                            }, _callee17, this);
                        }));
                        return function (_x28, _x29, _x30) {
                            return _ref19.apply(this, arguments);
                        };
                    }();
                    MatrixClient.prototype.setRoomReadMarkers = function () {
                        var _ref20 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee18(roomId, rmEventId, rrEvent, opts) {
                            var room, rrEventId;
                            return _regenerator["default"].wrap(function _callee18$(_context18) {
                                while (1) {
                                    switch (_context18.prev = _context18.next) {
                                        case 0:
                                            room = this.getRoom(roomId);
                                            if (!(room && room.hasPendingEvent(rmEventId))) {
                                                _context18.next = 3;
                                                break;
                                            }
                                            throw new Error("Cannot set read marker to a pending event (".concat(rmEventId, ")"));
                                        case 3:
                                            if (!rrEvent) {
                                                _context18.next = 8;
                                                break;
                                            }
                                            rrEventId = rrEvent.getId();
                                            if (!(room && room.hasPendingEvent(rrEventId))) {
                                                _context18.next = 7;
                                                break;
                                            }
                                            throw new Error("Cannot set read receipt to a pending event (".concat(rrEventId, ")"));
                                        case 7:
                                            if (room) {
                                                room._addLocalEchoReceipt(this.credentials.userId, rrEvent, "m.read");
                                            }
                                        case 8:
                                            return _context18.abrupt("return", this.setRoomReadMarkersHttpRequest(roomId, rmEventId, rrEventId, opts));
                                        case 9:
                                        case "end":
                                            return _context18.stop();
                                    }
                                }
                            }, _callee18, this);
                        }));
                        return function (_x31, _x32, _x33, _x34) {
                            return _ref20.apply(this, arguments);
                        };
                    }();
                    MatrixClient.prototype.getUrlPreview = function (url, ts, callback) {
                        ts = Math.floor(ts / 60000) * 60000;
                        var key = ts + "_" + url;
                        var cachedPreview = this.urlPreviewCache[key];
                        if (cachedPreview) {
                            if (callback) {
                                cachedPreview.then(callback)["catch"](callback);
                            }
                            return cachedPreview;
                        }
                        var resp = this._http.authedRequest(callback, "GET", "/preview_url", {
                            url: url,
                            ts: ts
                        }, undefined, {
                            prefix: _httpApi.PREFIX_MEDIA_R0
                        });
                        this.urlPreviewCache[key] = resp;
                        return resp;
                    };
                    MatrixClient.prototype.sendTyping = function (roomId, isTyping, timeoutMs, callback) {
                        if (this.isGuest()) {
                            return Promise.resolve({});
                        }
                        var path = utils.encodeUri("/rooms/$roomId/typing/$userId", {
                            $roomId: roomId,
                            $userId: this.credentials.userId
                        });
                        var data = {
                            typing: isTyping
                        };
                        if (isTyping) {
                            data.timeout = timeoutMs ? timeoutMs : 20000;
                        }
                        return this._http.authedRequest(callback, "PUT", path, undefined, data);
                    };
                    MatrixClient.prototype.getRoomUpgradeHistory = function (roomId) {
                        var verifyLinks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                        var currentRoom = this.getRoom(roomId);
                        if (!currentRoom)
                            return [];
                        var upgradeHistory = [currentRoom];
                        var createEvent = currentRoom.currentState.getStateEvents("m.room.create", "");
                        while (createEvent) {
                            _logger.logger.log("Looking at ".concat(createEvent.getId()));
                            var predecessor = createEvent.getContent()['predecessor'];
                            if (predecessor && predecessor['room_id']) {
                                _logger.logger.log("Looking at predecessor ".concat(predecessor['room_id']));
                                var refRoom = this.getRoom(predecessor['room_id']);
                                if (!refRoom)
                                    break;
                                if (verifyLinks) {
                                    var tombstone = refRoom.currentState.getStateEvents("m.room.tombstone", "");
                                    if (!tombstone || tombstone.getContent()['replacement_room'] !== refRoom.roomId) {
                                        break;
                                    }
                                }
                                upgradeHistory.splice(0, 0, refRoom);
                                createEvent = refRoom.currentState.getStateEvents("m.room.create", "");
                            }
                            else {
                                break;
                            }
                        }
                        var tombstoneEvent = currentRoom.currentState.getStateEvents("m.room.tombstone", "");
                        while (tombstoneEvent) {
                            var _refRoom = this.getRoom(tombstoneEvent.getContent()['replacement_room']);
                            if (!_refRoom)
                                break;
                            if (_refRoom.roomId === currentRoom.roomId)
                                break;
                            if (verifyLinks) {
                                createEvent = _refRoom.currentState.getStateEvents("m.room.create", "");
                                if (!createEvent || !createEvent.getContent()['predecessor'])
                                    break;
                                var _predecessor = createEvent.getContent()['predecessor'];
                                if (_predecessor['room_id'] !== currentRoom.roomId)
                                    break;
                            }
                            upgradeHistory.push(_refRoom);
                            var roomIds = new Set(upgradeHistory.map(function (ref) {
                                return ref.roomId;
                            }));
                            if (roomIds.size < upgradeHistory.length) {
                                return upgradeHistory.slice(0, upgradeHistory.length - 1);
                            }
                            currentRoom = _refRoom;
                            tombstoneEvent = currentRoom.currentState.getStateEvents("m.room.tombstone", "");
                        }
                        return upgradeHistory;
                    };
                    MatrixClient.prototype.invite = function (roomId, userId, callback, reason) {
                        return _membershipChange(this, roomId, userId, "invite", reason, callback);
                    };
                    MatrixClient.prototype.inviteByEmail = function (roomId, email, callback) {
                        return this.inviteByThreePid(roomId, "email", email, callback);
                    };
                    MatrixClient.prototype.inviteByThreePid = function () {
                        var _ref21 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee19(roomId, medium, address, callback) {
                            var path, identityServerUrl, params, identityAccessToken;
                            return _regenerator["default"].wrap(function _callee19$(_context19) {
                                while (1) {
                                    switch (_context19.prev = _context19.next) {
                                        case 0:
                                            path = utils.encodeUri("/rooms/$roomId/invite", {
                                                $roomId: roomId
                                            });
                                            identityServerUrl = this.getIdentityServerUrl(true);
                                            if (identityServerUrl) {
                                                _context19.next = 4;
                                                break;
                                            }
                                            return _context19.abrupt("return", Promise.reject(new _httpApi.MatrixError({
                                                error: "No supplied identity server URL",
                                                errcode: "ORG.MATRIX.JSSDK_MISSING_PARAM"
                                            })));
                                        case 4:
                                            params = {
                                                id_server: identityServerUrl,
                                                medium: medium,
                                                address: address
                                            };
                                            _context19.t0 = this.identityServer && this.identityServer.getAccessToken;
                                            if (!_context19.t0) {
                                                _context19.next = 10;
                                                break;
                                            }
                                            _context19.next = 9;
                                            return this.doesServerAcceptIdentityAccessToken();
                                        case 9:
                                            _context19.t0 = _context19.sent;
                                        case 10:
                                            if (!_context19.t0) {
                                                _context19.next = 15;
                                                break;
                                            }
                                            _context19.next = 13;
                                            return this.identityServer.getAccessToken();
                                        case 13:
                                            identityAccessToken = _context19.sent;
                                            if (identityAccessToken) {
                                                params.id_access_token = identityAccessToken;
                                            }
                                        case 15:
                                            return _context19.abrupt("return", this._http.authedRequest(callback, "POST", path, undefined, params));
                                        case 16:
                                        case "end":
                                            return _context19.stop();
                                    }
                                }
                            }, _callee19, this);
                        }));
                        return function (_x35, _x36, _x37, _x38) {
                            return _ref21.apply(this, arguments);
                        };
                    }();
                    MatrixClient.prototype.leave = function (roomId, callback) {
                        return _membershipChange(this, roomId, undefined, "leave", undefined, callback);
                    };
                    MatrixClient.prototype.leaveRoomChain = function (roomId) {
                        var _this5 = this;
                        var includeFuture = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
                        var upgradeHistory = this.getRoomUpgradeHistory(roomId);
                        var eligibleToLeave = upgradeHistory;
                        if (!includeFuture) {
                            eligibleToLeave = [];
                            var _iterator4 = _createForOfIteratorHelper(upgradeHistory), _step4;
                            try {
                                for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                                    var room = _step4.value;
                                    eligibleToLeave.push(room);
                                    if (room.roomId === roomId) {
                                        break;
                                    }
                                }
                            }
                            catch (err) {
                                _iterator4.e(err);
                            }
                            finally {
                                _iterator4.f();
                            }
                        }
                        var populationResults = {};
                        var promises = [];
                        var doLeave = function doLeave(roomId) {
                            return _this5.leave(roomId).then(function () {
                                populationResults[roomId] = null;
                            })["catch"](function (err) {
                                populationResults[roomId] = err;
                                return null;
                            });
                        };
                        var _iterator5 = _createForOfIteratorHelper(eligibleToLeave), _step5;
                        try {
                            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                                var _room = _step5.value;
                                promises.push(doLeave(_room.roomId));
                            }
                        }
                        catch (err) {
                            _iterator5.e(err);
                        }
                        finally {
                            _iterator5.f();
                        }
                        return Promise.all(promises).then(function () {
                            return populationResults;
                        });
                    };
                    MatrixClient.prototype.ban = function (roomId, userId, reason, callback) {
                        return _membershipChange(this, roomId, userId, "ban", reason, callback);
                    };
                    MatrixClient.prototype.forget = function (roomId, deleteRoom, callback) {
                        if (deleteRoom === undefined) {
                            deleteRoom = true;
                        }
                        var promise = _membershipChange(this, roomId, undefined, "forget", undefined, callback);
                        if (!deleteRoom) {
                            return promise;
                        }
                        var self = this;
                        return promise.then(function (response) {
                            self.store.removeRoom(roomId);
                            self.emit("deleteRoom", roomId);
                            return response;
                        });
                    };
                    MatrixClient.prototype.unban = function (roomId, userId, callback) {
                        var path = utils.encodeUri("/rooms/$roomId/unban", {
                            $roomId: roomId
                        });
                        var data = {
                            user_id: userId
                        };
                        return this._http.authedRequest(callback, "POST", path, undefined, data);
                    };
                    MatrixClient.prototype.kick = function (roomId, userId, reason, callback) {
                        return _setMembershipState(this, roomId, userId, "leave", reason, callback);
                    };
                    function _setMembershipState(client, roomId, userId, membershipValue, reason, callback) {
                        if (utils.isFunction(reason)) {
                            callback = reason;
                            reason = undefined;
                        }
                        var path = utils.encodeUri("/rooms/$roomId/state/m.room.member/$userId", {
                            $roomId: roomId,
                            $userId: userId
                        });
                        return client._http.authedRequest(callback, "PUT", path, undefined, {
                            membership: membershipValue,
                            reason: reason
                        });
                    }
                    function _membershipChange(client, roomId, userId, membership, reason, callback) {
                        if (utils.isFunction(reason)) {
                            callback = reason;
                            reason = undefined;
                        }
                        var path = utils.encodeUri("/rooms/$room_id/$membership", {
                            $room_id: roomId,
                            $membership: membership
                        });
                        return client._http.authedRequest(callback, "POST", path, undefined, {
                            user_id: userId,
                            reason: reason
                        });
                    }
                    MatrixClient.prototype.getPushActionsForEvent = function (event) {
                        if (!event.getPushActions()) {
                            event.setPushActions(this._pushProcessor.actionsForEvent(event));
                        }
                        return event.getPushActions();
                    };
                    MatrixClient.prototype.setProfileInfo = function (info, data, callback) {
                        var path = utils.encodeUri("/profile/$userId/$info", {
                            $userId: this.credentials.userId,
                            $info: info
                        });
                        return this._http.authedRequest(callback, "PUT", path, undefined, data);
                    };
                    MatrixClient.prototype.setDisplayName = function () {
                        var _ref22 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee20(name, callback) {
                            var prom, user;
                            return _regenerator["default"].wrap(function _callee20$(_context20) {
                                while (1) {
                                    switch (_context20.prev = _context20.next) {
                                        case 0:
                                            _context20.next = 2;
                                            return this.setProfileInfo("displayname", {
                                                displayname: name
                                            }, callback);
                                        case 2:
                                            prom = _context20.sent;
                                            user = this.getUser(this.getUserId());
                                            if (user) {
                                                user.displayName = name;
                                                user.emit("User.displayName", user.events.presence, user);
                                            }
                                            return _context20.abrupt("return", prom);
                                        case 6:
                                        case "end":
                                            return _context20.stop();
                                    }
                                }
                            }, _callee20, this);
                        }));
                        return function (_x39, _x40) {
                            return _ref22.apply(this, arguments);
                        };
                    }();
                    MatrixClient.prototype.setAvatarUrl = function () {
                        var _ref23 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee21(url, callback) {
                            var prom, user;
                            return _regenerator["default"].wrap(function _callee21$(_context21) {
                                while (1) {
                                    switch (_context21.prev = _context21.next) {
                                        case 0:
                                            _context21.next = 2;
                                            return this.setProfileInfo("avatar_url", {
                                                avatar_url: url
                                            }, callback);
                                        case 2:
                                            prom = _context21.sent;
                                            user = this.getUser(this.getUserId());
                                            if (user) {
                                                user.avatarUrl = url;
                                                user.emit("User.avatarUrl", user.events.presence, user);
                                            }
                                            return _context21.abrupt("return", prom);
                                        case 6:
                                        case "end":
                                            return _context21.stop();
                                    }
                                }
                            }, _callee21, this);
                        }));
                        return function (_x41, _x42) {
                            return _ref23.apply(this, arguments);
                        };
                    }();
                    MatrixClient.prototype.mxcUrlToHttp = function (mxcUrl, width, height, resizeMethod, allowDirectLinks) {
                        return (0, _contentRepo.getHttpUriForMxc)(this.baseUrl, mxcUrl, width, height, resizeMethod, allowDirectLinks);
                    };
                    MatrixClient.prototype._unstable_setStatusMessage = function (newMessage) {
                        var _this6 = this;
                        var type = "im.vector.user_status";
                        return Promise.all(this.getRooms().map(function (room) {
                            var isJoined = room.getMyMembership() === "join";
                            var looksLikeDm = room.getInvitedAndJoinedMemberCount() === 2;
                            if (!isJoined || !looksLikeDm) {
                                return Promise.resolve();
                            }
                            var maySend = room.currentState.mayClientSendStateEvent(type, _this6);
                            if (!maySend) {
                                return Promise.resolve();
                            }
                            return _this6.sendStateEvent(room.roomId, type, {
                                status: newMessage
                            }, _this6.getUserId());
                        }));
                    };
                    MatrixClient.prototype.setPresence = function (opts, callback) {
                        var path = utils.encodeUri("/presence/$userId/status", {
                            $userId: this.credentials.userId
                        });
                        if (typeof opts === "string") {
                            opts = {
                                presence: opts
                            };
                        }
                        var validStates = ["offline", "online", "unavailable"];
                        if (validStates.indexOf(opts.presence) == -1) {
                            throw new Error("Bad presence value: " + opts.presence);
                        }
                        return this._http.authedRequest(callback, "PUT", path, undefined, opts);
                    };
                    MatrixClient.prototype.getPresence = function (userId, callback) {
                        var path = utils.encodeUri("/presence/$userId/status", {
                            $userId: userId
                        });
                        return this._http.authedRequest(callback, "GET", path, undefined, undefined);
                    };
                    MatrixClient.prototype.scrollback = function (room, limit, callback) {
                        if (utils.isFunction(limit)) {
                            callback = limit;
                            limit = undefined;
                        }
                        limit = limit || 30;
                        var timeToWaitMs = 0;
                        var info = this._ongoingScrollbacks[room.roomId] || {};
                        if (info.promise) {
                            return info.promise;
                        }
                        else if (info.errorTs) {
                            var timeWaitedMs = Date.now() - info.errorTs;
                            timeToWaitMs = Math.max(SCROLLBACK_DELAY_MS - timeWaitedMs, 0);
                        }
                        if (room.oldState.paginationToken === null) {
                            return Promise.resolve(room);
                        }
                        var numAdded = this.store.scrollback(room, limit).length;
                        if (numAdded === limit) {
                            return Promise.resolve(room);
                        }
                        limit = limit - numAdded;
                        var self = this;
                        var prom = new Promise(function (resolve, reject) {
                            (0, utils.sleep)(timeToWaitMs).then(function () {
                                return self._createMessagesRequest(room.roomId, room.oldState.paginationToken, limit, 'b');
                            }).then(function (res) {
                                var matrixEvents = utils.map(res.chunk, _PojoToMatrixEventMapper(self));
                                if (res.state) {
                                    var stateEvents = utils.map(res.state, _PojoToMatrixEventMapper(self));
                                    room.currentState.setUnknownStateEvents(stateEvents);
                                }
                                room.addEventsToTimeline(matrixEvents, true, room.getLiveTimeline());
                                room.oldState.paginationToken = res.end;
                                if (res.chunk.length === 0) {
                                    room.oldState.paginationToken = null;
                                }
                                self.store.storeEvents(room, matrixEvents, res.end, true);
                                self._ongoingScrollbacks[room.roomId] = null;
                                _resolve(callback, resolve, room);
                            }, function (err) {
                                self._ongoingScrollbacks[room.roomId] = {
                                    errorTs: Date.now()
                                };
                                _reject(callback, reject, err);
                            });
                        });
                        info = {
                            promise: prom,
                            errorTs: null
                        };
                        this._ongoingScrollbacks[room.roomId] = info;
                        return prom;
                    };
                    MatrixClient.prototype.getEventTimeline = function (timelineSet, eventId) {
                        if (!this.timelineSupport) {
                            throw new Error("timeline support is disabled. Set the 'timelineSupport'" + " parameter to true when creating MatrixClient to enable" + " it.");
                        }
                        if (timelineSet.getTimelineForEvent(eventId)) {
                            return Promise.resolve(timelineSet.getTimelineForEvent(eventId));
                        }
                        var path = utils.encodeUri("/rooms/$roomId/context/$eventId", {
                            $roomId: timelineSet.room.roomId,
                            $eventId: eventId
                        });
                        var params = undefined;
                        if (this._clientOpts.lazyLoadMembers) {
                            params = {
                                filter: JSON.stringify(_filter.Filter.LAZY_LOADING_MESSAGES_FILTER)
                            };
                        }
                        var self = this;
                        var promise = self._http.authedRequest(undefined, "GET", path, params).then(function (res) {
                            if (!res.event) {
                                throw new Error("'event' not in '/context' result - homeserver too old?");
                            }
                            if (timelineSet.getTimelineForEvent(eventId)) {
                                return timelineSet.getTimelineForEvent(eventId);
                            }
                            res.events_after.reverse();
                            var events = res.events_after.concat([res.event]).concat(res.events_before);
                            var matrixEvents = utils.map(events, self.getEventMapper());
                            var timeline = timelineSet.getTimelineForEvent(matrixEvents[0].getId());
                            if (!timeline) {
                                timeline = timelineSet.addTimeline();
                                timeline.initialiseState(utils.map(res.state, self.getEventMapper()));
                                timeline.getState(_eventTimeline.EventTimeline.FORWARDS).paginationToken = res.end;
                            }
                            else {
                                var stateEvents = utils.map(res.state, self.getEventMapper());
                                timeline.getState(_eventTimeline.EventTimeline.BACKWARDS).setUnknownStateEvents(stateEvents);
                            }
                            timelineSet.addEventsToTimeline(matrixEvents, true, timeline, res.start);
                            var tl = timelineSet.getTimelineForEvent(eventId) || timeline;
                            return tl;
                        });
                        return promise;
                    };
                    MatrixClient.prototype._createMessagesRequest = function (roomId, fromToken, limit, dir) {
                        var timelineFilter = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;
                        var path = utils.encodeUri("/rooms/$roomId/messages", {
                            $roomId: roomId
                        });
                        if (limit === undefined) {
                            limit = 30;
                        }
                        var params = {
                            from: fromToken,
                            limit: limit,
                            dir: dir
                        };
                        var filter = null;
                        if (this._clientOpts.lazyLoadMembers) {
                            filter = Object.assign({}, _filter.Filter.LAZY_LOADING_MESSAGES_FILTER);
                        }
                        if (timelineFilter) {
                            filter = filter || {};
                            Object.assign(filter, timelineFilter.getRoomTimelineFilterComponent());
                        }
                        if (filter) {
                            params.filter = JSON.stringify(filter);
                        }
                        return this._http.authedRequest(undefined, "GET", path, params);
                    };
                    MatrixClient.prototype.paginateEventTimeline = function (eventTimeline, opts) {
                        var isNotifTimeline = eventTimeline.getTimelineSet() === this._notifTimelineSet;
                        opts = opts || {};
                        var backwards = opts.backwards || false;
                        if (isNotifTimeline) {
                            if (!backwards) {
                                throw new Error("paginateNotifTimeline can only paginate backwards");
                            }
                        }
                        var dir = backwards ? _eventTimeline.EventTimeline.BACKWARDS : _eventTimeline.EventTimeline.FORWARDS;
                        var token = eventTimeline.getPaginationToken(dir);
                        if (!token) {
                            return Promise.resolve(false);
                        }
                        var pendingRequest = eventTimeline._paginationRequests[dir];
                        if (pendingRequest) {
                            return pendingRequest;
                        }
                        var path;
                        var params;
                        var promise;
                        var self = this;
                        if (isNotifTimeline) {
                            path = "/notifications";
                            params = {
                                limit: 'limit' in opts ? opts.limit : 30,
                                only: 'highlight'
                            };
                            if (token && token !== "end") {
                                params.from = token;
                            }
                            promise = this._http.authedRequest(undefined, "GET", path, params, undefined).then(function (res) {
                                var token = res.next_token;
                                var matrixEvents = [];
                                for (var i = 0; i < res.notifications.length; i++) {
                                    var notification = res.notifications[i];
                                    var event = self.getEventMapper()(notification.event);
                                    event.setPushActions(_pushprocessor.PushProcessor.actionListToActionsObject(notification.actions));
                                    event.event.room_id = notification.room_id;
                                    matrixEvents[i] = event;
                                }
                                eventTimeline.getTimelineSet().addEventsToTimeline(matrixEvents, backwards, eventTimeline, token);
                                if (backwards && !res.next_token) {
                                    eventTimeline.setPaginationToken(null, dir);
                                }
                                return res.next_token ? true : false;
                            })["finally"](function () {
                                eventTimeline._paginationRequests[dir] = null;
                            });
                            eventTimeline._paginationRequests[dir] = promise;
                        }
                        else {
                            var room = this.getRoom(eventTimeline.getRoomId());
                            if (!room) {
                                throw new Error("Unknown room " + eventTimeline.getRoomId());
                            }
                            promise = this._createMessagesRequest(eventTimeline.getRoomId(), token, opts.limit, dir, eventTimeline.getFilter());
                            promise.then(function (res) {
                                if (res.state) {
                                    var roomState = eventTimeline.getState(dir);
                                    var stateEvents = utils.map(res.state, self.getEventMapper());
                                    roomState.setUnknownStateEvents(stateEvents);
                                }
                                var token = res.end;
                                var matrixEvents = utils.map(res.chunk, self.getEventMapper());
                                eventTimeline.getTimelineSet().addEventsToTimeline(matrixEvents, backwards, eventTimeline, token);
                                if (backwards && res.end == res.start) {
                                    eventTimeline.setPaginationToken(null, dir);
                                }
                                return res.end != res.start;
                            })["finally"](function () {
                                eventTimeline._paginationRequests[dir] = null;
                            });
                            eventTimeline._paginationRequests[dir] = promise;
                        }
                        return promise;
                    };
                    MatrixClient.prototype.resetNotifTimelineSet = function () {
                        if (!this._notifTimelineSet) {
                            return;
                        }
                        this._notifTimelineSet.resetLiveTimeline('end', null);
                    };
                    MatrixClient.prototype.peekInRoom = function (roomId) {
                        if (this._peekSync) {
                            this._peekSync.stopPeeking();
                        }
                        this._peekSync = new _sync.SyncApi(this, this._clientOpts);
                        return this._peekSync.peek(roomId);
                    };
                    MatrixClient.prototype.stopPeeking = function () {
                        if (this._peekSync) {
                            this._peekSync.stopPeeking();
                            this._peekSync = null;
                        }
                    };
                    MatrixClient.prototype.setGuestAccess = function (roomId, opts) {
                        var writePromise = this.sendStateEvent(roomId, "m.room.guest_access", {
                            guest_access: opts.allowJoin ? "can_join" : "forbidden"
                        });
                        var readPromise = Promise.resolve();
                        if (opts.allowRead) {
                            readPromise = this.sendStateEvent(roomId, "m.room.history_visibility", {
                                history_visibility: "world_readable"
                            });
                        }
                        return Promise.all([readPromise, writePromise]);
                    };
                    MatrixClient.prototype.requestRegisterEmailToken = function (email, clientSecret, sendAttempt, nextLink) {
                        return this._requestTokenFromEndpoint("/register/email/requestToken", {
                            email: email,
                            client_secret: clientSecret,
                            send_attempt: sendAttempt,
                            next_link: nextLink
                        });
                    };
                    MatrixClient.prototype.requestRegisterMsisdnToken = function (phoneCountry, phoneNumber, clientSecret, sendAttempt, nextLink) {
                        return this._requestTokenFromEndpoint("/register/msisdn/requestToken", {
                            country: phoneCountry,
                            phone_number: phoneNumber,
                            client_secret: clientSecret,
                            send_attempt: sendAttempt,
                            next_link: nextLink
                        });
                    };
                    MatrixClient.prototype.requestAdd3pidEmailToken = function (email, clientSecret, sendAttempt, nextLink) {
                        return this._requestTokenFromEndpoint("/account/3pid/email/requestToken", {
                            email: email,
                            client_secret: clientSecret,
                            send_attempt: sendAttempt,
                            next_link: nextLink
                        });
                    };
                    MatrixClient.prototype.requestAdd3pidMsisdnToken = function (phoneCountry, phoneNumber, clientSecret, sendAttempt, nextLink) {
                        return this._requestTokenFromEndpoint("/account/3pid/msisdn/requestToken", {
                            country: phoneCountry,
                            phone_number: phoneNumber,
                            client_secret: clientSecret,
                            send_attempt: sendAttempt,
                            next_link: nextLink
                        });
                    };
                    MatrixClient.prototype.requestPasswordEmailToken = function (email, clientSecret, sendAttempt, nextLink) {
                        return this._requestTokenFromEndpoint("/account/password/email/requestToken", {
                            email: email,
                            client_secret: clientSecret,
                            send_attempt: sendAttempt,
                            next_link: nextLink
                        });
                    };
                    MatrixClient.prototype.requestPasswordMsisdnToken = function (phoneCountry, phoneNumber, clientSecret, sendAttempt, nextLink) {
                        return this._requestTokenFromEndpoint("/account/password/msisdn/requestToken", {
                            country: phoneCountry,
                            phone_number: phoneNumber,
                            client_secret: clientSecret,
                            send_attempt: sendAttempt,
                            next_link: nextLink
                        });
                    };
                    MatrixClient.prototype._requestTokenFromEndpoint = function () {
                        var _ref24 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee22(endpoint, params) {
                            var postParams, idServerUrl, identityAccessToken;
                            return _regenerator["default"].wrap(function _callee22$(_context22) {
                                while (1) {
                                    switch (_context22.prev = _context22.next) {
                                        case 0:
                                            postParams = Object.assign({}, params);
                                            _context22.next = 3;
                                            return this.doesServerSupportSeparateAddAndBind();
                                        case 3:
                                            _context22.t0 = !_context22.sent;
                                            if (!_context22.t0) {
                                                _context22.next = 6;
                                                break;
                                            }
                                            _context22.t0 = this.idBaseUrl;
                                        case 6:
                                            if (!_context22.t0) {
                                                _context22.next = 21;
                                                break;
                                            }
                                            idServerUrl = _url["default"].parse(this.idBaseUrl);
                                            if (idServerUrl.host) {
                                                _context22.next = 10;
                                                break;
                                            }
                                            throw new Error("Invalid ID server URL: " + this.idBaseUrl);
                                        case 10:
                                            postParams.id_server = idServerUrl.host;
                                            _context22.t1 = this.identityServer && this.identityServer.getAccessToken;
                                            if (!_context22.t1) {
                                                _context22.next = 16;
                                                break;
                                            }
                                            _context22.next = 15;
                                            return this.doesServerAcceptIdentityAccessToken();
                                        case 15:
                                            _context22.t1 = _context22.sent;
                                        case 16:
                                            if (!_context22.t1) {
                                                _context22.next = 21;
                                                break;
                                            }
                                            _context22.next = 19;
                                            return this.identityServer.getAccessToken();
                                        case 19:
                                            identityAccessToken = _context22.sent;
                                            if (identityAccessToken) {
                                                postParams.id_access_token = identityAccessToken;
                                            }
                                        case 21:
                                            return _context22.abrupt("return", this._http.request(undefined, "POST", endpoint, undefined, postParams));
                                        case 22:
                                        case "end":
                                            return _context22.stop();
                                    }
                                }
                            }, _callee22, this);
                        }));
                        return function (_x43, _x44) {
                            return _ref24.apply(this, arguments);
                        };
                    }();
                    MatrixClient.prototype.getRoomPushRule = function (scope, roomId) {
                        if (this.pushRules) {
                            for (var i = 0; i < this.pushRules[scope].room.length; i++) {
                                var rule = this.pushRules[scope].room[i];
                                if (rule.rule_id === roomId) {
                                    return rule;
                                }
                            }
                        }
                        else {
                            throw new Error("SyncApi.sync() must be done before accessing to push rules.");
                        }
                    };
                    MatrixClient.prototype.setRoomMutePushRule = function (scope, roomId, mute) {
                        var self = this;
                        var deferred;
                        var hasDontNotifyRule;
                        var roomPushRule = this.getRoomPushRule(scope, roomId);
                        if (roomPushRule) {
                            if (0 <= roomPushRule.actions.indexOf("dont_notify")) {
                                hasDontNotifyRule = true;
                            }
                        }
                        if (!mute) {
                            if (hasDontNotifyRule) {
                                deferred = this.deletePushRule(scope, "room", roomPushRule.rule_id);
                            }
                        }
                        else {
                            if (!roomPushRule) {
                                deferred = this.addPushRule(scope, "room", roomId, {
                                    actions: ["dont_notify"]
                                });
                            }
                            else if (!hasDontNotifyRule) {
                                deferred = utils.defer();
                                this.deletePushRule(scope, "room", roomPushRule.rule_id).then(function () {
                                    self.addPushRule(scope, "room", roomId, {
                                        actions: ["dont_notify"]
                                    }).then(function () {
                                        deferred.resolve();
                                    }, function (err) {
                                        deferred.reject(err);
                                    });
                                }, function (err) {
                                    deferred.reject(err);
                                });
                                deferred = deferred.promise;
                            }
                        }
                        if (deferred) {
                            return new Promise(function (resolve, reject) {
                                deferred.then(function () {
                                    self.getPushRules().then(function (result) {
                                        self.pushRules = result;
                                        resolve();
                                    }, function (err) {
                                        reject(err);
                                    });
                                }, function (err) {
                                    self.getPushRules().then(function (result) {
                                        self.pushRules = result;
                                        reject(err);
                                    }, function (err2) {
                                        reject(err);
                                    });
                                });
                            });
                        }
                    };
                    MatrixClient.prototype.searchMessageText = function (opts, callback) {
                        var roomEvents = {
                            search_term: opts.query
                        };
                        if ('keys' in opts) {
                            roomEvents.keys = opts.keys;
                        }
                        return this.search({
                            body: {
                                search_categories: {
                                    room_events: roomEvents
                                }
                            }
                        }, callback);
                    };
                    MatrixClient.prototype.searchRoomEvents = function (opts) {
                        var body = {
                            search_categories: {
                                room_events: {
                                    search_term: opts.term,
                                    filter: opts.filter,
                                    order_by: "recent",
                                    event_context: {
                                        before_limit: 1,
                                        after_limit: 1,
                                        include_profile: true
                                    }
                                }
                            }
                        };
                        var searchResults = {
                            _query: body,
                            results: [],
                            highlights: []
                        };
                        return this.search({
                            body: body
                        }).then(this._processRoomEventsSearch.bind(this, searchResults));
                    };
                    MatrixClient.prototype.backPaginateRoomEventsSearch = function (searchResults) {
                        if (!searchResults.next_batch) {
                            return Promise.reject(new Error("Cannot backpaginate event search any further"));
                        }
                        if (searchResults.pendingRequest) {
                            return searchResults.pendingRequest;
                        }
                        var searchOpts = {
                            body: searchResults._query,
                            next_batch: searchResults.next_batch
                        };
                        var promise = this.search(searchOpts).then(this._processRoomEventsSearch.bind(this, searchResults))["finally"](function () {
                            searchResults.pendingRequest = null;
                        });
                        searchResults.pendingRequest = promise;
                        return promise;
                    };
                    MatrixClient.prototype._processRoomEventsSearch = function (searchResults, response) {
                        var room_events = response.search_categories.room_events;
                        searchResults.count = room_events.count;
                        searchResults.next_batch = room_events.next_batch;
                        var highlights = {};
                        room_events.highlights.forEach(function (hl) {
                            highlights[hl] = 1;
                        });
                        searchResults.highlights.forEach(function (hl) {
                            highlights[hl] = 1;
                        });
                        searchResults.highlights = Object.keys(highlights);
                        for (var i = 0; i < room_events.results.length; i++) {
                            var sr = _searchResult.SearchResult.fromJson(room_events.results[i], this.getEventMapper());
                            searchResults.results.push(sr);
                        }
                        return searchResults;
                    };
                    MatrixClient.prototype.syncLeftRooms = function () {
                        if (this._syncedLeftRooms) {
                            return Promise.resolve([]);
                        }
                        if (this._syncLeftRoomsPromise) {
                            return this._syncLeftRoomsPromise;
                        }
                        var self = this;
                        var syncApi = new _sync.SyncApi(this, this._clientOpts);
                        this._syncLeftRoomsPromise = syncApi.syncLeftRooms();
                        this._syncLeftRoomsPromise.then(function (res) {
                            _logger.logger.log("Marking success of sync left room request");
                            self._syncedLeftRooms = true;
                        })["finally"](function () {
                            self._syncLeftRoomsPromise = null;
                        });
                        return this._syncLeftRoomsPromise;
                    };
                    MatrixClient.prototype.createFilter = function (content) {
                        var self = this;
                        var path = utils.encodeUri("/user/$userId/filter", {
                            $userId: this.credentials.userId
                        });
                        return this._http.authedRequest(undefined, "POST", path, undefined, content).then(function (response) {
                            var filter = _filter.Filter.fromJson(self.credentials.userId, response.filter_id, content);
                            self.store.storeFilter(filter);
                            return filter;
                        });
                    };
                    MatrixClient.prototype.getFilter = function (userId, filterId, allowCached) {
                        if (allowCached) {
                            var filter = this.store.getFilter(userId, filterId);
                            if (filter) {
                                return Promise.resolve(filter);
                            }
                        }
                        var self = this;
                        var path = utils.encodeUri("/user/$userId/filter/$filterId", {
                            $userId: userId,
                            $filterId: filterId
                        });
                        return this._http.authedRequest(undefined, "GET", path, undefined, undefined).then(function (response) {
                            var filter = _filter.Filter.fromJson(userId, filterId, response);
                            self.store.storeFilter(filter);
                            return filter;
                        });
                    };
                    MatrixClient.prototype.getOrCreateFilter = function () {
                        var _ref25 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee23(filterName, filter) {
                            var filterId, existingId, existingFilter, oldDef, newDef, createdFilter;
                            return _regenerator["default"].wrap(function _callee23$(_context23) {
                                while (1) {
                                    switch (_context23.prev = _context23.next) {
                                        case 0:
                                            filterId = this.store.getFilterIdByName(filterName);
                                            existingId = undefined;
                                            if (!filterId) {
                                                _context23.next = 15;
                                                break;
                                            }
                                            _context23.prev = 3;
                                            _context23.next = 6;
                                            return this.getFilter(this.credentials.userId, filterId, true);
                                        case 6:
                                            existingFilter = _context23.sent;
                                            if (existingFilter) {
                                                oldDef = existingFilter.getDefinition();
                                                newDef = filter.getDefinition();
                                                if (utils.deepCompare(oldDef, newDef)) {
                                                    existingId = filterId;
                                                }
                                            }
                                            _context23.next = 14;
                                            break;
                                        case 10:
                                            _context23.prev = 10;
                                            _context23.t0 = _context23["catch"](3);
                                            if (!(_context23.t0.errcode !== "M_UNKNOWN" && _context23.t0.errcode !== "M_NOT_FOUND")) {
                                                _context23.next = 14;
                                                break;
                                            }
                                            throw _context23.t0;
                                        case 14:
                                            if (!existingId) {
                                                this.store.setFilterIdByName(filterName, undefined);
                                            }
                                        case 15:
                                            if (!existingId) {
                                                _context23.next = 17;
                                                break;
                                            }
                                            return _context23.abrupt("return", existingId);
                                        case 17:
                                            _context23.next = 19;
                                            return this.createFilter(filter.getDefinition());
                                        case 19:
                                            createdFilter = _context23.sent;
                                            this.store.setFilterIdByName(filterName, createdFilter.filterId);
                                            return _context23.abrupt("return", createdFilter.filterId);
                                        case 22:
                                        case "end":
                                            return _context23.stop();
                                    }
                                }
                            }, _callee23, this, [[3, 10]]);
                        }));
                        return function (_x45, _x46) {
                            return _ref25.apply(this, arguments);
                        };
                    }();
                    MatrixClient.prototype.getOpenIdToken = function () {
                        var path = utils.encodeUri("/user/$userId/openid/request_token", {
                            $userId: this.credentials.userId
                        });
                        return this._http.authedRequest(undefined, "POST", path, undefined, {});
                    };
                    MatrixClient.prototype.turnServer = function (callback) {
                        return this._http.authedRequest(callback, "GET", "/voip/turnServer");
                    };
                    MatrixClient.prototype.getTurnServers = function () {
                        return this._turnServers || [];
                    };
                    MatrixClient.prototype.getTurnServersExpiry = function () {
                        return this._turnServersExpiry;
                    };
                    MatrixClient.prototype._checkTurnServers = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee24() {
                        var credentialsGood, remainingTime, res, servers;
                        return _regenerator["default"].wrap(function _callee24$(_context24) {
                            while (1) {
                                switch (_context24.prev = _context24.next) {
                                    case 0:
                                        if (this._supportsVoip) {
                                            _context24.next = 2;
                                            break;
                                        }
                                        return _context24.abrupt("return");
                                    case 2:
                                        credentialsGood = false;
                                        remainingTime = this._turnServersExpiry - Date.now();
                                        if (!(remainingTime > TURN_CHECK_INTERVAL)) {
                                            _context24.next = 9;
                                            break;
                                        }
                                        _logger.logger.debug("TURN creds are valid for another " + remainingTime + " ms: not fetching new ones.");
                                        credentialsGood = true;
                                        _context24.next = 21;
                                        break;
                                    case 9:
                                        _logger.logger.debug("Fetching new TURN credentials");
                                        _context24.prev = 10;
                                        _context24.next = 13;
                                        return this.turnServer();
                                    case 13:
                                        res = _context24.sent;
                                        if (res.uris) {
                                            _logger.logger.log("Got TURN URIs: " + res.uris + " refresh in " + res.ttl + " secs");
                                            servers = {
                                                urls: res.uris,
                                                username: res.username,
                                                credential: res.password
                                            };
                                            this._turnServers = [servers];
                                            this._turnServersExpiry = Date.now() + res.ttl * 1000;
                                            credentialsGood = true;
                                        }
                                        _context24.next = 21;
                                        break;
                                    case 17:
                                        _context24.prev = 17;
                                        _context24.t0 = _context24["catch"](10);
                                        _logger.logger.error("Failed to get TURN URIs", _context24.t0);
                                        if (_context24.t0.httpStatus === 403) {
                                            _logger.logger.info("TURN access unavailable for this account: stopping credentials checks");
                                            if (this._checkTurnServersIntervalID !== null)
                                                global.clearInterval(this._checkTurnServersIntervalID);
                                            this._checkTurnServersIntervalID = null;
                                        }
                                    case 21:
                                        return _context24.abrupt("return", credentialsGood);
                                    case 22:
                                    case "end":
                                        return _context24.stop();
                                }
                            }
                        }, _callee24, this, [[10, 17]]);
                    }));
                    MatrixClient.prototype.setFallbackICEServerAllowed = function (allow) {
                        this._fallbackICEServerAllowed = allow;
                    };
                    MatrixClient.prototype.isFallbackICEServerAllowed = function () {
                        return this._fallbackICEServerAllowed;
                    };
                    MatrixClient.prototype.isSynapseAdministrator = function () {
                        var path = utils.encodeUri("/_synapse/admin/v1/users/$userId/admin", {
                            $userId: this.getUserId()
                        });
                        return this._http.authedRequest(undefined, 'GET', path, undefined, undefined, {
                            prefix: ''
                        }).then(function (r) {
                            return r['admin'];
                        });
                    };
                    MatrixClient.prototype.whoisSynapseUser = function (userId) {
                        var path = utils.encodeUri("/_synapse/admin/v1/whois/$userId", {
                            $userId: userId
                        });
                        return this._http.authedRequest(undefined, 'GET', path, undefined, undefined, {
                            prefix: ''
                        });
                    };
                    MatrixClient.prototype.deactivateSynapseUser = function (userId) {
                        var path = utils.encodeUri("/_synapse/admin/v1/deactivate/$userId", {
                            $userId: userId
                        });
                        return this._http.authedRequest(undefined, 'POST', path, undefined, undefined, {
                            prefix: ''
                        });
                    };
                    MatrixClient.prototype.startClient = function () {
                        var _ref27 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee25(opts) {
                            var _this7 = this;
                            var userId;
                            return _regenerator["default"].wrap(function _callee25$(_context25) {
                                while (1) {
                                    switch (_context25.prev = _context25.next) {
                                        case 0:
                                            if (!this.clientRunning) {
                                                _context25.next = 2;
                                                break;
                                            }
                                            return _context25.abrupt("return");
                                        case 2:
                                            this.clientRunning = true;
                                            if (typeof opts === "number") {
                                                opts = {
                                                    initialSyncLimit: opts
                                                };
                                            }
                                            userId = this.getUserId();
                                            if (userId) {
                                                this.store.storeUser(new _user.User(userId));
                                            }
                                            if (this._crypto) {
                                                this._crypto.uploadDeviceKeys();
                                                this._crypto.start();
                                            }
                                            if (this._supportsVoip) {
                                                this._checkTurnServersIntervalID = setInterval(function () {
                                                    _this7._checkTurnServers();
                                                }, TURN_CHECK_INTERVAL);
                                                this._checkTurnServers();
                                            }
                                            if (this._syncApi) {
                                                _logger.logger.error("Still have sync object whilst not running: stopping old one");
                                                this._syncApi.stop();
                                            }
                                            opts = Object.assign({}, opts);
                                            opts.crypto = this._crypto;
                                            opts.canResetEntireTimeline = function (roomId) {
                                                if (!_this7._canResetTimelineCallback) {
                                                    return false;
                                                }
                                                return _this7._canResetTimelineCallback(roomId);
                                            };
                                            this._clientOpts = opts;
                                            this._syncApi = new _sync.SyncApi(this, opts);
                                            this._syncApi.sync();
                                            if (opts.clientWellKnownPollPeriod !== undefined) {
                                                this._clientWellKnownIntervalID = setInterval(function () {
                                                    _this7._fetchClientWellKnown();
                                                }, 1000 * opts.clientWellKnownPollPeriod);
                                                this._fetchClientWellKnown();
                                            }
                                        case 16:
                                        case "end":
                                            return _context25.stop();
                                    }
                                }
                            }, _callee25, this);
                        }));
                        return function (_x47) {
                            return _ref27.apply(this, arguments);
                        };
                    }();
                    MatrixClient.prototype._fetchClientWellKnown = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee26() {
                        return _regenerator["default"].wrap(function _callee26$(_context26) {
                            while (1) {
                                switch (_context26.prev = _context26.next) {
                                    case 0:
                                        this._clientWellKnownPromise = _autodiscovery.AutoDiscovery.getRawClientConfig(this.getDomain());
                                        _context26.next = 3;
                                        return this._clientWellKnownPromise;
                                    case 3:
                                        this._clientWellKnown = _context26.sent;
                                        this.emit("WellKnown.client", this._clientWellKnown);
                                    case 5:
                                    case "end":
                                        return _context26.stop();
                                }
                            }
                        }, _callee26, this);
                    }));
                    MatrixClient.prototype.getClientWellKnown = function () {
                        return this._clientWellKnown;
                    };
                    MatrixClient.prototype.waitForClientWellKnown = function () {
                        return this._clientWellKnownPromise;
                    };
                    MatrixClient.prototype._storeClientOptions = function () {
                        var primTypes = ["boolean", "string", "number"];
                        var serializableOpts = Object.entries(this._clientOpts).filter(function (_ref29) {
                            var _ref30 = (0, _slicedToArray2["default"])(_ref29, 2), key = _ref30[0], value = _ref30[1];
                            return primTypes.includes((0, _typeof2["default"])(value));
                        }).reduce(function (obj, _ref31) {
                            var _ref32 = (0, _slicedToArray2["default"])(_ref31, 2), key = _ref32[0], value = _ref32[1];
                            obj[key] = value;
                            return obj;
                        }, {});
                        return this.store.storeClientOptions(serializableOpts);
                    };
                    MatrixClient.prototype._unstable_getSharedRooms = function () {
                        var _ref33 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee27(userId) {
                            var path, res;
                            return _regenerator["default"].wrap(function _callee27$(_context27) {
                                while (1) {
                                    switch (_context27.prev = _context27.next) {
                                        case 0:
                                            _context27.next = 2;
                                            return this.doesServerSupportUnstableFeature("uk.half-shot.msc2666");
                                        case 2:
                                            if (_context27.sent) {
                                                _context27.next = 4;
                                                break;
                                            }
                                            throw Error('Server does not support shared_rooms API');
                                        case 4:
                                            path = utils.encodeUri("/uk.half-shot.msc2666/user/shared_rooms/$userId", {
                                                $userId: userId
                                            });
                                            _context27.next = 7;
                                            return this._http.authedRequest(undefined, "GET", path, undefined, undefined, {
                                                prefix: _httpApi.PREFIX_UNSTABLE
                                            });
                                        case 7:
                                            res = _context27.sent;
                                            return _context27.abrupt("return", res.joined);
                                        case 9:
                                        case "end":
                                            return _context27.stop();
                                    }
                                }
                            }, _callee27, this);
                        }));
                        return function (_x48) {
                            return _ref33.apply(this, arguments);
                        };
                    }();
                    MatrixClient.prototype.stopClient = function () {
                        _logger.logger.log('stopping MatrixClient');
                        this.clientRunning = false;
                        if (this._syncApi) {
                            this._syncApi.stop();
                            this._syncApi = null;
                        }
                        if (this._crypto) {
                            this._crypto.stop();
                        }
                        if (this._peekSync) {
                            this._peekSync.stopPeeking();
                        }
                        if (this._callEventHandler) {
                            this._callEventHandler.stop();
                            this._callEventHandler = null;
                        }
                        global.clearInterval(this._checkTurnServersIntervalID);
                        if (this._clientWellKnownIntervalID !== undefined) {
                            global.clearInterval(this._clientWellKnownIntervalID);
                        }
                    };
                    MatrixClient.prototype.getVersions = function () {
                        var _this8 = this;
                        if (this._serverVersionsPromise) {
                            return this._serverVersionsPromise;
                        }
                        this._serverVersionsPromise = this._http.request(undefined, "GET", "/_matrix/client/versions", undefined, undefined, {
                            prefix: ''
                        })["catch"](function (e) {
                            _this8._serverVersionsPromise = null;
                            throw e;
                        });
                        return this._serverVersionsPromise;
                    };
                    MatrixClient.prototype.isVersionSupported = function () {
                        var _ref34 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee28(version) {
                            var _yield$this$getVersio, versions;
                            return _regenerator["default"].wrap(function _callee28$(_context28) {
                                while (1) {
                                    switch (_context28.prev = _context28.next) {
                                        case 0:
                                            _context28.next = 2;
                                            return this.getVersions();
                                        case 2:
                                            _yield$this$getVersio = _context28.sent;
                                            versions = _yield$this$getVersio.versions;
                                            return _context28.abrupt("return", versions && versions.includes(version));
                                        case 5:
                                        case "end":
                                            return _context28.stop();
                                    }
                                }
                            }, _callee28, this);
                        }));
                        return function (_x49) {
                            return _ref34.apply(this, arguments);
                        };
                    }();
                    MatrixClient.prototype.doesServerSupportLazyLoading = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee29() {
                        var response, versions, unstableFeatures;
                        return _regenerator["default"].wrap(function _callee29$(_context29) {
                            while (1) {
                                switch (_context29.prev = _context29.next) {
                                    case 0:
                                        _context29.next = 2;
                                        return this.getVersions();
                                    case 2:
                                        response = _context29.sent;
                                        if (response) {
                                            _context29.next = 5;
                                            break;
                                        }
                                        return _context29.abrupt("return", false);
                                    case 5:
                                        versions = response["versions"];
                                        unstableFeatures = response["unstable_features"];
                                        return _context29.abrupt("return", versions && versions.includes("r0.5.0") || unstableFeatures && unstableFeatures["m.lazy_load_members"]);
                                    case 8:
                                    case "end":
                                        return _context29.stop();
                                }
                            }
                        }, _callee29, this);
                    }));
                    MatrixClient.prototype.doesServerRequireIdServerParam = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee30() {
                        var response, versions, unstableFeatures;
                        return _regenerator["default"].wrap(function _callee30$(_context30) {
                            while (1) {
                                switch (_context30.prev = _context30.next) {
                                    case 0:
                                        _context30.next = 2;
                                        return this.getVersions();
                                    case 2:
                                        response = _context30.sent;
                                        if (response) {
                                            _context30.next = 5;
                                            break;
                                        }
                                        return _context30.abrupt("return", true);
                                    case 5:
                                        versions = response["versions"];
                                        if (!(versions && versions.includes("r0.6.0"))) {
                                            _context30.next = 8;
                                            break;
                                        }
                                        return _context30.abrupt("return", false);
                                    case 8:
                                        unstableFeatures = response["unstable_features"];
                                        if (unstableFeatures) {
                                            _context30.next = 11;
                                            break;
                                        }
                                        return _context30.abrupt("return", true);
                                    case 11:
                                        if (!(unstableFeatures["m.require_identity_server"] === undefined)) {
                                            _context30.next = 15;
                                            break;
                                        }
                                        return _context30.abrupt("return", true);
                                    case 15:
                                        return _context30.abrupt("return", unstableFeatures["m.require_identity_server"]);
                                    case 16:
                                    case "end":
                                        return _context30.stop();
                                }
                            }
                        }, _callee30, this);
                    }));
                    MatrixClient.prototype.doesServerAcceptIdentityAccessToken = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee31() {
                        var response, versions, unstableFeatures;
                        return _regenerator["default"].wrap(function _callee31$(_context31) {
                            while (1) {
                                switch (_context31.prev = _context31.next) {
                                    case 0:
                                        _context31.next = 2;
                                        return this.getVersions();
                                    case 2:
                                        response = _context31.sent;
                                        if (response) {
                                            _context31.next = 5;
                                            break;
                                        }
                                        return _context31.abrupt("return", false);
                                    case 5:
                                        versions = response["versions"];
                                        unstableFeatures = response["unstable_features"];
                                        return _context31.abrupt("return", versions && versions.includes("r0.6.0") || unstableFeatures && unstableFeatures["m.id_access_token"]);
                                    case 8:
                                    case "end":
                                        return _context31.stop();
                                }
                            }
                        }, _callee31, this);
                    }));
                    MatrixClient.prototype.doesServerSupportSeparateAddAndBind = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee32() {
                        var response, versions, unstableFeatures;
                        return _regenerator["default"].wrap(function _callee32$(_context32) {
                            while (1) {
                                switch (_context32.prev = _context32.next) {
                                    case 0:
                                        _context32.next = 2;
                                        return this.getVersions();
                                    case 2:
                                        response = _context32.sent;
                                        if (response) {
                                            _context32.next = 5;
                                            break;
                                        }
                                        return _context32.abrupt("return", false);
                                    case 5:
                                        versions = response["versions"];
                                        unstableFeatures = response["unstable_features"];
                                        return _context32.abrupt("return", versions && versions.includes("r0.6.0") || unstableFeatures && unstableFeatures["m.separate_add_and_bind"]);
                                    case 8:
                                    case "end":
                                        return _context32.stop();
                                }
                            }
                        }, _callee32, this);
                    }));
                    MatrixClient.prototype.doesServerSupportUnstableFeature = function () {
                        var _ref39 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee33(feature) {
                            var response, unstableFeatures;
                            return _regenerator["default"].wrap(function _callee33$(_context33) {
                                while (1) {
                                    switch (_context33.prev = _context33.next) {
                                        case 0:
                                            _context33.next = 2;
                                            return this.getVersions();
                                        case 2:
                                            response = _context33.sent;
                                            if (response) {
                                                _context33.next = 5;
                                                break;
                                            }
                                            return _context33.abrupt("return", false);
                                        case 5:
                                            unstableFeatures = response["unstable_features"];
                                            return _context33.abrupt("return", unstableFeatures && !!unstableFeatures[feature]);
                                        case 7:
                                        case "end":
                                            return _context33.stop();
                                    }
                                }
                            }, _callee33, this);
                        }));
                        return function (_x50) {
                            return _ref39.apply(this, arguments);
                        };
                    }();
                    MatrixClient.prototype.doesServerForceEncryptionForPreset = function () {
                        var _ref40 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee34(presetName) {
                            var response, unstableFeatures;
                            return _regenerator["default"].wrap(function _callee34$(_context34) {
                                while (1) {
                                    switch (_context34.prev = _context34.next) {
                                        case 0:
                                            _context34.next = 2;
                                            return this.getVersions();
                                        case 2:
                                            response = _context34.sent;
                                            if (response) {
                                                _context34.next = 5;
                                                break;
                                            }
                                            return _context34.abrupt("return", false);
                                        case 5:
                                            unstableFeatures = response["unstable_features"];
                                            return _context34.abrupt("return", unstableFeatures && !!unstableFeatures["io.element.e2ee_forced.".concat(presetName)]);
                                        case 7:
                                        case "end":
                                            return _context34.stop();
                                    }
                                }
                            }, _callee34, this);
                        }));
                        return function (_x51) {
                            return _ref40.apply(this, arguments);
                        };
                    }();
                    MatrixClient.prototype.hasLazyLoadMembersEnabled = function () {
                        return !!this._clientOpts.lazyLoadMembers;
                    };
                    MatrixClient.prototype.setCanResetTimelineCallback = function (cb) {
                        this._canResetTimelineCallback = cb;
                    };
                    MatrixClient.prototype.getCanResetTimelineCallback = function () {
                        return this._canResetTimelineCallback;
                    };
                    MatrixClient.prototype.relations = function () {
                        var _ref41 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee35(roomId, eventId, relationType, eventType) {
                            var opts, fetchedEventType, result, mapper, originalEvent, events, allEvents, _args35 = arguments;
                            return _regenerator["default"].wrap(function _callee35$(_context35) {
                                while (1) {
                                    switch (_context35.prev = _context35.next) {
                                        case 0:
                                            opts = _args35.length > 4 && _args35[4] !== undefined ? _args35[4] : {};
                                            fetchedEventType = _getEncryptedIfNeededEventType(this, roomId, eventType);
                                            _context35.next = 4;
                                            return this.fetchRelations(roomId, eventId, relationType, fetchedEventType, opts);
                                        case 4:
                                            result = _context35.sent;
                                            mapper = this.getEventMapper();
                                            if (result.original_event) {
                                                originalEvent = mapper(result.original_event);
                                            }
                                            events = result.chunk.map(mapper);
                                            if (!(fetchedEventType === "m.room.encrypted")) {
                                                _context35.next = 13;
                                                break;
                                            }
                                            allEvents = originalEvent ? events.concat(originalEvent) : events;
                                            _context35.next = 12;
                                            return Promise.all(allEvents.map(function (e) {
                                                return new Promise(function (resolve) {
                                                    return e.once("Event.decrypted", resolve);
                                                });
                                            }));
                                        case 12:
                                            events = events.filter(function (e) {
                                                return e.getType() === eventType;
                                            });
                                        case 13:
                                            if (originalEvent && relationType === "m.replace") {
                                                events = events.filter(function (e) {
                                                    return e.getSender() === originalEvent.getSender();
                                                });
                                            }
                                            return _context35.abrupt("return", {
                                                originalEvent: originalEvent,
                                                events: events,
                                                nextBatch: result.next_batch
                                            });
                                        case 15:
                                        case "end":
                                            return _context35.stop();
                                    }
                                }
                            }, _callee35, this);
                        }));
                        return function (_x52, _x53, _x54, _x55) {
                            return _ref41.apply(this, arguments);
                        };
                    }();
                    function _reject(callback, reject, err) {
                        if (callback) {
                            callback(err);
                        }
                        reject(err);
                    }
                    function _resolve(callback, resolve, res) {
                        if (callback) {
                            callback(null, res);
                        }
                        resolve(res);
                    }
                    function _PojoToMatrixEventMapper(client, options) {
                        var preventReEmit = Boolean(options && options.preventReEmit);
                        function mapper(plainOldJsObject) {
                            var event = new _event2.MatrixEvent(plainOldJsObject);
                            if (event.isEncrypted()) {
                                if (!preventReEmit) {
                                    client.reEmitter.reEmit(event, ["Event.decrypted"]);
                                }
                                event.attemptDecryption(client._crypto);
                            }
                            if (!preventReEmit) {
                                client.reEmitter.reEmit(event, ["Event.replaced"]);
                            }
                            return event;
                        }
                        return mapper;
                    }
                    MatrixClient.prototype.getEventMapper = function () {
                        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
                        return _PojoToMatrixEventMapper(this, options);
                    };
                    MatrixClient.prototype.getCrossSigningCacheCallbacks = function () {
                        return this._crypto && this._crypto._crossSigningInfo.getCacheCallbacks();
                    };
                    MatrixClient.prototype.generateClientSecret = function () {
                        return (0, _randomstring.randomString)(32);
                    };
                }).call(this);
            }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, { "./ReEmitter": 54, "./autodiscovery": 55, "./base-apis": 56, "./content-helpers": 59, "./content-repo": 60, "./crypto": 75, "./crypto/RoomList": 66, "./crypto/dehydration": 73, "./crypto/key_passphrase": 76, "./crypto/olmlib": 77, "./crypto/recoverykey": 78, "./filter": 93, "./http-api": 94, "./logger": 97, "./models/event": 102, "./models/event-timeline": 101, "./models/search-result": 109, "./models/user": 110, "./pushprocessor": 111, "./randomstring": 112, "./store/stub": 121, "./sync": 123, "./utils": 125, "./webrtc/call": 126, "./webrtc/callEventHandler": 127, "@babel/runtime/helpers/asyncToGenerator": 5, "@babel/runtime/helpers/interopRequireDefault": 12, "@babel/runtime/helpers/interopRequireWildcard": 13, "@babel/runtime/helpers/slicedToArray": 22, "@babel/runtime/helpers/typeof": 24, "@babel/runtime/regenerator": 27, "events": 36, "url": 51 }], 59: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.makeHtmlMessage = makeHtmlMessage;
            exports.makeHtmlNotice = makeHtmlNotice;
            exports.makeHtmlEmote = makeHtmlEmote;
            exports.makeTextMessage = makeTextMessage;
            exports.makeNotice = makeNotice;
            exports.makeEmoteMessage = makeEmoteMessage;
            function makeHtmlMessage(body, htmlBody) {
                return {
                    msgtype: "m.text",
                    format: "org.matrix.custom.html",
                    body: body,
                    formatted_body: htmlBody
                };
            }
            function makeHtmlNotice(body, htmlBody) {
                return {
                    msgtype: "m.notice",
                    format: "org.matrix.custom.html",
                    body: body,
                    formatted_body: htmlBody
                };
            }
            function makeHtmlEmote(body, htmlBody) {
                return {
                    msgtype: "m.emote",
                    format: "org.matrix.custom.html",
                    body: body,
                    formatted_body: htmlBody
                };
            }
            function makeTextMessage(body) {
                return {
                    msgtype: "m.text",
                    body: body
                };
            }
            function makeNotice(body) {
                return {
                    msgtype: "m.notice",
                    body: body
                };
            }
            function makeEmoteMessage(body) {
                return {
                    msgtype: "m.emote",
                    body: body
                };
            }
        }, {}], 60: [function (require, module, exports) {
            "use strict";
            var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.getHttpUriForMxc = getHttpUriForMxc;
            var utils = _interopRequireWildcard(require("./utils"));
            function getHttpUriForMxc(baseUrl, mxc, width, height, resizeMethod, allowDirectLinks) {
                if (typeof mxc !== "string" || !mxc) {
                    return '';
                }
                if (mxc.indexOf("mxc://") !== 0) {
                    if (allowDirectLinks) {
                        return mxc;
                    }
                    else {
                        return '';
                    }
                }
                var serverAndMediaId = mxc.slice(6);
                var prefix = "/_matrix/media/r0/download/";
                var params = {};
                if (width) {
                    params.width = Math.round(width);
                }
                if (height) {
                    params.height = Math.round(height);
                }
                if (resizeMethod) {
                    params.method = resizeMethod;
                }
                if (utils.keys(params).length > 0) {
                    prefix = "/_matrix/media/r0/thumbnail/";
                }
                var fragmentOffset = serverAndMediaId.indexOf("#");
                var fragment = "";
                if (fragmentOffset >= 0) {
                    fragment = serverAndMediaId.substr(fragmentOffset);
                    serverAndMediaId = serverAndMediaId.substr(0, fragmentOffset);
                }
                return baseUrl + prefix + serverAndMediaId + (utils.keys(params).length === 0 ? "" : "?" + utils.encodeParams(params)) + fragment;
            }
        }, { "./utils": 125, "@babel/runtime/helpers/interopRequireWildcard": 13 }], 61: [function (require, module, exports) {
            (function (global, Buffer) {
                (function () {
                    "use strict";
                    var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
                    Object.defineProperty(exports, "__esModule", {
                        value: true
                    });
                    exports.createCryptoStoreCacheCallbacks = createCryptoStoreCacheCallbacks;
                    exports.requestKeysDuringVerification = requestKeysDuringVerification;
                    exports.DeviceTrustLevel = exports.UserTrustLevel = exports.CrossSigningLevel = exports.CrossSigningInfo = void 0;
                    var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
                    var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
                    var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
                    var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
                    var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
                    var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
                    var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
                    var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
                    var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
                    var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
                    var _olmlib = require("./olmlib");
                    var _events = require("events");
                    var _logger = require("../logger");
                    var _indexeddbCryptoStore = require("../crypto/store/indexeddb-crypto-store");
                    var _aes = require("./aes");
                    function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
                        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                            if (it)
                                o = it;
                            var i = 0;
                            var F = function F() { };
                            return { s: F, n: function n() { if (i >= o.length)
                                    return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F };
                        }
                        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                    } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try {
                            if (!normalCompletion && it["return"] != null)
                                it["return"]();
                        }
                        finally {
                            if (didErr)
                                throw err;
                        } } }; }
                    function _unsupportedIterableToArray(o, minLen) { if (!o)
                        return; if (typeof o === "string")
                        return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor)
                        n = o.constructor.name; if (n === "Map" || n === "Set")
                        return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                        return _arrayLikeToArray(o, minLen); }
                    function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length)
                        len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) {
                        arr2[i] = arr[i];
                    } return arr2; }
                    function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) {
                        var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor;
                        result = Reflect.construct(Super, arguments, NewTarget);
                    }
                    else {
                        result = Super.apply(this, arguments);
                    } return (0, _possibleConstructorReturn2["default"])(this, result); }; }
                    function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct)
                        return false; if (Reflect.construct.sham)
                        return false; if (typeof Proxy === "function")
                        return true; try {
                        Date.prototype.toString.call(Reflect.construct(Date, [], function () { }));
                        return true;
                    }
                    catch (e) {
                        return false;
                    } }
                    var KEY_REQUEST_TIMEOUT_MS = 1000 * 60;
                    function publicKeyFromKeyInfo(keyInfo) {
                        return Object.values(keyInfo.keys)[0];
                    }
                    var CrossSigningInfo = function (_EventEmitter) {
                        (0, _inherits2["default"])(CrossSigningInfo, _EventEmitter);
                        var _super = _createSuper(CrossSigningInfo);
                        function CrossSigningInfo(userId, callbacks, cacheCallbacks) {
                            var _this;
                            (0, _classCallCheck2["default"])(this, CrossSigningInfo);
                            _this = _super.call(this);
                            Object.defineProperty((0, _assertThisInitialized2["default"])(_this), 'userId', {
                                enumerable: true,
                                value: userId
                            });
                            _this._callbacks = callbacks || {};
                            _this._cacheCallbacks = cacheCallbacks || {};
                            _this.keys = {};
                            _this.firstUse = true;
                            _this.crossSigningVerifiedBefore = false;
                            return _this;
                        }
                        (0, _createClass2["default"])(CrossSigningInfo, [{
                                key: "toStorage",
                                value: function toStorage() {
                                    return {
                                        keys: this.keys,
                                        firstUse: this.firstUse,
                                        crossSigningVerifiedBefore: this.crossSigningVerifiedBefore
                                    };
                                }
                            }, {
                                key: "getCrossSigningKey",
                                value: function () {
                                    var _getCrossSigningKey = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee(type, expectedPubkey) {
                                        var shouldCache, validateKey, privkey, cacheresult, result;
                                        return _regenerator["default"].wrap(function _callee$(_context) {
                                            while (1) {
                                                switch (_context.prev = _context.next) {
                                                    case 0:
                                                        validateKey = function _validateKey(key) {
                                                            if (!key)
                                                                return;
                                                            var signing = new global.Olm.PkSigning();
                                                            var gotPubkey = signing.init_with_seed(key);
                                                            if (gotPubkey === expectedPubkey) {
                                                                return [gotPubkey, signing];
                                                            }
                                                            signing.free();
                                                        };
                                                        shouldCache = ["master", "self_signing", "user_signing"].indexOf(type) >= 0;
                                                        if (this._callbacks.getCrossSigningKey) {
                                                            _context.next = 4;
                                                            break;
                                                        }
                                                        throw new Error("No getCrossSigningKey callback supplied");
                                                    case 4:
                                                        if (expectedPubkey === undefined) {
                                                            expectedPubkey = this.getId(type);
                                                        }
                                                        if (!(this._cacheCallbacks.getCrossSigningKeyCache && shouldCache)) {
                                                            _context.next = 9;
                                                            break;
                                                        }
                                                        _context.next = 8;
                                                        return this._cacheCallbacks.getCrossSigningKeyCache(type, expectedPubkey);
                                                    case 8:
                                                        privkey = _context.sent;
                                                    case 9:
                                                        cacheresult = validateKey(privkey);
                                                        if (!cacheresult) {
                                                            _context.next = 12;
                                                            break;
                                                        }
                                                        return _context.abrupt("return", cacheresult);
                                                    case 12:
                                                        _context.next = 14;
                                                        return this._callbacks.getCrossSigningKey(type, expectedPubkey);
                                                    case 14:
                                                        privkey = _context.sent;
                                                        result = validateKey(privkey);
                                                        if (!result) {
                                                            _context.next = 21;
                                                            break;
                                                        }
                                                        if (!(this._cacheCallbacks.storeCrossSigningKeyCache && shouldCache)) {
                                                            _context.next = 20;
                                                            break;
                                                        }
                                                        _context.next = 20;
                                                        return this._cacheCallbacks.storeCrossSigningKeyCache(type, privkey);
                                                    case 20:
                                                        return _context.abrupt("return", result);
                                                    case 21:
                                                        if (privkey) {
                                                            _context.next = 23;
                                                            break;
                                                        }
                                                        throw new Error("getCrossSigningKey callback for " + type + " returned falsey");
                                                    case 23:
                                                        throw new Error("Key type " + type + " from getCrossSigningKey callback did not match");
                                                    case 24:
                                                    case "end":
                                                        return _context.stop();
                                                }
                                            }
                                        }, _callee, this);
                                    }));
                                    function getCrossSigningKey(_x, _x2) {
                                        return _getCrossSigningKey.apply(this, arguments);
                                    }
                                    return getCrossSigningKey;
                                }()
                            }, {
                                key: "isStoredInSecretStorage",
                                value: function () {
                                    var _isStoredInSecretStorage = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee2(secretStorage) {
                                        var stored, intersect, _i2, _arr, type;
                                        return _regenerator["default"].wrap(function _callee2$(_context2) {
                                            while (1) {
                                                switch (_context2.prev = _context2.next) {
                                                    case 0:
                                                        intersect = function _intersect(s) {
                                                            for (var _i = 0, _Object$keys = Object.keys(stored); _i < _Object$keys.length; _i++) {
                                                                var k = _Object$keys[_i];
                                                                if (!s[k]) {
                                                                    delete stored[k];
                                                                }
                                                            }
                                                        };
                                                        _context2.next = 3;
                                                        return secretStorage.isStored("m.cross_signing.master", false);
                                                    case 3:
                                                        _context2.t0 = _context2.sent;
                                                        if (_context2.t0) {
                                                            _context2.next = 6;
                                                            break;
                                                        }
                                                        _context2.t0 = {};
                                                    case 6:
                                                        stored = _context2.t0;
                                                        _i2 = 0, _arr = ["self_signing", "user_signing"];
                                                    case 8:
                                                        if (!(_i2 < _arr.length)) {
                                                            _context2.next = 21;
                                                            break;
                                                        }
                                                        type = _arr[_i2];
                                                        _context2.t1 = intersect;
                                                        _context2.next = 13;
                                                        return secretStorage.isStored("m.cross_signing.".concat(type), false);
                                                    case 13:
                                                        _context2.t2 = _context2.sent;
                                                        if (_context2.t2) {
                                                            _context2.next = 16;
                                                            break;
                                                        }
                                                        _context2.t2 = {};
                                                    case 16:
                                                        _context2.t3 = _context2.t2;
                                                        (0, _context2.t1)(_context2.t3);
                                                    case 18:
                                                        _i2++;
                                                        _context2.next = 8;
                                                        break;
                                                    case 21:
                                                        return _context2.abrupt("return", Object.keys(stored).length ? stored : null);
                                                    case 22:
                                                    case "end":
                                                        return _context2.stop();
                                                }
                                            }
                                        }, _callee2);
                                    }));
                                    function isStoredInSecretStorage(_x3) {
                                        return _isStoredInSecretStorage.apply(this, arguments);
                                    }
                                    return isStoredInSecretStorage;
                                }()
                            }, {
                                key: "isStoredInKeyCache",
                                value: function () {
                                    var _isStoredInKeyCache = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee3(type) {
                                        var cacheCallbacks, types, _i3, _types, t;
                                        return _regenerator["default"].wrap(function _callee3$(_context3) {
                                            while (1) {
                                                switch (_context3.prev = _context3.next) {
                                                    case 0:
                                                        cacheCallbacks = this._cacheCallbacks;
                                                        if (cacheCallbacks) {
                                                            _context3.next = 3;
                                                            break;
                                                        }
                                                        return _context3.abrupt("return", false);
                                                    case 3:
                                                        types = type ? [type] : ["master", "self_signing", "user_signing"];
                                                        _i3 = 0, _types = types;
                                                    case 5:
                                                        if (!(_i3 < _types.length)) {
                                                            _context3.next = 14;
                                                            break;
                                                        }
                                                        t = _types[_i3];
                                                        _context3.next = 9;
                                                        return cacheCallbacks.getCrossSigningKeyCache(t);
                                                    case 9:
                                                        if (_context3.sent) {
                                                            _context3.next = 11;
                                                            break;
                                                        }
                                                        return _context3.abrupt("return", false);
                                                    case 11:
                                                        _i3++;
                                                        _context3.next = 5;
                                                        break;
                                                    case 14:
                                                        return _context3.abrupt("return", true);
                                                    case 15:
                                                    case "end":
                                                        return _context3.stop();
                                                }
                                            }
                                        }, _callee3, this);
                                    }));
                                    function isStoredInKeyCache(_x4) {
                                        return _isStoredInKeyCache.apply(this, arguments);
                                    }
                                    return isStoredInKeyCache;
                                }()
                            }, {
                                key: "getCrossSigningKeysFromCache",
                                value: function () {
                                    var _getCrossSigningKeysFromCache = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee4() {
                                        var keys, cacheCallbacks, _i4, _arr2, type, privKey;
                                        return _regenerator["default"].wrap(function _callee4$(_context4) {
                                            while (1) {
                                                switch (_context4.prev = _context4.next) {
                                                    case 0:
                                                        keys = new Map();
                                                        cacheCallbacks = this._cacheCallbacks;
                                                        if (cacheCallbacks) {
                                                            _context4.next = 4;
                                                            break;
                                                        }
                                                        return _context4.abrupt("return", keys);
                                                    case 4:
                                                        _i4 = 0, _arr2 = ["master", "self_signing", "user_signing"];
                                                    case 5:
                                                        if (!(_i4 < _arr2.length)) {
                                                            _context4.next = 16;
                                                            break;
                                                        }
                                                        type = _arr2[_i4];
                                                        _context4.next = 9;
                                                        return cacheCallbacks.getCrossSigningKeyCache(type);
                                                    case 9:
                                                        privKey = _context4.sent;
                                                        if (privKey) {
                                                            _context4.next = 12;
                                                            break;
                                                        }
                                                        return _context4.abrupt("continue", 13);
                                                    case 12:
                                                        keys.set(type, privKey);
                                                    case 13:
                                                        _i4++;
                                                        _context4.next = 5;
                                                        break;
                                                    case 16:
                                                        return _context4.abrupt("return", keys);
                                                    case 17:
                                                    case "end":
                                                        return _context4.stop();
                                                }
                                            }
                                        }, _callee4, this);
                                    }));
                                    function getCrossSigningKeysFromCache() {
                                        return _getCrossSigningKeysFromCache.apply(this, arguments);
                                    }
                                    return getCrossSigningKeysFromCache;
                                }()
                            }, {
                                key: "getId",
                                value: function getId(type) {
                                    type = type || "master";
                                    if (!this.keys[type])
                                        return null;
                                    var keyInfo = this.keys[type];
                                    return publicKeyFromKeyInfo(keyInfo);
                                }
                            }, {
                                key: "resetKeys",
                                value: function () {
                                    var _resetKeys = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee5(level) {
                                        var privateKeys, keys, masterSigning, masterPub, _yield$this$getCrossS, _yield$this$getCrossS2, sskSigning, sskPub, uskSigning, uskPub;
                                        return _regenerator["default"].wrap(function _callee5$(_context5) {
                                            while (1) {
                                                switch (_context5.prev = _context5.next) {
                                                    case 0:
                                                        if (this._callbacks.saveCrossSigningKeys) {
                                                            _context5.next = 2;
                                                            break;
                                                        }
                                                        throw new Error("No saveCrossSigningKeys callback supplied");
                                                    case 2:
                                                        if (!(level === undefined || level & CrossSigningLevel.MASTER || !this.keys.master)) {
                                                            _context5.next = 6;
                                                            break;
                                                        }
                                                        level = CrossSigningLevel.MASTER | CrossSigningLevel.USER_SIGNING | CrossSigningLevel.SELF_SIGNING;
                                                        _context5.next = 8;
                                                        break;
                                                    case 6:
                                                        if (!(level === 0)) {
                                                            _context5.next = 8;
                                                            break;
                                                        }
                                                        return _context5.abrupt("return");
                                                    case 8:
                                                        privateKeys = {};
                                                        keys = {};
                                                        _context5.prev = 10;
                                                        if (!(level & CrossSigningLevel.MASTER)) {
                                                            _context5.next = 18;
                                                            break;
                                                        }
                                                        masterSigning = new global.Olm.PkSigning();
                                                        privateKeys.master = masterSigning.generate_seed();
                                                        masterPub = masterSigning.init_with_seed(privateKeys.master);
                                                        keys.master = {
                                                            user_id: this.userId,
                                                            usage: ['master'],
                                                            keys: (0, _defineProperty2["default"])({}, 'ed25519:' + masterPub, masterPub)
                                                        };
                                                        _context5.next = 24;
                                                        break;
                                                    case 18:
                                                        _context5.next = 20;
                                                        return this.getCrossSigningKey("master");
                                                    case 20:
                                                        _yield$this$getCrossS = _context5.sent;
                                                        _yield$this$getCrossS2 = (0, _slicedToArray2["default"])(_yield$this$getCrossS, 2);
                                                        masterPub = _yield$this$getCrossS2[0];
                                                        masterSigning = _yield$this$getCrossS2[1];
                                                    case 24:
                                                        if (level & CrossSigningLevel.SELF_SIGNING) {
                                                            sskSigning = new global.Olm.PkSigning();
                                                            try {
                                                                privateKeys.self_signing = sskSigning.generate_seed();
                                                                sskPub = sskSigning.init_with_seed(privateKeys.self_signing);
                                                                keys.self_signing = {
                                                                    user_id: this.userId,
                                                                    usage: ['self_signing'],
                                                                    keys: (0, _defineProperty2["default"])({}, 'ed25519:' + sskPub, sskPub)
                                                                };
                                                                (0, _olmlib.pkSign)(keys.self_signing, masterSigning, this.userId, masterPub);
                                                            }
                                                            finally {
                                                                sskSigning.free();
                                                            }
                                                        }
                                                        if (level & CrossSigningLevel.USER_SIGNING) {
                                                            uskSigning = new global.Olm.PkSigning();
                                                            try {
                                                                privateKeys.user_signing = uskSigning.generate_seed();
                                                                uskPub = uskSigning.init_with_seed(privateKeys.user_signing);
                                                                keys.user_signing = {
                                                                    user_id: this.userId,
                                                                    usage: ['user_signing'],
                                                                    keys: (0, _defineProperty2["default"])({}, 'ed25519:' + uskPub, uskPub)
                                                                };
                                                                (0, _olmlib.pkSign)(keys.user_signing, masterSigning, this.userId, masterPub);
                                                            }
                                                            finally {
                                                                uskSigning.free();
                                                            }
                                                        }
                                                        Object.assign(this.keys, keys);
                                                        this._callbacks.saveCrossSigningKeys(privateKeys);
                                                    case 28:
                                                        _context5.prev = 28;
                                                        if (masterSigning) {
                                                            masterSigning.free();
                                                        }
                                                        return _context5.finish(28);
                                                    case 31:
                                                    case "end":
                                                        return _context5.stop();
                                                }
                                            }
                                        }, _callee5, this, [[10, , 28, 31]]);
                                    }));
                                    function resetKeys(_x5) {
                                        return _resetKeys.apply(this, arguments);
                                    }
                                    return resetKeys;
                                }()
                            }, {
                                key: "clearKeys",
                                value: function clearKeys() {
                                    this.keys = {};
                                }
                            }, {
                                key: "setKeys",
                                value: function setKeys(keys) {
                                    var signingKeys = {};
                                    if (keys.master) {
                                        if (keys.master.user_id !== this.userId) {
                                            var error = "Mismatched user ID " + keys.master.user_id + " in master key from " + this.userId;
                                            _logger.logger.error(error);
                                            throw new Error(error);
                                        }
                                        if (!this.keys.master) {
                                            this.firstUse = true;
                                        }
                                        else if (publicKeyFromKeyInfo(keys.master) !== this.getId()) {
                                            this.firstUse = false;
                                        }
                                        signingKeys.master = keys.master;
                                    }
                                    else if (this.keys.master) {
                                        signingKeys.master = this.keys.master;
                                    }
                                    else {
                                        throw new Error("Tried to set cross-signing keys without a master key");
                                    }
                                    var masterKey = publicKeyFromKeyInfo(signingKeys.master);
                                    if (keys.user_signing) {
                                        if (keys.user_signing.user_id !== this.userId) {
                                            var _error = "Mismatched user ID " + keys.master.user_id + " in user_signing key from " + this.userId;
                                            _logger.logger.error(_error);
                                            throw new Error(_error);
                                        }
                                        try {
                                            (0, _olmlib.pkVerify)(keys.user_signing, masterKey, this.userId);
                                        }
                                        catch (e) {
                                            _logger.logger.error("invalid signature on user-signing key");
                                            throw e;
                                        }
                                    }
                                    if (keys.self_signing) {
                                        if (keys.self_signing.user_id !== this.userId) {
                                            var _error2 = "Mismatched user ID " + keys.master.user_id + " in self_signing key from " + this.userId;
                                            _logger.logger.error(_error2);
                                            throw new Error(_error2);
                                        }
                                        try {
                                            (0, _olmlib.pkVerify)(keys.self_signing, masterKey, this.userId);
                                        }
                                        catch (e) {
                                            _logger.logger.error("invalid signature on self-signing key");
                                            throw e;
                                        }
                                    }
                                    if (keys.master) {
                                        this.keys.master = keys.master;
                                        this.keys.self_signing = null;
                                        this.keys.user_signing = null;
                                    }
                                    if (keys.self_signing) {
                                        this.keys.self_signing = keys.self_signing;
                                    }
                                    if (keys.user_signing) {
                                        this.keys.user_signing = keys.user_signing;
                                    }
                                }
                            }, {
                                key: "updateCrossSigningVerifiedBefore",
                                value: function updateCrossSigningVerifiedBefore(isCrossSigningVerified) {
                                    if (!this.crossSigningVerifiedBefore && isCrossSigningVerified) {
                                        this.crossSigningVerifiedBefore = true;
                                    }
                                }
                            }, {
                                key: "signObject",
                                value: function () {
                                    var _signObject = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee6(data, type) {
                                        var _yield$this$getCrossS3, _yield$this$getCrossS4, pubkey, signing;
                                        return _regenerator["default"].wrap(function _callee6$(_context6) {
                                            while (1) {
                                                switch (_context6.prev = _context6.next) {
                                                    case 0:
                                                        if (this.keys[type]) {
                                                            _context6.next = 2;
                                                            break;
                                                        }
                                                        throw new Error("Attempted to sign with " + type + " key but no such key present");
                                                    case 2:
                                                        _context6.next = 4;
                                                        return this.getCrossSigningKey(type);
                                                    case 4:
                                                        _yield$this$getCrossS3 = _context6.sent;
                                                        _yield$this$getCrossS4 = (0, _slicedToArray2["default"])(_yield$this$getCrossS3, 2);
                                                        pubkey = _yield$this$getCrossS4[0];
                                                        signing = _yield$this$getCrossS4[1];
                                                        _context6.prev = 8;
                                                        (0, _olmlib.pkSign)(data, signing, this.userId, pubkey);
                                                        return _context6.abrupt("return", data);
                                                    case 11:
                                                        _context6.prev = 11;
                                                        signing.free();
                                                        return _context6.finish(11);
                                                    case 14:
                                                    case "end":
                                                        return _context6.stop();
                                                }
                                            }
                                        }, _callee6, this, [[8, , 11, 14]]);
                                    }));
                                    function signObject(_x6, _x7) {
                                        return _signObject.apply(this, arguments);
                                    }
                                    return signObject;
                                }()
                            }, {
                                key: "signUser",
                                value: function () {
                                    var _signUser = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee7(key) {
                                        return _regenerator["default"].wrap(function _callee7$(_context7) {
                                            while (1) {
                                                switch (_context7.prev = _context7.next) {
                                                    case 0:
                                                        if (this.keys.user_signing) {
                                                            _context7.next = 3;
                                                            break;
                                                        }
                                                        _logger.logger.info("No user signing key: not signing user");
                                                        return _context7.abrupt("return");
                                                    case 3:
                                                        return _context7.abrupt("return", this.signObject(key.keys.master, "user_signing"));
                                                    case 4:
                                                    case "end":
                                                        return _context7.stop();
                                                }
                                            }
                                        }, _callee7, this);
                                    }));
                                    function signUser(_x8) {
                                        return _signUser.apply(this, arguments);
                                    }
                                    return signUser;
                                }()
                            }, {
                                key: "signDevice",
                                value: function () {
                                    var _signDevice = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee8(userId, device) {
                                        return _regenerator["default"].wrap(function _callee8$(_context8) {
                                            while (1) {
                                                switch (_context8.prev = _context8.next) {
                                                    case 0:
                                                        if (!(userId !== this.userId)) {
                                                            _context8.next = 2;
                                                            break;
                                                        }
                                                        throw new Error("Trying to sign ".concat(userId, "'s device; can only sign our own device"));
                                                    case 2:
                                                        if (this.keys.self_signing) {
                                                            _context8.next = 5;
                                                            break;
                                                        }
                                                        _logger.logger.info("No self signing key: not signing device");
                                                        return _context8.abrupt("return");
                                                    case 5:
                                                        return _context8.abrupt("return", this.signObject({
                                                            algorithms: device.algorithms,
                                                            keys: device.keys,
                                                            device_id: device.deviceId,
                                                            user_id: userId
                                                        }, "self_signing"));
                                                    case 6:
                                                    case "end":
                                                        return _context8.stop();
                                                }
                                            }
                                        }, _callee8, this);
                                    }));
                                    function signDevice(_x9, _x10) {
                                        return _signDevice.apply(this, arguments);
                                    }
                                    return signDevice;
                                }()
                            }, {
                                key: "checkUserTrust",
                                value: function checkUserTrust(userCrossSigning) {
                                    if (this.userId === userCrossSigning.userId && this.getId() && this.getId() === userCrossSigning.getId() && this.getId("self_signing") && this.getId("self_signing") === userCrossSigning.getId("self_signing")) {
                                        return new UserTrustLevel(true, true, this.firstUse);
                                    }
                                    if (!this.keys.user_signing) {
                                        return new UserTrustLevel(false, false, userCrossSigning.firstUse);
                                    }
                                    var userTrusted;
                                    var userMaster = userCrossSigning.keys.master;
                                    var uskId = this.getId('user_signing');
                                    try {
                                        (0, _olmlib.pkVerify)(userMaster, uskId, this.userId);
                                        userTrusted = true;
                                    }
                                    catch (e) {
                                        userTrusted = false;
                                    }
                                    return new UserTrustLevel(userTrusted, userCrossSigning.crossSigningVerifiedBefore, userCrossSigning.firstUse);
                                }
                            }, {
                                key: "checkDeviceTrust",
                                value: function checkDeviceTrust(userCrossSigning, device, localTrust, trustCrossSignedDevices) {
                                    var userTrust = this.checkUserTrust(userCrossSigning);
                                    var userSSK = userCrossSigning.keys.self_signing;
                                    if (!userSSK) {
                                        return new DeviceTrustLevel(false, false, localTrust, trustCrossSignedDevices);
                                    }
                                    var deviceObj = deviceToObject(device, userCrossSigning.userId);
                                    try {
                                        (0, _olmlib.pkVerify)(userSSK, userCrossSigning.getId(), userCrossSigning.userId);
                                        (0, _olmlib.pkVerify)(deviceObj, publicKeyFromKeyInfo(userSSK), userCrossSigning.userId);
                                        return DeviceTrustLevel.fromUserTrustLevel(userTrust, localTrust, trustCrossSignedDevices);
                                    }
                                    catch (e) {
                                        return new DeviceTrustLevel(false, false, localTrust, trustCrossSignedDevices);
                                    }
                                }
                            }, {
                                key: "getCacheCallbacks",
                                value: function getCacheCallbacks() {
                                    return this._cacheCallbacks;
                                }
                            }], [{
                                key: "fromStorage",
                                value: function fromStorage(obj, userId) {
                                    var res = new CrossSigningInfo(userId);
                                    for (var prop in obj) {
                                        if (obj.hasOwnProperty(prop)) {
                                            res[prop] = obj[prop];
                                        }
                                    }
                                    return res;
                                }
                            }, {
                                key: "storeInSecretStorage",
                                value: function () {
                                    var _storeInSecretStorage = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee9(keys, secretStorage) {
                                        var _iterator, _step, _step$value, type, privateKey, encodedKey;
                                        return _regenerator["default"].wrap(function _callee9$(_context9) {
                                            while (1) {
                                                switch (_context9.prev = _context9.next) {
                                                    case 0:
                                                        _iterator = _createForOfIteratorHelper(keys);
                                                        _context9.prev = 1;
                                                        _iterator.s();
                                                    case 3:
                                                        if ((_step = _iterator.n()).done) {
                                                            _context9.next = 10;
                                                            break;
                                                        }
                                                        _step$value = (0, _slicedToArray2["default"])(_step.value, 2), type = _step$value[0], privateKey = _step$value[1];
                                                        encodedKey = (0, _olmlib.encodeBase64)(privateKey);
                                                        _context9.next = 8;
                                                        return secretStorage.store("m.cross_signing.".concat(type), encodedKey);
                                                    case 8:
                                                        _context9.next = 3;
                                                        break;
                                                    case 10:
                                                        _context9.next = 15;
                                                        break;
                                                    case 12:
                                                        _context9.prev = 12;
                                                        _context9.t0 = _context9["catch"](1);
                                                        _iterator.e(_context9.t0);
                                                    case 15:
                                                        _context9.prev = 15;
                                                        _iterator.f();
                                                        return _context9.finish(15);
                                                    case 18:
                                                    case "end":
                                                        return _context9.stop();
                                                }
                                            }
                                        }, _callee9, null, [[1, 12, 15, 18]]);
                                    }));
                                    function storeInSecretStorage(_x11, _x12) {
                                        return _storeInSecretStorage.apply(this, arguments);
                                    }
                                    return storeInSecretStorage;
                                }()
                            }, {
                                key: "getFromSecretStorage",
                                value: function () {
                                    var _getFromSecretStorage = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee10(type, secretStorage) {
                                        var encodedKey;
                                        return _regenerator["default"].wrap(function _callee10$(_context10) {
                                            while (1) {
                                                switch (_context10.prev = _context10.next) {
                                                    case 0:
                                                        _context10.next = 2;
                                                        return secretStorage.get("m.cross_signing.".concat(type));
                                                    case 2:
                                                        encodedKey = _context10.sent;
                                                        if (encodedKey) {
                                                            _context10.next = 5;
                                                            break;
                                                        }
                                                        return _context10.abrupt("return", null);
                                                    case 5:
                                                        return _context10.abrupt("return", (0, _olmlib.decodeBase64)(encodedKey));
                                                    case 6:
                                                    case "end":
                                                        return _context10.stop();
                                                }
                                            }
                                        }, _callee10);
                                    }));
                                    function getFromSecretStorage(_x13, _x14) {
                                        return _getFromSecretStorage.apply(this, arguments);
                                    }
                                    return getFromSecretStorage;
                                }()
                            }]);
                        return CrossSigningInfo;
                    }(_events.EventEmitter);
                    exports.CrossSigningInfo = CrossSigningInfo;
                    function deviceToObject(device, userId) {
                        return {
                            algorithms: device.algorithms,
                            keys: device.keys,
                            device_id: device.deviceId,
                            user_id: userId,
                            signatures: device.signatures
                        };
                    }
                    var CrossSigningLevel = {
                        MASTER: 4,
                        USER_SIGNING: 2,
                        SELF_SIGNING: 1
                    };
                    exports.CrossSigningLevel = CrossSigningLevel;
                    var UserTrustLevel = function () {
                        function UserTrustLevel(crossSigningVerified, crossSigningVerifiedBefore, tofu) {
                            (0, _classCallCheck2["default"])(this, UserTrustLevel);
                            this._crossSigningVerified = crossSigningVerified;
                            this._crossSigningVerifiedBefore = crossSigningVerifiedBefore;
                            this._tofu = tofu;
                        }
                        (0, _createClass2["default"])(UserTrustLevel, [{
                                key: "isVerified",
                                value: function isVerified() {
                                    return this.isCrossSigningVerified();
                                }
                            }, {
                                key: "isCrossSigningVerified",
                                value: function isCrossSigningVerified() {
                                    return this._crossSigningVerified;
                                }
                            }, {
                                key: "wasCrossSigningVerified",
                                value: function wasCrossSigningVerified() {
                                    return this._crossSigningVerifiedBefore;
                                }
                            }, {
                                key: "isTofu",
                                value: function isTofu() {
                                    return this._tofu;
                                }
                            }]);
                        return UserTrustLevel;
                    }();
                    exports.UserTrustLevel = UserTrustLevel;
                    var DeviceTrustLevel = function () {
                        function DeviceTrustLevel(crossSigningVerified, tofu, localVerified, trustCrossSignedDevices) {
                            (0, _classCallCheck2["default"])(this, DeviceTrustLevel);
                            this._crossSigningVerified = crossSigningVerified;
                            this._tofu = tofu;
                            this._localVerified = localVerified;
                            this._trustCrossSignedDevices = trustCrossSignedDevices;
                        }
                        (0, _createClass2["default"])(DeviceTrustLevel, [{
                                key: "isVerified",
                                value: function isVerified() {
                                    return Boolean(this.isLocallyVerified() || this._trustCrossSignedDevices && this.isCrossSigningVerified());
                                }
                            }, {
                                key: "isCrossSigningVerified",
                                value: function isCrossSigningVerified() {
                                    return this._crossSigningVerified;
                                }
                            }, {
                                key: "isLocallyVerified",
                                value: function isLocallyVerified() {
                                    return this._localVerified;
                                }
                            }, {
                                key: "isTofu",
                                value: function isTofu() {
                                    return this._tofu;
                                }
                            }], [{
                                key: "fromUserTrustLevel",
                                value: function fromUserTrustLevel(userTrustLevel, localVerified, trustCrossSignedDevices) {
                                    return new DeviceTrustLevel(userTrustLevel._crossSigningVerified, userTrustLevel._tofu, localVerified, trustCrossSignedDevices);
                                }
                            }]);
                        return DeviceTrustLevel;
                    }();
                    exports.DeviceTrustLevel = DeviceTrustLevel;
                    function createCryptoStoreCacheCallbacks(store, olmdevice) {
                        return {
                            getCrossSigningKeyCache: function () {
                                var _getCrossSigningKeyCache = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee11(type, _expectedPublicKey) {
                                    var key, pickleKey, decrypted;
                                    return _regenerator["default"].wrap(function _callee11$(_context11) {
                                        while (1) {
                                            switch (_context11.prev = _context11.next) {
                                                case 0:
                                                    _context11.next = 2;
                                                    return new Promise(function (resolve) {
                                                        return store.doTxn('readonly', [_indexeddbCryptoStore.IndexedDBCryptoStore.STORE_ACCOUNT], function (txn) {
                                                            store.getSecretStorePrivateKey(txn, resolve, type);
                                                        });
                                                    });
                                                case 2:
                                                    key = _context11.sent;
                                                    if (!(key && key.ciphertext)) {
                                                        _context11.next = 11;
                                                        break;
                                                    }
                                                    pickleKey = Buffer.from(olmdevice._pickleKey);
                                                    _context11.next = 7;
                                                    return (0, _aes.decryptAES)(key, pickleKey, type);
                                                case 7:
                                                    decrypted = _context11.sent;
                                                    return _context11.abrupt("return", (0, _olmlib.decodeBase64)(decrypted));
                                                case 11:
                                                    return _context11.abrupt("return", key);
                                                case 12:
                                                case "end":
                                                    return _context11.stop();
                                            }
                                        }
                                    }, _callee11);
                                }));
                                function getCrossSigningKeyCache(_x15, _x16) {
                                    return _getCrossSigningKeyCache.apply(this, arguments);
                                }
                                return getCrossSigningKeyCache;
                            }(),
                            storeCrossSigningKeyCache: function () {
                                var _storeCrossSigningKeyCache = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee12(type, key) {
                                    var pickleKey;
                                    return _regenerator["default"].wrap(function _callee12$(_context12) {
                                        while (1) {
                                            switch (_context12.prev = _context12.next) {
                                                case 0:
                                                    if (key instanceof Uint8Array) {
                                                        _context12.next = 2;
                                                        break;
                                                    }
                                                    throw new Error("storeCrossSigningKeyCache expects Uint8Array, got ".concat(key));
                                                case 2:
                                                    pickleKey = Buffer.from(olmdevice._pickleKey);
                                                    _context12.next = 5;
                                                    return (0, _aes.encryptAES)((0, _olmlib.encodeBase64)(key), pickleKey, type);
                                                case 5:
                                                    key = _context12.sent;
                                                    return _context12.abrupt("return", store.doTxn('readwrite', [_indexeddbCryptoStore.IndexedDBCryptoStore.STORE_ACCOUNT], function (txn) {
                                                        store.storeSecretStorePrivateKey(txn, type, key);
                                                    }));
                                                case 7:
                                                case "end":
                                                    return _context12.stop();
                                            }
                                        }
                                    }, _callee12);
                                }));
                                function storeCrossSigningKeyCache(_x17, _x18) {
                                    return _storeCrossSigningKeyCache.apply(this, arguments);
                                }
                                return storeCrossSigningKeyCache;
                            }()
                        };
                    }
                    function requestKeysDuringVerification(_x19, _x20, _x21) {
                        return _requestKeysDuringVerification.apply(this, arguments);
                    }
                    function _requestKeysDuringVerification() {
                        _requestKeysDuringVerification = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee15(baseApis, userId, deviceId) {
                            return _regenerator["default"].wrap(function _callee15$(_context15) {
                                while (1) {
                                    switch (_context15.prev = _context15.next) {
                                        case 0:
                                            if (!(baseApis.getUserId() !== userId)) {
                                                _context15.next = 2;
                                                break;
                                            }
                                            return _context15.abrupt("return");
                                        case 2:
                                            _logger.logger.log("Cross-signing: Self-verification done; requesting keys");
                                            return _context15.abrupt("return", new Promise(function (resolve, reject) {
                                                var client = baseApis;
                                                var original = client._crypto._crossSigningInfo;
                                                var crossSigning = new CrossSigningInfo(original.userId, {
                                                    getCrossSigningKey: function () {
                                                        var _getCrossSigningKey2 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee13(type) {
                                                            var _client$requestSecret, promise, result, decoded;
                                                            return _regenerator["default"].wrap(function _callee13$(_context13) {
                                                                while (1) {
                                                                    switch (_context13.prev = _context13.next) {
                                                                        case 0:
                                                                            _logger.logger.debug("Cross-signing: requesting secret", type, deviceId);
                                                                            _client$requestSecret = client.requestSecret("m.cross_signing.".concat(type), [deviceId]), promise = _client$requestSecret.promise;
                                                                            _context13.next = 4;
                                                                            return promise;
                                                                        case 4:
                                                                            result = _context13.sent;
                                                                            decoded = (0, _olmlib.decodeBase64)(result);
                                                                            return _context13.abrupt("return", Uint8Array.from(decoded));
                                                                        case 7:
                                                                        case "end":
                                                                            return _context13.stop();
                                                                    }
                                                                }
                                                            }, _callee13);
                                                        }));
                                                        function getCrossSigningKey(_x22) {
                                                            return _getCrossSigningKey2.apply(this, arguments);
                                                        }
                                                        return getCrossSigningKey;
                                                    }()
                                                }, original._cacheCallbacks);
                                                crossSigning.keys = original.keys;
                                                var timeout = new Promise(function (resolve, reject) {
                                                    setTimeout(resolve, KEY_REQUEST_TIMEOUT_MS, new Error("Timeout"));
                                                });
                                                var backupKeyPromise = new Promise(function () {
                                                    var _ref = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee14(resolve) {
                                                        var cachedKey, secretReq, base64Key, decodedKey, backupInfo;
                                                        return _regenerator["default"].wrap(function _callee14$(_context14) {
                                                            while (1) {
                                                                switch (_context14.prev = _context14.next) {
                                                                    case 0:
                                                                        _context14.next = 2;
                                                                        return client._crypto.getSessionBackupPrivateKey();
                                                                    case 2:
                                                                        cachedKey = _context14.sent;
                                                                        if (cachedKey) {
                                                                            _context14.next = 18;
                                                                            break;
                                                                        }
                                                                        _logger.logger.info("No cached backup key found. Requesting...");
                                                                        secretReq = client.requestSecret('m.megolm_backup.v1', [deviceId]);
                                                                        _context14.next = 8;
                                                                        return secretReq.promise;
                                                                    case 8:
                                                                        base64Key = _context14.sent;
                                                                        _logger.logger.info("Got key backup key, decoding...");
                                                                        decodedKey = (0, _olmlib.decodeBase64)(base64Key);
                                                                        _logger.logger.info("Decoded backup key, storing...");
                                                                        client._crypto.storeSessionBackupPrivateKey(Uint8Array.from(decodedKey));
                                                                        _logger.logger.info("Backup key stored. Starting backup restore...");
                                                                        _context14.next = 16;
                                                                        return client.getKeyBackupVersion();
                                                                    case 16:
                                                                        backupInfo = _context14.sent;
                                                                        client.restoreKeyBackupWithCache(undefined, undefined, backupInfo).then(function () {
                                                                            _logger.logger.info("Backup restored.");
                                                                        });
                                                                    case 18:
                                                                        resolve();
                                                                    case 19:
                                                                    case "end":
                                                                        return _context14.stop();
                                                                }
                                                            }
                                                        }, _callee14);
                                                    }));
                                                    return function (_x23) {
                                                        return _ref.apply(this, arguments);
                                                    };
                                                }());
                                                return Promise.race([Promise.all([crossSigning.getCrossSigningKey("master"), crossSigning.getCrossSigningKey("self_signing"), crossSigning.getCrossSigningKey("user_signing"), backupKeyPromise]), timeout]).then(resolve, reject);
                                            })["catch"](function (e) {
                                                _logger.logger.warn("Cross-signing: failure while requesting keys:", e);
                                            }));
                                        case 4:
                                        case "end":
                                            return _context15.stop();
                                    }
                                }
                            }, _callee15);
                        }));
                        return _requestKeysDuringVerification.apply(this, arguments);
                    }
                }).call(this);
            }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, require("buffer").Buffer);
        }, { "../crypto/store/indexeddb-crypto-store": 80, "../logger": 97, "./aes": 68, "./olmlib": 77, "@babel/runtime/helpers/assertThisInitialized": 4, "@babel/runtime/helpers/asyncToGenerator": 5, "@babel/runtime/helpers/classCallCheck": 6, "@babel/runtime/helpers/createClass": 8, "@babel/runtime/helpers/defineProperty": 9, "@babel/runtime/helpers/getPrototypeOf": 10, "@babel/runtime/helpers/inherits": 11, "@babel/runtime/helpers/interopRequireDefault": 12, "@babel/runtime/helpers/possibleConstructorReturn": 20, "@babel/runtime/helpers/slicedToArray": 22, "@babel/runtime/regenerator": 27, "buffer": 34, "events": 36 }], 62: [function (require, module, exports) {
            "use strict";
            var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
            var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.DeviceList = void 0;
            var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
            var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
            var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
            var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
            var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
            var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
            var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
            var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
            var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
            var _events = require("events");
            var _logger = require("../logger");
            var _deviceinfo = require("./deviceinfo");
            var _CrossSigning = require("./CrossSigning");
            var olmlib = _interopRequireWildcard(require("./olmlib"));
            var _indexeddbCryptoStore = require("./store/indexeddb-crypto-store");
            var _utils = require("../utils");
            function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
                if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                    if (it)
                        o = it;
                    var i = 0;
                    var F = function F() { };
                    return { s: F, n: function n() { if (i >= o.length)
                            return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try {
                    if (!normalCompletion && it["return"] != null)
                        it["return"]();
                }
                finally {
                    if (didErr)
                        throw err;
                } } }; }
            function _unsupportedIterableToArray(o, minLen) { if (!o)
                return; if (typeof o === "string")
                return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor)
                n = o.constructor.name; if (n === "Map" || n === "Set")
                return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return _arrayLikeToArray(o, minLen); }
            function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length)
                len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
            } return arr2; }
            function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) {
                var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor;
                result = Reflect.construct(Super, arguments, NewTarget);
            }
            else {
                result = Super.apply(this, arguments);
            } return (0, _possibleConstructorReturn2["default"])(this, result); }; }
            function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct)
                return false; if (Reflect.construct.sham)
                return false; if (typeof Proxy === "function")
                return true; try {
                Date.prototype.toString.call(Reflect.construct(Date, [], function () { }));
                return true;
            }
            catch (e) {
                return false;
            } }
            var TRACKING_STATUS_NOT_TRACKED = 0;
            var TRACKING_STATUS_PENDING_DOWNLOAD = 1;
            var TRACKING_STATUS_DOWNLOAD_IN_PROGRESS = 2;
            var TRACKING_STATUS_UP_TO_DATE = 3;
            var DeviceList = function (_EventEmitter) {
                (0, _inherits2["default"])(DeviceList, _EventEmitter);
                var _super = _createSuper(DeviceList);
                function DeviceList(baseApis, cryptoStore, olmDevice) {
                    var _this;
                    (0, _classCallCheck2["default"])(this, DeviceList);
                    _this = _super.call(this);
                    _this._cryptoStore = cryptoStore;
                    _this._devices = {};
                    _this._crossSigningInfo = {};
                    _this._userByIdentityKey = {};
                    _this._deviceTrackingStatus = {};
                    _this._syncToken = null;
                    _this._serialiser = new DeviceListUpdateSerialiser(baseApis, olmDevice, (0, _assertThisInitialized2["default"])(_this));
                    _this._keyDownloadsInProgressByUser = {};
                    _this._dirty = false;
                    _this._savePromise = null;
                    _this._resolveSavePromise = null;
                    _this._savePromiseTime = null;
                    _this._saveTimer = null;
                    _this._hasFetched = null;
                    return _this;
                }
                (0, _createClass2["default"])(DeviceList, [{
                        key: "load",
                        value: function () {
                            var _load = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee() {
                                var _this2 = this;
                                var _i3, _Object$keys3, u;
                                return _regenerator["default"].wrap(function _callee$(_context) {
                                    while (1) {
                                        switch (_context.prev = _context.next) {
                                            case 0:
                                                _context.next = 2;
                                                return this._cryptoStore.doTxn('readonly', [_indexeddbCryptoStore.IndexedDBCryptoStore.STORE_DEVICE_DATA], function (txn) {
                                                    _this2._cryptoStore.getEndToEndDeviceData(txn, function (deviceData) {
                                                        _this2._hasFetched = Boolean(deviceData && deviceData.devices);
                                                        _this2._devices = deviceData ? deviceData.devices : {}, _this2._crossSigningInfo = deviceData ? deviceData.crossSigningInfo || {} : {};
                                                        _this2._deviceTrackingStatus = deviceData ? deviceData.trackingStatus : {};
                                                        _this2._syncToken = deviceData ? deviceData.syncToken : null;
                                                        _this2._userByIdentityKey = {};
                                                        for (var _i = 0, _Object$keys = Object.keys(_this2._devices); _i < _Object$keys.length; _i++) {
                                                            var user = _Object$keys[_i];
                                                            var userDevices = _this2._devices[user];
                                                            for (var _i2 = 0, _Object$keys2 = Object.keys(userDevices); _i2 < _Object$keys2.length; _i2++) {
                                                                var device = _Object$keys2[_i2];
                                                                var idKey = userDevices[device].keys['curve25519:' + device];
                                                                if (idKey !== undefined) {
                                                                    _this2._userByIdentityKey[idKey] = user;
                                                                }
                                                            }
                                                        }
                                                    });
                                                });
                                            case 2:
                                                for (_i3 = 0, _Object$keys3 = Object.keys(this._deviceTrackingStatus); _i3 < _Object$keys3.length; _i3++) {
                                                    u = _Object$keys3[_i3];
                                                    if (this._deviceTrackingStatus[u] == TRACKING_STATUS_DOWNLOAD_IN_PROGRESS) {
                                                        this._deviceTrackingStatus[u] = TRACKING_STATUS_PENDING_DOWNLOAD;
                                                    }
                                                }
                                            case 3:
                                            case "end":
                                                return _context.stop();
                                        }
                                    }
                                }, _callee, this);
                            }));
                            function load() {
                                return _load.apply(this, arguments);
                            }
                            return load;
                        }()
                    }, {
                        key: "stop",
                        value: function stop() {
                            if (this._saveTimer !== null) {
                                clearTimeout(this._saveTimer);
                            }
                        }
                    }, {
                        key: "saveIfDirty",
                        value: function () {
                            var _saveIfDirty = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee2(delay) {
                                var _this3 = this;
                                var targetTime, savePromise, resolveSavePromise;
                                return _regenerator["default"].wrap(function _callee2$(_context2) {
                                    while (1) {
                                        switch (_context2.prev = _context2.next) {
                                            case 0:
                                                if (this._dirty) {
                                                    _context2.next = 2;
                                                    break;
                                                }
                                                return _context2.abrupt("return", Promise.resolve(false));
                                            case 2:
                                                if (delay === undefined)
                                                    delay = 500;
                                                targetTime = Date.now + delay;
                                                if (this._savePromiseTime && targetTime < this._savePromiseTime) {
                                                    clearTimeout(this._saveTimer);
                                                    this._saveTimer = null;
                                                    this._savePromiseTime = null;
                                                }
                                                savePromise = this._savePromise;
                                                if (savePromise === null) {
                                                    savePromise = new Promise(function (resolve, reject) {
                                                        _this3._resolveSavePromise = resolve;
                                                    });
                                                    this._savePromise = savePromise;
                                                }
                                                if (this._saveTimer === null) {
                                                    resolveSavePromise = this._resolveSavePromise;
                                                    this._savePromiseTime = targetTime;
                                                    this._saveTimer = setTimeout(function () {
                                                        _logger.logger.log('Saving device tracking data', _this3._syncToken);
                                                        _this3._savePromiseTime = null;
                                                        _this3._saveTimer = null;
                                                        _this3._savePromise = null;
                                                        _this3._resolveSavePromise = null;
                                                        _this3._cryptoStore.doTxn('readwrite', [_indexeddbCryptoStore.IndexedDBCryptoStore.STORE_DEVICE_DATA], function (txn) {
                                                            _this3._cryptoStore.storeEndToEndDeviceData({
                                                                devices: _this3._devices,
                                                                crossSigningInfo: _this3._crossSigningInfo,
                                                                trackingStatus: _this3._deviceTrackingStatus,
                                                                syncToken: _this3._syncToken
                                                            }, txn);
                                                        }).then(function () {
                                                            _this3._dirty = false;
                                                            resolveSavePromise();
                                                        }, function (err) {
                                                            _logger.logger.error('Failed to save device tracking data', _this3._syncToken);
                                                            _logger.logger.error(err);
                                                        });
                                                    }, delay);
                                                }
                                                return _context2.abrupt("return", savePromise);
                                            case 9:
                                            case "end":
                                                return _context2.stop();
                                        }
                                    }
                                }, _callee2, this);
                            }));
                            function saveIfDirty(_x) {
                                return _saveIfDirty.apply(this, arguments);
                            }
                            return saveIfDirty;
                        }()
                    }, {
                        key: "getSyncToken",
                        value: function getSyncToken() {
                            return this._syncToken;
                        }
                    }, {
                        key: "setSyncToken",
                        value: function setSyncToken(st) {
                            this._syncToken = st;
                        }
                    }, {
                        key: "downloadKeys",
                        value: function downloadKeys(userIds, forceDownload) {
                            var _this4 = this;
                            var usersToDownload = [];
                            var promises = [];
                            userIds.forEach(function (u) {
                                var trackingStatus = _this4._deviceTrackingStatus[u];
                                if (_this4._keyDownloadsInProgressByUser[u]) {
                                    _logger.logger.log("downloadKeys: already have a download in progress for " + "".concat(u, ": awaiting its result"));
                                    promises.push(_this4._keyDownloadsInProgressByUser[u]);
                                }
                                else if (forceDownload || trackingStatus != TRACKING_STATUS_UP_TO_DATE) {
                                    usersToDownload.push(u);
                                }
                            });
                            if (usersToDownload.length != 0) {
                                _logger.logger.log("downloadKeys: downloading for", usersToDownload);
                                var downloadPromise = this._doKeyDownload(usersToDownload);
                                promises.push(downloadPromise);
                            }
                            if (promises.length === 0) {
                                _logger.logger.log("downloadKeys: already have all necessary keys");
                            }
                            return Promise.all(promises).then(function () {
                                return _this4._getDevicesFromStore(userIds);
                            });
                        }
                    }, {
                        key: "_getDevicesFromStore",
                        value: function _getDevicesFromStore(userIds) {
                            var stored = {};
                            var self = this;
                            userIds.map(function (u) {
                                stored[u] = {};
                                var devices = self.getStoredDevicesForUser(u) || [];
                                devices.map(function (dev) {
                                    stored[u][dev.deviceId] = dev;
                                });
                            });
                            return stored;
                        }
                    }, {
                        key: "getKnownUserIds",
                        value: function getKnownUserIds() {
                            return Object.keys(this._devices);
                        }
                    }, {
                        key: "getStoredDevicesForUser",
                        value: function getStoredDevicesForUser(userId) {
                            var devs = this._devices[userId];
                            if (!devs) {
                                return null;
                            }
                            var res = [];
                            for (var deviceId in devs) {
                                if (devs.hasOwnProperty(deviceId)) {
                                    res.push(_deviceinfo.DeviceInfo.fromStorage(devs[deviceId], deviceId));
                                }
                            }
                            return res;
                        }
                    }, {
                        key: "getRawStoredDevicesForUser",
                        value: function getRawStoredDevicesForUser(userId) {
                            return this._devices[userId];
                        }
                    }, {
                        key: "getStoredCrossSigningForUser",
                        value: function getStoredCrossSigningForUser(userId) {
                            if (!this._crossSigningInfo[userId])
                                return null;
                            return _CrossSigning.CrossSigningInfo.fromStorage(this._crossSigningInfo[userId], userId);
                        }
                    }, {
                        key: "storeCrossSigningForUser",
                        value: function storeCrossSigningForUser(userId, info) {
                            this._crossSigningInfo[userId] = info;
                            this._dirty = true;
                        }
                    }, {
                        key: "getStoredDevice",
                        value: function getStoredDevice(userId, deviceId) {
                            var devs = this._devices[userId];
                            if (!devs || !devs[deviceId]) {
                                return undefined;
                            }
                            return _deviceinfo.DeviceInfo.fromStorage(devs[deviceId], deviceId);
                        }
                    }, {
                        key: "getUserByIdentityKey",
                        value: function getUserByIdentityKey(algorithm, senderKey) {
                            if (algorithm !== olmlib.OLM_ALGORITHM && algorithm !== olmlib.MEGOLM_ALGORITHM) {
                                return null;
                            }
                            return this._userByIdentityKey[senderKey];
                        }
                    }, {
                        key: "getDeviceByIdentityKey",
                        value: function getDeviceByIdentityKey(algorithm, senderKey) {
                            var userId = this.getUserByIdentityKey(algorithm, senderKey);
                            if (!userId) {
                                return null;
                            }
                            var devices = this._devices[userId];
                            if (!devices) {
                                return null;
                            }
                            for (var deviceId in devices) {
                                if (!devices.hasOwnProperty(deviceId)) {
                                    continue;
                                }
                                var device = devices[deviceId];
                                for (var keyId in device.keys) {
                                    if (!device.keys.hasOwnProperty(keyId)) {
                                        continue;
                                    }
                                    if (keyId.indexOf("curve25519:") !== 0) {
                                        continue;
                                    }
                                    var deviceKey = device.keys[keyId];
                                    if (deviceKey == senderKey) {
                                        return _deviceinfo.DeviceInfo.fromStorage(device, deviceId);
                                    }
                                }
                            }
                            return null;
                        }
                    }, {
                        key: "storeDevicesForUser",
                        value: function storeDevicesForUser(u, devs) {
                            if (this._devices[u] !== undefined) {
                                for (var _i4 = 0, _Object$entries = Object.entries(this._devices[u]); _i4 < _Object$entries.length; _i4++) {
                                    var _Object$entries$_i = (0, _slicedToArray2["default"])(_Object$entries[_i4], 2), deviceId = _Object$entries$_i[0], dev = _Object$entries$_i[1];
                                    var identityKey = dev.keys['curve25519:' + deviceId];
                                    delete this._userByIdentityKey[identityKey];
                                }
                            }
                            this._devices[u] = devs;
                            for (var _i5 = 0, _Object$entries2 = Object.entries(devs); _i5 < _Object$entries2.length; _i5++) {
                                var _Object$entries2$_i = (0, _slicedToArray2["default"])(_Object$entries2[_i5], 2), _deviceId = _Object$entries2$_i[0], _dev = _Object$entries2$_i[1];
                                var _identityKey = _dev.keys['curve25519:' + _deviceId];
                                this._userByIdentityKey[_identityKey] = u;
                            }
                            this._dirty = true;
                        }
                    }, {
                        key: "startTrackingDeviceList",
                        value: function startTrackingDeviceList(userId) {
                            if (typeof userId !== 'string') {
                                throw new Error('userId must be a string; was ' + userId);
                            }
                            if (!this._deviceTrackingStatus[userId]) {
                                _logger.logger.log('Now tracking device list for ' + userId);
                                this._deviceTrackingStatus[userId] = TRACKING_STATUS_PENDING_DOWNLOAD;
                                this._dirty = true;
                            }
                        }
                    }, {
                        key: "stopTrackingDeviceList",
                        value: function stopTrackingDeviceList(userId) {
                            if (this._deviceTrackingStatus[userId]) {
                                _logger.logger.log('No longer tracking device list for ' + userId);
                                this._deviceTrackingStatus[userId] = TRACKING_STATUS_NOT_TRACKED;
                                this._dirty = true;
                            }
                        }
                    }, {
                        key: "stopTrackingAllDeviceLists",
                        value: function stopTrackingAllDeviceLists() {
                            for (var _i6 = 0, _Object$keys4 = Object.keys(this._deviceTrackingStatus); _i6 < _Object$keys4.length; _i6++) {
                                var userId = _Object$keys4[_i6];
                                this._deviceTrackingStatus[userId] = TRACKING_STATUS_NOT_TRACKED;
                            }
                            this._dirty = true;
                        }
                    }, {
                        key: "invalidateUserDeviceList",
                        value: function invalidateUserDeviceList(userId) {
                            if (this._deviceTrackingStatus[userId]) {
                                _logger.logger.log("Marking device list outdated for", userId);
                                this._deviceTrackingStatus[userId] = TRACKING_STATUS_PENDING_DOWNLOAD;
                                this._dirty = true;
                            }
                        }
                    }, {
                        key: "refreshOutdatedDeviceLists",
                        value: function refreshOutdatedDeviceLists() {
                            this.saveIfDirty();
                            var usersToDownload = [];
                            for (var _i7 = 0, _Object$keys5 = Object.keys(this._deviceTrackingStatus); _i7 < _Object$keys5.length; _i7++) {
                                var userId = _Object$keys5[_i7];
                                var stat = this._deviceTrackingStatus[userId];
                                if (stat == TRACKING_STATUS_PENDING_DOWNLOAD) {
                                    usersToDownload.push(userId);
                                }
                            }
                            return this._doKeyDownload(usersToDownload);
                        }
                    }, {
                        key: "_setRawStoredDevicesForUser",
                        value: function _setRawStoredDevicesForUser(userId, devices) {
                            if (this._devices[userId] !== undefined) {
                                for (var _i8 = 0, _Object$entries3 = Object.entries(this._devices[userId]); _i8 < _Object$entries3.length; _i8++) {
                                    var _Object$entries3$_i = (0, _slicedToArray2["default"])(_Object$entries3[_i8], 2), deviceId = _Object$entries3$_i[0], dev = _Object$entries3$_i[1];
                                    var identityKey = dev.keys['curve25519:' + deviceId];
                                    delete this._userByIdentityKey[identityKey];
                                }
                            }
                            this._devices[userId] = devices;
                            for (var _i9 = 0, _Object$entries4 = Object.entries(devices); _i9 < _Object$entries4.length; _i9++) {
                                var _Object$entries4$_i = (0, _slicedToArray2["default"])(_Object$entries4[_i9], 2), _deviceId2 = _Object$entries4$_i[0], _dev2 = _Object$entries4$_i[1];
                                var _identityKey2 = _dev2.keys['curve25519:' + _deviceId2];
                                this._userByIdentityKey[_identityKey2] = userId;
                            }
                        }
                    }, {
                        key: "setRawStoredCrossSigningForUser",
                        value: function setRawStoredCrossSigningForUser(userId, info) {
                            this._crossSigningInfo[userId] = info;
                        }
                    }, {
                        key: "_doKeyDownload",
                        value: function _doKeyDownload(users) {
                            var _this5 = this;
                            if (users.length === 0) {
                                return Promise.resolve();
                            }
                            var prom = this._serialiser.updateDevicesForUsers(users, this._syncToken).then(function () {
                                finished(true);
                            }, function (e) {
                                _logger.logger.error('Error downloading keys for ' + users + ":", e);
                                finished(false);
                                throw e;
                            });
                            users.forEach(function (u) {
                                _this5._keyDownloadsInProgressByUser[u] = prom;
                                var stat = _this5._deviceTrackingStatus[u];
                                if (stat == TRACKING_STATUS_PENDING_DOWNLOAD) {
                                    _this5._deviceTrackingStatus[u] = TRACKING_STATUS_DOWNLOAD_IN_PROGRESS;
                                }
                            });
                            var finished = function finished(success) {
                                _this5.emit("crypto.willUpdateDevices", users, !_this5._hasFetched);
                                users.forEach(function (u) {
                                    _this5._dirty = true;
                                    if (_this5._keyDownloadsInProgressByUser[u] !== prom) {
                                        _logger.logger.log('Another update in the queue for', u, '- not marking up-to-date');
                                        return;
                                    }
                                    delete _this5._keyDownloadsInProgressByUser[u];
                                    var stat = _this5._deviceTrackingStatus[u];
                                    if (stat == TRACKING_STATUS_DOWNLOAD_IN_PROGRESS) {
                                        if (success) {
                                            _this5._deviceTrackingStatus[u] = TRACKING_STATUS_UP_TO_DATE;
                                            _logger.logger.log("Device list for", u, "now up to date");
                                        }
                                        else {
                                            _this5._deviceTrackingStatus[u] = TRACKING_STATUS_PENDING_DOWNLOAD;
                                        }
                                    }
                                });
                                _this5.saveIfDirty();
                                _this5.emit("crypto.devicesUpdated", users, !_this5._hasFetched);
                                _this5._hasFetched = true;
                            };
                            return prom;
                        }
                    }]);
                return DeviceList;
            }(_events.EventEmitter);
            exports.DeviceList = DeviceList;
            var DeviceListUpdateSerialiser = function () {
                function DeviceListUpdateSerialiser(baseApis, olmDevice, deviceList) {
                    (0, _classCallCheck2["default"])(this, DeviceListUpdateSerialiser);
                    this._baseApis = baseApis;
                    this._olmDevice = olmDevice;
                    this._deviceList = deviceList;
                    this._downloadInProgress = false;
                    this._keyDownloadsQueuedByUser = {};
                    this._queuedQueryDeferred = null;
                    this._syncToken = null;
                }
                (0, _createClass2["default"])(DeviceListUpdateSerialiser, [{
                        key: "updateDevicesForUsers",
                        value: function updateDevicesForUsers(users, syncToken) {
                            var _this6 = this;
                            users.forEach(function (u) {
                                _this6._keyDownloadsQueuedByUser[u] = true;
                            });
                            if (!this._queuedQueryDeferred) {
                                this._queuedQueryDeferred = (0, _utils.defer)();
                            }
                            this._syncToken = syncToken;
                            if (this._downloadInProgress) {
                                _logger.logger.log('Queued key download for', users);
                                return this._queuedQueryDeferred.promise;
                            }
                            return this._doQueuedQueries();
                        }
                    }, {
                        key: "_doQueuedQueries",
                        value: function _doQueuedQueries() {
                            var _this7 = this;
                            if (this._downloadInProgress) {
                                throw new Error("DeviceListUpdateSerialiser._doQueuedQueries called with request active");
                            }
                            var downloadUsers = Object.keys(this._keyDownloadsQueuedByUser);
                            this._keyDownloadsQueuedByUser = {};
                            var deferred = this._queuedQueryDeferred;
                            this._queuedQueryDeferred = null;
                            _logger.logger.log('Starting key download for', downloadUsers);
                            this._downloadInProgress = true;
                            var opts = {};
                            if (this._syncToken) {
                                opts.token = this._syncToken;
                            }
                            this._baseApis.downloadKeysForUsers(downloadUsers, opts).then(function () {
                                var _ref = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee3(res) {
                                    var dk, masterKeys, ssks, usks, _iterator, _step, userId;
                                    return _regenerator["default"].wrap(function _callee3$(_context3) {
                                        while (1) {
                                            switch (_context3.prev = _context3.next) {
                                                case 0:
                                                    dk = res.device_keys || {};
                                                    masterKeys = res.master_keys || {};
                                                    ssks = res.self_signing_keys || {};
                                                    usks = res.user_signing_keys || {};
                                                    _iterator = _createForOfIteratorHelper(downloadUsers);
                                                    _context3.prev = 5;
                                                    _iterator.s();
                                                case 7:
                                                    if ((_step = _iterator.n()).done) {
                                                        _context3.next = 21;
                                                        break;
                                                    }
                                                    userId = _step.value;
                                                    _context3.next = 11;
                                                    return (0, _utils.sleep)(5);
                                                case 11:
                                                    _context3.prev = 11;
                                                    _context3.next = 14;
                                                    return _this7._processQueryResponseForUser(userId, dk[userId], {
                                                        master: masterKeys[userId],
                                                        self_signing: ssks[userId],
                                                        user_signing: usks[userId]
                                                    });
                                                case 14:
                                                    _context3.next = 19;
                                                    break;
                                                case 16:
                                                    _context3.prev = 16;
                                                    _context3.t0 = _context3["catch"](11);
                                                    _logger.logger.error("Error processing keys for ".concat(userId, ":"), _context3.t0);
                                                case 19:
                                                    _context3.next = 7;
                                                    break;
                                                case 21:
                                                    _context3.next = 26;
                                                    break;
                                                case 23:
                                                    _context3.prev = 23;
                                                    _context3.t1 = _context3["catch"](5);
                                                    _iterator.e(_context3.t1);
                                                case 26:
                                                    _context3.prev = 26;
                                                    _iterator.f();
                                                    return _context3.finish(26);
                                                case 29:
                                                case "end":
                                                    return _context3.stop();
                                            }
                                        }
                                    }, _callee3, null, [[5, 23, 26, 29], [11, 16]]);
                                }));
                                return function (_x2) {
                                    return _ref.apply(this, arguments);
                                };
                            }()).then(function () {
                                _logger.logger.log('Completed key download for ' + downloadUsers);
                                _this7._downloadInProgress = false;
                                deferred.resolve();
                                if (_this7._queuedQueryDeferred) {
                                    _this7._doQueuedQueries();
                                }
                            }, function (e) {
                                _logger.logger.warn('Error downloading keys for ' + downloadUsers + ':', e);
                                _this7._downloadInProgress = false;
                                deferred.reject(e);
                            });
                            return deferred.promise;
                        }
                    }, {
                        key: "_processQueryResponseForUser",
                        value: function () {
                            var _processQueryResponseForUser2 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee4(userId, dkResponse, crossSigningResponse) {
                                var userStore, devs, storage, crossSigning;
                                return _regenerator["default"].wrap(function _callee4$(_context4) {
                                    while (1) {
                                        switch (_context4.prev = _context4.next) {
                                            case 0:
                                                _logger.logger.log('got device keys for ' + userId + ':', dkResponse);
                                                _logger.logger.log('got cross-signing keys for ' + userId + ':', crossSigningResponse);
                                                userStore = {};
                                                devs = this._deviceList.getRawStoredDevicesForUser(userId);
                                                if (devs) {
                                                    Object.keys(devs).forEach(function (deviceId) {
                                                        var d = _deviceinfo.DeviceInfo.fromStorage(devs[deviceId], deviceId);
                                                        userStore[deviceId] = d;
                                                    });
                                                }
                                                _context4.next = 7;
                                                return _updateStoredDeviceKeysForUser(this._olmDevice, userId, userStore, dkResponse || {}, this._baseApis.getUserId(), this._baseApis.deviceId);
                                            case 7:
                                                storage = {};
                                                Object.keys(userStore).forEach(function (deviceId) {
                                                    storage[deviceId] = userStore[deviceId].toStorage();
                                                });
                                                this._deviceList._setRawStoredDevicesForUser(userId, storage);
                                                if (crossSigningResponse && (crossSigningResponse.master || crossSigningResponse.self_signing || crossSigningResponse.user_signing)) {
                                                    crossSigning = this._deviceList.getStoredCrossSigningForUser(userId) || new _CrossSigning.CrossSigningInfo(userId);
                                                    crossSigning.setKeys(crossSigningResponse);
                                                    this._deviceList.setRawStoredCrossSigningForUser(userId, crossSigning.toStorage());
                                                    this._deviceList.emit('userCrossSigningUpdated', userId);
                                                }
                                            case 11:
                                            case "end":
                                                return _context4.stop();
                                        }
                                    }
                                }, _callee4, this);
                            }));
                            function _processQueryResponseForUser(_x3, _x4, _x5) {
                                return _processQueryResponseForUser2.apply(this, arguments);
                            }
                            return _processQueryResponseForUser;
                        }()
                    }]);
                return DeviceListUpdateSerialiser;
            }();
            function _updateStoredDeviceKeysForUser(_x6, _x7, _x8, _x9, _x10, _x11) {
                return _updateStoredDeviceKeysForUser2.apply(this, arguments);
            }
            function _updateStoredDeviceKeysForUser2() {
                _updateStoredDeviceKeysForUser2 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee5(_olmDevice, userId, userStore, userResult, localUserId, localDeviceId) {
                    var updated, deviceId, _deviceId3, deviceResult;
                    return _regenerator["default"].wrap(function _callee5$(_context5) {
                        while (1) {
                            switch (_context5.prev = _context5.next) {
                                case 0:
                                    updated = false;
                                    _context5.t0 = _regenerator["default"].keys(userStore);
                                case 2:
                                    if ((_context5.t1 = _context5.t0()).done) {
                                        _context5.next = 15;
                                        break;
                                    }
                                    deviceId = _context5.t1.value;
                                    if (userStore.hasOwnProperty(deviceId)) {
                                        _context5.next = 6;
                                        break;
                                    }
                                    return _context5.abrupt("continue", 2);
                                case 6:
                                    if (deviceId in userResult) {
                                        _context5.next = 13;
                                        break;
                                    }
                                    if (!(userId === localUserId && deviceId === localDeviceId)) {
                                        _context5.next = 10;
                                        break;
                                    }
                                    _logger.logger.warn("Local device ".concat(deviceId, " missing from sync, skipping removal"));
                                    return _context5.abrupt("continue", 2);
                                case 10:
                                    _logger.logger.log("Device " + userId + ":" + deviceId + " has been removed");
                                    delete userStore[deviceId];
                                    updated = true;
                                case 13:
                                    _context5.next = 2;
                                    break;
                                case 15:
                                    _context5.t2 = _regenerator["default"].keys(userResult);
                                case 16:
                                    if ((_context5.t3 = _context5.t2()).done) {
                                        _context5.next = 33;
                                        break;
                                    }
                                    _deviceId3 = _context5.t3.value;
                                    if (userResult.hasOwnProperty(_deviceId3)) {
                                        _context5.next = 20;
                                        break;
                                    }
                                    return _context5.abrupt("continue", 16);
                                case 20:
                                    deviceResult = userResult[_deviceId3];
                                    if (!(deviceResult.user_id !== userId)) {
                                        _context5.next = 24;
                                        break;
                                    }
                                    _logger.logger.warn("Mismatched user_id " + deviceResult.user_id + " in keys from " + userId + ":" + _deviceId3);
                                    return _context5.abrupt("continue", 16);
                                case 24:
                                    if (!(deviceResult.device_id !== _deviceId3)) {
                                        _context5.next = 27;
                                        break;
                                    }
                                    _logger.logger.warn("Mismatched device_id " + deviceResult.device_id + " in keys from " + userId + ":" + _deviceId3);
                                    return _context5.abrupt("continue", 16);
                                case 27:
                                    _context5.next = 29;
                                    return _storeDeviceKeys(_olmDevice, userStore, deviceResult);
                                case 29:
                                    if (!_context5.sent) {
                                        _context5.next = 31;
                                        break;
                                    }
                                    updated = true;
                                case 31:
                                    _context5.next = 16;
                                    break;
                                case 33:
                                    return _context5.abrupt("return", updated);
                                case 34:
                                case "end":
                                    return _context5.stop();
                            }
                        }
                    }, _callee5);
                }));
                return _updateStoredDeviceKeysForUser2.apply(this, arguments);
            }
            function _storeDeviceKeys(_x12, _x13, _x14) {
                return _storeDeviceKeys2.apply(this, arguments);
            }
            function _storeDeviceKeys2() {
                _storeDeviceKeys2 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee6(_olmDevice, userStore, deviceResult) {
                    var deviceId, userId, signKeyId, signKey, unsigned, signatures, deviceStore;
                    return _regenerator["default"].wrap(function _callee6$(_context6) {
                        while (1) {
                            switch (_context6.prev = _context6.next) {
                                case 0:
                                    if (deviceResult.keys) {
                                        _context6.next = 2;
                                        break;
                                    }
                                    return _context6.abrupt("return", false);
                                case 2:
                                    deviceId = deviceResult.device_id;
                                    userId = deviceResult.user_id;
                                    signKeyId = "ed25519:" + deviceId;
                                    signKey = deviceResult.keys[signKeyId];
                                    if (signKey) {
                                        _context6.next = 9;
                                        break;
                                    }
                                    _logger.logger.warn("Device " + userId + ":" + deviceId + " has no ed25519 key");
                                    return _context6.abrupt("return", false);
                                case 9:
                                    unsigned = deviceResult.unsigned || {};
                                    signatures = deviceResult.signatures || {};
                                    _context6.prev = 11;
                                    _context6.next = 14;
                                    return olmlib.verifySignature(_olmDevice, deviceResult, userId, deviceId, signKey);
                                case 14:
                                    _context6.next = 20;
                                    break;
                                case 16:
                                    _context6.prev = 16;
                                    _context6.t0 = _context6["catch"](11);
                                    _logger.logger.warn("Unable to verify signature on device " + userId + ":" + deviceId + ":" + _context6.t0);
                                    return _context6.abrupt("return", false);
                                case 20:
                                    if (!(deviceId in userStore)) {
                                        _context6.next = 27;
                                        break;
                                    }
                                    deviceStore = userStore[deviceId];
                                    if (!(deviceStore.getFingerprint() != signKey)) {
                                        _context6.next = 25;
                                        break;
                                    }
                                    _logger.logger.warn("Ed25519 key for device " + userId + ":" + deviceId + " has changed");
                                    return _context6.abrupt("return", false);
                                case 25:
                                    _context6.next = 28;
                                    break;
                                case 27:
                                    userStore[deviceId] = deviceStore = new _deviceinfo.DeviceInfo(deviceId);
                                case 28:
                                    deviceStore.keys = deviceResult.keys || {};
                                    deviceStore.algorithms = deviceResult.algorithms || [];
                                    deviceStore.unsigned = unsigned;
                                    deviceStore.signatures = signatures;
                                    return _context6.abrupt("return", true);
                                case 33:
                                case "end":
                                    return _context6.stop();
                            }
                        }
                    }, _callee6, null, [[11, 16]]);
                }));
                return _storeDeviceKeys2.apply(this, arguments);
            }
        }, { "../logger": 97, "../utils": 125, "./CrossSigning": 61, "./deviceinfo": 74, "./olmlib": 77, "./store/indexeddb-crypto-store": 80, "@babel/runtime/helpers/assertThisInitialized": 4, "@babel/runtime/helpers/asyncToGenerator": 5, "@babel/runtime/helpers/classCallCheck": 6, "@babel/runtime/helpers/createClass": 8, "@babel/runtime/helpers/getPrototypeOf": 10, "@babel/runtime/helpers/inherits": 11, "@babel/runtime/helpers/interopRequireDefault": 12, "@babel/runtime/helpers/interopRequireWildcard": 13, "@babel/runtime/helpers/possibleConstructorReturn": 20, "@babel/runtime/helpers/slicedToArray": 22, "@babel/runtime/regenerator": 27, "events": 36 }], 63: [function (require, module, exports) {
            "use strict";
            var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.EncryptionSetupOperation = exports.EncryptionSetupBuilder = void 0;
            var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
            var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
            var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
            var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
            var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
            var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
            var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
            var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
            var _logger = require("../logger");
            var _event = require("../models/event");
            var _events = require("events");
            var _CrossSigning = require("./CrossSigning");
            var _indexeddbCryptoStore = require("./store/indexeddb-crypto-store");
            var _httpApi = require("../http-api");
            function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) {
                var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor;
                result = Reflect.construct(Super, arguments, NewTarget);
            }
            else {
                result = Super.apply(this, arguments);
            } return (0, _possibleConstructorReturn2["default"])(this, result); }; }
            function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct)
                return false; if (Reflect.construct.sham)
                return false; if (typeof Proxy === "function")
                return true; try {
                Date.prototype.toString.call(Reflect.construct(Date, [], function () { }));
                return true;
            }
            catch (e) {
                return false;
            } }
            function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
                if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                    if (it)
                        o = it;
                    var i = 0;
                    var F = function F() { };
                    return { s: F, n: function n() { if (i >= o.length)
                            return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try {
                    if (!normalCompletion && it["return"] != null)
                        it["return"]();
                }
                finally {
                    if (didErr)
                        throw err;
                } } }; }
            function _unsupportedIterableToArray(o, minLen) { if (!o)
                return; if (typeof o === "string")
                return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor)
                n = o.constructor.name; if (n === "Map" || n === "Set")
                return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return _arrayLikeToArray(o, minLen); }
            function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length)
                len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
            } return arr2; }
            var EncryptionSetupBuilder = function () {
                function EncryptionSetupBuilder(accountData, delegateCryptoCallbacks) {
                    (0, _classCallCheck2["default"])(this, EncryptionSetupBuilder);
                    this.accountDataClientAdapter = new AccountDataClientAdapter(accountData);
                    this.crossSigningCallbacks = new CrossSigningCallbacks();
                    this.ssssCryptoCallbacks = new SSSSCryptoCallbacks(delegateCryptoCallbacks);
                    this._crossSigningKeys = null;
                    this._keySignatures = null;
                    this._keyBackupInfo = null;
                }
                (0, _createClass2["default"])(EncryptionSetupBuilder, [{
                        key: "addCrossSigningKeys",
                        value: function addCrossSigningKeys(authUpload, keys) {
                            this._crossSigningKeys = {
                                authUpload: authUpload,
                                keys: keys
                            };
                        }
                    }, {
                        key: "addSessionBackup",
                        value: function addSessionBackup(keyBackupInfo) {
                            this._keyBackupInfo = keyBackupInfo;
                        }
                    }, {
                        key: "addSessionBackupPrivateKeyToCache",
                        value: function addSessionBackupPrivateKeyToCache(privateKey) {
                            this._sessionBackupPrivateKey = privateKey;
                        }
                    }, {
                        key: "addKeySignature",
                        value: function addKeySignature(userId, deviceId, signature) {
                            if (!this._keySignatures) {
                                this._keySignatures = {};
                            }
                            var userSignatures = this._keySignatures[userId] || {};
                            this._keySignatures[userId] = userSignatures;
                            userSignatures[deviceId] = signature;
                        }
                    }, {
                        key: "setAccountData",
                        value: function setAccountData(type, content) {
                            return this.accountDataClientAdapter.setAccountData(type, content);
                        }
                    }, {
                        key: "buildOperation",
                        value: function buildOperation() {
                            var accountData = this.accountDataClientAdapter._values;
                            return new EncryptionSetupOperation(accountData, this._crossSigningKeys, this._keyBackupInfo, this._keySignatures);
                        }
                    }, {
                        key: "persist",
                        value: function () {
                            var _persist = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee(crypto) {
                                var _this = this;
                                var cacheCallbacks, _i, _arr, type, privateKey;
                                return _regenerator["default"].wrap(function _callee$(_context) {
                                    while (1) {
                                        switch (_context.prev = _context.next) {
                                            case 0:
                                                if (!this._crossSigningKeys) {
                                                    _context.next = 14;
                                                    break;
                                                }
                                                cacheCallbacks = (0, _CrossSigning.createCryptoStoreCacheCallbacks)(crypto._cryptoStore, crypto._olmDevice);
                                                _i = 0, _arr = ["master", "self_signing", "user_signing"];
                                            case 3:
                                                if (!(_i < _arr.length)) {
                                                    _context.next = 12;
                                                    break;
                                                }
                                                type = _arr[_i];
                                                _logger.logger.log("Cache ".concat(type, " cross-signing private key locally"));
                                                privateKey = this.crossSigningCallbacks.privateKeys.get(type);
                                                _context.next = 9;
                                                return cacheCallbacks.storeCrossSigningKeyCache(type, privateKey);
                                            case 9:
                                                _i++;
                                                _context.next = 3;
                                                break;
                                            case 12:
                                                _context.next = 14;
                                                return crypto._cryptoStore.doTxn('readwrite', [_indexeddbCryptoStore.IndexedDBCryptoStore.STORE_ACCOUNT], function (txn) {
                                                    crypto._cryptoStore.storeCrossSigningKeys(txn, _this._crossSigningKeys.keys);
                                                });
                                            case 14:
                                                if (!this._sessionBackupPrivateKey) {
                                                    _context.next = 17;
                                                    break;
                                                }
                                                _context.next = 17;
                                                return crypto.storeSessionBackupPrivateKey(this._sessionBackupPrivateKey);
                                            case 17:
                                            case "end":
                                                return _context.stop();
                                        }
                                    }
                                }, _callee, this);
                            }));
                            function persist(_x) {
                                return _persist.apply(this, arguments);
                            }
                            return persist;
                        }()
                    }]);
                return EncryptionSetupBuilder;
            }();
            exports.EncryptionSetupBuilder = EncryptionSetupBuilder;
            var EncryptionSetupOperation = function () {
                function EncryptionSetupOperation(accountData, crossSigningKeys, keyBackupInfo, keySignatures) {
                    (0, _classCallCheck2["default"])(this, EncryptionSetupOperation);
                    this._accountData = accountData;
                    this._crossSigningKeys = crossSigningKeys;
                    this._keyBackupInfo = keyBackupInfo;
                    this._keySignatures = keySignatures;
                }
                (0, _createClass2["default"])(EncryptionSetupOperation, [{
                        key: "apply",
                        value: function () {
                            var _apply = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee2(crypto) {
                                var baseApis, keys, _i2, _Object$entries, _Object$entries$_i, name, key, _iterator, _step, _step$value, type, content;
                                return _regenerator["default"].wrap(function _callee2$(_context2) {
                                    while (1) {
                                        switch (_context2.prev = _context2.next) {
                                            case 0:
                                                baseApis = crypto._baseApis;
                                                if (!this._crossSigningKeys) {
                                                    _context2.next = 7;
                                                    break;
                                                }
                                                keys = {};
                                                for (_i2 = 0, _Object$entries = Object.entries(this._crossSigningKeys.keys); _i2 < _Object$entries.length; _i2++) {
                                                    _Object$entries$_i = (0, _slicedToArray2["default"])(_Object$entries[_i2], 2), name = _Object$entries$_i[0], key = _Object$entries$_i[1];
                                                    keys[name + "_key"] = key;
                                                }
                                                _context2.next = 6;
                                                return this._crossSigningKeys.authUpload(function (authDict) {
                                                    return baseApis.uploadDeviceSigningKeys(authDict, keys);
                                                });
                                            case 6:
                                                crypto._crossSigningInfo.setKeys(this._crossSigningKeys.keys);
                                            case 7:
                                                if (!this._accountData) {
                                                    _context2.next = 25;
                                                    break;
                                                }
                                                _iterator = _createForOfIteratorHelper(this._accountData);
                                                _context2.prev = 9;
                                                _iterator.s();
                                            case 11:
                                                if ((_step = _iterator.n()).done) {
                                                    _context2.next = 17;
                                                    break;
                                                }
                                                _step$value = (0, _slicedToArray2["default"])(_step.value, 2), type = _step$value[0], content = _step$value[1];
                                                _context2.next = 15;
                                                return baseApis.setAccountData(type, content);
                                            case 15:
                                                _context2.next = 11;
                                                break;
                                            case 17:
                                                _context2.next = 22;
                                                break;
                                            case 19:
                                                _context2.prev = 19;
                                                _context2.t0 = _context2["catch"](9);
                                                _iterator.e(_context2.t0);
                                            case 22:
                                                _context2.prev = 22;
                                                _iterator.f();
                                                return _context2.finish(22);
                                            case 25:
                                                if (!this._keySignatures) {
                                                    _context2.next = 28;
                                                    break;
                                                }
                                                _context2.next = 28;
                                                return baseApis.uploadKeySignatures(this._keySignatures);
                                            case 28:
                                                if (!this._keyBackupInfo) {
                                                    _context2.next = 36;
                                                    break;
                                                }
                                                if (!this._keyBackupInfo.version) {
                                                    _context2.next = 34;
                                                    break;
                                                }
                                                _context2.next = 32;
                                                return baseApis._http.authedRequest(undefined, "PUT", "/room_keys/version/" + this._keyBackupInfo.version, undefined, {
                                                    algorithm: this._keyBackupInfo.algorithm,
                                                    auth_data: this._keyBackupInfo.auth_data
                                                }, {
                                                    prefix: _httpApi.PREFIX_UNSTABLE
                                                });
                                            case 32:
                                                _context2.next = 36;
                                                break;
                                            case 34:
                                                _context2.next = 36;
                                                return baseApis._http.authedRequest(undefined, "POST", "/room_keys/version", undefined, this._keyBackupInfo, {
                                                    prefix: _httpApi.PREFIX_UNSTABLE
                                                });
                                            case 36:
                                            case "end":
                                                return _context2.stop();
                                        }
                                    }
                                }, _callee2, this, [[9, 19, 22, 25]]);
                            }));
                            function apply(_x2) {
                                return _apply.apply(this, arguments);
                            }
                            return apply;
                        }()
                    }]);
                return EncryptionSetupOperation;
            }();
            exports.EncryptionSetupOperation = EncryptionSetupOperation;
            var AccountDataClientAdapter = function (_EventEmitter) {
                (0, _inherits2["default"])(AccountDataClientAdapter, _EventEmitter);
                var _super = _createSuper(AccountDataClientAdapter);
                function AccountDataClientAdapter(accountData) {
                    var _this2;
                    (0, _classCallCheck2["default"])(this, AccountDataClientAdapter);
                    _this2 = _super.call(this);
                    _this2._existingValues = accountData;
                    _this2._values = new Map();
                    return _this2;
                }
                (0, _createClass2["default"])(AccountDataClientAdapter, [{
                        key: "getAccountDataFromServer",
                        value: function getAccountDataFromServer(type) {
                            return Promise.resolve(this.getAccountData(type));
                        }
                    }, {
                        key: "getAccountData",
                        value: function getAccountData(type) {
                            var modifiedValue = this._values.get(type);
                            if (modifiedValue) {
                                return modifiedValue;
                            }
                            var existingValue = this._existingValues[type];
                            if (existingValue) {
                                return existingValue.getContent();
                            }
                            return null;
                        }
                    }, {
                        key: "setAccountData",
                        value: function setAccountData(type, content) {
                            var _this3 = this;
                            var lastEvent = this._values.get(type);
                            this._values.set(type, content);
                            return Promise.resolve().then(function () {
                                var event = new _event.MatrixEvent({
                                    type: type,
                                    content: content
                                });
                                _this3.emit("accountData", event, lastEvent);
                            });
                        }
                    }]);
                return AccountDataClientAdapter;
            }(_events.EventEmitter);
            var CrossSigningCallbacks = function () {
                function CrossSigningCallbacks() {
                    (0, _classCallCheck2["default"])(this, CrossSigningCallbacks);
                    this.privateKeys = new Map();
                }
                (0, _createClass2["default"])(CrossSigningCallbacks, [{
                        key: "getCrossSigningKeyCache",
                        value: function getCrossSigningKeyCache(type, expectedPublicKey) {
                            return this.getCrossSigningKey(type, expectedPublicKey);
                        }
                    }, {
                        key: "storeCrossSigningKeyCache",
                        value: function storeCrossSigningKeyCache(type, key) {
                            this.privateKeys.set(type, key);
                            return Promise.resolve();
                        }
                    }, {
                        key: "getCrossSigningKey",
                        value: function getCrossSigningKey(type, _expectedPubkey) {
                            return Promise.resolve(this.privateKeys.get(type));
                        }
                    }, {
                        key: "saveCrossSigningKeys",
                        value: function saveCrossSigningKeys(privateKeys) {
                            for (var _i3 = 0, _Object$entries2 = Object.entries(privateKeys); _i3 < _Object$entries2.length; _i3++) {
                                var _Object$entries2$_i = (0, _slicedToArray2["default"])(_Object$entries2[_i3], 2), type = _Object$entries2$_i[0], privateKey = _Object$entries2$_i[1];
                                this.privateKeys.set(type, privateKey);
                            }
                        }
                    }]);
                return CrossSigningCallbacks;
            }();
            var SSSSCryptoCallbacks = function () {
                function SSSSCryptoCallbacks(delegateCryptoCallbacks) {
                    (0, _classCallCheck2["default"])(this, SSSSCryptoCallbacks);
                    this._privateKeys = new Map();
                    this._delegateCryptoCallbacks = delegateCryptoCallbacks;
                }
                (0, _createClass2["default"])(SSSSCryptoCallbacks, [{
                        key: "getSecretStorageKey",
                        value: function () {
                            var _getSecretStorageKey = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee3(_ref, name) {
                                var keys, _i4, _Object$keys, keyId, privateKey, result, _result, _keyId, _privateKey;
                                return _regenerator["default"].wrap(function _callee3$(_context3) {
                                    while (1) {
                                        switch (_context3.prev = _context3.next) {
                                            case 0:
                                                keys = _ref.keys;
                                                _i4 = 0, _Object$keys = Object.keys(keys);
                                            case 2:
                                                if (!(_i4 < _Object$keys.length)) {
                                                    _context3.next = 10;
                                                    break;
                                                }
                                                keyId = _Object$keys[_i4];
                                                privateKey = this._privateKeys.get(keyId);
                                                if (!privateKey) {
                                                    _context3.next = 7;
                                                    break;
                                                }
                                                return _context3.abrupt("return", [keyId, privateKey]);
                                            case 7:
                                                _i4++;
                                                _context3.next = 2;
                                                break;
                                            case 10:
                                                if (!this._delegateCryptoCallbacks) {
                                                    _context3.next = 16;
                                                    break;
                                                }
                                                _context3.next = 13;
                                                return this._delegateCryptoCallbacks.getSecretStorageKey({
                                                    keys: keys
                                                }, name);
                                            case 13:
                                                result = _context3.sent;
                                                if (result) {
                                                    _result = (0, _slicedToArray2["default"])(result, 2), _keyId = _result[0], _privateKey = _result[1];
                                                    this._privateKeys.set(_keyId, _privateKey);
                                                }
                                                return _context3.abrupt("return", result);
                                            case 16:
                                            case "end":
                                                return _context3.stop();
                                        }
                                    }
                                }, _callee3, this);
                            }));
                            function getSecretStorageKey(_x3, _x4) {
                                return _getSecretStorageKey.apply(this, arguments);
                            }
                            return getSecretStorageKey;
                        }()
                    }, {
                        key: "addPrivateKey",
                        value: function addPrivateKey(keyId, keyInfo, privKey) {
                            this._privateKeys.set(keyId, privKey);
                            if (this._delegateCryptoCallbacks && this._delegateCryptoCallbacks.cacheSecretStorageKey) {
                                this._delegateCryptoCallbacks.cacheSecretStorageKey(keyId, keyInfo, privKey);
                            }
                        }
                    }]);
                return SSSSCryptoCallbacks;
            }();
        }, { "../http-api": 94, "../logger": 97, "../models/event": 102, "./CrossSigning": 61, "./store/indexeddb-crypto-store": 80, "@babel/runtime/helpers/asyncToGenerator": 5, "@babel/runtime/helpers/classCallCheck": 6, "@babel/runtime/helpers/createClass": 8, "@babel/runtime/helpers/getPrototypeOf": 10, "@babel/runtime/helpers/inherits": 11, "@babel/runtime/helpers/interopRequireDefault": 12, "@babel/runtime/helpers/possibleConstructorReturn": 20, "@babel/runtime/helpers/slicedToArray": 22, "@babel/runtime/regenerator": 27, "events": 36 }], 64: [function (require, module, exports) {
            (function (global) {
                (function () {
                    "use strict";
                    var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
                    var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
                    Object.defineProperty(exports, "__esModule", {
                        value: true
                    });
                    exports.OlmDevice = OlmDevice;
                    exports.WITHHELD_MESSAGES = void 0;
                    var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
                    var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
                    var _logger = require("../logger");
                    var _indexeddbCryptoStore = require("./store/indexeddb-crypto-store");
                    var algorithms = _interopRequireWildcard(require("./algorithms"));
                    function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
                        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                            if (it)
                                o = it;
                            var i = 0;
                            var F = function F() { };
                            return { s: F, n: function n() { if (i >= o.length)
                                    return { done: true }; return { done: false, value: o[i++] }; }, e: function (_e) { function e(_x62) { return _e.apply(this, arguments); } e.toString = function () { return _e.toString(); }; return e; }(function (e) { throw e; }), f: F };
                        }
                        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                    } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function (_e2) { function e(_x63) { return _e2.apply(this, arguments); } e.toString = function () { return _e2.toString(); }; return e; }(function (e) { didErr = true; err = e; }), f: function f() { try {
                            if (!normalCompletion && it["return"] != null)
                                it["return"]();
                        }
                        finally {
                            if (didErr)
                                throw err;
                        } } }; }
                    function _unsupportedIterableToArray(o, minLen) { if (!o)
                        return; if (typeof o === "string")
                        return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor)
                        n = o.constructor.name; if (n === "Map" || n === "Set")
                        return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                        return _arrayLikeToArray(o, minLen); }
                    function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length)
                        len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) {
                        arr2[i] = arr[i];
                    } return arr2; }
                    var MAX_PLAINTEXT_LENGTH = 65536 * 3 / 4;
                    function checkPayloadLength(payloadString) {
                        if (payloadString === undefined) {
                            throw new Error("payloadString undefined");
                        }
                        if (payloadString.length > MAX_PLAINTEXT_LENGTH) {
                            var err = new Error("Message too long (" + payloadString.length + " bytes). " + "The maximum for an encrypted message is " + MAX_PLAINTEXT_LENGTH + " bytes.");
                            err.data = {
                                errcode: "M_TOO_LARGE",
                                error: "Payload too large for encrypted message"
                            };
                            throw err;
                        }
                    }
                    function OlmDevice(cryptoStore) {
                        this._cryptoStore = cryptoStore;
                        this._pickleKey = "DEFAULT_KEY";
                        this.deviceCurve25519Key = null;
                        this.deviceEd25519Key = null;
                        this._maxOneTimeKeys = null;
                        this._outboundGroupSessionStore = {};
                        this._inboundGroupSessionMessageIndexes = {};
                        this._sessionsInProgress = {};
                        this._olmPrekeyPromise = Promise.resolve();
                    }
                    OlmDevice.prototype.init = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee() {
                        var opts, e2eKeys, account, pickleKey, fromExportedDevice, _args = arguments;
                        return _regenerator["default"].wrap(function _callee$(_context) {
                            while (1) {
                                switch (_context.prev = _context.next) {
                                    case 0:
                                        opts = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};
                                        account = new global.Olm.Account();
                                        pickleKey = opts.pickleKey, fromExportedDevice = opts.fromExportedDevice;
                                        _context.prev = 3;
                                        if (!fromExportedDevice) {
                                            _context.next = 11;
                                            break;
                                        }
                                        if (pickleKey) {
                                            _logger.logger.warn('ignoring opts.pickleKey' + ' because opts.fromExportedDevice is present.');
                                        }
                                        this._pickleKey = fromExportedDevice.pickleKey;
                                        _context.next = 9;
                                        return _initialiseFromExportedDevice(fromExportedDevice, this._cryptoStore, this._pickleKey, account);
                                    case 9:
                                        _context.next = 14;
                                        break;
                                    case 11:
                                        if (pickleKey) {
                                            this._pickleKey = pickleKey;
                                        }
                                        _context.next = 14;
                                        return _initialiseAccount(this._cryptoStore, this._pickleKey, account);
                                    case 14:
                                        e2eKeys = JSON.parse(account.identity_keys());
                                        this._maxOneTimeKeys = account.max_number_of_one_time_keys();
                                    case 16:
                                        _context.prev = 16;
                                        account.free();
                                        return _context.finish(16);
                                    case 19:
                                        this.deviceCurve25519Key = e2eKeys.curve25519;
                                        this.deviceEd25519Key = e2eKeys.ed25519;
                                    case 21:
                                    case "end":
                                        return _context.stop();
                                }
                            }
                        }, _callee, this, [[3, , 16, 19]]);
                    }));
                    function _initialiseFromExportedDevice(_x, _x2, _x3, _x4) {
                        return _initialiseFromExportedDevice2.apply(this, arguments);
                    }
                    function _initialiseFromExportedDevice2() {
                        _initialiseFromExportedDevice2 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee24(exportedData, cryptoStore, pickleKey, account) {
                            return _regenerator["default"].wrap(function _callee24$(_context24) {
                                while (1) {
                                    switch (_context24.prev = _context24.next) {
                                        case 0:
                                            _context24.next = 2;
                                            return cryptoStore.doTxn('readwrite', [_indexeddbCryptoStore.IndexedDBCryptoStore.STORE_ACCOUNT, _indexeddbCryptoStore.IndexedDBCryptoStore.STORE_SESSIONS], function (txn) {
                                                cryptoStore.storeAccount(txn, exportedData.pickledAccount);
                                                exportedData.sessions.forEach(function (session) {
                                                    var deviceKey = session.deviceKey, sessionId = session.sessionId;
                                                    var sessionInfo = {
                                                        session: session.session,
                                                        lastReceivedMessageTs: session.lastReceivedMessageTs
                                                    };
                                                    cryptoStore.storeEndToEndSession(deviceKey, sessionId, sessionInfo, txn);
                                                });
                                            });
                                        case 2:
                                            account.unpickle(pickleKey, exportedData.pickledAccount);
                                        case 3:
                                        case "end":
                                            return _context24.stop();
                                    }
                                }
                            }, _callee24);
                        }));
                        return _initialiseFromExportedDevice2.apply(this, arguments);
                    }
                    function _initialiseAccount(_x5, _x6, _x7) {
                        return _initialiseAccount2.apply(this, arguments);
                    }
                    function _initialiseAccount2() {
                        _initialiseAccount2 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee25(cryptoStore, pickleKey, account) {
                            return _regenerator["default"].wrap(function _callee25$(_context25) {
                                while (1) {
                                    switch (_context25.prev = _context25.next) {
                                        case 0:
                                            _context25.next = 2;
                                            return cryptoStore.doTxn('readwrite', [_indexeddbCryptoStore.IndexedDBCryptoStore.STORE_ACCOUNT], function (txn) {
                                                cryptoStore.getAccount(txn, function (pickledAccount) {
                                                    if (pickledAccount !== null) {
                                                        account.unpickle(pickleKey, pickledAccount);
                                                    }
                                                    else {
                                                        account.create();
                                                        pickledAccount = account.pickle(pickleKey);
                                                        cryptoStore.storeAccount(txn, pickledAccount);
                                                    }
                                                });
                                            });
                                        case 2:
                                        case "end":
                                            return _context25.stop();
                                    }
                                }
                            }, _callee25);
                        }));
                        return _initialiseAccount2.apply(this, arguments);
                    }
                    OlmDevice.getOlmVersion = function () {
                        return global.Olm.get_library_version();
                    };
                    OlmDevice.prototype._getAccount = function (txn, func) {
                        var _this = this;
                        this._cryptoStore.getAccount(txn, function (pickledAccount) {
                            var account = new global.Olm.Account();
                            try {
                                account.unpickle(_this._pickleKey, pickledAccount);
                                func(account);
                            }
                            finally {
                                account.free();
                            }
                        });
                    };
                    OlmDevice.prototype._storeAccount = function (txn, account) {
                        this._cryptoStore.storeAccount(txn, account.pickle(this._pickleKey));
                    };
                    OlmDevice.prototype["export"] = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee2() {
                        var _this2 = this;
                        var result;
                        return _regenerator["default"].wrap(function _callee2$(_context2) {
                            while (1) {
                                switch (_context2.prev = _context2.next) {
                                    case 0:
                                        result = {
                                            pickleKey: this._pickleKey
                                        };
                                        _context2.next = 3;
                                        return this._cryptoStore.doTxn('readonly', [_indexeddbCryptoStore.IndexedDBCryptoStore.STORE_ACCOUNT, _indexeddbCryptoStore.IndexedDBCryptoStore.STORE_SESSIONS], function (txn) {
                                            _this2._cryptoStore.getAccount(txn, function (pickledAccount) {
                                                result.pickledAccount = pickledAccount;
                                            });
                                            result.sessions = [];
                                            _this2._cryptoStore.getAllEndToEndSessions(txn, function (pickledSession) {
                                                result.sessions.push(pickledSession);
                                            });
                                        });
                                    case 3:
                                        return _context2.abrupt("return", result);
                                    case 4:
                                    case "end":
                                        return _context2.stop();
                                }
                            }
                        }, _callee2, this);
                    }));
                    OlmDevice.prototype._getSession = function (deviceKey, sessionId, txn, func) {
                        var _this3 = this;
                        this._cryptoStore.getEndToEndSession(deviceKey, sessionId, txn, function (sessionInfo) {
                            _this3._unpickleSession(sessionInfo, func);
                        });
                    };
                    OlmDevice.prototype._unpickleSession = function (sessionInfo, func) {
                        var session = new global.Olm.Session();
                        try {
                            session.unpickle(this._pickleKey, sessionInfo.session);
                            var unpickledSessInfo = Object.assign({}, sessionInfo, {
                                session: session
                            });
                            func(unpickledSessInfo);
                        }
                        finally {
                            session.free();
                        }
                    };
                    OlmDevice.prototype._saveSession = function (deviceKey, sessionInfo, txn) {
                        var sessionId = sessionInfo.session.session_id();
                        var pickledSessionInfo = Object.assign(sessionInfo, {
                            session: sessionInfo.session.pickle(this._pickleKey)
                        });
                        this._cryptoStore.storeEndToEndSession(deviceKey, sessionId, pickledSessionInfo, txn);
                    };
                    OlmDevice.prototype._getUtility = function (func) {
                        var utility = new global.Olm.Utility();
                        try {
                            return func(utility);
                        }
                        finally {
                            utility.free();
                        }
                    };
                    OlmDevice.prototype.sign = function () {
                        var _ref3 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee3(message) {
                            var _this4 = this;
                            var result;
                            return _regenerator["default"].wrap(function _callee3$(_context3) {
                                while (1) {
                                    switch (_context3.prev = _context3.next) {
                                        case 0:
                                            _context3.next = 2;
                                            return this._cryptoStore.doTxn('readonly', [_indexeddbCryptoStore.IndexedDBCryptoStore.STORE_ACCOUNT], function (txn) {
                                                _this4._getAccount(txn, function (account) {
                                                    result = account.sign(message);
                                                });
                                            });
                                        case 2:
                                            return _context3.abrupt("return", result);
                                        case 3:
                                        case "end":
                                            return _context3.stop();
                                    }
                                }
                            }, _callee3, this);
                        }));
                        return function (_x8) {
                            return _ref3.apply(this, arguments);
                        };
                    }();
                    OlmDevice.prototype.getOneTimeKeys = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee4() {
                        var _this5 = this;
                        var result;
                        return _regenerator["default"].wrap(function _callee4$(_context4) {
                            while (1) {
                                switch (_context4.prev = _context4.next) {
                                    case 0:
                                        _context4.next = 2;
                                        return this._cryptoStore.doTxn('readonly', [_indexeddbCryptoStore.IndexedDBCryptoStore.STORE_ACCOUNT], function (txn) {
                                            _this5._getAccount(txn, function (account) {
                                                result = JSON.parse(account.one_time_keys());
                                            });
                                        });
                                    case 2:
                                        return _context4.abrupt("return", result);
                                    case 3:
                                    case "end":
                                        return _context4.stop();
                                }
                            }
                        }, _callee4, this);
                    }));
                    OlmDevice.prototype.maxNumberOfOneTimeKeys = function () {
                        return this._maxOneTimeKeys;
                    };
                    OlmDevice.prototype.markKeysAsPublished = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee5() {
                        var _this6 = this;
                        return _regenerator["default"].wrap(function _callee5$(_context5) {
                            while (1) {
                                switch (_context5.prev = _context5.next) {
                                    case 0:
                                        _context5.next = 2;
                                        return this._cryptoStore.doTxn('readwrite', [_indexeddbCryptoStore.IndexedDBCryptoStore.STORE_ACCOUNT], function (txn) {
                                            _this6._getAccount(txn, function (account) {
                                                account.mark_keys_as_published();
                                                _this6._storeAccount(txn, account);
                                            });
                                        });
                                    case 2:
                                    case "end":
                                        return _context5.stop();
                                }
                            }
                        }, _callee5, this);
                    }));
                    OlmDevice.prototype.generateOneTimeKeys = function (numKeys) {
                        var _this7 = this;
                        return this._cryptoStore.doTxn('readwrite', [_indexeddbCryptoStore.IndexedDBCryptoStore.STORE_ACCOUNT], function (txn) {
                            _this7._getAccount(txn, function (account) {
                                account.generate_one_time_keys(numKeys);
                                _this7._storeAccount(txn, account);
                            });
                        });
                    };
                    OlmDevice.prototype.generateFallbackKey = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee6() {
                        var _this8 = this;
                        return _regenerator["default"].wrap(function _callee6$(_context6) {
                            while (1) {
                                switch (_context6.prev = _context6.next) {
                                    case 0:
                                        _context6.next = 2;
                                        return this._cryptoStore.doTxn('readwrite', [_indexeddbCryptoStore.IndexedDBCryptoStore.STORE_ACCOUNT], function (txn) {
                                            _this8._getAccount(txn, function (account) {
                                                account.generate_fallback_key();
                                                _this8._storeAccount(txn, account);
                                            });
                                        });
                                    case 2:
                                    case "end":
                                        return _context6.stop();
                                }
                            }
                        }, _callee6, this);
                    }));
                    OlmDevice.prototype.getFallbackKey = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee7() {
                        var _this9 = this;
                        var result;
                        return _regenerator["default"].wrap(function _callee7$(_context7) {
                            while (1) {
                                switch (_context7.prev = _context7.next) {
                                    case 0:
                                        _context7.next = 2;
                                        return this._cryptoStore.doTxn('readonly', [_indexeddbCryptoStore.IndexedDBCryptoStore.STORE_ACCOUNT], function (txn) {
                                            _this9._getAccount(txn, function (account) {
                                                result = JSON.parse(account.fallback_key());
                                            });
                                        });
                                    case 2:
                                        return _context7.abrupt("return", result);
                                    case 3:
                                    case "end":
                                        return _context7.stop();
                                }
                            }
                        }, _callee7, this);
                    }));
                    OlmDevice.prototype.createOutboundSession = function () {
                        var _ref8 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee8(theirIdentityKey, theirOneTimeKey) {
                            var _this10 = this;
                            var newSessionId;
                            return _regenerator["default"].wrap(function _callee8$(_context8) {
                                while (1) {
                                    switch (_context8.prev = _context8.next) {
                                        case 0:
                                            _context8.next = 2;
                                            return this._cryptoStore.doTxn('readwrite', [_indexeddbCryptoStore.IndexedDBCryptoStore.STORE_ACCOUNT, _indexeddbCryptoStore.IndexedDBCryptoStore.STORE_SESSIONS], function (txn) {
                                                _this10._getAccount(txn, function (account) {
                                                    var session = new global.Olm.Session();
                                                    try {
                                                        session.create_outbound(account, theirIdentityKey, theirOneTimeKey);
                                                        newSessionId = session.session_id();
                                                        _this10._storeAccount(txn, account);
                                                        var sessionInfo = {
                                                            session: session,
                                                            lastReceivedMessageTs: Date.now()
                                                        };
                                                        _this10._saveSession(theirIdentityKey, sessionInfo, txn);
                                                    }
                                                    finally {
                                                        session.free();
                                                    }
                                                });
                                            }, _logger.logger.withPrefix("[createOutboundSession]"));
                                        case 2:
                                            return _context8.abrupt("return", newSessionId);
                                        case 3:
                                        case "end":
                                            return _context8.stop();
                                    }
                                }
                            }, _callee8, this);
                        }));
                        return function (_x9, _x10) {
                            return _ref8.apply(this, arguments);
                        };
                    }();
                    OlmDevice.prototype.createInboundSession = function () {
                        var _ref9 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee9(theirDeviceIdentityKey, messageType, ciphertext) {
                            var _this11 = this;
                            var result;
                            return _regenerator["default"].wrap(function _callee9$(_context9) {
                                while (1) {
                                    switch (_context9.prev = _context9.next) {
                                        case 0:
                                            if (!(messageType !== 0)) {
                                                _context9.next = 2;
                                                break;
                                            }
                                            throw new Error("Need messageType == 0 to create inbound session");
                                        case 2:
                                            _context9.next = 4;
                                            return this._cryptoStore.doTxn('readwrite', [_indexeddbCryptoStore.IndexedDBCryptoStore.STORE_ACCOUNT, _indexeddbCryptoStore.IndexedDBCryptoStore.STORE_SESSIONS], function (txn) {
                                                _this11._getAccount(txn, function (account) {
                                                    var session = new global.Olm.Session();
                                                    try {
                                                        session.create_inbound_from(account, theirDeviceIdentityKey, ciphertext);
                                                        account.remove_one_time_keys(session);
                                                        _this11._storeAccount(txn, account);
                                                        var payloadString = session.decrypt(messageType, ciphertext);
                                                        var sessionInfo = {
                                                            session: session,
                                                            lastReceivedMessageTs: Date.now()
                                                        };
                                                        _this11._saveSession(theirDeviceIdentityKey, sessionInfo, txn);
                                                        result = {
                                                            payload: payloadString,
                                                            session_id: session.session_id()
                                                        };
                                                    }
                                                    finally {
                                                        session.free();
                                                    }
                                                });
                                            }, _logger.logger.withPrefix("[createInboundSession]"));
                                        case 4:
                                            return _context9.abrupt("return", result);
                                        case 5:
                                        case "end":
                                            return _context9.stop();
                                    }
                                }
                            }, _callee9, this);
                        }));
                        return function (_x11, _x12, _x13) {
                            return _ref9.apply(this, arguments);
                        };
                    }();
                    OlmDevice.prototype.getSessionIdsForDevice = function () {
                        var _ref10 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee10(theirDeviceIdentityKey) {
                            var _this12 = this;
                            var log, sessionIds;
                            return _regenerator["default"].wrap(function _callee10$(_context10) {
                                while (1) {
                                    switch (_context10.prev = _context10.next) {
                                        case 0:
                                            log = _logger.logger.withPrefix("[getSessionIdsForDevice]");
                                            if (!this._sessionsInProgress[theirDeviceIdentityKey]) {
                                                _context10.next = 10;
                                                break;
                                            }
                                            log.debug("Waiting for Olm session for ".concat(theirDeviceIdentityKey, " to be created"));
                                            _context10.prev = 3;
                                            _context10.next = 6;
                                            return this._sessionsInProgress[theirDeviceIdentityKey];
                                        case 6:
                                            _context10.next = 10;
                                            break;
                                        case 8:
                                            _context10.prev = 8;
                                            _context10.t0 = _context10["catch"](3);
                                        case 10:
                                            _context10.next = 12;
                                            return this._cryptoStore.doTxn('readonly', [_indexeddbCryptoStore.IndexedDBCryptoStore.STORE_SESSIONS], function (txn) {
                                                _this12._cryptoStore.getEndToEndSessions(theirDeviceIdentityKey, txn, function (sessions) {
                                                    sessionIds = Object.keys(sessions);
                                                });
                                            }, log);
                                        case 12:
                                            return _context10.abrupt("return", sessionIds);
                                        case 13:
                                        case "end":
                                            return _context10.stop();
                                    }
                                }
                            }, _callee10, this, [[3, 8]]);
                        }));
                        return function (_x14) {
                            return _ref10.apply(this, arguments);
                        };
                    }();
                    OlmDevice.prototype.getSessionIdForDevice = function () {
                        var _ref11 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee11(theirDeviceIdentityKey, nowait, log) {
                            var sessionInfos, idxOfBest, i, thisSessInfo, thisLastReceived, bestSessInfo, bestLastReceived;
                            return _regenerator["default"].wrap(function _callee11$(_context11) {
                                while (1) {
                                    switch (_context11.prev = _context11.next) {
                                        case 0:
                                            _context11.next = 2;
                                            return this.getSessionInfoForDevice(theirDeviceIdentityKey, nowait, log);
                                        case 2:
                                            sessionInfos = _context11.sent;
                                            if (!(sessionInfos.length === 0)) {
                                                _context11.next = 5;
                                                break;
                                            }
                                            return _context11.abrupt("return", null);
                                        case 5:
                                            idxOfBest = 0;
                                            for (i = 1; i < sessionInfos.length; i++) {
                                                thisSessInfo = sessionInfos[i];
                                                thisLastReceived = thisSessInfo.lastReceivedMessageTs === undefined ? 0 : thisSessInfo.lastReceivedMessageTs;
                                                bestSessInfo = sessionInfos[idxOfBest];
                                                bestLastReceived = bestSessInfo.lastReceivedMessageTs === undefined ? 0 : bestSessInfo.lastReceivedMessageTs;
                                                if (thisLastReceived > bestLastReceived || thisLastReceived === bestLastReceived && thisSessInfo.sessionId < bestSessInfo.sessionId) {
                                                    idxOfBest = i;
                                                }
                                            }
                                            return _context11.abrupt("return", sessionInfos[idxOfBest].sessionId);
                                        case 8:
                                        case "end":
                                            return _context11.stop();
                                    }
                                }
                            }, _callee11, this);
                        }));
                        return function (_x15, _x16, _x17) {
                            return _ref11.apply(this, arguments);
                        };
                    }();
                    OlmDevice.prototype.getSessionInfoForDevice = function () {
                        var _ref12 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee12(deviceIdentityKey, nowait) {
                            var _this13 = this;
                            var log, info, _args12 = arguments;
                            return _regenerator["default"].wrap(function _callee12$(_context12) {
                                while (1) {
                                    switch (_context12.prev = _context12.next) {
                                        case 0:
                                            log = _args12.length > 2 && _args12[2] !== undefined ? _args12[2] : _logger.logger;
                                            log = log.withPrefix("[getSessionInfoForDevice]");
                                            if (!(this._sessionsInProgress[deviceIdentityKey] && !nowait)) {
                                                _context12.next = 11;
                                                break;
                                            }
                                            log.debug("Waiting for Olm session for ".concat(deviceIdentityKey, " to be created"));
                                            _context12.prev = 4;
                                            _context12.next = 7;
                                            return this._sessionsInProgress[deviceIdentityKey];
                                        case 7:
                                            _context12.next = 11;
                                            break;
                                        case 9:
                                            _context12.prev = 9;
                                            _context12.t0 = _context12["catch"](4);
                                        case 11:
                                            info = [];
                                            _context12.next = 14;
                                            return this._cryptoStore.doTxn('readonly', [_indexeddbCryptoStore.IndexedDBCryptoStore.STORE_SESSIONS], function (txn) {
                                                _this13._cryptoStore.getEndToEndSessions(deviceIdentityKey, txn, function (sessions) {
                                                    var sessionIds = Object.keys(sessions).sort();
                                                    var _iterator = _createForOfIteratorHelper(sessionIds), _step;
                                                    try {
                                                        var _loop = function _loop() {
                                                            var sessionId = _step.value;
                                                            _this13._unpickleSession(sessions[sessionId], function (sessInfo) {
                                                                info.push({
                                                                    lastReceivedMessageTs: sessInfo.lastReceivedMessageTs,
                                                                    hasReceivedMessage: sessInfo.session.has_received_message(),
                                                                    sessionId: sessionId
                                                                });
                                                            });
                                                        };
                                                        for (_iterator.s(); !(_step = _iterator.n()).done;) {
                                                            _loop();
                                                        }
                                                    }
                                                    catch (err) {
                                                        _iterator.e(err);
                                                    }
                                                    finally {
                                                        _iterator.f();
                                                    }
                                                });
                                            }, log);
                                        case 14:
                                            return _context12.abrupt("return", info);
                                        case 15:
                                        case "end":
                                            return _context12.stop();
                                    }
                                }
                            }, _callee12, this, [[4, 9]]);
                        }));
                        return function (_x18, _x19) {
                            return _ref12.apply(this, arguments);
                        };
                    }();
                    OlmDevice.prototype.encryptMessage = function () {
                        var _ref13 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee13(theirDeviceIdentityKey, sessionId, payloadString) {
                            var _this14 = this;
                            var res;
                            return _regenerator["default"].wrap(function _callee13$(_context13) {
                                while (1) {
                                    switch (_context13.prev = _context13.next) {
                                        case 0:
                                            checkPayloadLength(payloadString);
                                            _context13.next = 3;
                                            return this._cryptoStore.doTxn('readwrite', [_indexeddbCryptoStore.IndexedDBCryptoStore.STORE_SESSIONS], function (txn) {
                                                _this14._getSession(theirDeviceIdentityKey, sessionId, txn, function (sessionInfo) {
                                                    var sessionDesc = sessionInfo.session.describe();
                                                    _logger.logger.log("encryptMessage: Olm Session ID " + sessionId + " to " + theirDeviceIdentityKey + ": " + sessionDesc);
                                                    res = sessionInfo.session.encrypt(payloadString);
                                                    _this14._saveSession(theirDeviceIdentityKey, sessionInfo, txn);
                                                });
                                            }, _logger.logger.withPrefix("[encryptMessage]"));
                                        case 3:
                                            return _context13.abrupt("return", res);
                                        case 4:
                                        case "end":
                                            return _context13.stop();
                                    }
                                }
                            }, _callee13, this);
                        }));
                        return function (_x20, _x21, _x22) {
                            return _ref13.apply(this, arguments);
                        };
                    }();
                    OlmDevice.prototype.decryptMessage = function () {
                        var _ref14 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee14(theirDeviceIdentityKey, sessionId, messageType, ciphertext) {
                            var _this15 = this;
                            var payloadString;
                            return _regenerator["default"].wrap(function _callee14$(_context14) {
                                while (1) {
                                    switch (_context14.prev = _context14.next) {
                                        case 0:
                                            _context14.next = 2;
                                            return this._cryptoStore.doTxn('readwrite', [_indexeddbCryptoStore.IndexedDBCryptoStore.STORE_SESSIONS], function (txn) {
                                                _this15._getSession(theirDeviceIdentityKey, sessionId, txn, function (sessionInfo) {
                                                    var sessionDesc = sessionInfo.session.describe();
                                                    _logger.logger.log("decryptMessage: Olm Session ID " + sessionId + " from " + theirDeviceIdentityKey + ": " + sessionDesc);
                                                    payloadString = sessionInfo.session.decrypt(messageType, ciphertext);
                                                    sessionInfo.lastReceivedMessageTs = Date.now();
                                                    _this15._saveSession(theirDeviceIdentityKey, sessionInfo, txn);
                                                });
                                            }, _logger.logger.withPrefix("[decryptMessage]"));
                                        case 2:
                                            return _context14.abrupt("return", payloadString);
                                        case 3:
                                        case "end":
                                            return _context14.stop();
                                    }
                                }
                            }, _callee14, this);
                        }));
                        return function (_x23, _x24, _x25, _x26) {
                            return _ref14.apply(this, arguments);
                        };
                    }();
                    OlmDevice.prototype.matchesSession = function () {
                        var _ref15 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee15(theirDeviceIdentityKey, sessionId, messageType, ciphertext) {
                            var _this16 = this;
                            var matches;
                            return _regenerator["default"].wrap(function _callee15$(_context15) {
                                while (1) {
                                    switch (_context15.prev = _context15.next) {
                                        case 0:
                                            if (!(messageType !== 0)) {
                                                _context15.next = 2;
                                                break;
                                            }
                                            return _context15.abrupt("return", false);
                                        case 2:
                                            _context15.next = 4;
                                            return this._cryptoStore.doTxn('readonly', [_indexeddbCryptoStore.IndexedDBCryptoStore.STORE_SESSIONS], function (txn) {
                                                _this16._getSession(theirDeviceIdentityKey, sessionId, txn, function (sessionInfo) {
                                                    matches = sessionInfo.session.matches_inbound(ciphertext);
                                                });
                                            }, _logger.logger.withPrefix("[matchesSession]"));
                                        case 4:
                                            return _context15.abrupt("return", matches);
                                        case 5:
                                        case "end":
                                            return _context15.stop();
                                    }
                                }
                            }, _callee15, this);
                        }));
                        return function (_x27, _x28, _x29, _x30) {
                            return _ref15.apply(this, arguments);
                        };
                    }();
                    OlmDevice.prototype.recordSessionProblem = function () {
                        var _ref16 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee16(deviceKey, type, fixed) {
                            return _regenerator["default"].wrap(function _callee16$(_context16) {
                                while (1) {
                                    switch (_context16.prev = _context16.next) {
                                        case 0:
                                            _context16.next = 2;
                                            return this._cryptoStore.storeEndToEndSessionProblem(deviceKey, type, fixed);
                                        case 2:
                                        case "end":
                                            return _context16.stop();
                                    }
                                }
                            }, _callee16, this);
                        }));
                        return function (_x31, _x32, _x33) {
                            return _ref16.apply(this, arguments);
                        };
                    }();
                    OlmDevice.prototype.sessionMayHaveProblems = function () {
                        var _ref17 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee17(deviceKey, timestamp) {
                            return _regenerator["default"].wrap(function _callee17$(_context17) {
                                while (1) {
                                    switch (_context17.prev = _context17.next) {
                                        case 0:
                                            _context17.next = 2;
                                            return this._cryptoStore.getEndToEndSessionProblem(deviceKey, timestamp);
                                        case 2:
                                            return _context17.abrupt("return", _context17.sent);
                                        case 3:
                                        case "end":
                                            return _context17.stop();
                                    }
                                }
                            }, _callee17, this);
                        }));
                        return function (_x34, _x35) {
                            return _ref17.apply(this, arguments);
                        };
                    }();
                    OlmDevice.prototype.filterOutNotifiedErrorDevices = function () {
                        var _ref18 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee18(devices) {
                            return _regenerator["default"].wrap(function _callee18$(_context18) {
                                while (1) {
                                    switch (_context18.prev = _context18.next) {
                                        case 0:
                                            _context18.next = 2;
                                            return this._cryptoStore.filterOutNotifiedErrorDevices(devices);
                                        case 2:
                                            return _context18.abrupt("return", _context18.sent);
                                        case 3:
                                        case "end":
                                            return _context18.stop();
                                    }
                                }
                            }, _callee18, this);
                        }));
                        return function (_x36) {
                            return _ref18.apply(this, arguments);
                        };
                    }();
                    OlmDevice.prototype._saveOutboundGroupSession = function (session) {
                        var pickledSession = session.pickle(this._pickleKey);
                        this._outboundGroupSessionStore[session.session_id()] = pickledSession;
                    };
                    OlmDevice.prototype._getOutboundGroupSession = function (sessionId, func) {
                        var pickled = this._outboundGroupSessionStore[sessionId];
                        if (pickled === undefined) {
                            throw new Error("Unknown outbound group session " + sessionId);
                        }
                        var session = new global.Olm.OutboundGroupSession();
                        try {
                            session.unpickle(this._pickleKey, pickled);
                            return func(session);
                        }
                        finally {
                            session.free();
                        }
                    };
                    OlmDevice.prototype.createOutboundGroupSession = function () {
                        var session = new global.Olm.OutboundGroupSession();
                        try {
                            session.create();
                            this._saveOutboundGroupSession(session);
                            return session.session_id();
                        }
                        finally {
                            session.free();
                        }
                    };
                    OlmDevice.prototype.encryptGroupMessage = function (sessionId, payloadString) {
                        var self = this;
                        _logger.logger.log("encrypting msg with megolm session ".concat(sessionId));
                        checkPayloadLength(payloadString);
                        return this._getOutboundGroupSession(sessionId, function (session) {
                            var res = session.encrypt(payloadString);
                            self._saveOutboundGroupSession(session);
                            return res;
                        });
                    };
                    OlmDevice.prototype.getOutboundGroupSessionKey = function (sessionId) {
                        return this._getOutboundGroupSession(sessionId, function (session) {
                            return {
                                chain_index: session.message_index(),
                                key: session.session_key()
                            };
                        });
                    };
                    OlmDevice.prototype._unpickleInboundGroupSession = function (sessionData, func) {
                        var session = new global.Olm.InboundGroupSession();
                        try {
                            session.unpickle(this._pickleKey, sessionData.session);
                            return func(session);
                        }
                        finally {
                            session.free();
                        }
                    };
                    OlmDevice.prototype._getInboundGroupSession = function (roomId, senderKey, sessionId, txn, func) {
                        var _this17 = this;
                        this._cryptoStore.getEndToEndInboundGroupSession(senderKey, sessionId, txn, function (sessionData, withheld) {
                            if (sessionData === null) {
                                func(null, null, withheld);
                                return;
                            }
                            if (roomId !== null && roomId !== sessionData.room_id) {
                                throw new Error("Mismatched room_id for inbound group session (expected " + sessionData.room_id + ", was " + roomId + ")");
                            }
                            _this17._unpickleInboundGroupSession(sessionData, function (session) {
                                func(session, sessionData, withheld);
                            });
                        });
                    };
                    OlmDevice.prototype.addInboundGroupSession = function () {
                        var _ref19 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee19(roomId, senderKey, forwardingCurve25519KeyChain, sessionId, sessionKey, keysClaimed, exportFormat) {
                            var _this18 = this;
                            var extraSessionData, _args19 = arguments;
                            return _regenerator["default"].wrap(function _callee19$(_context19) {
                                while (1) {
                                    switch (_context19.prev = _context19.next) {
                                        case 0:
                                            extraSessionData = _args19.length > 7 && _args19[7] !== undefined ? _args19[7] : {};
                                            _context19.next = 3;
                                            return this._cryptoStore.doTxn('readwrite', [_indexeddbCryptoStore.IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS, _indexeddbCryptoStore.IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS_WITHHELD], function (txn) {
                                                _this18._getInboundGroupSession(roomId, senderKey, sessionId, txn, function (existingSession, existingSessionData) {
                                                    var session = new global.Olm.InboundGroupSession();
                                                    try {
                                                        if (exportFormat) {
                                                            session.import_session(sessionKey);
                                                        }
                                                        else {
                                                            session.create(sessionKey);
                                                        }
                                                        if (sessionId != session.session_id()) {
                                                            throw new Error("Mismatched group session ID from senderKey: " + senderKey);
                                                        }
                                                        if (existingSession) {
                                                            _logger.logger.log("Update for megolm session " + senderKey + "/" + sessionId);
                                                            if (existingSession.first_known_index() <= session.first_known_index() && !(existingSession.first_known_index() == session.first_known_index() && !extraSessionData.untrusted && existingSessionData.untrusted)) {
                                                                _logger.logger.log("Keeping existing megolm session ".concat(sessionId));
                                                                return;
                                                            }
                                                        }
                                                        _logger.logger.info("Storing megolm session " + senderKey + "/" + sessionId + " with first index " + session.first_known_index());
                                                        var sessionData = Object.assign({}, extraSessionData, {
                                                            room_id: roomId,
                                                            session: session.pickle(_this18._pickleKey),
                                                            keysClaimed: keysClaimed,
                                                            forwardingCurve25519KeyChain: forwardingCurve25519KeyChain
                                                        });
                                                        _this18._cryptoStore.storeEndToEndInboundGroupSession(senderKey, sessionId, sessionData, txn);
                                                    }
                                                    finally {
                                                        session.free();
                                                    }
                                                });
                                            }, _logger.logger.withPrefix("[addInboundGroupSession]"));
                                        case 3:
                                        case "end":
                                            return _context19.stop();
                                    }
                                }
                            }, _callee19, this);
                        }));
                        return function (_x37, _x38, _x39, _x40, _x41, _x42, _x43) {
                            return _ref19.apply(this, arguments);
                        };
                    }();
                    OlmDevice.prototype.addInboundGroupSessionWithheld = function () {
                        var _ref20 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee20(roomId, senderKey, sessionId, code, reason) {
                            var _this19 = this;
                            return _regenerator["default"].wrap(function _callee20$(_context20) {
                                while (1) {
                                    switch (_context20.prev = _context20.next) {
                                        case 0:
                                            _context20.next = 2;
                                            return this._cryptoStore.doTxn('readwrite', [_indexeddbCryptoStore.IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS_WITHHELD], function (txn) {
                                                _this19._cryptoStore.storeEndToEndInboundGroupSessionWithheld(senderKey, sessionId, {
                                                    room_id: roomId,
                                                    code: code,
                                                    reason: reason
                                                }, txn);
                                            });
                                        case 2:
                                        case "end":
                                            return _context20.stop();
                                    }
                                }
                            }, _callee20, this);
                        }));
                        return function (_x44, _x45, _x46, _x47, _x48) {
                            return _ref20.apply(this, arguments);
                        };
                    }();
                    var WITHHELD_MESSAGES = {
                        "m.unverified": "The sender has disabled encrypting to unverified devices.",
                        "m.blacklisted": "The sender has blocked you.",
                        "m.unauthorised": "You are not authorised to read the message.",
                        "m.no_olm": "Unable to establish a secure channel."
                    };
                    exports.WITHHELD_MESSAGES = WITHHELD_MESSAGES;
                    function _calculateWithheldMessage(withheld) {
                        if (withheld.code && withheld.code in WITHHELD_MESSAGES) {
                            return WITHHELD_MESSAGES[withheld.code];
                        }
                        else if (withheld.reason) {
                            return withheld.reason;
                        }
                        else {
                            return "decryption key withheld";
                        }
                    }
                    OlmDevice.prototype.decryptGroupMessage = function () {
                        var _ref21 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee21(roomId, senderKey, sessionId, body, eventId, timestamp) {
                            var _this20 = this;
                            var result, error;
                            return _regenerator["default"].wrap(function _callee21$(_context21) {
                                while (1) {
                                    switch (_context21.prev = _context21.next) {
                                        case 0:
                                            _context21.next = 2;
                                            return this._cryptoStore.doTxn('readwrite', [_indexeddbCryptoStore.IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS, _indexeddbCryptoStore.IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS_WITHHELD], function (txn) {
                                                _this20._getInboundGroupSession(roomId, senderKey, sessionId, txn, function (session, sessionData, withheld) {
                                                    if (session === null) {
                                                        if (withheld) {
                                                            error = new algorithms.DecryptionError("MEGOLM_UNKNOWN_INBOUND_SESSION_ID", _calculateWithheldMessage(withheld), {
                                                                session: senderKey + '|' + sessionId
                                                            });
                                                        }
                                                        result = null;
                                                        return;
                                                    }
                                                    var res;
                                                    try {
                                                        res = session.decrypt(body);
                                                    }
                                                    catch (e) {
                                                        if (e && e.message === 'OLM.UNKNOWN_MESSAGE_INDEX' && withheld) {
                                                            error = new algorithms.DecryptionError("MEGOLM_UNKNOWN_INBOUND_SESSION_ID", _calculateWithheldMessage(withheld), {
                                                                session: senderKey + '|' + sessionId
                                                            });
                                                        }
                                                        else {
                                                            error = e;
                                                        }
                                                        return;
                                                    }
                                                    var plaintext = res.plaintext;
                                                    if (plaintext === undefined) {
                                                        plaintext = res;
                                                    }
                                                    else {
                                                        var messageIndexKey = senderKey + "|" + sessionId + "|" + res.message_index;
                                                        if (messageIndexKey in _this20._inboundGroupSessionMessageIndexes) {
                                                            var msgInfo = _this20._inboundGroupSessionMessageIndexes[messageIndexKey];
                                                            if (msgInfo.id !== eventId || msgInfo.timestamp !== timestamp) {
                                                                error = new Error("Duplicate message index, possible replay attack: " + messageIndexKey);
                                                                return;
                                                            }
                                                        }
                                                        _this20._inboundGroupSessionMessageIndexes[messageIndexKey] = {
                                                            id: eventId,
                                                            timestamp: timestamp
                                                        };
                                                    }
                                                    sessionData.session = session.pickle(_this20._pickleKey);
                                                    _this20._cryptoStore.storeEndToEndInboundGroupSession(senderKey, sessionId, sessionData, txn);
                                                    result = {
                                                        result: plaintext,
                                                        keysClaimed: sessionData.keysClaimed || {},
                                                        senderKey: senderKey,
                                                        forwardingCurve25519KeyChain: sessionData.forwardingCurve25519KeyChain || [],
                                                        untrusted: sessionData.untrusted
                                                    };
                                                });
                                            }, _logger.logger.withPrefix("[decryptGroupMessage]"));
                                        case 2:
                                            if (!error) {
                                                _context21.next = 4;
                                                break;
                                            }
                                            throw error;
                                        case 4:
                                            return _context21.abrupt("return", result);
                                        case 5:
                                        case "end":
                                            return _context21.stop();
                                    }
                                }
                            }, _callee21, this);
                        }));
                        return function (_x49, _x50, _x51, _x52, _x53, _x54) {
                            return _ref21.apply(this, arguments);
                        };
                    }();
                    OlmDevice.prototype.hasInboundSessionKeys = function () {
                        var _ref22 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee22(roomId, senderKey, sessionId) {
                            var _this21 = this;
                            var result;
                            return _regenerator["default"].wrap(function _callee22$(_context22) {
                                while (1) {
                                    switch (_context22.prev = _context22.next) {
                                        case 0:
                                            _context22.next = 2;
                                            return this._cryptoStore.doTxn('readonly', [_indexeddbCryptoStore.IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS, _indexeddbCryptoStore.IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS_WITHHELD], function (txn) {
                                                _this21._cryptoStore.getEndToEndInboundGroupSession(senderKey, sessionId, txn, function (sessionData) {
                                                    if (sessionData === null) {
                                                        result = false;
                                                        return;
                                                    }
                                                    if (roomId !== sessionData.room_id) {
                                                        _logger.logger.warn("requested keys for inbound group session ".concat(senderKey, "|") + "".concat(sessionId, ", with incorrect room_id ") + "(expected ".concat(sessionData.room_id, ", ") + "was ".concat(roomId, ")"));
                                                        result = false;
                                                    }
                                                    else {
                                                        result = true;
                                                    }
                                                });
                                            }, _logger.logger.withPrefix("[hasInboundSessionKeys]"));
                                        case 2:
                                            return _context22.abrupt("return", result);
                                        case 3:
                                        case "end":
                                            return _context22.stop();
                                    }
                                }
                            }, _callee22, this);
                        }));
                        return function (_x55, _x56, _x57) {
                            return _ref22.apply(this, arguments);
                        };
                    }();
                    OlmDevice.prototype.getInboundGroupSessionKey = function () {
                        var _ref23 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee23(roomId, senderKey, sessionId, chainIndex) {
                            var _this22 = this;
                            var result;
                            return _regenerator["default"].wrap(function _callee23$(_context23) {
                                while (1) {
                                    switch (_context23.prev = _context23.next) {
                                        case 0:
                                            _context23.next = 2;
                                            return this._cryptoStore.doTxn('readonly', [_indexeddbCryptoStore.IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS, _indexeddbCryptoStore.IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS_WITHHELD], function (txn) {
                                                _this22._getInboundGroupSession(roomId, senderKey, sessionId, txn, function (session, sessionData) {
                                                    if (session === null) {
                                                        result = null;
                                                        return;
                                                    }
                                                    if (chainIndex === undefined) {
                                                        chainIndex = session.first_known_index();
                                                    }
                                                    var exportedSession = session.export_session(chainIndex);
                                                    var claimedKeys = sessionData.keysClaimed || {};
                                                    var senderEd25519Key = claimedKeys.ed25519 || null;
                                                    result = {
                                                        "chain_index": chainIndex,
                                                        "key": exportedSession,
                                                        "forwarding_curve25519_key_chain": sessionData.forwardingCurve25519KeyChain || [],
                                                        "sender_claimed_ed25519_key": senderEd25519Key
                                                    };
                                                });
                                            }, _logger.logger.withPrefix("[getInboundGroupSessionKey]"));
                                        case 2:
                                            return _context23.abrupt("return", result);
                                        case 3:
                                        case "end":
                                            return _context23.stop();
                                    }
                                }
                            }, _callee23, this);
                        }));
                        return function (_x58, _x59, _x60, _x61) {
                            return _ref23.apply(this, arguments);
                        };
                    }();
                    OlmDevice.prototype.exportInboundGroupSession = function (senderKey, sessionId, sessionData) {
                        return this._unpickleInboundGroupSession(sessionData, function (session) {
                            var messageIndex = session.first_known_index();
                            return {
                                "sender_key": senderKey,
                                "sender_claimed_keys": sessionData.keysClaimed,
                                "room_id": sessionData.room_id,
                                "session_id": sessionId,
                                "session_key": session.export_session(messageIndex),
                                "forwarding_curve25519_key_chain": session.forwardingCurve25519KeyChain || [],
                                "first_known_index": session.first_known_index()
                            };
                        });
                    };
                    OlmDevice.prototype.verifySignature = function (key, message, signature) {
                        this._getUtility(function (util) {
                            util.ed25519_verify(key, message, signature);
                        });
                    };
                }).call(this);
            }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, { "../logger": 97, "./algorithms": 70, "./store/indexeddb-crypto-store": 80, "@babel/runtime/helpers/asyncToGenerator": 5, "@babel/runtime/helpers/interopRequireDefault": 12, "@babel/runtime/helpers/interopRequireWildcard": 13, "@babel/runtime/regenerator": 27 }], 65: [function (require, module, exports) {
            (function (global) {
                (function () {
                    "use strict";
                    var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
                    var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
                    Object.defineProperty(exports, "__esModule", {
                        value: true
                    });
                    exports.OutgoingRoomKeyRequestManager = exports.ROOM_KEY_REQUEST_STATES = void 0;
                    var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
                    var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
                    var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
                    var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
                    var _logger = require("../logger");
                    var utils = _interopRequireWildcard(require("../utils"));
                    function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
                        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                            if (it)
                                o = it;
                            var i = 0;
                            var F = function F() { };
                            return { s: F, n: function n() { if (i >= o.length)
                                    return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F };
                        }
                        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                    } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try {
                            if (!normalCompletion && it["return"] != null)
                                it["return"]();
                        }
                        finally {
                            if (didErr)
                                throw err;
                        } } }; }
                    function _unsupportedIterableToArray(o, minLen) { if (!o)
                        return; if (typeof o === "string")
                        return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor)
                        n = o.constructor.name; if (n === "Map" || n === "Set")
                        return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                        return _arrayLikeToArray(o, minLen); }
                    function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length)
                        len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) {
                        arr2[i] = arr[i];
                    } return arr2; }
                    var SEND_KEY_REQUESTS_DELAY_MS = 500;
                    var ROOM_KEY_REQUEST_STATES = {
                        UNSENT: 0,
                        SENT: 1,
                        CANCELLATION_PENDING: 2,
                        CANCELLATION_PENDING_AND_WILL_RESEND: 3
                    };
                    exports.ROOM_KEY_REQUEST_STATES = ROOM_KEY_REQUEST_STATES;
                    var OutgoingRoomKeyRequestManager = function () {
                        function OutgoingRoomKeyRequestManager(baseApis, deviceId, cryptoStore) {
                            (0, _classCallCheck2["default"])(this, OutgoingRoomKeyRequestManager);
                            this._baseApis = baseApis;
                            this._deviceId = deviceId;
                            this._cryptoStore = cryptoStore;
                            this._sendOutgoingRoomKeyRequestsTimer = null;
                            this._sendOutgoingRoomKeyRequestsRunning = false;
                            this._clientRunning = false;
                        }
                        (0, _createClass2["default"])(OutgoingRoomKeyRequestManager, [{
                                key: "start",
                                value: function start() {
                                    this._clientRunning = true;
                                }
                            }, {
                                key: "stop",
                                value: function stop() {
                                    _logger.logger.log('stopping OutgoingRoomKeyRequestManager');
                                    this._clientRunning = false;
                                }
                            }, {
                                key: "sendQueuedRequests",
                                value: function sendQueuedRequests() {
                                    this._startTimer();
                                }
                            }, {
                                key: "queueRoomKeyRequest",
                                value: function () {
                                    var _queueRoomKeyRequest = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee(requestBody, recipients) {
                                        var resend, req, state, _state, updatedReq, _args = arguments;
                                        return _regenerator["default"].wrap(function _callee$(_context) {
                                            while (1) {
                                                switch (_context.prev = _context.next) {
                                                    case 0:
                                                        resend = _args.length > 2 && _args[2] !== undefined ? _args[2] : false;
                                                        _context.next = 3;
                                                        return this._cryptoStore.getOutgoingRoomKeyRequest(requestBody);
                                                    case 3:
                                                        req = _context.sent;
                                                        if (req) {
                                                            _context.next = 9;
                                                            break;
                                                        }
                                                        _context.next = 7;
                                                        return this._cryptoStore.getOrAddOutgoingRoomKeyRequest({
                                                            requestBody: requestBody,
                                                            recipients: recipients,
                                                            requestId: this._baseApis.makeTxnId(),
                                                            state: ROOM_KEY_REQUEST_STATES.UNSENT
                                                        });
                                                    case 7:
                                                        _context.next = 36;
                                                        break;
                                                    case 9:
                                                        _context.t0 = req.state;
                                                        _context.next = _context.t0 === ROOM_KEY_REQUEST_STATES.CANCELLATION_PENDING_AND_WILL_RESEND ? 12 : _context.t0 === ROOM_KEY_REQUEST_STATES.UNSENT ? 12 : _context.t0 === ROOM_KEY_REQUEST_STATES.CANCELLATION_PENDING ? 13 : _context.t0 === ROOM_KEY_REQUEST_STATES.SENT ? 17 : 35;
                                                        break;
                                                    case 12:
                                                        return _context.abrupt("return");
                                                    case 13:
                                                        state = resend ? ROOM_KEY_REQUEST_STATES.CANCELLATION_PENDING_AND_WILL_RESEND : ROOM_KEY_REQUEST_STATES.SENT;
                                                        _context.next = 16;
                                                        return this._cryptoStore.updateOutgoingRoomKeyRequest(req.requestId, ROOM_KEY_REQUEST_STATES.CANCELLATION_PENDING, {
                                                            state: state,
                                                            cancellationTxnId: this._baseApis.makeTxnId()
                                                        });
                                                    case 16:
                                                        return _context.abrupt("break", 36);
                                                    case 17:
                                                        if (!resend) {
                                                            _context.next = 34;
                                                            break;
                                                        }
                                                        _state = ROOM_KEY_REQUEST_STATES.CANCELLATION_PENDING_AND_WILL_RESEND;
                                                        _context.next = 21;
                                                        return this._cryptoStore.updateOutgoingRoomKeyRequest(req.requestId, ROOM_KEY_REQUEST_STATES.SENT, {
                                                            state: _state,
                                                            cancellationTxnId: this._baseApis.makeTxnId(),
                                                            requestTxnId: this._baseApis.makeTxnId()
                                                        });
                                                    case 21:
                                                        updatedReq = _context.sent;
                                                        if (updatedReq) {
                                                            _context.next = 26;
                                                            break;
                                                        }
                                                        _context.next = 25;
                                                        return this.queueRoomKeyRequest(requestBody, recipients, resend);
                                                    case 25:
                                                        return _context.abrupt("return", _context.sent);
                                                    case 26:
                                                        _context.prev = 26;
                                                        _context.next = 29;
                                                        return this._sendOutgoingRoomKeyRequestCancellation(updatedReq, true);
                                                    case 29:
                                                        _context.next = 34;
                                                        break;
                                                    case 31:
                                                        _context.prev = 31;
                                                        _context.t1 = _context["catch"](26);
                                                        _logger.logger.error("Error sending room key request cancellation;" + " will retry later.", _context.t1);
                                                    case 34:
                                                        return _context.abrupt("break", 36);
                                                    case 35:
                                                        throw new Error('unhandled state: ' + req.state);
                                                    case 36:
                                                    case "end":
                                                        return _context.stop();
                                                }
                                            }
                                        }, _callee, this, [[26, 31]]);
                                    }));
                                    function queueRoomKeyRequest(_x, _x2) {
                                        return _queueRoomKeyRequest.apply(this, arguments);
                                    }
                                    return queueRoomKeyRequest;
                                }()
                            }, {
                                key: "cancelRoomKeyRequest",
                                value: function cancelRoomKeyRequest(requestBody) {
                                    var _this = this;
                                    return this._cryptoStore.getOutgoingRoomKeyRequest(requestBody).then(function (req) {
                                        if (!req) {
                                            return;
                                        }
                                        switch (req.state) {
                                            case ROOM_KEY_REQUEST_STATES.CANCELLATION_PENDING:
                                            case ROOM_KEY_REQUEST_STATES.CANCELLATION_PENDING_AND_WILL_RESEND:
                                                return;
                                            case ROOM_KEY_REQUEST_STATES.UNSENT:
                                                _logger.logger.log('deleting unnecessary room key request for ' + stringifyRequestBody(requestBody));
                                                return _this._cryptoStore.deleteOutgoingRoomKeyRequest(req.requestId, ROOM_KEY_REQUEST_STATES.UNSENT);
                                            case ROOM_KEY_REQUEST_STATES.SENT:
                                                {
                                                    return _this._cryptoStore.updateOutgoingRoomKeyRequest(req.requestId, ROOM_KEY_REQUEST_STATES.SENT, {
                                                        state: ROOM_KEY_REQUEST_STATES.CANCELLATION_PENDING,
                                                        cancellationTxnId: _this._baseApis.makeTxnId()
                                                    }).then(function (updatedReq) {
                                                        if (!updatedReq) {
                                                            _logger.logger.log('Tried to cancel room key request for ' + stringifyRequestBody(requestBody) + ' but it was already cancelled in another tab');
                                                            return;
                                                        }
                                                        _this._sendOutgoingRoomKeyRequestCancellation(updatedReq)["catch"](function (e) {
                                                            _logger.logger.error("Error sending room key request cancellation;" + " will retry later.", e);
                                                            _this._startTimer();
                                                        });
                                                    });
                                                }
                                            default:
                                                throw new Error('unhandled state: ' + req.state);
                                        }
                                    });
                                }
                            }, {
                                key: "getOutgoingSentRoomKeyRequest",
                                value: function getOutgoingSentRoomKeyRequest(userId, deviceId) {
                                    return this._cryptoStore.getOutgoingRoomKeyRequestsByTarget(userId, deviceId, [ROOM_KEY_REQUEST_STATES.SENT]);
                                }
                            }, {
                                key: "cancelAndResendAllOutgoingRequests",
                                value: function () {
                                    var _cancelAndResendAllOutgoingRequests = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee2() {
                                        var _this2 = this;
                                        var outgoings;
                                        return _regenerator["default"].wrap(function _callee2$(_context2) {
                                            while (1) {
                                                switch (_context2.prev = _context2.next) {
                                                    case 0:
                                                        _context2.next = 2;
                                                        return this._cryptoStore.getAllOutgoingRoomKeyRequestsByState(ROOM_KEY_REQUEST_STATES.SENT);
                                                    case 2:
                                                        outgoings = _context2.sent;
                                                        return _context2.abrupt("return", Promise.all(outgoings.map(function (_ref) {
                                                            var requestBody = _ref.requestBody, recipients = _ref.recipients;
                                                            return _this2.queueRoomKeyRequest(requestBody, recipients, true);
                                                        })));
                                                    case 4:
                                                    case "end":
                                                        return _context2.stop();
                                                }
                                            }
                                        }, _callee2, this);
                                    }));
                                    function cancelAndResendAllOutgoingRequests() {
                                        return _cancelAndResendAllOutgoingRequests.apply(this, arguments);
                                    }
                                    return cancelAndResendAllOutgoingRequests;
                                }()
                            }, {
                                key: "_startTimer",
                                value: function _startTimer() {
                                    var _this3 = this;
                                    if (this._sendOutgoingRoomKeyRequestsTimer) {
                                        return;
                                    }
                                    var startSendingOutgoingRoomKeyRequests = function startSendingOutgoingRoomKeyRequests() {
                                        if (_this3._sendOutgoingRoomKeyRequestsRunning) {
                                            throw new Error("RoomKeyRequestSend already in progress!");
                                        }
                                        _this3._sendOutgoingRoomKeyRequestsRunning = true;
                                        _this3._sendOutgoingRoomKeyRequests()["finally"](function () {
                                            _this3._sendOutgoingRoomKeyRequestsRunning = false;
                                        })["catch"](function (e) {
                                            _logger.logger.warn("error in OutgoingRoomKeyRequestManager: ".concat(e));
                                        });
                                    };
                                    this._sendOutgoingRoomKeyRequestsTimer = global.setTimeout(startSendingOutgoingRoomKeyRequests, SEND_KEY_REQUESTS_DELAY_MS);
                                }
                            }, {
                                key: "_sendOutgoingRoomKeyRequests",
                                value: function _sendOutgoingRoomKeyRequests() {
                                    var _this4 = this;
                                    if (!this._clientRunning) {
                                        this._sendOutgoingRoomKeyRequestsTimer = null;
                                        return Promise.resolve();
                                    }
                                    return this._cryptoStore.getOutgoingRoomKeyRequestByState([ROOM_KEY_REQUEST_STATES.CANCELLATION_PENDING, ROOM_KEY_REQUEST_STATES.CANCELLATION_PENDING_AND_WILL_RESEND, ROOM_KEY_REQUEST_STATES.UNSENT]).then(function (req) {
                                        if (!req) {
                                            _this4._sendOutgoingRoomKeyRequestsTimer = null;
                                            return;
                                        }
                                        var prom;
                                        switch (req.state) {
                                            case ROOM_KEY_REQUEST_STATES.UNSENT:
                                                prom = _this4._sendOutgoingRoomKeyRequest(req);
                                                break;
                                            case ROOM_KEY_REQUEST_STATES.CANCELLATION_PENDING:
                                                prom = _this4._sendOutgoingRoomKeyRequestCancellation(req);
                                                break;
                                            case ROOM_KEY_REQUEST_STATES.CANCELLATION_PENDING_AND_WILL_RESEND:
                                                prom = _this4._sendOutgoingRoomKeyRequestCancellation(req, true);
                                                break;
                                        }
                                        return prom.then(function () {
                                            return _this4._sendOutgoingRoomKeyRequests();
                                        })["catch"](function (e) {
                                            _logger.logger.error("Error sending room key request; will retry later.", e);
                                            _this4._sendOutgoingRoomKeyRequestsTimer = null;
                                        });
                                    });
                                }
                            }, {
                                key: "_sendOutgoingRoomKeyRequest",
                                value: function _sendOutgoingRoomKeyRequest(req) {
                                    var _this5 = this;
                                    _logger.logger.log("Requesting keys for ".concat(stringifyRequestBody(req.requestBody)) + " from ".concat(stringifyRecipientList(req.recipients)) + "(id ".concat(req.requestId, ")"));
                                    var requestMessage = {
                                        action: "request",
                                        requesting_device_id: this._deviceId,
                                        request_id: req.requestId,
                                        body: req.requestBody
                                    };
                                    return this._sendMessageToDevices(requestMessage, req.recipients, req.requestTxnId || req.requestId).then(function () {
                                        return _this5._cryptoStore.updateOutgoingRoomKeyRequest(req.requestId, ROOM_KEY_REQUEST_STATES.UNSENT, {
                                            state: ROOM_KEY_REQUEST_STATES.SENT
                                        });
                                    });
                                }
                            }, {
                                key: "_sendOutgoingRoomKeyRequestCancellation",
                                value: function _sendOutgoingRoomKeyRequestCancellation(req, andResend) {
                                    var _this6 = this;
                                    _logger.logger.log("Sending cancellation for key request for " + "".concat(stringifyRequestBody(req.requestBody), " to ") + "".concat(stringifyRecipientList(req.recipients), " ") + "(cancellation id ".concat(req.cancellationTxnId, ")"));
                                    var requestMessage = {
                                        action: "request_cancellation",
                                        requesting_device_id: this._deviceId,
                                        request_id: req.requestId
                                    };
                                    return this._sendMessageToDevices(requestMessage, req.recipients, req.cancellationTxnId).then(function () {
                                        if (andResend) {
                                            return _this6._cryptoStore.updateOutgoingRoomKeyRequest(req.requestId, ROOM_KEY_REQUEST_STATES.CANCELLATION_PENDING_AND_WILL_RESEND, {
                                                state: ROOM_KEY_REQUEST_STATES.UNSENT
                                            });
                                        }
                                        return _this6._cryptoStore.deleteOutgoingRoomKeyRequest(req.requestId, ROOM_KEY_REQUEST_STATES.CANCELLATION_PENDING);
                                    });
                                }
                            }, {
                                key: "_sendMessageToDevices",
                                value: function _sendMessageToDevices(message, recipients, txnId) {
                                    var contentMap = {};
                                    var _iterator = _createForOfIteratorHelper(recipients), _step;
                                    try {
                                        for (_iterator.s(); !(_step = _iterator.n()).done;) {
                                            var recip = _step.value;
                                            if (!contentMap[recip.userId]) {
                                                contentMap[recip.userId] = {};
                                            }
                                            contentMap[recip.userId][recip.deviceId] = message;
                                        }
                                    }
                                    catch (err) {
                                        _iterator.e(err);
                                    }
                                    finally {
                                        _iterator.f();
                                    }
                                    return this._baseApis.sendToDevice('m.room_key_request', contentMap, txnId);
                                }
                            }]);
                        return OutgoingRoomKeyRequestManager;
                    }();
                    exports.OutgoingRoomKeyRequestManager = OutgoingRoomKeyRequestManager;
                    function stringifyRequestBody(requestBody) {
                        return requestBody.room_id + " / " + requestBody.session_id;
                    }
                    function stringifyRecipientList(recipients) {
                        return '[' + utils.map(recipients, function (r) {
                            return "".concat(r.userId, ":").concat(r.deviceId);
                        }).join(",") + ']';
                    }
                }).call(this);
            }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, { "../logger": 97, "../utils": 125, "@babel/runtime/helpers/asyncToGenerator": 5, "@babel/runtime/helpers/classCallCheck": 6, "@babel/runtime/helpers/createClass": 8, "@babel/runtime/helpers/interopRequireDefault": 12, "@babel/runtime/helpers/interopRequireWildcard": 13, "@babel/runtime/regenerator": 27 }], 66: [function (require, module, exports) {
            "use strict";
            var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.RoomList = void 0;
            var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
            var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
            var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
            var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
            var _indexeddbCryptoStore = require("./store/indexeddb-crypto-store");
            var RoomList = function () {
                function RoomList(cryptoStore) {
                    (0, _classCallCheck2["default"])(this, RoomList);
                    this._cryptoStore = cryptoStore;
                    this._roomEncryption = {};
                }
                (0, _createClass2["default"])(RoomList, [{
                        key: "init",
                        value: function () {
                            var _init = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee() {
                                var _this = this;
                                return _regenerator["default"].wrap(function _callee$(_context) {
                                    while (1) {
                                        switch (_context.prev = _context.next) {
                                            case 0:
                                                _context.next = 2;
                                                return this._cryptoStore.doTxn('readwrite', [_indexeddbCryptoStore.IndexedDBCryptoStore.STORE_ROOMS], function (txn) {
                                                    _this._cryptoStore.getEndToEndRooms(txn, function (result) {
                                                        _this._roomEncryption = result;
                                                    });
                                                });
                                            case 2:
                                            case "end":
                                                return _context.stop();
                                        }
                                    }
                                }, _callee, this);
                            }));
                            function init() {
                                return _init.apply(this, arguments);
                            }
                            return init;
                        }()
                    }, {
                        key: "getRoomEncryption",
                        value: function getRoomEncryption(roomId) {
                            return this._roomEncryption[roomId] || null;
                        }
                    }, {
                        key: "isRoomEncrypted",
                        value: function isRoomEncrypted(roomId) {
                            return Boolean(this.getRoomEncryption(roomId));
                        }
                    }, {
                        key: "setRoomEncryption",
                        value: function () {
                            var _setRoomEncryption = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee2(roomId, roomInfo) {
                                var _this2 = this;
                                return _regenerator["default"].wrap(function _callee2$(_context2) {
                                    while (1) {
                                        switch (_context2.prev = _context2.next) {
                                            case 0:
                                                this._roomEncryption[roomId] = roomInfo;
                                                _context2.next = 3;
                                                return this._cryptoStore.doTxn('readwrite', [_indexeddbCryptoStore.IndexedDBCryptoStore.STORE_ROOMS], function (txn) {
                                                    _this2._cryptoStore.storeEndToEndRoom(roomId, roomInfo, txn);
                                                });
                                            case 3:
                                            case "end":
                                                return _context2.stop();
                                        }
                                    }
                                }, _callee2, this);
                            }));
                            function setRoomEncryption(_x, _x2) {
                                return _setRoomEncryption.apply(this, arguments);
                            }
                            return setRoomEncryption;
                        }()
                    }]);
                return RoomList;
            }();
            exports.RoomList = RoomList;
        }, { "./store/indexeddb-crypto-store": 80, "@babel/runtime/helpers/asyncToGenerator": 5, "@babel/runtime/helpers/classCallCheck": 6, "@babel/runtime/helpers/createClass": 8, "@babel/runtime/helpers/interopRequireDefault": 12, "@babel/runtime/regenerator": 27 }], 67: [function (require, module, exports) {
            "use strict";
            var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
            var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.SecretStorage = exports.SECRET_STORAGE_ALGORITHM_V1_AES = void 0;
            var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
            var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
            var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
            var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
            var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
            var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
            var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
            var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
            var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
            var _events = require("events");
            var _logger = require("../logger");
            var olmlib = _interopRequireWildcard(require("./olmlib"));
            var _randomstring = require("../randomstring");
            var _aes = require("./aes");
            function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
                if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                    if (it)
                        o = it;
                    var i = 0;
                    var F = function F() { };
                    return { s: F, n: function n() { if (i >= o.length)
                            return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try {
                    if (!normalCompletion && it["return"] != null)
                        it["return"]();
                }
                finally {
                    if (didErr)
                        throw err;
                } } }; }
            function _unsupportedIterableToArray(o, minLen) { if (!o)
                return; if (typeof o === "string")
                return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor)
                n = o.constructor.name; if (n === "Map" || n === "Set")
                return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return _arrayLikeToArray(o, minLen); }
            function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length)
                len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
            } return arr2; }
            function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) {
                var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor;
                result = Reflect.construct(Super, arguments, NewTarget);
            }
            else {
                result = Super.apply(this, arguments);
            } return (0, _possibleConstructorReturn2["default"])(this, result); }; }
            function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct)
                return false; if (Reflect.construct.sham)
                return false; if (typeof Proxy === "function")
                return true; try {
                Date.prototype.toString.call(Reflect.construct(Date, [], function () { }));
                return true;
            }
            catch (e) {
                return false;
            } }
            var SECRET_STORAGE_ALGORITHM_V1_AES = "m.secret_storage.v1.aes-hmac-sha2";
            exports.SECRET_STORAGE_ALGORITHM_V1_AES = SECRET_STORAGE_ALGORITHM_V1_AES;
            var ZERO_STR = "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
            var SecretStorage = function (_EventEmitter) {
                (0, _inherits2["default"])(SecretStorage, _EventEmitter);
                var _super = _createSuper(SecretStorage);
                function SecretStorage(baseApis, cryptoCallbacks) {
                    var _this;
                    (0, _classCallCheck2["default"])(this, SecretStorage);
                    _this = _super.call(this);
                    _this._baseApis = baseApis;
                    _this._cryptoCallbacks = cryptoCallbacks;
                    _this._requests = {};
                    _this._incomingRequests = {};
                    return _this;
                }
                (0, _createClass2["default"])(SecretStorage, [{
                        key: "getDefaultKeyId",
                        value: function () {
                            var _getDefaultKeyId = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee() {
                                var defaultKey;
                                return _regenerator["default"].wrap(function _callee$(_context) {
                                    while (1) {
                                        switch (_context.prev = _context.next) {
                                            case 0:
                                                _context.next = 2;
                                                return this._baseApis.getAccountDataFromServer('m.secret_storage.default_key');
                                            case 2:
                                                defaultKey = _context.sent;
                                                if (defaultKey) {
                                                    _context.next = 5;
                                                    break;
                                                }
                                                return _context.abrupt("return", null);
                                            case 5:
                                                return _context.abrupt("return", defaultKey.key);
                                            case 6:
                                            case "end":
                                                return _context.stop();
                                        }
                                    }
                                }, _callee, this);
                            }));
                            function getDefaultKeyId() {
                                return _getDefaultKeyId.apply(this, arguments);
                            }
                            return getDefaultKeyId;
                        }()
                    }, {
                        key: "setDefaultKeyId",
                        value: function setDefaultKeyId(keyId) {
                            var _this2 = this;
                            return new Promise(function () {
                                var _ref = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee2(resolve, reject) {
                                    var listener;
                                    return _regenerator["default"].wrap(function _callee2$(_context2) {
                                        while (1) {
                                            switch (_context2.prev = _context2.next) {
                                                case 0:
                                                    listener = function listener(ev) {
                                                        if (ev.getType() === 'm.secret_storage.default_key' && ev.getContent().key === keyId) {
                                                            _this2._baseApis.removeListener('accountData', listener);
                                                            resolve();
                                                        }
                                                    };
                                                    _this2._baseApis.on('accountData', listener);
                                                    _context2.prev = 2;
                                                    _context2.next = 5;
                                                    return _this2._baseApis.setAccountData('m.secret_storage.default_key', {
                                                        key: keyId
                                                    });
                                                case 5:
                                                    _context2.next = 11;
                                                    break;
                                                case 7:
                                                    _context2.prev = 7;
                                                    _context2.t0 = _context2["catch"](2);
                                                    _this2._baseApis.removeListener('accountData', listener);
                                                    reject(_context2.t0);
                                                case 11:
                                                case "end":
                                                    return _context2.stop();
                                            }
                                        }
                                    }, _callee2, null, [[2, 7]]);
                                }));
                                return function (_x, _x2) {
                                    return _ref.apply(this, arguments);
                                };
                            }());
                        }
                    }, {
                        key: "addKey",
                        value: function () {
                            var _addKey = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee3(algorithm, opts, keyId) {
                                var keyInfo, _yield$SecretStorage$, iv, mac;
                                return _regenerator["default"].wrap(function _callee3$(_context3) {
                                    while (1) {
                                        switch (_context3.prev = _context3.next) {
                                            case 0:
                                                keyInfo = {
                                                    algorithm: algorithm
                                                };
                                                if (!opts)
                                                    opts = {};
                                                if (opts.name) {
                                                    keyInfo.name = opts.name;
                                                }
                                                if (!(algorithm === SECRET_STORAGE_ALGORITHM_V1_AES)) {
                                                    _context3.next = 15;
                                                    break;
                                                }
                                                if (opts.passphrase) {
                                                    keyInfo.passphrase = opts.passphrase;
                                                }
                                                if (!opts.key) {
                                                    _context3.next = 13;
                                                    break;
                                                }
                                                _context3.next = 8;
                                                return SecretStorage._calculateKeyCheck(opts.key);
                                            case 8:
                                                _yield$SecretStorage$ = _context3.sent;
                                                iv = _yield$SecretStorage$.iv;
                                                mac = _yield$SecretStorage$.mac;
                                                keyInfo.iv = iv;
                                                keyInfo.mac = mac;
                                            case 13:
                                                _context3.next = 16;
                                                break;
                                            case 15:
                                                throw new Error("Unknown key algorithm ".concat(opts.algorithm));
                                            case 16:
                                                if (keyId) {
                                                    _context3.next = 21;
                                                    break;
                                                }
                                            case 17:
                                                keyId = (0, _randomstring.randomString)(32);
                                            case 18:
                                                _context3.next = 20;
                                                return this._baseApis.getAccountDataFromServer("m.secret_storage.key.".concat(keyId));
                                            case 20:
                                                if (_context3.sent) {
                                                    _context3.next = 17;
                                                    break;
                                                }
                                            case 21:
                                                _context3.next = 23;
                                                return this._baseApis.setAccountData("m.secret_storage.key.".concat(keyId), keyInfo);
                                            case 23:
                                                return _context3.abrupt("return", {
                                                    keyId: keyId,
                                                    keyInfo: keyInfo
                                                });
                                            case 24:
                                            case "end":
                                                return _context3.stop();
                                        }
                                    }
                                }, _callee3, this);
                            }));
                            function addKey(_x3, _x4, _x5) {
                                return _addKey.apply(this, arguments);
                            }
                            return addKey;
                        }()
                    }, {
                        key: "getKey",
                        value: function () {
                            var _getKey = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee4(keyId) {
                                var keyInfo;
                                return _regenerator["default"].wrap(function _callee4$(_context4) {
                                    while (1) {
                                        switch (_context4.prev = _context4.next) {
                                            case 0:
                                                if (keyId) {
                                                    _context4.next = 4;
                                                    break;
                                                }
                                                _context4.next = 3;
                                                return this.getDefaultKeyId();
                                            case 3:
                                                keyId = _context4.sent;
                                            case 4:
                                                if (keyId) {
                                                    _context4.next = 6;
                                                    break;
                                                }
                                                return _context4.abrupt("return", null);
                                            case 6:
                                                _context4.next = 8;
                                                return this._baseApis.getAccountDataFromServer("m.secret_storage.key." + keyId);
                                            case 8:
                                                keyInfo = _context4.sent;
                                                return _context4.abrupt("return", keyInfo ? [keyId, keyInfo] : null);
                                            case 10:
                                            case "end":
                                                return _context4.stop();
                                        }
                                    }
                                }, _callee4, this);
                            }));
                            function getKey(_x6) {
                                return _getKey.apply(this, arguments);
                            }
                            return getKey;
                        }()
                    }, {
                        key: "hasKey",
                        value: function () {
                            var _hasKey = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee5(keyId) {
                                return _regenerator["default"].wrap(function _callee5$(_context5) {
                                    while (1) {
                                        switch (_context5.prev = _context5.next) {
                                            case 0:
                                                _context5.next = 2;
                                                return this.getKey(keyId);
                                            case 2:
                                                return _context5.abrupt("return", !!_context5.sent);
                                            case 3:
                                            case "end":
                                                return _context5.stop();
                                        }
                                    }
                                }, _callee5, this);
                            }));
                            function hasKey(_x7) {
                                return _hasKey.apply(this, arguments);
                            }
                            return hasKey;
                        }()
                    }, {
                        key: "checkKey",
                        value: function () {
                            var _checkKey = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee6(key, info) {
                                var _yield$SecretStorage$2, mac;
                                return _regenerator["default"].wrap(function _callee6$(_context6) {
                                    while (1) {
                                        switch (_context6.prev = _context6.next) {
                                            case 0:
                                                if (!(info.algorithm === SECRET_STORAGE_ALGORITHM_V1_AES)) {
                                                    _context6.next = 12;
                                                    break;
                                                }
                                                if (!info.mac) {
                                                    _context6.next = 9;
                                                    break;
                                                }
                                                _context6.next = 4;
                                                return SecretStorage._calculateKeyCheck(key, info.iv);
                                            case 4:
                                                _yield$SecretStorage$2 = _context6.sent;
                                                mac = _yield$SecretStorage$2.mac;
                                                return _context6.abrupt("return", info.mac.replace(/=+$/g, '') === mac.replace(/=+$/g, ''));
                                            case 9:
                                                return _context6.abrupt("return", true);
                                            case 10:
                                                _context6.next = 13;
                                                break;
                                            case 12:
                                                throw new Error("Unknown algorithm");
                                            case 13:
                                            case "end":
                                                return _context6.stop();
                                        }
                                    }
                                }, _callee6);
                            }));
                            function checkKey(_x8, _x9) {
                                return _checkKey.apply(this, arguments);
                            }
                            return checkKey;
                        }()
                    }, {
                        key: "store",
                        value: function () {
                            var _store = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee7(name, secret, keys) {
                                var encrypted, defaultKeyId, _iterator, _step, keyId, keyInfo, _keys, _yield$this$_getSecre, _yield$this$_getSecre2, encryption;
                                return _regenerator["default"].wrap(function _callee7$(_context7) {
                                    while (1) {
                                        switch (_context7.prev = _context7.next) {
                                            case 0:
                                                encrypted = {};
                                                if (keys) {
                                                    _context7.next = 8;
                                                    break;
                                                }
                                                _context7.next = 4;
                                                return this.getDefaultKeyId();
                                            case 4:
                                                defaultKeyId = _context7.sent;
                                                if (defaultKeyId) {
                                                    _context7.next = 7;
                                                    break;
                                                }
                                                throw new Error("No keys specified and no default key present");
                                            case 7:
                                                keys = [defaultKeyId];
                                            case 8:
                                                if (!(keys.length === 0)) {
                                                    _context7.next = 10;
                                                    break;
                                                }
                                                throw new Error("Zero keys given to encrypt with!");
                                            case 10:
                                                _iterator = _createForOfIteratorHelper(keys);
                                                _context7.prev = 11;
                                                _iterator.s();
                                            case 13:
                                                if ((_step = _iterator.n()).done) {
                                                    _context7.next = 35;
                                                    break;
                                                }
                                                keyId = _step.value;
                                                _context7.next = 17;
                                                return this._baseApis.getAccountDataFromServer("m.secret_storage.key." + keyId);
                                            case 17:
                                                keyInfo = _context7.sent;
                                                if (keyInfo) {
                                                    _context7.next = 20;
                                                    break;
                                                }
                                                throw new Error("Unknown key: " + keyId);
                                            case 20:
                                                if (!(keyInfo.algorithm === SECRET_STORAGE_ALGORITHM_V1_AES)) {
                                                    _context7.next = 32;
                                                    break;
                                                }
                                                _keys = (0, _defineProperty2["default"])({}, keyId, keyInfo);
                                                _context7.next = 24;
                                                return this._getSecretStorageKey(_keys, name);
                                            case 24:
                                                _yield$this$_getSecre = _context7.sent;
                                                _yield$this$_getSecre2 = (0, _slicedToArray2["default"])(_yield$this$_getSecre, 2);
                                                encryption = _yield$this$_getSecre2[1];
                                                _context7.next = 29;
                                                return encryption.encrypt(secret);
                                            case 29:
                                                encrypted[keyId] = _context7.sent;
                                                _context7.next = 33;
                                                break;
                                            case 32:
                                                _logger.logger.warn("unknown algorithm for secret storage key " + keyId + ": " + keyInfo.algorithm);
                                            case 33:
                                                _context7.next = 13;
                                                break;
                                            case 35:
                                                _context7.next = 40;
                                                break;
                                            case 37:
                                                _context7.prev = 37;
                                                _context7.t0 = _context7["catch"](11);
                                                _iterator.e(_context7.t0);
                                            case 40:
                                                _context7.prev = 40;
                                                _iterator.f();
                                                return _context7.finish(40);
                                            case 43:
                                                _context7.next = 45;
                                                return this._baseApis.setAccountData(name, {
                                                    encrypted: encrypted
                                                });
                                            case 45:
                                            case "end":
                                                return _context7.stop();
                                        }
                                    }
                                }, _callee7, this, [[11, 37, 40, 43]]);
                            }));
                            function store(_x10, _x11, _x12) {
                                return _store.apply(this, arguments);
                            }
                            return store;
                        }()
                    }, {
                        key: "_fixupStoredSecret",
                        value: function () {
                            var _fixupStoredSecret2 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee8(name, secretInfo) {
                                var keys, hasKey, newData;
                                return _regenerator["default"].wrap(function _callee8$(_context8) {
                                    while (1) {
                                        switch (_context8.prev = _context8.next) {
                                            case 0:
                                                keys = Object.keys(secretInfo);
                                                if (!(keys.length === 1 && keys[0] !== 'encrypted' && secretInfo[keys[0]].passthrough)) {
                                                    _context8.next = 13;
                                                    break;
                                                }
                                                _context8.next = 4;
                                                return this.hasKey(keys[0]);
                                            case 4:
                                                hasKey = _context8.sent;
                                                if (!hasKey) {
                                                    _context8.next = 13;
                                                    break;
                                                }
                                                _logger.logger.log("Fixing up passthrough secret: " + name);
                                                _context8.next = 9;
                                                return this.storePassthrough(name, keys[0]);
                                            case 9:
                                                _context8.next = 11;
                                                return this._baseApis.getAccountDataFromServer(name);
                                            case 11:
                                                newData = _context8.sent;
                                                return _context8.abrupt("return", newData);
                                            case 13:
                                                return _context8.abrupt("return", null);
                                            case 14:
                                            case "end":
                                                return _context8.stop();
                                        }
                                    }
                                }, _callee8, this);
                            }));
                            function _fixupStoredSecret(_x13, _x14) {
                                return _fixupStoredSecret2.apply(this, arguments);
                            }
                            return _fixupStoredSecret;
                        }()
                    }, {
                        key: "get",
                        value: function () {
                            var _get = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee9(name) {
                                var secretInfo, keys, _i, _Object$keys, _keyId, keyInfo, encInfo, keyId, decryption, _yield$this$_getSecre3, _yield$this$_getSecre4, _encInfo;
                                return _regenerator["default"].wrap(function _callee9$(_context9) {
                                    while (1) {
                                        switch (_context9.prev = _context9.next) {
                                            case 0:
                                                _context9.next = 2;
                                                return this._baseApis.getAccountDataFromServer(name);
                                            case 2:
                                                secretInfo = _context9.sent;
                                                if (secretInfo) {
                                                    _context9.next = 5;
                                                    break;
                                                }
                                                return _context9.abrupt("return");
                                            case 5:
                                                if (secretInfo.encrypted) {
                                                    _context9.next = 11;
                                                    break;
                                                }
                                                _context9.next = 8;
                                                return this._fixupStoredSecret(name, secretInfo);
                                            case 8:
                                                secretInfo = _context9.sent;
                                                if (!(!secretInfo || !secretInfo.encrypted)) {
                                                    _context9.next = 11;
                                                    break;
                                                }
                                                throw new Error("Content is not encrypted!");
                                            case 11:
                                                keys = {};
                                                _i = 0, _Object$keys = Object.keys(secretInfo.encrypted);
                                            case 13:
                                                if (!(_i < _Object$keys.length)) {
                                                    _context9.next = 23;
                                                    break;
                                                }
                                                _keyId = _Object$keys[_i];
                                                _context9.next = 17;
                                                return this._baseApis.getAccountDataFromServer("m.secret_storage.key." + _keyId);
                                            case 17:
                                                keyInfo = _context9.sent;
                                                encInfo = secretInfo.encrypted[_keyId];
                                                if (keyInfo.algorithm === SECRET_STORAGE_ALGORITHM_V1_AES) {
                                                    if (encInfo.iv && encInfo.ciphertext && encInfo.mac) {
                                                        keys[_keyId] = keyInfo;
                                                    }
                                                }
                                            case 20:
                                                _i++;
                                                _context9.next = 13;
                                                break;
                                            case 23:
                                                if (!(Object.keys(keys).length === 0)) {
                                                    _context9.next = 25;
                                                    break;
                                                }
                                                throw new Error("Could not decrypt ".concat(name, " because none of ") + "the keys it is encrypted with are for a supported algorithm");
                                            case 25:
                                                _context9.prev = 25;
                                                _context9.next = 28;
                                                return this._getSecretStorageKey(keys, name);
                                            case 28:
                                                _yield$this$_getSecre3 = _context9.sent;
                                                _yield$this$_getSecre4 = (0, _slicedToArray2["default"])(_yield$this$_getSecre3, 2);
                                                keyId = _yield$this$_getSecre4[0];
                                                decryption = _yield$this$_getSecre4[1];
                                                _encInfo = secretInfo.encrypted[keyId];
                                                if (!_encInfo.passthrough) {
                                                    _context9.next = 35;
                                                    break;
                                                }
                                                return _context9.abrupt("return", (0, olmlib.encodeBase64)(decryption.get_private_key()));
                                            case 35:
                                                _context9.next = 37;
                                                return decryption.decrypt(_encInfo);
                                            case 37:
                                                return _context9.abrupt("return", _context9.sent);
                                            case 38:
                                                _context9.prev = 38;
                                                if (decryption && decryption.free)
                                                    decryption.free();
                                                return _context9.finish(38);
                                            case 41:
                                            case "end":
                                                return _context9.stop();
                                        }
                                    }
                                }, _callee9, this, [[25, , 38, 41]]);
                            }));
                            function get(_x15) {
                                return _get.apply(this, arguments);
                            }
                            return get;
                        }()
                    }, {
                        key: "isStored",
                        value: function () {
                            var _isStored = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee10(name, checkKey) {
                                var secretInfo, ret, _i2, _Object$keys2, keyId, keyInfo, encInfo;
                                return _regenerator["default"].wrap(function _callee10$(_context10) {
                                    while (1) {
                                        switch (_context10.prev = _context10.next) {
                                            case 0:
                                                _context10.next = 2;
                                                return this._baseApis.getAccountDataFromServer(name);
                                            case 2:
                                                secretInfo = _context10.sent;
                                                if (secretInfo) {
                                                    _context10.next = 5;
                                                    break;
                                                }
                                                return _context10.abrupt("return", null);
                                            case 5:
                                                if (secretInfo.encrypted) {
                                                    _context10.next = 11;
                                                    break;
                                                }
                                                _context10.next = 8;
                                                return this._fixupStoredSecret(name, secretInfo);
                                            case 8:
                                                secretInfo = _context10.sent;
                                                if (!(!secretInfo || !secretInfo.encrypted)) {
                                                    _context10.next = 11;
                                                    break;
                                                }
                                                return _context10.abrupt("return", null);
                                            case 11:
                                                if (checkKey === undefined)
                                                    checkKey = true;
                                                ret = {};
                                                _i2 = 0, _Object$keys2 = Object.keys(secretInfo.encrypted);
                                            case 14:
                                                if (!(_i2 < _Object$keys2.length)) {
                                                    _context10.next = 26;
                                                    break;
                                                }
                                                keyId = _Object$keys2[_i2];
                                                _context10.next = 18;
                                                return this._baseApis.getAccountDataFromServer("m.secret_storage.key." + keyId);
                                            case 18:
                                                keyInfo = _context10.sent;
                                                if (keyInfo) {
                                                    _context10.next = 21;
                                                    break;
                                                }
                                                return _context10.abrupt("continue", 23);
                                            case 21:
                                                encInfo = secretInfo.encrypted[keyId];
                                                if (keyInfo.algorithm === SECRET_STORAGE_ALGORITHM_V1_AES) {
                                                    if (encInfo.iv && encInfo.ciphertext && encInfo.mac) {
                                                        ret[keyId] = keyInfo;
                                                    }
                                                }
                                            case 23:
                                                _i2++;
                                                _context10.next = 14;
                                                break;
                                            case 26:
                                                return _context10.abrupt("return", Object.keys(ret).length ? ret : null);
                                            case 27:
                                            case "end":
                                                return _context10.stop();
                                        }
                                    }
                                }, _callee10, this);
                            }));
                            function isStored(_x16, _x17) {
                                return _isStored.apply(this, arguments);
                            }
                            return isStored;
                        }()
                    }, {
                        key: "request",
                        value: function request(name, devices) {
                            var _this3 = this;
                            var requestId = this._baseApis.makeTxnId();
                            var requestControl = this._requests[requestId] = {
                                name: name,
                                devices: devices
                            };
                            var promise = new Promise(function (resolve, reject) {
                                requestControl.resolve = resolve;
                                requestControl.reject = reject;
                            });
                            var cancel = function cancel(reason) {
                                var cancelData = {
                                    action: "request_cancellation",
                                    requesting_device_id: _this3._baseApis.deviceId,
                                    request_id: requestId
                                };
                                var toDevice = {};
                                var _iterator2 = _createForOfIteratorHelper(devices), _step2;
                                try {
                                    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                                        var device = _step2.value;
                                        toDevice[device] = cancelData;
                                    }
                                }
                                catch (err) {
                                    _iterator2.e(err);
                                }
                                finally {
                                    _iterator2.f();
                                }
                                _this3._baseApis.sendToDevice("m.secret.request", (0, _defineProperty2["default"])({}, _this3._baseApis.getUserId(), toDevice));
                                requestControl.reject(new Error(reason || "Cancelled"));
                            };
                            var requestData = {
                                name: name,
                                action: "request",
                                requesting_device_id: this._baseApis.deviceId,
                                request_id: requestId
                            };
                            var toDevice = {};
                            var _iterator3 = _createForOfIteratorHelper(devices), _step3;
                            try {
                                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                                    var device = _step3.value;
                                    toDevice[device] = requestData;
                                }
                            }
                            catch (err) {
                                _iterator3.e(err);
                            }
                            finally {
                                _iterator3.f();
                            }
                            _logger.logger.info("Request secret ".concat(name, " from ").concat(devices, ", id ").concat(requestId));
                            this._baseApis.sendToDevice("m.secret.request", (0, _defineProperty2["default"])({}, this._baseApis.getUserId(), toDevice));
                            return {
                                request_id: requestId,
                                promise: promise,
                                cancel: cancel
                            };
                        }
                    }, {
                        key: "_onRequestReceived",
                        value: function () {
                            var _onRequestReceived2 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee11(event) {
                                var sender, content, deviceId, secret, payload, encryptedContent, contentMap;
                                return _regenerator["default"].wrap(function _callee11$(_context11) {
                                    while (1) {
                                        switch (_context11.prev = _context11.next) {
                                            case 0:
                                                sender = event.getSender();
                                                content = event.getContent();
                                                if (!(sender !== this._baseApis.getUserId() || !(content.name && content.action && content.requesting_device_id && content.request_id))) {
                                                    _context11.next = 4;
                                                    break;
                                                }
                                                return _context11.abrupt("return");
                                            case 4:
                                                deviceId = content.requesting_device_id;
                                                if (!(content.action === "request_cancellation")) {
                                                    _context11.next = 9;
                                                    break;
                                                }
                                                if (this._incomingRequests[deviceId] && this._incomingRequests[deviceId][content.request_id]) {
                                                    _logger.logger.info("received request cancellation for secret (" + sender + ", " + deviceId + ", " + content.request_id + ")");
                                                    this.baseApis.emit("crypto.secrets.requestCancelled", {
                                                        user_id: sender,
                                                        device_id: deviceId,
                                                        request_id: content.request_id
                                                    });
                                                }
                                                _context11.next = 32;
                                                break;
                                            case 9:
                                                if (!(content.action === "request")) {
                                                    _context11.next = 32;
                                                    break;
                                                }
                                                if (!(deviceId === this._baseApis.deviceId)) {
                                                    _context11.next = 12;
                                                    break;
                                                }
                                                return _context11.abrupt("return");
                                            case 12:
                                                _logger.logger.info("received request for secret (" + sender + ", " + deviceId + ", " + content.request_id + ")");
                                                if (this._cryptoCallbacks.onSecretRequested) {
                                                    _context11.next = 15;
                                                    break;
                                                }
                                                return _context11.abrupt("return");
                                            case 15:
                                                _context11.next = 17;
                                                return this._cryptoCallbacks.onSecretRequested(sender, deviceId, content.request_id, content.name, this._baseApis.checkDeviceTrust(sender, deviceId));
                                            case 17:
                                                secret = _context11.sent;
                                                if (!secret) {
                                                    _context11.next = 31;
                                                    break;
                                                }
                                                _logger.logger.info("Preparing ".concat(content.name, " secret for ").concat(deviceId));
                                                payload = {
                                                    type: "m.secret.send",
                                                    content: {
                                                        request_id: content.request_id,
                                                        secret: secret
                                                    }
                                                };
                                                encryptedContent = {
                                                    algorithm: olmlib.OLM_ALGORITHM,
                                                    sender_key: this._baseApis._crypto._olmDevice.deviceCurve25519Key,
                                                    ciphertext: {}
                                                };
                                                _context11.next = 24;
                                                return olmlib.ensureOlmSessionsForDevices(this._baseApis._crypto._olmDevice, this._baseApis, (0, _defineProperty2["default"])({}, sender, [this._baseApis.getStoredDevice(sender, deviceId)]));
                                            case 24:
                                                _context11.next = 26;
                                                return olmlib.encryptMessageForDevice(encryptedContent.ciphertext, this._baseApis.getUserId(), this._baseApis.deviceId, this._baseApis._crypto._olmDevice, sender, this._baseApis.getStoredDevice(sender, deviceId), payload);
                                            case 26:
                                                contentMap = (0, _defineProperty2["default"])({}, sender, (0, _defineProperty2["default"])({}, deviceId, encryptedContent));
                                                _logger.logger.info("Sending ".concat(content.name, " secret for ").concat(deviceId));
                                                this._baseApis.sendToDevice("m.room.encrypted", contentMap);
                                                _context11.next = 32;
                                                break;
                                            case 31:
                                                _logger.logger.info("Request denied for ".concat(content.name, " secret for ").concat(deviceId));
                                            case 32:
                                            case "end":
                                                return _context11.stop();
                                        }
                                    }
                                }, _callee11, this);
                            }));
                            function _onRequestReceived(_x18) {
                                return _onRequestReceived2.apply(this, arguments);
                            }
                            return _onRequestReceived;
                        }()
                    }, {
                        key: "_onSecretReceived",
                        value: function _onSecretReceived(event) {
                            if (event.getSender() !== this._baseApis.getUserId()) {
                                return;
                            }
                            var content = event.getContent();
                            _logger.logger.log("got secret share for request", content.request_id);
                            var requestControl = this._requests[content.request_id];
                            if (requestControl) {
                                var deviceInfo = this._baseApis._crypto._deviceList.getDeviceByIdentityKey(olmlib.OLM_ALGORITHM, event.getSenderKey());
                                if (!deviceInfo) {
                                    _logger.logger.log("secret share from unknown device with key", event.getSenderKey());
                                    return;
                                }
                                if (!requestControl.devices.includes(deviceInfo.deviceId)) {
                                    _logger.logger.log("unsolicited secret share from device", deviceInfo.deviceId);
                                    return;
                                }
                                _logger.logger.log("Successfully received secret ".concat(requestControl.name, " ") + "from ".concat(deviceInfo.deviceId));
                                requestControl.resolve(content.secret);
                            }
                        }
                    }, {
                        key: "_getSecretStorageKey",
                        value: function () {
                            var _getSecretStorageKey2 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee14(keys, name) {
                                var returned, _returned, keyId, privateKey, decryption;
                                return _regenerator["default"].wrap(function _callee14$(_context14) {
                                    while (1) {
                                        switch (_context14.prev = _context14.next) {
                                            case 0:
                                                if (this._cryptoCallbacks.getSecretStorageKey) {
                                                    _context14.next = 2;
                                                    break;
                                                }
                                                throw new Error("No getSecretStorageKey callback supplied");
                                            case 2:
                                                _context14.next = 4;
                                                return this._cryptoCallbacks.getSecretStorageKey({
                                                    keys: keys
                                                }, name);
                                            case 4:
                                                returned = _context14.sent;
                                                if (returned) {
                                                    _context14.next = 7;
                                                    break;
                                                }
                                                throw new Error("getSecretStorageKey callback returned falsey");
                                            case 7:
                                                if (!(returned.length < 2)) {
                                                    _context14.next = 9;
                                                    break;
                                                }
                                                throw new Error("getSecretStorageKey callback returned invalid data");
                                            case 9:
                                                _returned = (0, _slicedToArray2["default"])(returned, 2), keyId = _returned[0], privateKey = _returned[1];
                                                if (keys[keyId]) {
                                                    _context14.next = 12;
                                                    break;
                                                }
                                                throw new Error("App returned unknown key from getSecretStorageKey!");
                                            case 12:
                                                if (!(keys[keyId].algorithm === SECRET_STORAGE_ALGORITHM_V1_AES)) {
                                                    _context14.next = 17;
                                                    break;
                                                }
                                                decryption = {
                                                    encrypt: function () {
                                                        var _encrypt = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee12(secret) {
                                                            return _regenerator["default"].wrap(function _callee12$(_context12) {
                                                                while (1) {
                                                                    switch (_context12.prev = _context12.next) {
                                                                        case 0:
                                                                            _context12.next = 2;
                                                                            return (0, _aes.encryptAES)(secret, privateKey, name);
                                                                        case 2:
                                                                            return _context12.abrupt("return", _context12.sent);
                                                                        case 3:
                                                                        case "end":
                                                                            return _context12.stop();
                                                                    }
                                                                }
                                                            }, _callee12);
                                                        }));
                                                        function encrypt(_x21) {
                                                            return _encrypt.apply(this, arguments);
                                                        }
                                                        return encrypt;
                                                    }(),
                                                    decrypt: function () {
                                                        var _decrypt = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee13(encInfo) {
                                                            return _regenerator["default"].wrap(function _callee13$(_context13) {
                                                                while (1) {
                                                                    switch (_context13.prev = _context13.next) {
                                                                        case 0:
                                                                            _context13.next = 2;
                                                                            return (0, _aes.decryptAES)(encInfo, privateKey, name);
                                                                        case 2:
                                                                            return _context13.abrupt("return", _context13.sent);
                                                                        case 3:
                                                                        case "end":
                                                                            return _context13.stop();
                                                                    }
                                                                }
                                                            }, _callee13);
                                                        }));
                                                        function decrypt(_x22) {
                                                            return _decrypt.apply(this, arguments);
                                                        }
                                                        return decrypt;
                                                    }()
                                                };
                                                return _context14.abrupt("return", [keyId, decryption]);
                                            case 17:
                                                throw new Error("Unknown key type: " + keys[keyId].algorithm);
                                            case 18:
                                            case "end":
                                                return _context14.stop();
                                        }
                                    }
                                }, _callee14, this);
                            }));
                            function _getSecretStorageKey(_x19, _x20) {
                                return _getSecretStorageKey2.apply(this, arguments);
                            }
                            return _getSecretStorageKey;
                        }()
                    }], [{
                        key: "_calculateKeyCheck",
                        value: function () {
                            var _calculateKeyCheck2 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee15(key, iv) {
                                return _regenerator["default"].wrap(function _callee15$(_context15) {
                                    while (1) {
                                        switch (_context15.prev = _context15.next) {
                                            case 0:
                                                _context15.next = 2;
                                                return (0, _aes.encryptAES)(ZERO_STR, key, "", iv);
                                            case 2:
                                                return _context15.abrupt("return", _context15.sent);
                                            case 3:
                                            case "end":
                                                return _context15.stop();
                                        }
                                    }
                                }, _callee15);
                            }));
                            function _calculateKeyCheck(_x23, _x24) {
                                return _calculateKeyCheck2.apply(this, arguments);
                            }
                            return _calculateKeyCheck;
                        }()
                    }]);
                return SecretStorage;
            }(_events.EventEmitter);
            exports.SecretStorage = SecretStorage;
        }, { "../logger": 97, "../randomstring": 112, "./aes": 68, "./olmlib": 77, "@babel/runtime/helpers/asyncToGenerator": 5, "@babel/runtime/helpers/classCallCheck": 6, "@babel/runtime/helpers/createClass": 8, "@babel/runtime/helpers/defineProperty": 9, "@babel/runtime/helpers/getPrototypeOf": 10, "@babel/runtime/helpers/inherits": 11, "@babel/runtime/helpers/interopRequireDefault": 12, "@babel/runtime/helpers/interopRequireWildcard": 13, "@babel/runtime/helpers/possibleConstructorReturn": 20, "@babel/runtime/helpers/slicedToArray": 22, "@babel/runtime/regenerator": 27, "events": 36 }], 68: [function (require, module, exports) {
            (function (Buffer) {
                (function () {
                    "use strict";
                    var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
                    Object.defineProperty(exports, "__esModule", {
                        value: true
                    });
                    exports.encryptAES = encryptAES;
                    exports.decryptAES = decryptAES;
                    var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
                    var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
                    var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
                    var _utils = require("../utils");
                    var _olmlib = require("./olmlib");
                    var subtleCrypto = typeof window !== "undefined" && window.crypto ? window.crypto.subtle || window.crypto.webkitSubtle : null;
                    var zerosalt = new Uint8Array(8);
                    function encryptNode(_x, _x2, _x3, _x4) {
                        return _encryptNode.apply(this, arguments);
                    }
                    function _encryptNode() {
                        _encryptNode = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee(data, key, name, ivStr) {
                            var crypto, iv, _deriveKeysNode, _deriveKeysNode2, aesKey, hmacKey, cipher, ciphertext, hmac;
                            return _regenerator["default"].wrap(function _callee$(_context) {
                                while (1) {
                                    switch (_context.prev = _context.next) {
                                        case 0:
                                            crypto = (0, _utils.getCrypto)();
                                            if (crypto) {
                                                _context.next = 3;
                                                break;
                                            }
                                            throw new Error("No usable crypto implementation");
                                        case 3:
                                            if (ivStr) {
                                                iv = (0, _olmlib.decodeBase64)(ivStr);
                                            }
                                            else {
                                                iv = crypto.randomBytes(16);
                                            }
                                            iv[8] &= 0x7f;
                                            _deriveKeysNode = deriveKeysNode(key, name), _deriveKeysNode2 = (0, _slicedToArray2["default"])(_deriveKeysNode, 2), aesKey = _deriveKeysNode2[0], hmacKey = _deriveKeysNode2[1];
                                            cipher = crypto.createCipheriv("aes-256-ctr", aesKey, iv);
                                            ciphertext = cipher.update(data, "utf-8", "base64") + cipher["final"]("base64");
                                            hmac = crypto.createHmac("sha256", hmacKey).update(ciphertext, "base64").digest("base64");
                                            return _context.abrupt("return", {
                                                iv: (0, _olmlib.encodeBase64)(iv),
                                                ciphertext: ciphertext,
                                                mac: hmac
                                            });
                                        case 10:
                                        case "end":
                                            return _context.stop();
                                    }
                                }
                            }, _callee);
                        }));
                        return _encryptNode.apply(this, arguments);
                    }
                    function decryptNode(_x5, _x6, _x7) {
                        return _decryptNode.apply(this, arguments);
                    }
                    function _decryptNode() {
                        _decryptNode = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee2(data, key, name) {
                            var crypto, _deriveKeysNode3, _deriveKeysNode4, aesKey, hmacKey, hmac, decipher;
                            return _regenerator["default"].wrap(function _callee2$(_context2) {
                                while (1) {
                                    switch (_context2.prev = _context2.next) {
                                        case 0:
                                            crypto = (0, _utils.getCrypto)();
                                            if (crypto) {
                                                _context2.next = 3;
                                                break;
                                            }
                                            throw new Error("No usable crypto implementation");
                                        case 3:
                                            _deriveKeysNode3 = deriveKeysNode(key, name), _deriveKeysNode4 = (0, _slicedToArray2["default"])(_deriveKeysNode3, 2), aesKey = _deriveKeysNode4[0], hmacKey = _deriveKeysNode4[1];
                                            hmac = crypto.createHmac("sha256", hmacKey).update(data.ciphertext, "base64").digest("base64").replace(/=+$/g, '');
                                            if (!(hmac !== data.mac.replace(/=+$/g, ''))) {
                                                _context2.next = 7;
                                                break;
                                            }
                                            throw new Error("Error decrypting secret ".concat(name, ": bad MAC"));
                                        case 7:
                                            decipher = crypto.createDecipheriv("aes-256-ctr", aesKey, (0, _olmlib.decodeBase64)(data.iv));
                                            return _context2.abrupt("return", decipher.update(data.ciphertext, "base64", "utf-8") + decipher["final"]("utf-8"));
                                        case 9:
                                        case "end":
                                            return _context2.stop();
                                    }
                                }
                            }, _callee2);
                        }));
                        return _decryptNode.apply(this, arguments);
                    }
                    function deriveKeysNode(key, name) {
                        var crypto = (0, _utils.getCrypto)();
                        var prk = crypto.createHmac("sha256", zerosalt).update(key).digest();
                        var b = Buffer.alloc(1, 1);
                        var aesKey = crypto.createHmac("sha256", prk).update(name, "utf-8").update(b).digest();
                        b[0] = 2;
                        var hmacKey = crypto.createHmac("sha256", prk).update(aesKey).update(name, "utf-8").update(b).digest();
                        return [aesKey, hmacKey];
                    }
                    function encryptBrowser(_x8, _x9, _x10, _x11) {
                        return _encryptBrowser.apply(this, arguments);
                    }
                    function _encryptBrowser() {
                        _encryptBrowser = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee3(data, key, name, ivStr) {
                            var iv, _yield$deriveKeysBrow, _yield$deriveKeysBrow2, aesKey, hmacKey, encodedData, ciphertext, hmac;
                            return _regenerator["default"].wrap(function _callee3$(_context3) {
                                while (1) {
                                    switch (_context3.prev = _context3.next) {
                                        case 0:
                                            if (ivStr) {
                                                iv = (0, _olmlib.decodeBase64)(ivStr);
                                            }
                                            else {
                                                iv = new Uint8Array(16);
                                                window.crypto.getRandomValues(iv);
                                            }
                                            iv[8] &= 0x7f;
                                            _context3.next = 4;
                                            return deriveKeysBrowser(key, name);
                                        case 4:
                                            _yield$deriveKeysBrow = _context3.sent;
                                            _yield$deriveKeysBrow2 = (0, _slicedToArray2["default"])(_yield$deriveKeysBrow, 2);
                                            aesKey = _yield$deriveKeysBrow2[0];
                                            hmacKey = _yield$deriveKeysBrow2[1];
                                            encodedData = new TextEncoder().encode(data);
                                            _context3.next = 11;
                                            return subtleCrypto.encrypt({
                                                name: "AES-CTR",
                                                counter: iv,
                                                length: 64
                                            }, aesKey, encodedData);
                                        case 11:
                                            ciphertext = _context3.sent;
                                            _context3.next = 14;
                                            return subtleCrypto.sign({
                                                name: 'HMAC'
                                            }, hmacKey, ciphertext);
                                        case 14:
                                            hmac = _context3.sent;
                                            return _context3.abrupt("return", {
                                                iv: (0, _olmlib.encodeBase64)(iv),
                                                ciphertext: (0, _olmlib.encodeBase64)(ciphertext),
                                                mac: (0, _olmlib.encodeBase64)(hmac)
                                            });
                                        case 16:
                                        case "end":
                                            return _context3.stop();
                                    }
                                }
                            }, _callee3);
                        }));
                        return _encryptBrowser.apply(this, arguments);
                    }
                    function decryptBrowser(_x12, _x13, _x14) {
                        return _decryptBrowser.apply(this, arguments);
                    }
                    function _decryptBrowser() {
                        _decryptBrowser = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee4(data, key, name) {
                            var _yield$deriveKeysBrow3, _yield$deriveKeysBrow4, aesKey, hmacKey, ciphertext, plaintext;
                            return _regenerator["default"].wrap(function _callee4$(_context4) {
                                while (1) {
                                    switch (_context4.prev = _context4.next) {
                                        case 0:
                                            _context4.next = 2;
                                            return deriveKeysBrowser(key, name);
                                        case 2:
                                            _yield$deriveKeysBrow3 = _context4.sent;
                                            _yield$deriveKeysBrow4 = (0, _slicedToArray2["default"])(_yield$deriveKeysBrow3, 2);
                                            aesKey = _yield$deriveKeysBrow4[0];
                                            hmacKey = _yield$deriveKeysBrow4[1];
                                            ciphertext = (0, _olmlib.decodeBase64)(data.ciphertext);
                                            _context4.next = 9;
                                            return subtleCrypto.verify({
                                                name: "HMAC"
                                            }, hmacKey, (0, _olmlib.decodeBase64)(data.mac), ciphertext);
                                        case 9:
                                            if (_context4.sent) {
                                                _context4.next = 11;
                                                break;
                                            }
                                            throw new Error("Error decrypting secret ".concat(name, ": bad MAC"));
                                        case 11:
                                            _context4.next = 13;
                                            return subtleCrypto.decrypt({
                                                name: "AES-CTR",
                                                counter: (0, _olmlib.decodeBase64)(data.iv),
                                                length: 64
                                            }, aesKey, ciphertext);
                                        case 13:
                                            plaintext = _context4.sent;
                                            return _context4.abrupt("return", new TextDecoder().decode(new Uint8Array(plaintext)));
                                        case 15:
                                        case "end":
                                            return _context4.stop();
                                    }
                                }
                            }, _callee4);
                        }));
                        return _decryptBrowser.apply(this, arguments);
                    }
                    function deriveKeysBrowser(_x15, _x16) {
                        return _deriveKeysBrowser.apply(this, arguments);
                    }
                    function _deriveKeysBrowser() {
                        _deriveKeysBrowser = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee5(key, name) {
                            var hkdfkey, keybits, aesKey, hmacKey, aesProm, hmacProm;
                            return _regenerator["default"].wrap(function _callee5$(_context5) {
                                while (1) {
                                    switch (_context5.prev = _context5.next) {
                                        case 0:
                                            _context5.next = 2;
                                            return subtleCrypto.importKey('raw', key, {
                                                name: "HKDF"
                                            }, false, ["deriveBits"]);
                                        case 2:
                                            hkdfkey = _context5.sent;
                                            _context5.next = 5;
                                            return subtleCrypto.deriveBits({
                                                name: "HKDF",
                                                salt: zerosalt,
                                                info: new TextEncoder().encode(name),
                                                hash: "SHA-256"
                                            }, hkdfkey, 512);
                                        case 5:
                                            keybits = _context5.sent;
                                            aesKey = keybits.slice(0, 32);
                                            hmacKey = keybits.slice(32);
                                            aesProm = subtleCrypto.importKey('raw', aesKey, {
                                                name: 'AES-CTR'
                                            }, false, ['encrypt', 'decrypt']);
                                            hmacProm = subtleCrypto.importKey('raw', hmacKey, {
                                                name: 'HMAC',
                                                hash: {
                                                    name: 'SHA-256'
                                                }
                                            }, false, ['sign', 'verify']);
                                            _context5.next = 12;
                                            return Promise.all([aesProm, hmacProm]);
                                        case 12:
                                            return _context5.abrupt("return", _context5.sent);
                                        case 13:
                                        case "end":
                                            return _context5.stop();
                                    }
                                }
                            }, _callee5);
                        }));
                        return _deriveKeysBrowser.apply(this, arguments);
                    }
                    function encryptAES() {
                        return subtleCrypto ? encryptBrowser.apply(void 0, arguments) : encryptNode.apply(void 0, arguments);
                    }
                    function decryptAES() {
                        return subtleCrypto ? decryptBrowser.apply(void 0, arguments) : decryptNode.apply(void 0, arguments);
                    }
                }).call(this);
            }).call(this, require("buffer").Buffer);
        }, { "../utils": 125, "./olmlib": 77, "@babel/runtime/helpers/asyncToGenerator": 5, "@babel/runtime/helpers/interopRequireDefault": 12, "@babel/runtime/helpers/slicedToArray": 22, "@babel/runtime/regenerator": 27, "buffer": 34 }], 69: [function (require, module, exports) {
            "use strict";
            var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.registerAlgorithm = registerAlgorithm;
            exports.UnknownDeviceError = exports.DecryptionError = exports.DecryptionAlgorithm = exports.EncryptionAlgorithm = exports.DECRYPTION_CLASSES = exports.ENCRYPTION_CLASSES = void 0;
            var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
            var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
            var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
            var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
            var _wrapNativeSuper2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapNativeSuper"));
            var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
            var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
            var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
            var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
            function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) {
                var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor;
                result = Reflect.construct(Super, arguments, NewTarget);
            }
            else {
                result = Super.apply(this, arguments);
            } return (0, _possibleConstructorReturn2["default"])(this, result); }; }
            function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct)
                return false; if (Reflect.construct.sham)
                return false; if (typeof Proxy === "function")
                return true; try {
                Date.prototype.toString.call(Reflect.construct(Date, [], function () { }));
                return true;
            }
            catch (e) {
                return false;
            } }
            var ENCRYPTION_CLASSES = {};
            exports.ENCRYPTION_CLASSES = ENCRYPTION_CLASSES;
            var DECRYPTION_CLASSES = {};
            exports.DECRYPTION_CLASSES = DECRYPTION_CLASSES;
            var EncryptionAlgorithm = function () {
                function EncryptionAlgorithm(params) {
                    (0, _classCallCheck2["default"])(this, EncryptionAlgorithm);
                    this._userId = params.userId;
                    this._deviceId = params.deviceId;
                    this._crypto = params.crypto;
                    this._olmDevice = params.olmDevice;
                    this._baseApis = params.baseApis;
                    this._roomId = params.roomId;
                }
                (0, _createClass2["default"])(EncryptionAlgorithm, [{
                        key: "prepareToEncrypt",
                        value: function prepareToEncrypt(room) { }
                    }, {
                        key: "onRoomMembership",
                        value: function onRoomMembership(event, member, oldMembership) { }
                    }]);
                return EncryptionAlgorithm;
            }();
            exports.EncryptionAlgorithm = EncryptionAlgorithm;
            var DecryptionAlgorithm = function () {
                function DecryptionAlgorithm(params) {
                    (0, _classCallCheck2["default"])(this, DecryptionAlgorithm);
                    this._userId = params.userId;
                    this._crypto = params.crypto;
                    this._olmDevice = params.olmDevice;
                    this._baseApis = params.baseApis;
                    this._roomId = params.roomId;
                }
                (0, _createClass2["default"])(DecryptionAlgorithm, [{
                        key: "onRoomKeyEvent",
                        value: function onRoomKeyEvent(params) {
                        }
                    }, {
                        key: "importRoomKey",
                        value: function importRoomKey(session) {
                        }
                    }, {
                        key: "hasKeysForKeyRequest",
                        value: function hasKeysForKeyRequest(keyRequest) {
                            return Promise.resolve(false);
                        }
                    }, {
                        key: "shareKeysWithDevice",
                        value: function shareKeysWithDevice(keyRequest) {
                            throw new Error("shareKeysWithDevice not supported for this DecryptionAlgorithm");
                        }
                    }, {
                        key: "retryDecryptionFromSender",
                        value: function () {
                            var _retryDecryptionFromSender = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee(senderKey) {
                                return _regenerator["default"].wrap(function _callee$(_context) {
                                    while (1) {
                                        switch (_context.prev = _context.next) {
                                            case 0:
                                            case "end":
                                                return _context.stop();
                                        }
                                    }
                                }, _callee);
                            }));
                            function retryDecryptionFromSender(_x) {
                                return _retryDecryptionFromSender.apply(this, arguments);
                            }
                            return retryDecryptionFromSender;
                        }()
                    }]);
                return DecryptionAlgorithm;
            }();
            exports.DecryptionAlgorithm = DecryptionAlgorithm;
            var DecryptionError = function (_Error) {
                (0, _inherits2["default"])(DecryptionError, _Error);
                var _super = _createSuper(DecryptionError);
                function DecryptionError(code, msg, details) {
                    var _this;
                    (0, _classCallCheck2["default"])(this, DecryptionError);
                    _this = _super.call(this, msg);
                    _this.code = code;
                    _this.name = 'DecryptionError';
                    _this.detailedString = _detailedStringForDecryptionError((0, _assertThisInitialized2["default"])(_this), details);
                    return _this;
                }
                return DecryptionError;
            }((0, _wrapNativeSuper2["default"])(Error));
            exports.DecryptionError = DecryptionError;
            function _detailedStringForDecryptionError(err, details) {
                var result = err.name + '[msg: ' + err.message;
                if (details) {
                    result += ', ' + Object.keys(details).map(function (k) {
                        return k + ': ' + details[k];
                    }).join(', ');
                }
                result += ']';
                return result;
            }
            var UnknownDeviceError = function (_Error2) {
                (0, _inherits2["default"])(UnknownDeviceError, _Error2);
                var _super2 = _createSuper(UnknownDeviceError);
                function UnknownDeviceError(msg, devices) {
                    var _this2;
                    (0, _classCallCheck2["default"])(this, UnknownDeviceError);
                    _this2 = _super2.call(this, msg);
                    _this2.name = "UnknownDeviceError";
                    _this2.devices = devices;
                    return _this2;
                }
                return UnknownDeviceError;
            }((0, _wrapNativeSuper2["default"])(Error));
            exports.UnknownDeviceError = UnknownDeviceError;
            function registerAlgorithm(algorithm, encryptor, decryptor) {
                ENCRYPTION_CLASSES[algorithm] = encryptor;
                DECRYPTION_CLASSES[algorithm] = decryptor;
            }
        }, { "@babel/runtime/helpers/assertThisInitialized": 4, "@babel/runtime/helpers/asyncToGenerator": 5, "@babel/runtime/helpers/classCallCheck": 6, "@babel/runtime/helpers/createClass": 8, "@babel/runtime/helpers/getPrototypeOf": 10, "@babel/runtime/helpers/inherits": 11, "@babel/runtime/helpers/interopRequireDefault": 12, "@babel/runtime/helpers/possibleConstructorReturn": 20, "@babel/runtime/helpers/wrapNativeSuper": 26, "@babel/runtime/regenerator": 27 }], 70: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            require("./olm");
            require("./megolm");
            var _base = require("./base");
            Object.keys(_base).forEach(function (key) {
                if (key === "default" || key === "__esModule")
                    return;
                if (key in exports && exports[key] === _base[key])
                    return;
                Object.defineProperty(exports, key, {
                    enumerable: true,
                    get: function get() {
                        return _base[key];
                    }
                });
            });
        }, { "./base": 69, "./megolm": 71, "./olm": 72 }], 71: [function (require, module, exports) {
            "use strict";
            var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
            var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
            var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
            var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
            var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
            var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
            var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
            var _logger = require("../../logger");
            var utils = _interopRequireWildcard(require("../../utils"));
            var olmlib = _interopRequireWildcard(require("../olmlib"));
            var _base = require("./base");
            var _OlmDevice = require("../OlmDevice");
            function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
                if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                    if (it)
                        o = it;
                    var i = 0;
                    var F = function F() { };
                    return { s: F, n: function n() { if (i >= o.length)
                            return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try {
                    if (!normalCompletion && it["return"] != null)
                        it["return"]();
                }
                finally {
                    if (didErr)
                        throw err;
                } } }; }
            function _unsupportedIterableToArray(o, minLen) { if (!o)
                return; if (typeof o === "string")
                return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor)
                n = o.constructor.name; if (n === "Map" || n === "Set")
                return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return _arrayLikeToArray(o, minLen); }
            function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length)
                len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
            } return arr2; }
            function OutboundSessionInfo(sessionId) {
                this.sessionId = sessionId;
                this.useCount = 0;
                this.creationTime = new Date().getTime();
                this.sharedWithDevices = {};
                this.blockedDevicesNotified = {};
            }
            OutboundSessionInfo.prototype.needsRotation = function (rotationPeriodMsgs, rotationPeriodMs) {
                var sessionLifetime = new Date().getTime() - this.creationTime;
                if (this.useCount >= rotationPeriodMsgs || sessionLifetime >= rotationPeriodMs) {
                    _logger.logger.log("Rotating megolm session after " + this.useCount + " messages, " + sessionLifetime + "ms");
                    return true;
                }
                return false;
            };
            OutboundSessionInfo.prototype.markSharedWithDevice = function (userId, deviceId, chainIndex) {
                if (!this.sharedWithDevices[userId]) {
                    this.sharedWithDevices[userId] = {};
                }
                this.sharedWithDevices[userId][deviceId] = chainIndex;
            };
            OutboundSessionInfo.prototype.markNotifiedBlockedDevice = function (userId, deviceId) {
                if (!this.blockedDevicesNotified[userId]) {
                    this.blockedDevicesNotified[userId] = {};
                }
                this.blockedDevicesNotified[userId][deviceId] = true;
            };
            OutboundSessionInfo.prototype.sharedWithTooManyDevices = function (devicesInRoom) {
                for (var userId in this.sharedWithDevices) {
                    if (!this.sharedWithDevices.hasOwnProperty(userId)) {
                        continue;
                    }
                    if (!devicesInRoom.hasOwnProperty(userId)) {
                        _logger.logger.log("Starting new megolm session because we shared with " + userId);
                        return true;
                    }
                    for (var deviceId in this.sharedWithDevices[userId]) {
                        if (!this.sharedWithDevices[userId].hasOwnProperty(deviceId)) {
                            continue;
                        }
                        if (!devicesInRoom[userId].hasOwnProperty(deviceId)) {
                            _logger.logger.log("Starting new megolm session because we shared with " + userId + ":" + deviceId);
                            return true;
                        }
                    }
                }
            };
            function MegolmEncryption(params) {
                (0, utils.polyfillSuper)(this, _base.EncryptionAlgorithm, params);
                this._setupPromise = Promise.resolve();
                this._outboundSessions = {};
                this._sessionRotationPeriodMsgs = 100;
                this._sessionRotationPeriodMs = 7 * 24 * 3600 * 1000;
                if (params.config.rotation_period_ms !== undefined) {
                    this._sessionRotationPeriodMs = params.config.rotation_period_ms;
                }
                if (params.config.rotation_period_msgs !== undefined) {
                    this._sessionRotationPeriodMsgs = params.config.rotation_period_msgs;
                }
            }
            utils.inherits(MegolmEncryption, _base.EncryptionAlgorithm);
            MegolmEncryption.prototype._ensureOutboundSession = function () {
                var _ref = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee6(devicesInRoom, blocked, singleOlmCreationPhase) {
                    var _this = this;
                    var session, prepareSession, returnSession, prom;
                    return _regenerator["default"].wrap(function _callee6$(_context6) {
                        while (1) {
                            switch (_context6.prev = _context6.next) {
                                case 0:
                                    returnSession = function _returnSession() {
                                        return session;
                                    };
                                    prepareSession = function () {
                                        var _ref2 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee5(oldSession) {
                                            var shareMap, _i, _Object$entries, _Object$entries$_i, userId, userDevices, _i2, _Object$entries2, _Object$entries2$_i, deviceId, deviceInfo, _key, key, payload, _yield$olmlib$getExis, _yield$olmlib$getExis2, devicesWithoutSession, olmSessions;
                                            return _regenerator["default"].wrap(function _callee5$(_context5) {
                                                while (1) {
                                                    switch (_context5.prev = _context5.next) {
                                                        case 0:
                                                            session = oldSession;
                                                            if (session && session.needsRotation(_this._sessionRotationPeriodMsgs, _this._sessionRotationPeriodMs)) {
                                                                _logger.logger.log("Starting new megolm session because we need to rotate.");
                                                                session = null;
                                                            }
                                                            if (session && session.sharedWithTooManyDevices(devicesInRoom)) {
                                                                session = null;
                                                            }
                                                            if (session) {
                                                                _context5.next = 10;
                                                                break;
                                                            }
                                                            _logger.logger.log("Starting new megolm session for room ".concat(_this._roomId));
                                                            _context5.next = 7;
                                                            return _this._prepareNewSession();
                                                        case 7:
                                                            session = _context5.sent;
                                                            _logger.logger.log("Started new megolm session ".concat(session.sessionId, " ") + "for room ".concat(_this._roomId));
                                                            _this._outboundSessions[session.sessionId] = session;
                                                        case 10:
                                                            shareMap = {};
                                                            _i = 0, _Object$entries = Object.entries(devicesInRoom);
                                                        case 12:
                                                            if (!(_i < _Object$entries.length)) {
                                                                _context5.next = 27;
                                                                break;
                                                            }
                                                            _Object$entries$_i = (0, _slicedToArray2["default"])(_Object$entries[_i], 2), userId = _Object$entries$_i[0], userDevices = _Object$entries$_i[1];
                                                            _i2 = 0, _Object$entries2 = Object.entries(userDevices);
                                                        case 15:
                                                            if (!(_i2 < _Object$entries2.length)) {
                                                                _context5.next = 24;
                                                                break;
                                                            }
                                                            _Object$entries2$_i = (0, _slicedToArray2["default"])(_Object$entries2[_i2], 2), deviceId = _Object$entries2$_i[0], deviceInfo = _Object$entries2$_i[1];
                                                            _key = deviceInfo.getIdentityKey();
                                                            if (!(_key == _this._olmDevice.deviceCurve25519Key)) {
                                                                _context5.next = 20;
                                                                break;
                                                            }
                                                            return _context5.abrupt("continue", 21);
                                                        case 20:
                                                            if (!session.sharedWithDevices[userId] || session.sharedWithDevices[userId][deviceId] === undefined) {
                                                                shareMap[userId] = shareMap[userId] || [];
                                                                shareMap[userId].push(deviceInfo);
                                                            }
                                                        case 21:
                                                            _i2++;
                                                            _context5.next = 15;
                                                            break;
                                                        case 24:
                                                            _i++;
                                                            _context5.next = 12;
                                                            break;
                                                        case 27:
                                                            key = _this._olmDevice.getOutboundGroupSessionKey(session.sessionId);
                                                            payload = {
                                                                type: "m.room_key",
                                                                content: {
                                                                    algorithm: olmlib.MEGOLM_ALGORITHM,
                                                                    room_id: _this._roomId,
                                                                    session_id: session.sessionId,
                                                                    session_key: key.key,
                                                                    chain_index: key.chain_index
                                                                }
                                                            };
                                                            _context5.next = 31;
                                                            return olmlib.getExistingOlmSessions(_this._olmDevice, _this._baseApis, shareMap);
                                                        case 31:
                                                            _yield$olmlib$getExis = _context5.sent;
                                                            _yield$olmlib$getExis2 = (0, _slicedToArray2["default"])(_yield$olmlib$getExis, 2);
                                                            devicesWithoutSession = _yield$olmlib$getExis2[0];
                                                            olmSessions = _yield$olmlib$getExis2[1];
                                                            _context5.next = 37;
                                                            return Promise.all([(0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee() {
                                                                    return _regenerator["default"].wrap(function _callee$(_context) {
                                                                        while (1) {
                                                                            switch (_context.prev = _context.next) {
                                                                                case 0:
                                                                                    _logger.logger.debug("Sharing keys with existing Olm sessions in ".concat(_this._roomId));
                                                                                    _context.next = 3;
                                                                                    return _this._shareKeyWithOlmSessions(session, key, payload, olmSessions);
                                                                                case 3:
                                                                                    _logger.logger.debug("Shared keys with existing Olm sessions in ".concat(_this._roomId));
                                                                                case 4:
                                                                                case "end":
                                                                                    return _context.stop();
                                                                            }
                                                                        }
                                                                    }, _callee);
                                                                }))(), (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee3() {
                                                                    var errorDevices, start, failedServers;
                                                                    return _regenerator["default"].wrap(function _callee3$(_context3) {
                                                                        while (1) {
                                                                            switch (_context3.prev = _context3.next) {
                                                                                case 0:
                                                                                    _logger.logger.debug("Sharing keys (start phase 1) with new Olm sessions in ".concat(_this._roomId));
                                                                                    errorDevices = [];
                                                                                    start = Date.now();
                                                                                    failedServers = [];
                                                                                    _context3.next = 6;
                                                                                    return _this._shareKeyWithDevices(session, key, payload, devicesWithoutSession, errorDevices, singleOlmCreationPhase ? 10000 : 2000, failedServers);
                                                                                case 6:
                                                                                    _logger.logger.debug("Shared keys (end phase 1) with new Olm sessions in ".concat(_this._roomId));
                                                                                    if (!(!singleOlmCreationPhase && Date.now() - start < 10000)) {
                                                                                        _context3.next = 11;
                                                                                        break;
                                                                                    }
                                                                                    (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee2() {
                                                                                        var retryDevices, failedServerMap, _iterator, _step, server, failedDevices, _iterator2, _step2, _step2$value, _userId, _deviceInfo, userHS;
                                                                                        return _regenerator["default"].wrap(function _callee2$(_context2) {
                                                                                            while (1) {
                                                                                                switch (_context2.prev = _context2.next) {
                                                                                                    case 0:
                                                                                                        retryDevices = {};
                                                                                                        failedServerMap = new Set();
                                                                                                        _iterator = _createForOfIteratorHelper(failedServers);
                                                                                                        try {
                                                                                                            for (_iterator.s(); !(_step = _iterator.n()).done;) {
                                                                                                                server = _step.value;
                                                                                                                failedServerMap.add(server);
                                                                                                            }
                                                                                                        }
                                                                                                        catch (err) {
                                                                                                            _iterator.e(err);
                                                                                                        }
                                                                                                        finally {
                                                                                                            _iterator.f();
                                                                                                        }
                                                                                                        failedDevices = [];
                                                                                                        _iterator2 = _createForOfIteratorHelper(errorDevices);
                                                                                                        try {
                                                                                                            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                                                                                                                _step2$value = _step2.value, _userId = _step2$value.userId, _deviceInfo = _step2$value.deviceInfo;
                                                                                                                userHS = _userId.slice(_userId.indexOf(":") + 1);
                                                                                                                if (failedServerMap.has(userHS)) {
                                                                                                                    retryDevices[_userId] = retryDevices[_userId] || [];
                                                                                                                    retryDevices[_userId].push(_deviceInfo);
                                                                                                                }
                                                                                                                else {
                                                                                                                    failedDevices.push({
                                                                                                                        userId: _userId,
                                                                                                                        deviceInfo: _deviceInfo
                                                                                                                    });
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                        catch (err) {
                                                                                                            _iterator2.e(err);
                                                                                                        }
                                                                                                        finally {
                                                                                                            _iterator2.f();
                                                                                                        }
                                                                                                        _logger.logger.debug("Sharing keys (start phase 2) with new Olm sessions in ".concat(_this._roomId));
                                                                                                        _context2.next = 10;
                                                                                                        return _this._shareKeyWithDevices(session, key, payload, retryDevices, failedDevices, 30000);
                                                                                                    case 10:
                                                                                                        _logger.logger.debug("Shared keys (end phase 2) with new Olm sessions in ".concat(_this._roomId));
                                                                                                        _context2.next = 13;
                                                                                                        return _this._notifyFailedOlmDevices(session, key, failedDevices);
                                                                                                    case 13:
                                                                                                    case "end":
                                                                                                        return _context2.stop();
                                                                                                }
                                                                                            }
                                                                                        }, _callee2);
                                                                                    }))();
                                                                                    _context3.next = 13;
                                                                                    break;
                                                                                case 11:
                                                                                    _context3.next = 13;
                                                                                    return _this._notifyFailedOlmDevices(session, key, errorDevices);
                                                                                case 13:
                                                                                    _logger.logger.debug("Shared keys (all phases done) with new Olm sessions in ".concat(_this._roomId));
                                                                                case 14:
                                                                                case "end":
                                                                                    return _context3.stop();
                                                                            }
                                                                        }
                                                                    }, _callee3);
                                                                }))(), (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee4() {
                                                                    var blockedMap, blockedCount, _i3, _Object$entries3, _Object$entries3$_i, _userId2, userBlockedDevices, _i4, _Object$entries4, _Object$entries4$_i, _deviceId, device;
                                                                    return _regenerator["default"].wrap(function _callee4$(_context4) {
                                                                        while (1) {
                                                                            switch (_context4.prev = _context4.next) {
                                                                                case 0:
                                                                                    _logger.logger.debug("Notifying blocked devices in ".concat(_this._roomId));
                                                                                    blockedMap = {};
                                                                                    blockedCount = 0;
                                                                                    for (_i3 = 0, _Object$entries3 = Object.entries(blocked); _i3 < _Object$entries3.length; _i3++) {
                                                                                        _Object$entries3$_i = (0, _slicedToArray2["default"])(_Object$entries3[_i3], 2), _userId2 = _Object$entries3$_i[0], userBlockedDevices = _Object$entries3$_i[1];
                                                                                        for (_i4 = 0, _Object$entries4 = Object.entries(userBlockedDevices); _i4 < _Object$entries4.length; _i4++) {
                                                                                            _Object$entries4$_i = (0, _slicedToArray2["default"])(_Object$entries4[_i4], 2), _deviceId = _Object$entries4$_i[0], device = _Object$entries4$_i[1];
                                                                                            if (!session.blockedDevicesNotified[_userId2] || session.blockedDevicesNotified[_userId2][_deviceId] === undefined) {
                                                                                                blockedMap[_userId2] = blockedMap[_userId2] || {};
                                                                                                blockedMap[_userId2][_deviceId] = {
                                                                                                    device: device
                                                                                                };
                                                                                                blockedCount++;
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                    _context4.next = 6;
                                                                                    return _this._notifyBlockedDevices(session, blockedMap);
                                                                                case 6:
                                                                                    _logger.logger.debug("Notified ".concat(blockedCount, " blocked devices in ").concat(_this._roomId));
                                                                                case 7:
                                                                                case "end":
                                                                                    return _context4.stop();
                                                                            }
                                                                        }
                                                                    }, _callee4);
                                                                }))()]);
                                                        case 37:
                                                        case "end":
                                                            return _context5.stop();
                                                    }
                                                }
                                            }, _callee5);
                                        }));
                                        return function prepareSession(_x4) {
                                            return _ref2.apply(this, arguments);
                                        };
                                    }();
                                    prom = this._setupPromise.then(prepareSession);
                                    prom["catch"](function (e) {
                                        _logger.logger.error("Failed to ensure outbound session in ".concat(_this._roomId), e);
                                    });
                                    this._setupPromise = prom.then(returnSession, returnSession);
                                    return _context6.abrupt("return", prom.then(returnSession));
                                case 6:
                                case "end":
                                    return _context6.stop();
                            }
                        }
                    }, _callee6, this);
                }));
                return function (_x, _x2, _x3) {
                    return _ref.apply(this, arguments);
                };
            }();
            MegolmEncryption.prototype._prepareNewSession = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee7() {
                var sessionId, key;
                return _regenerator["default"].wrap(function _callee7$(_context7) {
                    while (1) {
                        switch (_context7.prev = _context7.next) {
                            case 0:
                                sessionId = this._olmDevice.createOutboundGroupSession();
                                key = this._olmDevice.getOutboundGroupSessionKey(sessionId);
                                _context7.next = 4;
                                return this._olmDevice.addInboundGroupSession(this._roomId, this._olmDevice.deviceCurve25519Key, [], sessionId, key.key, {
                                    ed25519: this._olmDevice.deviceEd25519Key
                                });
                            case 4:
                                this._crypto.backupGroupSession(this._roomId, this._olmDevice.deviceCurve25519Key, [], sessionId, key.key);
                                return _context7.abrupt("return", new OutboundSessionInfo(sessionId));
                            case 6:
                            case "end":
                                return _context7.stop();
                        }
                    }
                }, _callee7, this);
            }));
            MegolmEncryption.prototype._getDevicesWithoutSessions = function (devicemap, devicesByUser, noOlmDevices) {
                noOlmDevices = noOlmDevices || [];
                for (var _i5 = 0, _Object$entries5 = Object.entries(devicesByUser); _i5 < _Object$entries5.length; _i5++) {
                    var _Object$entries5$_i = (0, _slicedToArray2["default"])(_Object$entries5[_i5], 2), userId = _Object$entries5$_i[0], devicesToShareWith = _Object$entries5$_i[1];
                    var sessionResults = devicemap[userId];
                    var _iterator3 = _createForOfIteratorHelper(devicesToShareWith), _step3;
                    try {
                        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                            var deviceInfo = _step3.value;
                            var deviceId = deviceInfo.deviceId;
                            var sessionResult = sessionResults[deviceId];
                            if (!sessionResult.sessionId) {
                                noOlmDevices.push({
                                    userId: userId,
                                    deviceInfo: deviceInfo
                                });
                                delete sessionResults[deviceId];
                                continue;
                            }
                        }
                    }
                    catch (err) {
                        _iterator3.e(err);
                    }
                    finally {
                        _iterator3.f();
                    }
                }
                return noOlmDevices;
            };
            MegolmEncryption.prototype._splitDevices = function (devicesByUser) {
                var maxDevicesPerRequest = 20;
                var currentSlice = [];
                var mapSlices = [currentSlice];
                for (var _i6 = 0, _Object$entries6 = Object.entries(devicesByUser); _i6 < _Object$entries6.length; _i6++) {
                    var _Object$entries6$_i = (0, _slicedToArray2["default"])(_Object$entries6[_i6], 2), userId = _Object$entries6$_i[0], userDevices = _Object$entries6$_i[1];
                    for (var _i7 = 0, _Object$values = Object.values(userDevices); _i7 < _Object$values.length; _i7++) {
                        var deviceInfo = _Object$values[_i7];
                        currentSlice.push({
                            userId: userId,
                            deviceInfo: deviceInfo.device
                        });
                    }
                    if (currentSlice.length > maxDevicesPerRequest) {
                        currentSlice = [];
                        mapSlices.push(currentSlice);
                    }
                }
                if (currentSlice.length === 0) {
                    mapSlices.pop();
                }
                return mapSlices;
            };
            MegolmEncryption.prototype._encryptAndSendKeysToDevices = function (session, chainIndex, userDeviceMap, payload) {
                var _this2 = this;
                var contentMap = {};
                var promises = [];
                for (var i = 0; i < userDeviceMap.length; i++) {
                    var encryptedContent = {
                        algorithm: olmlib.OLM_ALGORITHM,
                        sender_key: this._olmDevice.deviceCurve25519Key,
                        ciphertext: {}
                    };
                    var val = userDeviceMap[i];
                    var userId = val.userId;
                    var deviceInfo = val.deviceInfo;
                    var deviceId = deviceInfo.deviceId;
                    if (!contentMap[userId]) {
                        contentMap[userId] = {};
                    }
                    contentMap[userId][deviceId] = encryptedContent;
                    promises.push(olmlib.encryptMessageForDevice(encryptedContent.ciphertext, this._userId, this._deviceId, this._olmDevice, userId, deviceInfo, payload));
                }
                return Promise.all(promises).then(function () {
                    for (var _i8 = 0, _Object$keys = Object.keys(contentMap); _i8 < _Object$keys.length; _i8++) {
                        var _userId3 = _Object$keys[_i8];
                        for (var _i9 = 0, _Object$keys2 = Object.keys(contentMap[_userId3]); _i9 < _Object$keys2.length; _i9++) {
                            var _deviceId2 = _Object$keys2[_i9];
                            if (Object.keys(contentMap[_userId3][_deviceId2].ciphertext).length === 0) {
                                _logger.logger.log("No ciphertext for device " + _userId3 + ":" + _deviceId2 + ": pruning");
                                delete contentMap[_userId3][_deviceId2];
                            }
                        }
                        if (Object.keys(contentMap[_userId3]).length === 0) {
                            _logger.logger.log("Pruned all devices for user " + _userId3);
                            delete contentMap[_userId3];
                        }
                    }
                    if (Object.keys(contentMap).length === 0) {
                        _logger.logger.log("No users left to send to: aborting");
                        return;
                    }
                    return _this2._baseApis.sendToDevice("m.room.encrypted", contentMap).then(function () {
                        for (var _i10 = 0, _Object$keys3 = Object.keys(contentMap); _i10 < _Object$keys3.length; _i10++) {
                            var _userId4 = _Object$keys3[_i10];
                            for (var _i11 = 0, _Object$keys4 = Object.keys(contentMap[_userId4]); _i11 < _Object$keys4.length; _i11++) {
                                var _deviceId3 = _Object$keys4[_i11];
                                session.markSharedWithDevice(_userId4, _deviceId3, chainIndex);
                            }
                        }
                    });
                });
            };
            MegolmEncryption.prototype._sendBlockedNotificationsToDevices = function () {
                var _ref8 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee8(session, userDeviceMap, payload) {
                    var contentMap, _iterator4, _step4, val, _userId5, blockedInfo, deviceInfo, _deviceId4, message, _i12, _Object$keys5, userId, _i13, _Object$keys6, deviceId;
                    return _regenerator["default"].wrap(function _callee8$(_context8) {
                        while (1) {
                            switch (_context8.prev = _context8.next) {
                                case 0:
                                    contentMap = {};
                                    _iterator4 = _createForOfIteratorHelper(userDeviceMap);
                                    try {
                                        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                                            val = _step4.value;
                                            _userId5 = val.userId;
                                            blockedInfo = val.deviceInfo;
                                            deviceInfo = blockedInfo.deviceInfo;
                                            _deviceId4 = deviceInfo.deviceId;
                                            message = Object.assign({}, payload);
                                            message.code = blockedInfo.code;
                                            message.reason = blockedInfo.reason;
                                            if (message.code === "m.no_olm") {
                                                delete message.room_id;
                                                delete message.session_id;
                                            }
                                            if (!contentMap[_userId5]) {
                                                contentMap[_userId5] = {};
                                            }
                                            contentMap[_userId5][_deviceId4] = message;
                                        }
                                    }
                                    catch (err) {
                                        _iterator4.e(err);
                                    }
                                    finally {
                                        _iterator4.f();
                                    }
                                    _context8.next = 5;
                                    return this._baseApis.sendToDevice("org.matrix.room_key.withheld", contentMap);
                                case 5:
                                    for (_i12 = 0, _Object$keys5 = Object.keys(contentMap); _i12 < _Object$keys5.length; _i12++) {
                                        userId = _Object$keys5[_i12];
                                        for (_i13 = 0, _Object$keys6 = Object.keys(contentMap[userId]); _i13 < _Object$keys6.length; _i13++) {
                                            deviceId = _Object$keys6[_i13];
                                            session.markNotifiedBlockedDevice(userId, deviceId);
                                        }
                                    }
                                case 6:
                                case "end":
                                    return _context8.stop();
                            }
                        }
                    }, _callee8, this);
                }));
                return function (_x5, _x6, _x7) {
                    return _ref8.apply(this, arguments);
                };
            }();
            MegolmEncryption.prototype.reshareKeyWithDevice = function () {
                var _ref9 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee9(senderKey, sessionId, userId, device) {
                    var obSessionInfo, sentChainIndex, key, payload, encryptedContent;
                    return _regenerator["default"].wrap(function _callee9$(_context9) {
                        while (1) {
                            switch (_context9.prev = _context9.next) {
                                case 0:
                                    obSessionInfo = this._outboundSessions[sessionId];
                                    if (obSessionInfo) {
                                        _context9.next = 4;
                                        break;
                                    }
                                    _logger.logger.debug("megolm session ".concat(sessionId, " not found: not re-sharing keys"));
                                    return _context9.abrupt("return");
                                case 4:
                                    if (!(obSessionInfo.sharedWithDevices[userId] === undefined)) {
                                        _context9.next = 7;
                                        break;
                                    }
                                    _logger.logger.debug("megolm session ".concat(sessionId, " never shared with user ").concat(userId));
                                    return _context9.abrupt("return");
                                case 7:
                                    sentChainIndex = obSessionInfo.sharedWithDevices[userId][device.deviceId];
                                    if (!(sentChainIndex === undefined)) {
                                        _context9.next = 11;
                                        break;
                                    }
                                    _logger.logger.debug("megolm session ID " + sessionId + " never shared with device " + userId + ":" + device.deviceId);
                                    return _context9.abrupt("return");
                                case 11:
                                    _context9.next = 13;
                                    return this._olmDevice.getInboundGroupSessionKey(this._roomId, senderKey, sessionId, sentChainIndex);
                                case 13:
                                    key = _context9.sent;
                                    if (key) {
                                        _context9.next = 17;
                                        break;
                                    }
                                    _logger.logger.warn("No inbound session key found for megolm ".concat(sessionId, ": not re-sharing keys"));
                                    return _context9.abrupt("return");
                                case 17:
                                    _context9.next = 19;
                                    return olmlib.ensureOlmSessionsForDevices(this._olmDevice, this._baseApis, (0, _defineProperty2["default"])({}, userId, [device]));
                                case 19:
                                    payload = {
                                        type: "m.forwarded_room_key",
                                        content: {
                                            algorithm: olmlib.MEGOLM_ALGORITHM,
                                            room_id: this._roomId,
                                            session_id: sessionId,
                                            session_key: key.key,
                                            chain_index: key.chain_index,
                                            sender_key: senderKey,
                                            sender_claimed_ed25519_key: key.sender_claimed_ed25519_key,
                                            forwarding_curve25519_key_chain: key.forwarding_curve25519_key_chain
                                        }
                                    };
                                    encryptedContent = {
                                        algorithm: olmlib.OLM_ALGORITHM,
                                        sender_key: this._olmDevice.deviceCurve25519Key,
                                        ciphertext: {}
                                    };
                                    _context9.next = 23;
                                    return olmlib.encryptMessageForDevice(encryptedContent.ciphertext, this._userId, this._deviceId, this._olmDevice, userId, device, payload);
                                case 23:
                                    _context9.next = 25;
                                    return this._baseApis.sendToDevice("m.room.encrypted", (0, _defineProperty2["default"])({}, userId, (0, _defineProperty2["default"])({}, device.deviceId, encryptedContent)));
                                case 25:
                                    _logger.logger.debug("Re-shared key for megolm session ".concat(sessionId, " ") + "with ".concat(userId, ":").concat(device.deviceId));
                                case 26:
                                case "end":
                                    return _context9.stop();
                            }
                        }
                    }, _callee9, this);
                }));
                return function (_x8, _x9, _x10, _x11) {
                    return _ref9.apply(this, arguments);
                };
            }();
            MegolmEncryption.prototype._shareKeyWithDevices = function () {
                var _ref10 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee10(session, key, payload, devicesByUser, errorDevices, otkTimeout, failedServers) {
                    var devicemap;
                    return _regenerator["default"].wrap(function _callee10$(_context10) {
                        while (1) {
                            switch (_context10.prev = _context10.next) {
                                case 0:
                                    _logger.logger.debug("Ensuring Olm sessions for devices in ".concat(this._roomId));
                                    _context10.next = 3;
                                    return olmlib.ensureOlmSessionsForDevices(this._olmDevice, this._baseApis, devicesByUser, otkTimeout, failedServers, _logger.logger.withPrefix("[".concat(this._roomId, "]")));
                                case 3:
                                    devicemap = _context10.sent;
                                    _logger.logger.debug("Ensured Olm sessions for devices in ".concat(this._roomId));
                                    this._getDevicesWithoutSessions(devicemap, devicesByUser, errorDevices);
                                    _logger.logger.debug("Sharing keys with Olm sessions in ".concat(this._roomId));
                                    _context10.next = 9;
                                    return this._shareKeyWithOlmSessions(session, key, payload, devicemap);
                                case 9:
                                    _logger.logger.debug("Shared keys with Olm sessions in ".concat(this._roomId));
                                case 10:
                                case "end":
                                    return _context10.stop();
                            }
                        }
                    }, _callee10, this);
                }));
                return function (_x12, _x13, _x14, _x15, _x16, _x17, _x18) {
                    return _ref10.apply(this, arguments);
                };
            }();
            MegolmEncryption.prototype._shareKeyWithOlmSessions = function () {
                var _ref11 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee11(session, key, payload, devicemap) {
                    var userDeviceMaps, i, taskDetail;
                    return _regenerator["default"].wrap(function _callee11$(_context11) {
                        while (1) {
                            switch (_context11.prev = _context11.next) {
                                case 0:
                                    userDeviceMaps = this._splitDevices(devicemap);
                                    i = 0;
                                case 2:
                                    if (!(i < userDeviceMaps.length)) {
                                        _context11.next = 18;
                                        break;
                                    }
                                    taskDetail = "megolm keys for ".concat(session.sessionId, " ") + "in ".concat(this._roomId, " (slice ").concat(i + 1, "/").concat(userDeviceMaps.length, ")");
                                    _context11.prev = 4;
                                    _logger.logger.debug("Sharing ".concat(taskDetail));
                                    _context11.next = 8;
                                    return this._encryptAndSendKeysToDevices(session, key.chain_index, userDeviceMaps[i], payload);
                                case 8:
                                    _logger.logger.debug("Shared ".concat(taskDetail));
                                    _context11.next = 15;
                                    break;
                                case 11:
                                    _context11.prev = 11;
                                    _context11.t0 = _context11["catch"](4);
                                    _logger.logger.error("Failed to share ".concat(taskDetail));
                                    throw _context11.t0;
                                case 15:
                                    i++;
                                    _context11.next = 2;
                                    break;
                                case 18:
                                case "end":
                                    return _context11.stop();
                            }
                        }
                    }, _callee11, this, [[4, 11]]);
                }));
                return function (_x19, _x20, _x21, _x22) {
                    return _ref11.apply(this, arguments);
                };
            }();
            MegolmEncryption.prototype._notifyFailedOlmDevices = function () {
                var _ref12 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee12(session, key, failedDevices) {
                    var _iterator5, _step5, _step5$value, userId, deviceInfo, deviceId, filteredFailedDevices, blockedMap, _iterator6, _step6, _step6$value, _userId7, _deviceInfo2;
                    return _regenerator["default"].wrap(function _callee12$(_context12) {
                        while (1) {
                            switch (_context12.prev = _context12.next) {
                                case 0:
                                    _logger.logger.debug("Notifying ".concat(failedDevices.length, " devices we failed to ") + "create Olm sessions in ".concat(this._roomId));
                                    _iterator5 = _createForOfIteratorHelper(failedDevices);
                                    try {
                                        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                                            _step5$value = _step5.value, userId = _step5$value.userId, deviceInfo = _step5$value.deviceInfo;
                                            deviceId = deviceInfo.deviceId;
                                            session.markSharedWithDevice(userId, deviceId, key.chain_index);
                                        }
                                    }
                                    catch (err) {
                                        _iterator5.e(err);
                                    }
                                    finally {
                                        _iterator5.f();
                                    }
                                    _context12.next = 5;
                                    return this._olmDevice.filterOutNotifiedErrorDevices(failedDevices);
                                case 5:
                                    filteredFailedDevices = _context12.sent;
                                    _logger.logger.debug("Filtered down to ".concat(filteredFailedDevices.length, " error devices ") + "in ".concat(this._roomId));
                                    blockedMap = {};
                                    _iterator6 = _createForOfIteratorHelper(filteredFailedDevices);
                                    try {
                                        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                                            _step6$value = _step6.value, _userId7 = _step6$value.userId, _deviceInfo2 = _step6$value.deviceInfo;
                                            blockedMap[_userId7] = blockedMap[_userId7] || {};
                                            blockedMap[_userId7][_deviceInfo2.deviceId] = {
                                                device: {
                                                    code: "m.no_olm",
                                                    reason: _OlmDevice.WITHHELD_MESSAGES["m.no_olm"],
                                                    deviceInfo: _deviceInfo2
                                                }
                                            };
                                        }
                                    }
                                    catch (err) {
                                        _iterator6.e(err);
                                    }
                                    finally {
                                        _iterator6.f();
                                    }
                                    _context12.next = 12;
                                    return this._notifyBlockedDevices(session, blockedMap);
                                case 12:
                                    _logger.logger.debug("Notified ".concat(filteredFailedDevices.length, " devices we failed to ") + "create Olm sessions in ".concat(this._roomId));
                                case 13:
                                case "end":
                                    return _context12.stop();
                            }
                        }
                    }, _callee12, this);
                }));
                return function (_x23, _x24, _x25) {
                    return _ref12.apply(this, arguments);
                };
            }();
            MegolmEncryption.prototype._notifyBlockedDevices = function () {
                var _ref13 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee13(session, devicesByUser) {
                    var payload, userDeviceMaps, i;
                    return _regenerator["default"].wrap(function _callee13$(_context13) {
                        while (1) {
                            switch (_context13.prev = _context13.next) {
                                case 0:
                                    payload = {
                                        room_id: this._roomId,
                                        session_id: session.sessionId,
                                        algorithm: olmlib.MEGOLM_ALGORITHM,
                                        sender_key: this._olmDevice.deviceCurve25519Key
                                    };
                                    userDeviceMaps = this._splitDevices(devicesByUser);
                                    i = 0;
                                case 3:
                                    if (!(i < userDeviceMaps.length)) {
                                        _context13.next = 17;
                                        break;
                                    }
                                    _context13.prev = 4;
                                    _context13.next = 7;
                                    return this._sendBlockedNotificationsToDevices(session, userDeviceMaps[i], payload);
                                case 7:
                                    _logger.logger.log("Completed blacklist notification for ".concat(session.sessionId, " ") + "in ".concat(this._roomId, " (slice ").concat(i + 1, "/").concat(userDeviceMaps.length, ")"));
                                    _context13.next = 14;
                                    break;
                                case 10:
                                    _context13.prev = 10;
                                    _context13.t0 = _context13["catch"](4);
                                    _logger.logger.log("blacklist notification for ".concat(session.sessionId, " in ") + "".concat(this._roomId, " (slice ").concat(i + 1, "/").concat(userDeviceMaps.length, ") failed"));
                                    throw _context13.t0;
                                case 14:
                                    i++;
                                    _context13.next = 3;
                                    break;
                                case 17:
                                case "end":
                                    return _context13.stop();
                            }
                        }
                    }, _callee13, this, [[4, 10]]);
                }));
                return function (_x26, _x27) {
                    return _ref13.apply(this, arguments);
                };
            }();
            MegolmEncryption.prototype.prepareToEncrypt = function (room) {
                var _this3 = this;
                if (this.encryptionPreparation) {
                    var elapsedTime = Date.now() - this.encryptionPreparationMetadata.startTime;
                    _logger.logger.debug("Already started preparing to encrypt for ".concat(this._roomId, " ") + "".concat(elapsedTime, " ms ago, skipping"));
                    return;
                }
                _logger.logger.debug("Preparing to encrypt events for ".concat(this._roomId));
                this.encryptionPreparationMetadata = {
                    startTime: Date.now()
                };
                this.encryptionPreparation = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee14() {
                    var _yield$_this3$_getDev, _yield$_this3$_getDev2, devicesInRoom, blocked;
                    return _regenerator["default"].wrap(function _callee14$(_context14) {
                        while (1) {
                            switch (_context14.prev = _context14.next) {
                                case 0:
                                    _context14.prev = 0;
                                    _logger.logger.debug("Getting devices in ".concat(_this3._roomId));
                                    _context14.next = 4;
                                    return _this3._getDevicesInRoom(room);
                                case 4:
                                    _yield$_this3$_getDev = _context14.sent;
                                    _yield$_this3$_getDev2 = (0, _slicedToArray2["default"])(_yield$_this3$_getDev, 2);
                                    devicesInRoom = _yield$_this3$_getDev2[0];
                                    blocked = _yield$_this3$_getDev2[1];
                                    if (_this3._crypto.getGlobalErrorOnUnknownDevices()) {
                                        _this3._removeUnknownDevices(devicesInRoom);
                                    }
                                    _logger.logger.debug("Ensuring outbound session in ".concat(_this3._roomId));
                                    _context14.next = 12;
                                    return _this3._ensureOutboundSession(devicesInRoom, blocked, true);
                                case 12:
                                    _logger.logger.debug("Ready to encrypt events for ".concat(_this3._roomId));
                                    _context14.next = 18;
                                    break;
                                case 15:
                                    _context14.prev = 15;
                                    _context14.t0 = _context14["catch"](0);
                                    _logger.logger.error("Failed to prepare to encrypt events for ".concat(_this3._roomId), _context14.t0);
                                case 18:
                                    _context14.prev = 18;
                                    delete _this3.encryptionPreparationMetadata;
                                    delete _this3.encryptionPreparation;
                                    return _context14.finish(18);
                                case 22:
                                case "end":
                                    return _context14.stop();
                            }
                        }
                    }, _callee14, null, [[0, 15, 18, 22]]);
                }))();
            };
            MegolmEncryption.prototype.encryptMessage = function () {
                var _ref15 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee15(room, eventType, content) {
                    var _yield$this$_getDevic, _yield$this$_getDevic2, devicesInRoom, blocked, session, payloadJson, ciphertext, encryptedContent;
                    return _regenerator["default"].wrap(function _callee15$(_context15) {
                        while (1) {
                            switch (_context15.prev = _context15.next) {
                                case 0:
                                    _logger.logger.log("Starting to encrypt event for ".concat(this._roomId));
                                    if (!this.encryptionPreparation) {
                                        _context15.next = 9;
                                        break;
                                    }
                                    _context15.prev = 2;
                                    _context15.next = 5;
                                    return this.encryptionPreparation;
                                case 5:
                                    _context15.next = 9;
                                    break;
                                case 7:
                                    _context15.prev = 7;
                                    _context15.t0 = _context15["catch"](2);
                                case 9:
                                    _context15.next = 11;
                                    return this._getDevicesInRoom(room);
                                case 11:
                                    _yield$this$_getDevic = _context15.sent;
                                    _yield$this$_getDevic2 = (0, _slicedToArray2["default"])(_yield$this$_getDevic, 2);
                                    devicesInRoom = _yield$this$_getDevic2[0];
                                    blocked = _yield$this$_getDevic2[1];
                                    if (this._crypto.getGlobalErrorOnUnknownDevices()) {
                                        this._checkForUnknownDevices(devicesInRoom);
                                    }
                                    _context15.next = 18;
                                    return this._ensureOutboundSession(devicesInRoom, blocked);
                                case 18:
                                    session = _context15.sent;
                                    payloadJson = {
                                        room_id: this._roomId,
                                        type: eventType,
                                        content: content
                                    };
                                    ciphertext = this._olmDevice.encryptGroupMessage(session.sessionId, JSON.stringify(payloadJson));
                                    encryptedContent = {
                                        algorithm: olmlib.MEGOLM_ALGORITHM,
                                        sender_key: this._olmDevice.deviceCurve25519Key,
                                        ciphertext: ciphertext,
                                        session_id: session.sessionId,
                                        device_id: this._deviceId
                                    };
                                    session.useCount++;
                                    return _context15.abrupt("return", encryptedContent);
                                case 24:
                                case "end":
                                    return _context15.stop();
                            }
                        }
                    }, _callee15, this, [[2, 7]]);
                }));
                return function (_x28, _x29, _x30) {
                    return _ref15.apply(this, arguments);
                };
            }();
            MegolmEncryption.prototype.forceDiscardSession = function () {
                this._setupPromise = this._setupPromise.then(function () {
                    return null;
                });
            };
            MegolmEncryption.prototype._checkForUnknownDevices = function (devicesInRoom) {
                var unknownDevices = {};
                Object.keys(devicesInRoom).forEach(function (userId) {
                    Object.keys(devicesInRoom[userId]).forEach(function (deviceId) {
                        var device = devicesInRoom[userId][deviceId];
                        if (device.isUnverified() && !device.isKnown()) {
                            if (!unknownDevices[userId]) {
                                unknownDevices[userId] = {};
                            }
                            unknownDevices[userId][deviceId] = device;
                        }
                    });
                });
                if (Object.keys(unknownDevices).length) {
                    throw new _base.UnknownDeviceError("This room contains unknown devices which have not been verified. " + "We strongly recommend you verify them before continuing.", unknownDevices);
                }
            };
            MegolmEncryption.prototype._removeUnknownDevices = function (devicesInRoom) {
                for (var _i14 = 0, _Object$entries7 = Object.entries(devicesInRoom); _i14 < _Object$entries7.length; _i14++) {
                    var _Object$entries7$_i = (0, _slicedToArray2["default"])(_Object$entries7[_i14], 2), userId = _Object$entries7$_i[0], userDevices = _Object$entries7$_i[1];
                    for (var _i15 = 0, _Object$entries8 = Object.entries(userDevices); _i15 < _Object$entries8.length; _i15++) {
                        var _Object$entries8$_i = (0, _slicedToArray2["default"])(_Object$entries8[_i15], 2), deviceId = _Object$entries8$_i[0], device = _Object$entries8$_i[1];
                        if (device.isUnverified() && !device.isKnown()) {
                            delete userDevices[deviceId];
                        }
                    }
                    if (Object.keys(userDevices).length === 0) {
                        delete devicesInRoom[userId];
                    }
                }
            };
            MegolmEncryption.prototype._getDevicesInRoom = function () {
                var _ref16 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee16(room) {
                    var members, roomMembers, isBlacklisting, devices, blocked, userId, userDevices, deviceId, deviceTrust, blockedInfo;
                    return _regenerator["default"].wrap(function _callee16$(_context16) {
                        while (1) {
                            switch (_context16.prev = _context16.next) {
                                case 0:
                                    _context16.next = 2;
                                    return room.getEncryptionTargetMembers();
                                case 2:
                                    members = _context16.sent;
                                    roomMembers = utils.map(members, function (u) {
                                        return u.userId;
                                    });
                                    isBlacklisting = this._crypto.getGlobalBlacklistUnverifiedDevices();
                                    if (typeof room.getBlacklistUnverifiedDevices() === 'boolean') {
                                        isBlacklisting = room.getBlacklistUnverifiedDevices();
                                    }
                                    _context16.next = 8;
                                    return this._crypto.downloadKeys(roomMembers, false);
                                case 8:
                                    devices = _context16.sent;
                                    blocked = {};
                                    _context16.t0 = _regenerator["default"].keys(devices);
                                case 11:
                                    if ((_context16.t1 = _context16.t0()).done) {
                                        _context16.next = 27;
                                        break;
                                    }
                                    userId = _context16.t1.value;
                                    if (devices.hasOwnProperty(userId)) {
                                        _context16.next = 15;
                                        break;
                                    }
                                    return _context16.abrupt("continue", 11);
                                case 15:
                                    userDevices = devices[userId];
                                    _context16.t2 = _regenerator["default"].keys(userDevices);
                                case 17:
                                    if ((_context16.t3 = _context16.t2()).done) {
                                        _context16.next = 25;
                                        break;
                                    }
                                    deviceId = _context16.t3.value;
                                    if (userDevices.hasOwnProperty(deviceId)) {
                                        _context16.next = 21;
                                        break;
                                    }
                                    return _context16.abrupt("continue", 17);
                                case 21:
                                    deviceTrust = this._crypto.checkDeviceTrust(userId, deviceId);
                                    if (userDevices[deviceId].isBlocked() || !deviceTrust.isVerified() && isBlacklisting) {
                                        if (!blocked[userId]) {
                                            blocked[userId] = {};
                                        }
                                        blockedInfo = userDevices[deviceId].isBlocked() ? {
                                            code: "m.blacklisted",
                                            reason: _OlmDevice.WITHHELD_MESSAGES["m.blacklisted"]
                                        } : {
                                            code: "m.unverified",
                                            reason: _OlmDevice.WITHHELD_MESSAGES["m.unverified"]
                                        };
                                        blockedInfo.deviceInfo = userDevices[deviceId];
                                        blocked[userId][deviceId] = blockedInfo;
                                        delete userDevices[deviceId];
                                    }
                                    _context16.next = 17;
                                    break;
                                case 25:
                                    _context16.next = 11;
                                    break;
                                case 27:
                                    return _context16.abrupt("return", [devices, blocked]);
                                case 28:
                                case "end":
                                    return _context16.stop();
                            }
                        }
                    }, _callee16, this);
                }));
                return function (_x31) {
                    return _ref16.apply(this, arguments);
                };
            }();
            function MegolmDecryption(params) {
                (0, utils.polyfillSuper)(this, _base.DecryptionAlgorithm, params);
                this._pendingEvents = {};
                this.olmlib = olmlib;
            }
            utils.inherits(MegolmDecryption, _base.DecryptionAlgorithm);
            var PROBLEM_DESCRIPTIONS = {
                no_olm: "The sender was unable to establish a secure channel.",
                unknown: "The secure channel with the sender was corrupted."
            };
            MegolmDecryption.prototype.decryptEvent = function () {
                var _ref17 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee17(event) {
                    var content, res, errorCode, problem, problemDescription, payload;
                    return _regenerator["default"].wrap(function _callee17$(_context17) {
                        while (1) {
                            switch (_context17.prev = _context17.next) {
                                case 0:
                                    content = event.getWireContent();
                                    if (!(!content.sender_key || !content.session_id || !content.ciphertext)) {
                                        _context17.next = 3;
                                        break;
                                    }
                                    throw new _base.DecryptionError("MEGOLM_MISSING_FIELDS", "Missing fields in input");
                                case 3:
                                    this._addEventToPendingList(event);
                                    _context17.prev = 4;
                                    _context17.next = 7;
                                    return this._olmDevice.decryptGroupMessage(event.getRoomId(), content.sender_key, content.session_id, content.ciphertext, event.getId(), event.getTs());
                                case 7:
                                    res = _context17.sent;
                                    _context17.next = 17;
                                    break;
                                case 10:
                                    _context17.prev = 10;
                                    _context17.t0 = _context17["catch"](4);
                                    if (!(_context17.t0.name === "DecryptionError")) {
                                        _context17.next = 14;
                                        break;
                                    }
                                    throw _context17.t0;
                                case 14:
                                    errorCode = "OLM_DECRYPT_GROUP_MESSAGE_ERROR";
                                    if (_context17.t0 && _context17.t0.message === 'OLM.UNKNOWN_MESSAGE_INDEX') {
                                        this._requestKeysForEvent(event);
                                        errorCode = 'OLM_UNKNOWN_MESSAGE_INDEX';
                                    }
                                    throw new _base.DecryptionError(errorCode, _context17.t0 ? _context17.t0.toString() : "Unknown Error: Error is undefined", {
                                        session: content.sender_key + '|' + content.session_id
                                    });
                                case 17:
                                    if (!(res === null)) {
                                        _context17.next = 27;
                                        break;
                                    }
                                    this._requestKeysForEvent(event);
                                    _context17.next = 21;
                                    return this._olmDevice.sessionMayHaveProblems(content.sender_key, event.getTs() - 120000);
                                case 21:
                                    problem = _context17.sent;
                                    if (!problem) {
                                        _context17.next = 26;
                                        break;
                                    }
                                    problemDescription = PROBLEM_DESCRIPTIONS[problem.type] || PROBLEM_DESCRIPTIONS.unknown;
                                    if (problem.fixed) {
                                        problemDescription += " Trying to create a new secure channel and re-requesting the keys.";
                                    }
                                    throw new _base.DecryptionError("MEGOLM_UNKNOWN_INBOUND_SESSION_ID", problemDescription, {
                                        session: content.sender_key + '|' + content.session_id
                                    });
                                case 26:
                                    throw new _base.DecryptionError("MEGOLM_UNKNOWN_INBOUND_SESSION_ID", "The sender's device has not sent us the keys for this message.", {
                                        session: content.sender_key + '|' + content.session_id
                                    });
                                case 27:
                                    this._removeEventFromPendingList(event);
                                    payload = JSON.parse(res.result);
                                    if (!(payload.room_id !== event.getRoomId())) {
                                        _context17.next = 31;
                                        break;
                                    }
                                    throw new _base.DecryptionError("MEGOLM_BAD_ROOM", "Message intended for room " + payload.room_id);
                                case 31:
                                    return _context17.abrupt("return", {
                                        clearEvent: payload,
                                        senderCurve25519Key: res.senderKey,
                                        claimedEd25519Key: res.keysClaimed.ed25519,
                                        forwardingCurve25519KeyChain: res.forwardingCurve25519KeyChain,
                                        untrusted: res.untrusted
                                    });
                                case 32:
                                case "end":
                                    return _context17.stop();
                            }
                        }
                    }, _callee17, this, [[4, 10]]);
                }));
                return function (_x32) {
                    return _ref17.apply(this, arguments);
                };
            }();
            MegolmDecryption.prototype._requestKeysForEvent = function (event) {
                var wireContent = event.getWireContent();
                var recipients = event.getKeyRequestRecipients(this._userId);
                this._crypto.requestRoomKey({
                    room_id: event.getRoomId(),
                    algorithm: wireContent.algorithm,
                    sender_key: wireContent.sender_key,
                    session_id: wireContent.session_id
                }, recipients);
            };
            MegolmDecryption.prototype._addEventToPendingList = function (event) {
                var content = event.getWireContent();
                var senderKey = content.sender_key;
                var sessionId = content.session_id;
                if (!this._pendingEvents[senderKey]) {
                    this._pendingEvents[senderKey] = new Map();
                }
                var senderPendingEvents = this._pendingEvents[senderKey];
                if (!senderPendingEvents.has(sessionId)) {
                    senderPendingEvents.set(sessionId, new Set());
                }
                senderPendingEvents.get(sessionId).add(event);
            };
            MegolmDecryption.prototype._removeEventFromPendingList = function (event) {
                var content = event.getWireContent();
                var senderKey = content.sender_key;
                var sessionId = content.session_id;
                var senderPendingEvents = this._pendingEvents[senderKey];
                var pendingEvents = senderPendingEvents && senderPendingEvents.get(sessionId);
                if (!pendingEvents) {
                    return;
                }
                pendingEvents["delete"](event);
                if (pendingEvents.size === 0) {
                    senderPendingEvents["delete"](senderKey);
                }
                if (senderPendingEvents.size === 0) {
                    delete this._pendingEvents[senderKey];
                }
            };
            MegolmDecryption.prototype.onRoomKeyEvent = function (event) {
                var _this4 = this;
                var content = event.getContent();
                var sessionId = content.session_id;
                var senderKey = event.getSenderKey();
                var forwardingKeyChain = [];
                var exportFormat = false;
                var keysClaimed;
                if (!content.room_id || !sessionId || !content.session_key) {
                    _logger.logger.error("key event is missing fields");
                    return;
                }
                if (!senderKey) {
                    _logger.logger.error("key event has no sender key (not encrypted?)");
                    return;
                }
                if (event.getType() == "m.forwarded_room_key") {
                    exportFormat = true;
                    forwardingKeyChain = content.forwarding_curve25519_key_chain;
                    if (!utils.isArray(forwardingKeyChain)) {
                        forwardingKeyChain = [];
                    }
                    forwardingKeyChain = forwardingKeyChain.slice();
                    forwardingKeyChain.push(senderKey);
                    senderKey = content.sender_key;
                    if (!senderKey) {
                        _logger.logger.error("forwarded_room_key event is missing sender_key field");
                        return;
                    }
                    var ed25519Key = content.sender_claimed_ed25519_key;
                    if (!ed25519Key) {
                        _logger.logger.error("forwarded_room_key_event is missing sender_claimed_ed25519_key field");
                        return;
                    }
                    keysClaimed = {
                        ed25519: ed25519Key
                    };
                }
                else {
                    keysClaimed = event.getKeysClaimed();
                }
                return this._olmDevice.addInboundGroupSession(content.room_id, senderKey, forwardingKeyChain, sessionId, content.session_key, keysClaimed, exportFormat).then(function () {
                    _this4._retryDecryption(senderKey, sessionId).then(function (success) {
                        if (success) {
                            _this4._crypto.cancelRoomKeyRequest({
                                algorithm: content.algorithm,
                                room_id: content.room_id,
                                session_id: content.session_id,
                                sender_key: senderKey
                            });
                        }
                    });
                }).then(function () {
                    _this4._crypto.backupGroupSession(content.room_id, senderKey, forwardingKeyChain, content.session_id, content.session_key, keysClaimed, exportFormat);
                })["catch"](function (e) {
                    _logger.logger.error("Error handling m.room_key_event: ".concat(e));
                });
            };
            MegolmDecryption.prototype.onRoomKeyWithheldEvent = function () {
                var _ref18 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee18(event) {
                    var content, senderKey, sender, device, encryptedContent;
                    return _regenerator["default"].wrap(function _callee18$(_context18) {
                        while (1) {
                            switch (_context18.prev = _context18.next) {
                                case 0:
                                    content = event.getContent();
                                    senderKey = content.sender_key;
                                    if (!(content.code === "m.no_olm")) {
                                        _context18.next = 36;
                                        break;
                                    }
                                    sender = event.getSender();
                                    _logger.logger.warn("".concat(sender, ":").concat(senderKey, " was unable to establish an olm session with us"));
                                    _context18.next = 7;
                                    return this._olmDevice.getSessionIdForDevice(senderKey);
                                case 7:
                                    if (!_context18.sent) {
                                        _context18.next = 13;
                                        break;
                                    }
                                    _logger.logger.debug("New session already created.  Not creating a new one.");
                                    _context18.next = 11;
                                    return this._olmDevice.recordSessionProblem(senderKey, "no_olm", true);
                                case 11:
                                    this.retryDecryptionFromSender(senderKey);
                                    return _context18.abrupt("return");
                                case 13:
                                    device = this._crypto._deviceList.getDeviceByIdentityKey(content.algorithm, senderKey);
                                    if (device) {
                                        _context18.next = 24;
                                        break;
                                    }
                                    _context18.next = 17;
                                    return this._crypto.downloadKeys([sender], false);
                                case 17:
                                    device = this._crypto._deviceList.getDeviceByIdentityKey(content.algorithm, senderKey);
                                    if (device) {
                                        _context18.next = 24;
                                        break;
                                    }
                                    _logger.logger.info("Couldn't find device for identity key " + senderKey + ": not establishing session");
                                    _context18.next = 22;
                                    return this._olmDevice.recordSessionProblem(senderKey, "no_olm", false);
                                case 22:
                                    this.retryDecryptionFromSender(senderKey);
                                    return _context18.abrupt("return");
                                case 24:
                                    _context18.next = 26;
                                    return olmlib.ensureOlmSessionsForDevices(this._olmDevice, this._baseApis, (0, _defineProperty2["default"])({}, sender, [device]), false);
                                case 26:
                                    encryptedContent = {
                                        algorithm: olmlib.OLM_ALGORITHM,
                                        sender_key: this._olmDevice.deviceCurve25519Key,
                                        ciphertext: {}
                                    };
                                    _context18.next = 29;
                                    return olmlib.encryptMessageForDevice(encryptedContent.ciphertext, this._userId, this._deviceId, this._olmDevice, sender, device, {
                                        type: "m.dummy"
                                    });
                                case 29:
                                    _context18.next = 31;
                                    return this._olmDevice.recordSessionProblem(senderKey, "no_olm", true);
                                case 31:
                                    this.retryDecryptionFromSender(senderKey);
                                    _context18.next = 34;
                                    return this._baseApis.sendToDevice("m.room.encrypted", (0, _defineProperty2["default"])({}, sender, (0, _defineProperty2["default"])({}, device.deviceId, encryptedContent)));
                                case 34:
                                    _context18.next = 38;
                                    break;
                                case 36:
                                    _context18.next = 38;
                                    return this._olmDevice.addInboundGroupSessionWithheld(content.room_id, senderKey, content.session_id, content.code, content.reason);
                                case 38:
                                case "end":
                                    return _context18.stop();
                            }
                        }
                    }, _callee18, this);
                }));
                return function (_x33) {
                    return _ref18.apply(this, arguments);
                };
            }();
            MegolmDecryption.prototype.hasKeysForKeyRequest = function (keyRequest) {
                var body = keyRequest.requestBody;
                return this._olmDevice.hasInboundSessionKeys(body.room_id, body.sender_key, body.session_id);
            };
            MegolmDecryption.prototype.shareKeysWithDevice = function (keyRequest) {
                var _this5 = this;
                var userId = keyRequest.userId;
                var deviceId = keyRequest.deviceId;
                var deviceInfo = this._crypto.getStoredDevice(userId, deviceId);
                var body = keyRequest.requestBody;
                this.olmlib.ensureOlmSessionsForDevices(this._olmDevice, this._baseApis, (0, _defineProperty2["default"])({}, userId, [deviceInfo])).then(function (devicemap) {
                    var olmSessionResult = devicemap[userId][deviceId];
                    if (!olmSessionResult.sessionId) {
                        return null;
                    }
                    _logger.logger.log("sharing keys for session " + body.sender_key + "|" + body.session_id + " with device " + userId + ":" + deviceId);
                    return _this5._buildKeyForwardingMessage(body.room_id, body.sender_key, body.session_id);
                }).then(function (payload) {
                    var encryptedContent = {
                        algorithm: olmlib.OLM_ALGORITHM,
                        sender_key: _this5._olmDevice.deviceCurve25519Key,
                        ciphertext: {}
                    };
                    return _this5.olmlib.encryptMessageForDevice(encryptedContent.ciphertext, _this5._userId, _this5._deviceId, _this5._olmDevice, userId, deviceInfo, payload).then(function () {
                        var contentMap = (0, _defineProperty2["default"])({}, userId, (0, _defineProperty2["default"])({}, deviceId, encryptedContent));
                        return _this5._baseApis.sendToDevice("m.room.encrypted", contentMap);
                    });
                });
            };
            MegolmDecryption.prototype._buildKeyForwardingMessage = function () {
                var _ref19 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee19(roomId, senderKey, sessionId) {
                    var key;
                    return _regenerator["default"].wrap(function _callee19$(_context19) {
                        while (1) {
                            switch (_context19.prev = _context19.next) {
                                case 0:
                                    _context19.next = 2;
                                    return this._olmDevice.getInboundGroupSessionKey(roomId, senderKey, sessionId);
                                case 2:
                                    key = _context19.sent;
                                    return _context19.abrupt("return", {
                                        type: "m.forwarded_room_key",
                                        content: {
                                            algorithm: olmlib.MEGOLM_ALGORITHM,
                                            room_id: roomId,
                                            sender_key: senderKey,
                                            sender_claimed_ed25519_key: key.sender_claimed_ed25519_key,
                                            session_id: sessionId,
                                            session_key: key.key,
                                            chain_index: key.chain_index,
                                            forwarding_curve25519_key_chain: key.forwarding_curve25519_key_chain
                                        }
                                    });
                                case 4:
                                case "end":
                                    return _context19.stop();
                            }
                        }
                    }, _callee19, this);
                }));
                return function (_x34, _x35, _x36) {
                    return _ref19.apply(this, arguments);
                };
            }();
            MegolmDecryption.prototype.importRoomKey = function (session) {
                var _this6 = this;
                var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                return this._olmDevice.addInboundGroupSession(session.room_id, session.sender_key, session.forwarding_curve25519_key_chain, session.session_id, session.session_key, session.sender_claimed_keys, true, opts.untrusted ? {
                    untrusted: opts.untrusted
                } : {}).then(function () {
                    if (opts.source !== "backup") {
                        _this6._crypto.backupGroupSession(session.room_id, session.sender_key, session.forwarding_curve25519_key_chain, session.session_id, session.session_key, session.sender_claimed_keys, true)["catch"](function (e) {
                            _logger.logger.log("Failed to back up megolm session", e);
                        });
                    }
                    _this6._retryDecryption(session.sender_key, session.session_id);
                });
            };
            MegolmDecryption.prototype._retryDecryption = function () {
                var _ref20 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee21(senderKey, sessionId) {
                    var _this7 = this;
                    var senderPendingEvents, pending;
                    return _regenerator["default"].wrap(function _callee21$(_context21) {
                        while (1) {
                            switch (_context21.prev = _context21.next) {
                                case 0:
                                    senderPendingEvents = this._pendingEvents[senderKey];
                                    if (senderPendingEvents) {
                                        _context21.next = 3;
                                        break;
                                    }
                                    return _context21.abrupt("return", true);
                                case 3:
                                    pending = senderPendingEvents.get(sessionId);
                                    if (pending) {
                                        _context21.next = 6;
                                        break;
                                    }
                                    return _context21.abrupt("return", true);
                                case 6:
                                    _logger.logger.debug("Retrying decryption on events", (0, _toConsumableArray2["default"])(pending));
                                    _context21.next = 9;
                                    return Promise.all((0, _toConsumableArray2["default"])(pending).map(function () {
                                        var _ref21 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee20(ev) {
                                            return _regenerator["default"].wrap(function _callee20$(_context20) {
                                                while (1) {
                                                    switch (_context20.prev = _context20.next) {
                                                        case 0:
                                                            _context20.prev = 0;
                                                            _context20.next = 3;
                                                            return ev.attemptDecryption(_this7._crypto, true);
                                                        case 3:
                                                            _context20.next = 7;
                                                            break;
                                                        case 5:
                                                            _context20.prev = 5;
                                                            _context20.t0 = _context20["catch"](0);
                                                        case 7:
                                                        case "end":
                                                            return _context20.stop();
                                                    }
                                                }
                                            }, _callee20, null, [[0, 5]]);
                                        }));
                                        return function (_x39) {
                                            return _ref21.apply(this, arguments);
                                        };
                                    }()));
                                case 9:
                                    return _context21.abrupt("return", !(this._pendingEvents[senderKey] || {})[sessionId]);
                                case 10:
                                case "end":
                                    return _context21.stop();
                            }
                        }
                    }, _callee21, this);
                }));
                return function (_x37, _x38) {
                    return _ref20.apply(this, arguments);
                };
            }();
            MegolmDecryption.prototype.retryDecryptionFromSender = function () {
                var _ref22 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee24(senderKey) {
                    var _this8 = this;
                    var senderPendingEvents;
                    return _regenerator["default"].wrap(function _callee24$(_context24) {
                        while (1) {
                            switch (_context24.prev = _context24.next) {
                                case 0:
                                    senderPendingEvents = this._pendingEvents[senderKey];
                                    if (senderPendingEvents) {
                                        _context24.next = 3;
                                        break;
                                    }
                                    return _context24.abrupt("return", true);
                                case 3:
                                    delete this._pendingEvents[senderKey];
                                    _context24.next = 6;
                                    return Promise.all((0, _toConsumableArray2["default"])(senderPendingEvents).map(function () {
                                        var _ref24 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee23(_ref23) {
                                            var _ref25, _sessionId, pending;
                                            return _regenerator["default"].wrap(function _callee23$(_context23) {
                                                while (1) {
                                                    switch (_context23.prev = _context23.next) {
                                                        case 0:
                                                            _ref25 = (0, _slicedToArray2["default"])(_ref23, 2), _sessionId = _ref25[0], pending = _ref25[1];
                                                            _context23.next = 3;
                                                            return Promise.all((0, _toConsumableArray2["default"])(pending).map(function () {
                                                                var _ref26 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee22(ev) {
                                                                    return _regenerator["default"].wrap(function _callee22$(_context22) {
                                                                        while (1) {
                                                                            switch (_context22.prev = _context22.next) {
                                                                                case 0:
                                                                                    _context22.prev = 0;
                                                                                    _context22.next = 3;
                                                                                    return ev.attemptDecryption(_this8._crypto);
                                                                                case 3:
                                                                                    _context22.next = 7;
                                                                                    break;
                                                                                case 5:
                                                                                    _context22.prev = 5;
                                                                                    _context22.t0 = _context22["catch"](0);
                                                                                case 7:
                                                                                case "end":
                                                                                    return _context22.stop();
                                                                            }
                                                                        }
                                                                    }, _callee22, null, [[0, 5]]);
                                                                }));
                                                                return function (_x42) {
                                                                    return _ref26.apply(this, arguments);
                                                                };
                                                            }()));
                                                        case 3:
                                                        case "end":
                                                            return _context23.stop();
                                                    }
                                                }
                                            }, _callee23);
                                        }));
                                        return function (_x41) {
                                            return _ref24.apply(this, arguments);
                                        };
                                    }()));
                                case 6:
                                    return _context24.abrupt("return", !this._pendingEvents[senderKey]);
                                case 7:
                                case "end":
                                    return _context24.stop();
                            }
                        }
                    }, _callee24, this);
                }));
                return function (_x40) {
                    return _ref22.apply(this, arguments);
                };
            }();
            (0, _base.registerAlgorithm)(olmlib.MEGOLM_ALGORITHM, MegolmEncryption, MegolmDecryption);
        }, { "../../logger": 97, "../../utils": 125, "../OlmDevice": 64, "../olmlib": 77, "./base": 69, "@babel/runtime/helpers/asyncToGenerator": 5, "@babel/runtime/helpers/defineProperty": 9, "@babel/runtime/helpers/interopRequireDefault": 12, "@babel/runtime/helpers/interopRequireWildcard": 13, "@babel/runtime/helpers/slicedToArray": 22, "@babel/runtime/helpers/toConsumableArray": 23, "@babel/runtime/regenerator": 27 }], 72: [function (require, module, exports) {
            "use strict";
            var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
            var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
            var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
            var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
            var _logger = require("../../logger");
            var utils = _interopRequireWildcard(require("../../utils"));
            var olmlib = _interopRequireWildcard(require("../olmlib"));
            var _deviceinfo = require("../deviceinfo");
            var _base = require("./base");
            var DeviceVerification = _deviceinfo.DeviceInfo.DeviceVerification;
            function OlmEncryption(params) {
                (0, utils.polyfillSuper)(this, _base.EncryptionAlgorithm, params);
                this._sessionPrepared = false;
                this._prepPromise = null;
            }
            utils.inherits(OlmEncryption, _base.EncryptionAlgorithm);
            OlmEncryption.prototype._ensureSession = function (roomMembers) {
                if (this._prepPromise) {
                    return this._prepPromise;
                }
                if (this._sessionPrepared) {
                    return Promise.resolve();
                }
                var self = this;
                this._prepPromise = self._crypto.downloadKeys(roomMembers).then(function (res) {
                    return self._crypto.ensureOlmSessionsForUsers(roomMembers);
                }).then(function () {
                    self._sessionPrepared = true;
                })["finally"](function () {
                    self._prepPromise = null;
                });
                return this._prepPromise;
            };
            OlmEncryption.prototype.encryptMessage = function () {
                var _ref = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee(room, eventType, content) {
                    var members, users, self, payloadFields, encryptedContent, promises, i, userId, devices, j, deviceInfo, key;
                    return _regenerator["default"].wrap(function _callee$(_context) {
                        while (1) {
                            switch (_context.prev = _context.next) {
                                case 0:
                                    _context.next = 2;
                                    return room.getEncryptionTargetMembers();
                                case 2:
                                    members = _context.sent;
                                    users = utils.map(members, function (u) {
                                        return u.userId;
                                    });
                                    self = this;
                                    _context.next = 7;
                                    return this._ensureSession(users);
                                case 7:
                                    payloadFields = {
                                        room_id: room.roomId,
                                        type: eventType,
                                        content: content
                                    };
                                    encryptedContent = {
                                        algorithm: olmlib.OLM_ALGORITHM,
                                        sender_key: self._olmDevice.deviceCurve25519Key,
                                        ciphertext: {}
                                    };
                                    promises = [];
                                    i = 0;
                                case 11:
                                    if (!(i < users.length)) {
                                        _context.next = 29;
                                        break;
                                    }
                                    userId = users[i];
                                    devices = self._crypto.getStoredDevicesForUser(userId);
                                    j = 0;
                                case 15:
                                    if (!(j < devices.length)) {
                                        _context.next = 26;
                                        break;
                                    }
                                    deviceInfo = devices[j];
                                    key = deviceInfo.getIdentityKey();
                                    if (!(key == self._olmDevice.deviceCurve25519Key)) {
                                        _context.next = 20;
                                        break;
                                    }
                                    return _context.abrupt("continue", 23);
                                case 20:
                                    if (!(deviceInfo.verified == DeviceVerification.BLOCKED)) {
                                        _context.next = 22;
                                        break;
                                    }
                                    return _context.abrupt("continue", 23);
                                case 22:
                                    promises.push(olmlib.encryptMessageForDevice(encryptedContent.ciphertext, self._userId, self._deviceId, self._olmDevice, userId, deviceInfo, payloadFields));
                                case 23:
                                    ++j;
                                    _context.next = 15;
                                    break;
                                case 26:
                                    ++i;
                                    _context.next = 11;
                                    break;
                                case 29:
                                    _context.next = 31;
                                    return Promise.all(promises).then(function () {
                                        return encryptedContent;
                                    });
                                case 31:
                                    return _context.abrupt("return", _context.sent);
                                case 32:
                                case "end":
                                    return _context.stop();
                            }
                        }
                    }, _callee, this);
                }));
                return function (_x, _x2, _x3) {
                    return _ref.apply(this, arguments);
                };
            }();
            function OlmDecryption(params) {
                (0, utils.polyfillSuper)(this, _base.DecryptionAlgorithm, params);
            }
            utils.inherits(OlmDecryption, _base.DecryptionAlgorithm);
            OlmDecryption.prototype.decryptEvent = function () {
                var _ref2 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee2(event) {
                    var content, deviceKey, ciphertext, message, payloadString, payload, claimedKeys;
                    return _regenerator["default"].wrap(function _callee2$(_context2) {
                        while (1) {
                            switch (_context2.prev = _context2.next) {
                                case 0:
                                    content = event.getWireContent();
                                    deviceKey = content.sender_key;
                                    ciphertext = content.ciphertext;
                                    if (ciphertext) {
                                        _context2.next = 5;
                                        break;
                                    }
                                    throw new _base.DecryptionError("OLM_MISSING_CIPHERTEXT", "Missing ciphertext");
                                case 5:
                                    if (this._olmDevice.deviceCurve25519Key in ciphertext) {
                                        _context2.next = 7;
                                        break;
                                    }
                                    throw new _base.DecryptionError("OLM_NOT_INCLUDED_IN_RECIPIENTS", "Not included in recipients");
                                case 7:
                                    message = ciphertext[this._olmDevice.deviceCurve25519Key];
                                    _context2.prev = 8;
                                    _context2.next = 11;
                                    return this._decryptMessage(deviceKey, message);
                                case 11:
                                    payloadString = _context2.sent;
                                    _context2.next = 17;
                                    break;
                                case 14:
                                    _context2.prev = 14;
                                    _context2.t0 = _context2["catch"](8);
                                    throw new _base.DecryptionError("OLM_BAD_ENCRYPTED_MESSAGE", "Bad Encrypted Message", {
                                        sender: deviceKey,
                                        err: _context2.t0
                                    });
                                case 17:
                                    payload = JSON.parse(payloadString);
                                    if (!(payload.recipient != this._userId)) {
                                        _context2.next = 20;
                                        break;
                                    }
                                    throw new _base.DecryptionError("OLM_BAD_RECIPIENT", "Message was intented for " + payload.recipient);
                                case 20:
                                    if (!(payload.recipient_keys.ed25519 != this._olmDevice.deviceEd25519Key)) {
                                        _context2.next = 22;
                                        break;
                                    }
                                    throw new _base.DecryptionError("OLM_BAD_RECIPIENT_KEY", "Message not intended for this device", {
                                        intended: payload.recipient_keys.ed25519,
                                        our_key: this._olmDevice.deviceEd25519Key
                                    });
                                case 22:
                                    if (!(payload.sender != event.getSender())) {
                                        _context2.next = 24;
                                        break;
                                    }
                                    throw new _base.DecryptionError("OLM_FORWARDED_MESSAGE", "Message forwarded from " + payload.sender, {
                                        reported_sender: event.getSender()
                                    });
                                case 24:
                                    if (!(payload.room_id !== event.getRoomId())) {
                                        _context2.next = 26;
                                        break;
                                    }
                                    throw new _base.DecryptionError("OLM_BAD_ROOM", "Message intended for room " + payload.room_id, {
                                        reported_room: event.room_id
                                    });
                                case 26:
                                    claimedKeys = payload.keys || {};
                                    return _context2.abrupt("return", {
                                        clearEvent: payload,
                                        senderCurve25519Key: deviceKey,
                                        claimedEd25519Key: claimedKeys.ed25519 || null
                                    });
                                case 28:
                                case "end":
                                    return _context2.stop();
                            }
                        }
                    }, _callee2, this, [[8, 14]]);
                }));
                return function (_x4) {
                    return _ref2.apply(this, arguments);
                };
            }();
            OlmDecryption.prototype._decryptMessage = function () {
                var _ref3 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee3(theirDeviceIdentityKey, message) {
                    var _this = this;
                    var myPromise;
                    return _regenerator["default"].wrap(function _callee3$(_context3) {
                        while (1) {
                            switch (_context3.prev = _context3.next) {
                                case 0:
                                    if (!(message.type !== 0)) {
                                        _context3.next = 4;
                                        break;
                                    }
                                    return _context3.abrupt("return", this._reallyDecryptMessage(theirDeviceIdentityKey, message));
                                case 4:
                                    myPromise = this._olmDevice._olmPrekeyPromise.then(function () {
                                        return _this._reallyDecryptMessage(theirDeviceIdentityKey, message);
                                    });
                                    this._olmDevice._olmPrekeyPromise = myPromise["catch"](function () { });
                                    _context3.next = 8;
                                    return myPromise;
                                case 8:
                                    return _context3.abrupt("return", _context3.sent);
                                case 9:
                                case "end":
                                    return _context3.stop();
                            }
                        }
                    }, _callee3, this);
                }));
                return function (_x5, _x6) {
                    return _ref3.apply(this, arguments);
                };
            }();
            OlmDecryption.prototype._reallyDecryptMessage = function () {
                var _ref4 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee4(theirDeviceIdentityKey, message) {
                    var sessionIds, decryptionErrors, i, sessionId, payload, foundSession, res;
                    return _regenerator["default"].wrap(function _callee4$(_context4) {
                        while (1) {
                            switch (_context4.prev = _context4.next) {
                                case 0:
                                    _context4.next = 2;
                                    return this._olmDevice.getSessionIdsForDevice(theirDeviceIdentityKey);
                                case 2:
                                    sessionIds = _context4.sent;
                                    decryptionErrors = {};
                                    i = 0;
                                case 5:
                                    if (!(i < sessionIds.length)) {
                                        _context4.next = 26;
                                        break;
                                    }
                                    sessionId = sessionIds[i];
                                    _context4.prev = 7;
                                    _context4.next = 10;
                                    return this._olmDevice.decryptMessage(theirDeviceIdentityKey, sessionId, message.type, message.body);
                                case 10:
                                    payload = _context4.sent;
                                    _logger.logger.log("Decrypted Olm message from " + theirDeviceIdentityKey + " with session " + sessionId);
                                    return _context4.abrupt("return", payload);
                                case 15:
                                    _context4.prev = 15;
                                    _context4.t0 = _context4["catch"](7);
                                    _context4.next = 19;
                                    return this._olmDevice.matchesSession(theirDeviceIdentityKey, sessionId, message.type, message.body);
                                case 19:
                                    foundSession = _context4.sent;
                                    if (!foundSession) {
                                        _context4.next = 22;
                                        break;
                                    }
                                    throw new Error("Error decrypting prekey message with existing session id " + sessionId + ": " + _context4.t0.message);
                                case 22:
                                    decryptionErrors[sessionId] = _context4.t0.message;
                                case 23:
                                    i++;
                                    _context4.next = 5;
                                    break;
                                case 26:
                                    if (!(message.type !== 0)) {
                                        _context4.next = 30;
                                        break;
                                    }
                                    if (!(sessionIds.length === 0)) {
                                        _context4.next = 29;
                                        break;
                                    }
                                    throw new Error("No existing sessions");
                                case 29:
                                    throw new Error("Error decrypting non-prekey message with existing sessions: " + JSON.stringify(decryptionErrors));
                                case 30:
                                    _context4.prev = 30;
                                    _context4.next = 33;
                                    return this._olmDevice.createInboundSession(theirDeviceIdentityKey, message.type, message.body);
                                case 33:
                                    res = _context4.sent;
                                    _context4.next = 40;
                                    break;
                                case 36:
                                    _context4.prev = 36;
                                    _context4.t1 = _context4["catch"](30);
                                    decryptionErrors["(new)"] = _context4.t1.message;
                                    throw new Error("Error decrypting prekey message: " + JSON.stringify(decryptionErrors));
                                case 40:
                                    _logger.logger.log("created new inbound Olm session ID " + res.session_id + " with " + theirDeviceIdentityKey);
                                    return _context4.abrupt("return", res.payload);
                                case 42:
                                case "end":
                                    return _context4.stop();
                            }
                        }
                    }, _callee4, this, [[7, 15], [30, 36]]);
                }));
                return function (_x7, _x8) {
                    return _ref4.apply(this, arguments);
                };
            }();
            (0, _base.registerAlgorithm)(olmlib.OLM_ALGORITHM, OlmEncryption, OlmDecryption);
        }, { "../../logger": 97, "../../utils": 125, "../deviceinfo": 74, "../olmlib": 77, "./base": 69, "@babel/runtime/helpers/asyncToGenerator": 5, "@babel/runtime/helpers/interopRequireDefault": 12, "@babel/runtime/helpers/interopRequireWildcard": 13, "@babel/runtime/regenerator": 27 }], 73: [function (require, module, exports) {
            (function (global, Buffer) {
                (function () {
                    "use strict";
                    var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
                        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
                        return new (P || (P = Promise))(function (resolve, reject) {
                            function fulfilled(value) { try {
                                step(generator.next(value));
                            }
                            catch (e) {
                                reject(e);
                            } }
                            function rejected(value) { try {
                                step(generator["throw"](value));
                            }
                            catch (e) {
                                reject(e);
                            } }
                            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
                            step((generator = generator.apply(thisArg, _arguments || [])).next());
                        });
                    };
                    var __importDefault = (this && this.__importDefault) || function (mod) {
                        return (mod && mod.__esModule) ? mod : { "default": mod };
                    };
                    Object.defineProperty(exports, "__esModule", { value: true });
                    exports.DehydrationManager = exports.DEHYDRATION_ALGORITHM = void 0;
                    const olmlib_1 = require("./olmlib");
                    const indexeddb_crypto_store_1 = require("../crypto/store/indexeddb-crypto-store");
                    const aes_1 = require("./aes");
                    const another_json_1 = __importDefault(require("another-json"));
                    const logger_1 = require("../logger");
                    exports.DEHYDRATION_ALGORITHM = "org.matrix.msc2697.v1.olm.libolm_pickle";
                    const oneweek = 7 * 24 * 60 * 60 * 1000;
                    class DehydrationManager {
                        constructor(crypto) {
                            this.crypto = crypto;
                            this.inProgress = false;
                            this.getDehydrationKeyFromCache();
                        }
                        getDehydrationKeyFromCache() {
                            return __awaiter(this, void 0, void 0, function* () {
                                return yield this.crypto._cryptoStore.doTxn('readonly', [indexeddb_crypto_store_1.IndexedDBCryptoStore.STORE_ACCOUNT], (txn) => {
                                    this.crypto._cryptoStore.getSecretStorePrivateKey(txn, (result) => __awaiter(this, void 0, void 0, function* () {
                                        if (result) {
                                            const { key, keyInfo, deviceDisplayName, time } = result;
                                            const pickleKey = Buffer.from(this.crypto._olmDevice._pickleKey);
                                            const decrypted = yield aes_1.decryptAES(key, pickleKey, exports.DEHYDRATION_ALGORITHM);
                                            this.key = olmlib_1.decodeBase64(decrypted);
                                            this.keyInfo = keyInfo;
                                            this.deviceDisplayName = deviceDisplayName;
                                            const now = Date.now();
                                            const delay = Math.max(1, time + oneweek - now);
                                            this.timeoutId = global.setTimeout(this.dehydrateDevice.bind(this), delay);
                                        }
                                    }), "dehydration");
                                });
                            });
                        }
                        setKeyAndQueueDehydration(key, keyInfo = {}, deviceDisplayName = undefined) {
                            return __awaiter(this, void 0, void 0, function* () {
                                const matches = yield this.setKey(key, keyInfo, deviceDisplayName);
                                if (!matches) {
                                    this.dehydrateDevice();
                                }
                            });
                        }
                        setKey(key, keyInfo = {}, deviceDisplayName = undefined) {
                            return __awaiter(this, void 0, void 0, function* () {
                                if (!key) {
                                    if (this.timeoutId) {
                                        global.clearTimeout(this.timeoutId);
                                        this.timeoutId = undefined;
                                    }
                                    yield this.crypto._cryptoStore.doTxn('readwrite', [indexeddb_crypto_store_1.IndexedDBCryptoStore.STORE_ACCOUNT], (txn) => {
                                        this.crypto._cryptoStore.storeSecretStorePrivateKey(txn, "dehydration", null);
                                    });
                                    this.key = undefined;
                                    this.keyInfo = undefined;
                                    return;
                                }
                                let matches = this.key && key.length == this.key.length;
                                for (let i = 0; matches && i < key.length; i++) {
                                    if (key[i] != this.key[i]) {
                                        matches = false;
                                    }
                                }
                                if (!matches) {
                                    this.key = key;
                                    this.keyInfo = keyInfo;
                                    this.deviceDisplayName = deviceDisplayName;
                                }
                                return matches;
                            });
                        }
                        dehydrateDevice() {
                            return __awaiter(this, void 0, void 0, function* () {
                                if (this.inProgress) {
                                    logger_1.logger.log("Dehydration already in progress -- not starting new dehydration");
                                    return;
                                }
                                this.inProgress = true;
                                if (this.timeoutId) {
                                    global.clearTimeout(this.timeoutId);
                                    this.timeoutId = undefined;
                                }
                                try {
                                    const pickleKey = Buffer.from(this.crypto._olmDevice._pickleKey);
                                    const key = yield aes_1.encryptAES(olmlib_1.encodeBase64(this.key), pickleKey, exports.DEHYDRATION_ALGORITHM);
                                    yield this.crypto._cryptoStore.doTxn('readwrite', [indexeddb_crypto_store_1.IndexedDBCryptoStore.STORE_ACCOUNT], (txn) => {
                                        this.crypto._cryptoStore.storeSecretStorePrivateKey(txn, "dehydration", {
                                            keyInfo: this.keyInfo,
                                            key,
                                            deviceDisplayName: this.deviceDisplayName,
                                            time: Date.now(),
                                        });
                                    });
                                    logger_1.logger.log("Attempting to dehydrate device");
                                    logger_1.logger.log("Creating account");
                                    const account = new global.Olm.Account();
                                    account.create();
                                    const e2eKeys = JSON.parse(account.identity_keys());
                                    const maxKeys = account.max_number_of_one_time_keys();
                                    account.generate_one_time_keys(maxKeys / 2);
                                    account.generate_fallback_key();
                                    const otks = JSON.parse(account.one_time_keys());
                                    const fallbacks = JSON.parse(account.fallback_key());
                                    account.mark_keys_as_published();
                                    const pickledAccount = account.pickle(new Uint8Array(this.key));
                                    const deviceData = {
                                        algorithm: exports.DEHYDRATION_ALGORITHM,
                                        account: pickledAccount,
                                    };
                                    if (this.keyInfo.passphrase) {
                                        deviceData.passphrase = this.keyInfo.passphrase;
                                    }
                                    logger_1.logger.log("Uploading account to server");
                                    const dehydrateResult = yield this.crypto._baseApis._http.authedRequest(undefined, "PUT", "/dehydrated_device", undefined, {
                                        device_data: deviceData,
                                        initial_device_display_name: this.deviceDisplayName,
                                    }, {
                                        prefix: "/_matrix/client/unstable/org.matrix.msc2697.v2",
                                    });
                                    const deviceId = dehydrateResult.device_id;
                                    logger_1.logger.log("Preparing device keys", deviceId);
                                    const deviceKeys = {
                                        algorithms: this.crypto._supportedAlgorithms,
                                        device_id: deviceId,
                                        user_id: this.crypto._userId,
                                        keys: {
                                            [`ed25519:${deviceId}`]: e2eKeys.ed25519,
                                            [`curve25519:${deviceId}`]: e2eKeys.curve25519,
                                        },
                                    };
                                    const deviceSignature = account.sign(another_json_1.default.stringify(deviceKeys));
                                    deviceKeys.signatures = {
                                        [this.crypto._userId]: {
                                            [`ed25519:${deviceId}`]: deviceSignature,
                                        },
                                    };
                                    if (this.crypto._crossSigningInfo.getId("self_signing")) {
                                        yield this.crypto._crossSigningInfo.signObject(deviceKeys, "self_signing");
                                    }
                                    logger_1.logger.log("Preparing one-time keys");
                                    const oneTimeKeys = {};
                                    for (const [keyId, key] of Object.entries(otks.curve25519)) {
                                        const k = { key };
                                        const signature = account.sign(another_json_1.default.stringify(k));
                                        k.signatures = {
                                            [this.crypto._userId]: {
                                                [`ed25519:${deviceId}`]: signature,
                                            },
                                        };
                                        oneTimeKeys[`signed_curve25519:${keyId}`] = k;
                                    }
                                    logger_1.logger.log("Preparing fallback keys");
                                    const fallbackKeys = {};
                                    for (const [keyId, key] of Object.entries(fallbacks.curve25519)) {
                                        const k = { key, fallback: true };
                                        const signature = account.sign(another_json_1.default.stringify(k));
                                        k.signatures = {
                                            [this.crypto._userId]: {
                                                [`ed25519:${deviceId}`]: signature,
                                            },
                                        };
                                        fallbackKeys[`signed_curve25519:${keyId}`] = k;
                                    }
                                    logger_1.logger.log("Uploading keys to server");
                                    yield this.crypto._baseApis._http.authedRequest(undefined, "POST", "/keys/upload/" + encodeURI(deviceId), undefined, {
                                        "device_keys": deviceKeys,
                                        "one_time_keys": oneTimeKeys,
                                        "org.matrix.msc2732.fallback_keys": fallbackKeys,
                                    });
                                    logger_1.logger.log("Done dehydrating");
                                    this.timeoutId = global.setTimeout(this.dehydrateDevice.bind(this), oneweek);
                                    return deviceId;
                                }
                                finally {
                                    this.inProgress = false;
                                }
                            });
                        }
                        stop() {
                            if (this.timeoutId) {
                                global.clearTimeout(this.timeoutId);
                                this.timeoutId = undefined;
                            }
                        }
                    }
                    exports.DehydrationManager = DehydrationManager;
                }).call(this);
            }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, require("buffer").Buffer);
        }, { "../crypto/store/indexeddb-crypto-store": 80, "../logger": 97, "./aes": 68, "./olmlib": 77, "another-json": 28, "buffer": 34 }], 74: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.DeviceInfo = DeviceInfo;
            function DeviceInfo(deviceId) {
                Object.defineProperty(this, 'deviceId', {
                    enumerable: true,
                    value: deviceId
                });
                this.algorithms = [];
                this.keys = {};
                this.verified = DeviceVerification.UNVERIFIED;
                this.known = false;
                this.unsigned = {};
                this.signatures = {};
            }
            DeviceInfo.fromStorage = function (obj, deviceId) {
                var res = new DeviceInfo(deviceId);
                for (var prop in obj) {
                    if (obj.hasOwnProperty(prop)) {
                        res[prop] = obj[prop];
                    }
                }
                return res;
            };
            DeviceInfo.prototype.toStorage = function () {
                return {
                    algorithms: this.algorithms,
                    keys: this.keys,
                    verified: this.verified,
                    known: this.known,
                    unsigned: this.unsigned,
                    signatures: this.signatures
                };
            };
            DeviceInfo.prototype.getFingerprint = function () {
                return this.keys["ed25519:" + this.deviceId];
            };
            DeviceInfo.prototype.getIdentityKey = function () {
                return this.keys["curve25519:" + this.deviceId];
            };
            DeviceInfo.prototype.getDisplayName = function () {
                return this.unsigned.device_display_name || null;
            };
            DeviceInfo.prototype.isBlocked = function () {
                return this.verified == DeviceVerification.BLOCKED;
            };
            DeviceInfo.prototype.isVerified = function () {
                return this.verified == DeviceVerification.VERIFIED;
            };
            DeviceInfo.prototype.isUnverified = function () {
                return this.verified == DeviceVerification.UNVERIFIED;
            };
            DeviceInfo.prototype.isKnown = function () {
                return this.known == true;
            };
            DeviceInfo.DeviceVerification = {
                VERIFIED: 1,
                UNVERIFIED: 0,
                BLOCKED: -1
            };
            var DeviceVerification = DeviceInfo.DeviceVerification;
        }, {}], 75: [function (require, module, exports) {
            (function (global, Buffer) {
                (function () {
                    "use strict";
                    var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
                    var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
                    Object.defineProperty(exports, "__esModule", {
                        value: true
                    });
                    exports.isCryptoAvailable = isCryptoAvailable;
                    exports.Crypto = Crypto;
                    exports.fixBackupKey = fixBackupKey;
                    exports.verificationMethods = void 0;
                    var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
                    var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
                    var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
                    var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
                    var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
                    var _anotherJson = _interopRequireDefault(require("another-json"));
                    var _events = require("events");
                    var _ReEmitter = require("../ReEmitter");
                    var _logger = require("../logger");
                    var utils = _interopRequireWildcard(require("../utils"));
                    var _OlmDevice = require("./OlmDevice");
                    var olmlib = _interopRequireWildcard(require("./olmlib"));
                    var _DeviceList = require("./DeviceList");
                    var _deviceinfo = require("./deviceinfo");
                    var algorithms = _interopRequireWildcard(require("./algorithms"));
                    var _CrossSigning = require("./CrossSigning");
                    var _EncryptionSetup = require("./EncryptionSetup");
                    var _SecretStorage = require("./SecretStorage");
                    var _OutgoingRoomKeyRequestManager = require("./OutgoingRoomKeyRequestManager");
                    var _indexeddbCryptoStore = require("./store/indexeddb-crypto-store");
                    var _QRCode = require("./verification/QRCode");
                    var _SAS = require("./verification/SAS");
                    var _key_passphrase = require("./key_passphrase");
                    var _recoverykey = require("./recoverykey");
                    var _VerificationRequest = require("./verification/request/VerificationRequest");
                    var _InRoomChannel = require("./verification/request/InRoomChannel");
                    var _ToDeviceChannel = require("./verification/request/ToDeviceChannel");
                    var _IllegalMethod = require("./verification/IllegalMethod");
                    var _errors = require("../errors");
                    var _aes = require("./aes");
                    var _dehydration = require("./dehydration");
                    var _event = require("../models/event");
                    var _defaultVerificationM;
                    function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
                        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                            if (it)
                                o = it;
                            var i = 0;
                            var F = function F() { };
                            return { s: F, n: function n() { if (i >= o.length)
                                    return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F };
                        }
                        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                    } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try {
                            if (!normalCompletion && it["return"] != null)
                                it["return"]();
                        }
                        finally {
                            if (didErr)
                                throw err;
                        } } }; }
                    function _unsupportedIterableToArray(o, minLen) { if (!o)
                        return; if (typeof o === "string")
                        return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor)
                        n = o.constructor.name; if (n === "Map" || n === "Set")
                        return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                        return _arrayLikeToArray(o, minLen); }
                    function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length)
                        len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) {
                        arr2[i] = arr[i];
                    } return arr2; }
                    var DeviceVerification = _deviceinfo.DeviceInfo.DeviceVerification;
                    var defaultVerificationMethods = (_defaultVerificationM = {}, (0, _defineProperty2["default"])(_defaultVerificationM, _QRCode.ReciprocateQRCode.NAME, _QRCode.ReciprocateQRCode), (0, _defineProperty2["default"])(_defaultVerificationM, _SAS.SAS.NAME, _SAS.SAS), (0, _defineProperty2["default"])(_defaultVerificationM, _QRCode.SHOW_QR_CODE_METHOD, _IllegalMethod.IllegalMethod), (0, _defineProperty2["default"])(_defaultVerificationM, _QRCode.SCAN_QR_CODE_METHOD, _IllegalMethod.IllegalMethod), _defaultVerificationM);
                    var verificationMethods = {
                        RECIPROCATE_QR_CODE: _QRCode.ReciprocateQRCode.NAME,
                        SAS: _SAS.SAS.NAME
                    };
                    exports.verificationMethods = verificationMethods;
                    function isCryptoAvailable() {
                        return Boolean(global.Olm);
                    }
                    var MIN_FORCE_SESSION_INTERVAL_MS = 60 * 60 * 1000;
                    var KEY_BACKUP_KEYS_PER_REQUEST = 200;
                    function Crypto(baseApis, sessionStore, userId, deviceId, clientStore, cryptoStore, roomList, verificationMethods) {
                        var _this = this;
                        this._onDeviceListUserCrossSigningUpdated = this._onDeviceListUserCrossSigningUpdated.bind(this);
                        this._trustCrossSignedDevices = true;
                        this._reEmitter = new _ReEmitter.ReEmitter(this);
                        this._baseApis = baseApis;
                        this._sessionStore = sessionStore;
                        this._userId = userId;
                        this._deviceId = deviceId;
                        this._clientStore = clientStore;
                        this._cryptoStore = cryptoStore;
                        this._roomList = roomList;
                        if (verificationMethods) {
                            this._verificationMethods = new Map();
                            var _iterator = _createForOfIteratorHelper(verificationMethods), _step;
                            try {
                                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                                    var method = _step.value;
                                    if (typeof method === "string") {
                                        if (defaultVerificationMethods[method]) {
                                            this._verificationMethods.set(method, defaultVerificationMethods[method]);
                                        }
                                    }
                                    else if (method.NAME) {
                                        this._verificationMethods.set(method.NAME, method);
                                    }
                                    else {
                                        _logger.logger.warn("Excluding unknown verification method ".concat(method));
                                    }
                                }
                            }
                            catch (err) {
                                _iterator.e(err);
                            }
                            finally {
                                _iterator.f();
                            }
                        }
                        else {
                            this._verificationMethods = defaultVerificationMethods;
                        }
                        this.backupInfo = null;
                        this.backupKey = null;
                        this._checkedForBackup = false;
                        this._sendingBackups = false;
                        this._olmDevice = new _OlmDevice.OlmDevice(cryptoStore);
                        this._deviceList = new _DeviceList.DeviceList(baseApis, cryptoStore, this._olmDevice);
                        this._deviceList.on('userCrossSigningUpdated', this._onDeviceListUserCrossSigningUpdated);
                        this._reEmitter.reEmit(this._deviceList, ["crypto.devicesUpdated", "crypto.willUpdateDevices"]);
                        this._lastOneTimeKeyCheck = null;
                        this._oneTimeKeyCheckInProgress = false;
                        this._roomEncryptors = {};
                        this._roomDecryptors = {};
                        this._supportedAlgorithms = utils.keys(algorithms.DECRYPTION_CLASSES);
                        this._deviceKeys = {};
                        this._globalBlacklistUnverifiedDevices = false;
                        this._globalErrorOnUnknownDevices = true;
                        this._outgoingRoomKeyRequestManager = new _OutgoingRoomKeyRequestManager.OutgoingRoomKeyRequestManager(baseApis, this._deviceId, this._cryptoStore);
                        this._receivedRoomKeyRequests = [];
                        this._receivedRoomKeyRequestCancellations = [];
                        this._processingRoomKeyRequests = false;
                        this._lazyLoadMembers = false;
                        this._roomDeviceTrackingState = {};
                        this._lastNewSessionForced = {};
                        this._toDeviceVerificationRequests = new _ToDeviceChannel.ToDeviceRequests();
                        this._inRoomVerificationRequests = new _InRoomChannel.InRoomRequests();
                        this._sendKeyRequestsImmediately = false;
                        var cryptoCallbacks = this._baseApis._cryptoCallbacks || {};
                        var cacheCallbacks = (0, _CrossSigning.createCryptoStoreCacheCallbacks)(cryptoStore, this._olmDevice);
                        this._crossSigningInfo = new _CrossSigning.CrossSigningInfo(userId, cryptoCallbacks, cacheCallbacks);
                        this._secretStorage = new _SecretStorage.SecretStorage(baseApis, cryptoCallbacks);
                        this._dehydrationManager = new _dehydration.DehydrationManager(this);
                        if (!cryptoCallbacks.getCrossSigningKey && cryptoCallbacks.getSecretStorageKey) {
                            cryptoCallbacks.getCrossSigningKey = function () {
                                var _ref = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee(type) {
                                    return _regenerator["default"].wrap(function _callee$(_context) {
                                        while (1) {
                                            switch (_context.prev = _context.next) {
                                                case 0:
                                                    return _context.abrupt("return", _CrossSigning.CrossSigningInfo.getFromSecretStorage(type, _this._secretStorage));
                                                case 1:
                                                case "end":
                                                    return _context.stop();
                                            }
                                        }
                                    }, _callee);
                                }));
                                return function (_x) {
                                    return _ref.apply(this, arguments);
                                };
                            }();
                        }
                    }
                    utils.inherits(Crypto, _events.EventEmitter);
                    Crypto.prototype.init = function () {
                        var _ref2 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee2(opts) {
                            var _this2 = this;
                            var _ref3, exportedOlmDevice, pickleKey, myDevices, deviceInfo;
                            return _regenerator["default"].wrap(function _callee2$(_context2) {
                                while (1) {
                                    switch (_context2.prev = _context2.next) {
                                        case 0:
                                            _ref3 = opts || {}, exportedOlmDevice = _ref3.exportedOlmDevice, pickleKey = _ref3.pickleKey;
                                            _logger.logger.log("Crypto: initialising Olm...");
                                            _context2.next = 4;
                                            return global.Olm.init();
                                        case 4:
                                            _logger.logger.log(exportedOlmDevice ? "Crypto: initialising Olm device from exported device..." : "Crypto: initialising Olm device...");
                                            _context2.next = 7;
                                            return this._olmDevice.init({
                                                fromExportedDevice: exportedOlmDevice,
                                                pickleKey: pickleKey
                                            });
                                        case 7:
                                            _logger.logger.log("Crypto: loading device list...");
                                            _context2.next = 10;
                                            return this._deviceList.load();
                                        case 10:
                                            this._deviceKeys["ed25519:" + this._deviceId] = this._olmDevice.deviceEd25519Key;
                                            this._deviceKeys["curve25519:" + this._deviceId] = this._olmDevice.deviceCurve25519Key;
                                            _logger.logger.log("Crypto: fetching own devices...");
                                            myDevices = this._deviceList.getRawStoredDevicesForUser(this._userId);
                                            if (!myDevices) {
                                                myDevices = {};
                                            }
                                            if (!myDevices[this._deviceId]) {
                                                _logger.logger.log("Crypto: adding this device to the store...");
                                                deviceInfo = {
                                                    keys: this._deviceKeys,
                                                    algorithms: this._supportedAlgorithms,
                                                    verified: DeviceVerification.VERIFIED,
                                                    known: true
                                                };
                                                myDevices[this._deviceId] = deviceInfo;
                                                this._deviceList.storeDevicesForUser(this._userId, myDevices);
                                                this._deviceList.saveIfDirty();
                                            }
                                            _context2.next = 18;
                                            return this._cryptoStore.doTxn('readonly', [_indexeddbCryptoStore.IndexedDBCryptoStore.STORE_ACCOUNT], function (txn) {
                                                _this2._cryptoStore.getCrossSigningKeys(txn, function (keys) {
                                                    if (keys && Object.keys(keys).length !== 0) {
                                                        _logger.logger.log("Loaded cross-signing public keys from crypto store");
                                                        _this2._crossSigningInfo.setKeys(keys);
                                                    }
                                                });
                                            });
                                        case 18:
                                            this._deviceList.startTrackingDeviceList(this._userId);
                                            _logger.logger.log("Crypto: checking for key backup...");
                                            this._checkAndStartKeyBackup();
                                        case 21:
                                        case "end":
                                            return _context2.stop();
                                    }
                                }
                            }, _callee2, this);
                        }));
                        return function (_x2) {
                            return _ref2.apply(this, arguments);
                        };
                    }();
                    Crypto.prototype.getCryptoTrustCrossSignedDevices = function () {
                        return this._trustCrossSignedDevices;
                    };
                    Crypto.prototype.setCryptoTrustCrossSignedDevices = function (val) {
                        this._trustCrossSignedDevices = val;
                        var _iterator2 = _createForOfIteratorHelper(this._deviceList.getKnownUserIds()), _step2;
                        try {
                            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                                var userId = _step2.value;
                                var devices = this._deviceList.getRawStoredDevicesForUser(userId);
                                for (var _i = 0, _Object$keys = Object.keys(devices); _i < _Object$keys.length; _i++) {
                                    var deviceId = _Object$keys[_i];
                                    var deviceTrust = this.checkDeviceTrust(userId, deviceId);
                                    if (!deviceTrust.isLocallyVerified() && deviceTrust.isCrossSigningVerified()) {
                                        var deviceObj = this._deviceList.getStoredDevice(userId, deviceId);
                                        this.emit("deviceVerificationChanged", userId, deviceId, deviceObj);
                                    }
                                }
                            }
                        }
                        catch (err) {
                            _iterator2.e(err);
                        }
                        finally {
                            _iterator2.f();
                        }
                    };
                    Crypto.prototype.createRecoveryKeyFromPassphrase = function () {
                        var _ref4 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee3(password) {
                            var decryption, keyInfo, derivation, privateKey, encodedPrivateKey;
                            return _regenerator["default"].wrap(function _callee3$(_context3) {
                                while (1) {
                                    switch (_context3.prev = _context3.next) {
                                        case 0:
                                            decryption = new global.Olm.PkDecryption();
                                            _context3.prev = 1;
                                            keyInfo = {};
                                            if (!password) {
                                                _context3.next = 11;
                                                break;
                                            }
                                            _context3.next = 6;
                                            return (0, _key_passphrase.keyFromPassphrase)(password);
                                        case 6:
                                            derivation = _context3.sent;
                                            keyInfo.passphrase = {
                                                algorithm: "m.pbkdf2",
                                                iterations: derivation.iterations,
                                                salt: derivation.salt
                                            };
                                            keyInfo.pubkey = decryption.init_with_private_key(derivation.key);
                                            _context3.next = 12;
                                            break;
                                        case 11:
                                            keyInfo.pubkey = decryption.generate_key();
                                        case 12:
                                            privateKey = decryption.get_private_key();
                                            encodedPrivateKey = (0, _recoverykey.encodeRecoveryKey)(privateKey);
                                            return _context3.abrupt("return", {
                                                keyInfo: keyInfo,
                                                encodedPrivateKey: encodedPrivateKey,
                                                privateKey: privateKey
                                            });
                                        case 15:
                                            _context3.prev = 15;
                                            if (decryption)
                                                decryption.free();
                                            return _context3.finish(15);
                                        case 18:
                                        case "end":
                                            return _context3.stop();
                                    }
                                }
                            }, _callee3, null, [[1, , 15, 18]]);
                        }));
                        return function (_x3) {
                            return _ref4.apply(this, arguments);
                        };
                    }();
                    Crypto.prototype.isCrossSigningReady = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee4() {
                        var publicKeysOnDevice, privateKeysExistSomewhere;
                        return _regenerator["default"].wrap(function _callee4$(_context4) {
                            while (1) {
                                switch (_context4.prev = _context4.next) {
                                    case 0:
                                        publicKeysOnDevice = this._crossSigningInfo.getId();
                                        _context4.next = 3;
                                        return this._crossSigningInfo.isStoredInKeyCache();
                                    case 3:
                                        _context4.t0 = _context4.sent;
                                        if (_context4.t0) {
                                            _context4.next = 8;
                                            break;
                                        }
                                        _context4.next = 7;
                                        return this._crossSigningInfo.isStoredInSecretStorage(this._secretStorage);
                                    case 7:
                                        _context4.t0 = _context4.sent;
                                    case 8:
                                        privateKeysExistSomewhere = _context4.t0;
                                        return _context4.abrupt("return", !!(publicKeysOnDevice && privateKeysExistSomewhere));
                                    case 10:
                                    case "end":
                                        return _context4.stop();
                                }
                            }
                        }, _callee4, this);
                    }));
                    Crypto.prototype.isSecretStorageReady = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee5() {
                        var secretStorageKeyInAccount, privateKeysInStorage, sessionBackupInStorage;
                        return _regenerator["default"].wrap(function _callee5$(_context5) {
                            while (1) {
                                switch (_context5.prev = _context5.next) {
                                    case 0:
                                        _context5.next = 2;
                                        return this._secretStorage.hasKey();
                                    case 2:
                                        secretStorageKeyInAccount = _context5.sent;
                                        _context5.next = 5;
                                        return this._crossSigningInfo.isStoredInSecretStorage(this._secretStorage);
                                    case 5:
                                        privateKeysInStorage = _context5.sent;
                                        sessionBackupInStorage = !this._baseApis.getKeyBackupEnabled() || this._baseApis.isKeyBackupKeyStored();
                                        return _context5.abrupt("return", !!(secretStorageKeyInAccount && privateKeysInStorage && sessionBackupInStorage));
                                    case 8:
                                    case "end":
                                        return _context5.stop();
                                }
                            }
                        }, _callee5, this);
                    }));
                    Crypto.prototype.bootstrapCrossSigning = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee7() {
                        var _this3 = this;
                        var _ref8, authUploadDeviceSigningKeys, setupNewCrossSigning, delegateCryptoCallbacks, builder, crossSigningInfo, resetCrossSigning, publicKeysOnDevice, privateKeysInCache, privateKeysInStorage, privateKeysExistSomewhere, crossSigningPrivateKeys, secretStorage, operation, _args7 = arguments;
                        return _regenerator["default"].wrap(function _callee7$(_context7) {
                            while (1) {
                                switch (_context7.prev = _context7.next) {
                                    case 0:
                                        _ref8 = _args7.length > 0 && _args7[0] !== undefined ? _args7[0] : {}, authUploadDeviceSigningKeys = _ref8.authUploadDeviceSigningKeys, setupNewCrossSigning = _ref8.setupNewCrossSigning;
                                        _logger.logger.log("Bootstrapping cross-signing");
                                        delegateCryptoCallbacks = this._baseApis._cryptoCallbacks;
                                        builder = new _EncryptionSetup.EncryptionSetupBuilder(this._baseApis.store.accountData, delegateCryptoCallbacks);
                                        crossSigningInfo = new _CrossSigning.CrossSigningInfo(this._userId, builder.crossSigningCallbacks, builder.crossSigningCallbacks);
                                        resetCrossSigning = function () {
                                            var _ref9 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee6() {
                                                var device, deviceSignature;
                                                return _regenerator["default"].wrap(function _callee6$(_context6) {
                                                    while (1) {
                                                        switch (_context6.prev = _context6.next) {
                                                            case 0:
                                                                crossSigningInfo.resetKeys();
                                                                _context6.next = 3;
                                                                return _this3._signObject(crossSigningInfo.keys.master);
                                                            case 3:
                                                                builder.addCrossSigningKeys(authUploadDeviceSigningKeys, crossSigningInfo.keys);
                                                                device = _this3._deviceList.getStoredDevice(_this3._userId, _this3._deviceId);
                                                                _context6.next = 7;
                                                                return crossSigningInfo.signDevice(_this3._userId, device);
                                                            case 7:
                                                                deviceSignature = _context6.sent;
                                                                builder.addKeySignature(_this3._userId, _this3._deviceId, deviceSignature);
                                                                if (!_this3.backupInfo) {
                                                                    _context6.next = 13;
                                                                    break;
                                                                }
                                                                _context6.next = 12;
                                                                return crossSigningInfo.signObject(_this3.backupInfo.auth_data, "master");
                                                            case 12:
                                                                builder.addSessionBackup(_this3.backupInfo);
                                                            case 13:
                                                            case "end":
                                                                return _context6.stop();
                                                        }
                                                    }
                                                }, _callee6);
                                            }));
                                            return function resetCrossSigning() {
                                                return _ref9.apply(this, arguments);
                                            };
                                        }();
                                        publicKeysOnDevice = this._crossSigningInfo.getId();
                                        _context7.next = 9;
                                        return this._crossSigningInfo.isStoredInKeyCache();
                                    case 9:
                                        privateKeysInCache = _context7.sent;
                                        _context7.next = 12;
                                        return this._crossSigningInfo.isStoredInSecretStorage(this._secretStorage);
                                    case 12:
                                        privateKeysInStorage = _context7.sent;
                                        privateKeysExistSomewhere = privateKeysInCache || privateKeysInStorage;
                                        _logger.logger.log({
                                            setupNewCrossSigning: setupNewCrossSigning,
                                            publicKeysOnDevice: publicKeysOnDevice,
                                            privateKeysInCache: privateKeysInCache,
                                            privateKeysInStorage: privateKeysInStorage,
                                            privateKeysExistSomewhere: privateKeysExistSomewhere
                                        });
                                        if (!(!privateKeysExistSomewhere || setupNewCrossSigning)) {
                                            _context7.next = 21;
                                            break;
                                        }
                                        _logger.logger.log("Cross-signing private keys not found locally or in secret storage, " + "creating new keys");
                                        _context7.next = 19;
                                        return resetCrossSigning();
                                    case 19:
                                        _context7.next = 29;
                                        break;
                                    case 21:
                                        if (!(publicKeysOnDevice && privateKeysInCache)) {
                                            _context7.next = 25;
                                            break;
                                        }
                                        _logger.logger.log("Cross-signing public keys trusted and private keys found locally");
                                        _context7.next = 29;
                                        break;
                                    case 25:
                                        if (!privateKeysInStorage) {
                                            _context7.next = 29;
                                            break;
                                        }
                                        _logger.logger.log("Cross-signing private keys not found locally, but they are available " + "in secret storage, reading storage and caching locally");
                                        _context7.next = 29;
                                        return this.checkOwnCrossSigningTrust();
                                    case 29:
                                        crossSigningPrivateKeys = builder.crossSigningCallbacks.privateKeys;
                                        if (!(crossSigningPrivateKeys.size && !this._baseApis._cryptoCallbacks.saveCrossSigningKeys)) {
                                            _context7.next = 38;
                                            break;
                                        }
                                        secretStorage = new _SecretStorage.SecretStorage(builder.accountDataClientAdapter, builder.ssssCryptoCallbacks);
                                        _context7.next = 34;
                                        return secretStorage.hasKey();
                                    case 34:
                                        if (!_context7.sent) {
                                            _context7.next = 38;
                                            break;
                                        }
                                        _logger.logger.log("Storing new cross-signing private keys in secret storage");
                                        _context7.next = 38;
                                        return _CrossSigning.CrossSigningInfo.storeInSecretStorage(crossSigningPrivateKeys, secretStorage);
                                    case 38:
                                        operation = builder.buildOperation();
                                        _context7.next = 41;
                                        return operation.apply(this);
                                    case 41:
                                        _context7.next = 43;
                                        return builder.persist(this);
                                    case 43:
                                        _logger.logger.log("Cross-signing ready");
                                    case 44:
                                    case "end":
                                        return _context7.stop();
                                }
                            }
                        }, _callee7, this);
                    }));
                    Crypto.prototype.bootstrapSecretStorage = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee12() {
                        var _this4 = this;
                        var _ref11, _ref11$createSecretSt, createSecretStorageKey, keyBackupInfo, setupNewKeyBackup, setupNewSecretStorage, getKeyBackupPassphrase, delegateCryptoCallbacks, builder, secretStorage, newKeyId, createSSSS, ensureCanCheckPassphrase, signKeyBackupWithCrossSigning, oldSSSSKey, _ref16, _ref17, oldKeyId, oldKeyInfo, storageExists, _yield$createSecretSt, keyInfo, privateKey, backupKey, opts, crossSigningPrivateKeys, info, _privateKey, data, sessionBackupKey, fixedBackupKey, decodedBackupKey, operation, _args12 = arguments;
                        return _regenerator["default"].wrap(function _callee12$(_context12) {
                            while (1) {
                                switch (_context12.prev = _context12.next) {
                                    case 0:
                                        _ref11 = _args12.length > 0 && _args12[0] !== undefined ? _args12[0] : {}, _ref11$createSecretSt = _ref11.createSecretStorageKey, createSecretStorageKey = _ref11$createSecretSt === void 0 ? (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee8() {
                                            return _regenerator["default"].wrap(function _callee8$(_context8) {
                                                while (1) {
                                                    switch (_context8.prev = _context8.next) {
                                                        case 0:
                                                            return _context8.abrupt("return", {});
                                                        case 1:
                                                        case "end":
                                                            return _context8.stop();
                                                    }
                                                }
                                            }, _callee8);
                                        })) : _ref11$createSecretSt, keyBackupInfo = _ref11.keyBackupInfo, setupNewKeyBackup = _ref11.setupNewKeyBackup, setupNewSecretStorage = _ref11.setupNewSecretStorage, getKeyBackupPassphrase = _ref11.getKeyBackupPassphrase;
                                        _logger.logger.log("Bootstrapping Secure Secret Storage");
                                        delegateCryptoCallbacks = this._baseApis._cryptoCallbacks;
                                        builder = new _EncryptionSetup.EncryptionSetupBuilder(this._baseApis.store.accountData, delegateCryptoCallbacks);
                                        secretStorage = new _SecretStorage.SecretStorage(builder.accountDataClientAdapter, builder.ssssCryptoCallbacks);
                                        newKeyId = null;
                                        createSSSS = function () {
                                            var _ref13 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee9(opts, privateKey) {
                                                var _yield$secretStorage$, keyId, keyInfo;
                                                return _regenerator["default"].wrap(function _callee9$(_context9) {
                                                    while (1) {
                                                        switch (_context9.prev = _context9.next) {
                                                            case 0:
                                                                opts = opts || {};
                                                                if (privateKey) {
                                                                    opts.key = privateKey;
                                                                }
                                                                _context9.next = 4;
                                                                return secretStorage.addKey(_SecretStorage.SECRET_STORAGE_ALGORITHM_V1_AES, opts);
                                                            case 4:
                                                                _yield$secretStorage$ = _context9.sent;
                                                                keyId = _yield$secretStorage$.keyId;
                                                                keyInfo = _yield$secretStorage$.keyInfo;
                                                                if (privateKey) {
                                                                    builder.ssssCryptoCallbacks.addPrivateKey(keyId, keyInfo, privateKey);
                                                                }
                                                                _context9.next = 10;
                                                                return secretStorage.setDefaultKeyId(keyId);
                                                            case 10:
                                                                return _context9.abrupt("return", keyId);
                                                            case 11:
                                                            case "end":
                                                                return _context9.stop();
                                                        }
                                                    }
                                                }, _callee9);
                                            }));
                                            return function createSSSS(_x4, _x5) {
                                                return _ref13.apply(this, arguments);
                                            };
                                        }();
                                        ensureCanCheckPassphrase = function () {
                                            var _ref14 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee10(keyId, keyInfo) {
                                                var key, privateKey, _yield$SecretStorage$, iv, mac;
                                                return _regenerator["default"].wrap(function _callee10$(_context10) {
                                                    while (1) {
                                                        switch (_context10.prev = _context10.next) {
                                                            case 0:
                                                                if (keyInfo.mac) {
                                                                    _context10.next = 16;
                                                                    break;
                                                                }
                                                                _context10.next = 3;
                                                                return _this4._baseApis._cryptoCallbacks.getSecretStorageKey({
                                                                    keys: (0, _defineProperty2["default"])({}, keyId, keyInfo)
                                                                }, "");
                                                            case 3:
                                                                key = _context10.sent;
                                                                if (!key) {
                                                                    _context10.next = 16;
                                                                    break;
                                                                }
                                                                privateKey = key[1];
                                                                builder.ssssCryptoCallbacks.addPrivateKey(keyId, keyInfo, privateKey);
                                                                _context10.next = 9;
                                                                return _SecretStorage.SecretStorage._calculateKeyCheck(privateKey);
                                                            case 9:
                                                                _yield$SecretStorage$ = _context10.sent;
                                                                iv = _yield$SecretStorage$.iv;
                                                                mac = _yield$SecretStorage$.mac;
                                                                keyInfo.iv = iv;
                                                                keyInfo.mac = mac;
                                                                _context10.next = 16;
                                                                return builder.setAccountData("m.secret_storage.key.".concat(keyId), keyInfo);
                                                            case 16:
                                                            case "end":
                                                                return _context10.stop();
                                                        }
                                                    }
                                                }, _callee10);
                                            }));
                                            return function ensureCanCheckPassphrase(_x6, _x7) {
                                                return _ref14.apply(this, arguments);
                                            };
                                        }();
                                        signKeyBackupWithCrossSigning = function () {
                                            var _ref15 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee11(keyBackupAuthData) {
                                                return _regenerator["default"].wrap(function _callee11$(_context11) {
                                                    while (1) {
                                                        switch (_context11.prev = _context11.next) {
                                                            case 0:
                                                                _context11.t0 = _this4._crossSigningInfo.getId();
                                                                if (!_context11.t0) {
                                                                    _context11.next = 5;
                                                                    break;
                                                                }
                                                                _context11.next = 4;
                                                                return _this4._crossSigningInfo.isStoredInKeyCache("master");
                                                            case 4:
                                                                _context11.t0 = _context11.sent;
                                                            case 5:
                                                                if (!_context11.t0) {
                                                                    _context11.next = 17;
                                                                    break;
                                                                }
                                                                _context11.prev = 6;
                                                                _logger.logger.log("Adding cross-signing signature to key backup");
                                                                _context11.next = 10;
                                                                return _this4._crossSigningInfo.signObject(keyBackupAuthData, "master");
                                                            case 10:
                                                                _context11.next = 15;
                                                                break;
                                                            case 12:
                                                                _context11.prev = 12;
                                                                _context11.t1 = _context11["catch"](6);
                                                                _logger.logger.error("Signing key backup with cross-signing keys failed", _context11.t1);
                                                            case 15:
                                                                _context11.next = 18;
                                                                break;
                                                            case 17:
                                                                _logger.logger.warn("Cross-signing keys not available, skipping signature on key backup");
                                                            case 18:
                                                            case "end":
                                                                return _context11.stop();
                                                        }
                                                    }
                                                }, _callee11, null, [[6, 12]]);
                                            }));
                                            return function signKeyBackupWithCrossSigning(_x8) {
                                                return _ref15.apply(this, arguments);
                                            };
                                        }();
                                        _context12.next = 11;
                                        return this.getSecretStorageKey();
                                    case 11:
                                        oldSSSSKey = _context12.sent;
                                        _ref16 = oldSSSSKey || [null, null], _ref17 = (0, _slicedToArray2["default"])(_ref16, 2), oldKeyId = _ref17[0], oldKeyInfo = _ref17[1];
                                        storageExists = !setupNewSecretStorage && oldKeyInfo && oldKeyInfo.algorithm === _SecretStorage.SECRET_STORAGE_ALGORITHM_V1_AES;
                                        _logger.logger.log({
                                            keyBackupInfo: keyBackupInfo,
                                            setupNewKeyBackup: setupNewKeyBackup,
                                            setupNewSecretStorage: setupNewSecretStorage,
                                            storageExists: storageExists,
                                            oldKeyInfo: oldKeyInfo
                                        });
                                        if (!(!storageExists && !keyBackupInfo)) {
                                            _context12.next = 27;
                                            break;
                                        }
                                        _logger.logger.log("Secret storage does not exist, creating new storage key");
                                        _context12.next = 19;
                                        return createSecretStorageKey();
                                    case 19:
                                        _yield$createSecretSt = _context12.sent;
                                        keyInfo = _yield$createSecretSt.keyInfo;
                                        privateKey = _yield$createSecretSt.privateKey;
                                        _context12.next = 24;
                                        return createSSSS(keyInfo, privateKey);
                                    case 24:
                                        newKeyId = _context12.sent;
                                        _context12.next = 53;
                                        break;
                                    case 27:
                                        if (!(!storageExists && keyBackupInfo)) {
                                            _context12.next = 49;
                                            break;
                                        }
                                        _logger.logger.log("Secret storage does not exist, using key backup key");
                                        _context12.next = 31;
                                        return this.getSessionBackupPrivateKey();
                                    case 31:
                                        _context12.t0 = _context12.sent;
                                        if (_context12.t0) {
                                            _context12.next = 36;
                                            break;
                                        }
                                        _context12.next = 35;
                                        return getKeyBackupPassphrase();
                                    case 35:
                                        _context12.t0 = _context12.sent;
                                    case 36:
                                        backupKey = _context12.t0;
                                        opts = {};
                                        if (keyBackupInfo.auth_data.private_key_salt && keyBackupInfo.auth_data.private_key_iterations) {
                                            opts.passphrase = {
                                                algorithm: "m.pbkdf2",
                                                iterations: keyBackupInfo.auth_data.private_key_iterations,
                                                salt: keyBackupInfo.auth_data.private_key_salt,
                                                bits: 256
                                            };
                                        }
                                        _context12.next = 41;
                                        return createSSSS(opts, backupKey);
                                    case 41:
                                        newKeyId = _context12.sent;
                                        _context12.next = 44;
                                        return secretStorage.store("m.megolm_backup.v1", olmlib.encodeBase64(backupKey), [newKeyId]);
                                    case 44:
                                        _context12.next = 46;
                                        return signKeyBackupWithCrossSigning(keyBackupInfo.auth_data);
                                    case 46:
                                        builder.addSessionBackup(keyBackupInfo);
                                        _context12.next = 53;
                                        break;
                                    case 49:
                                        _logger.logger.log("Secret storage exists");
                                        if (!(oldKeyInfo && oldKeyInfo.algorithm === _SecretStorage.SECRET_STORAGE_ALGORITHM_V1_AES)) {
                                            _context12.next = 53;
                                            break;
                                        }
                                        _context12.next = 53;
                                        return ensureCanCheckPassphrase(oldKeyId, oldKeyInfo);
                                    case 53:
                                        _context12.t2 = !this._baseApis._cryptoCallbacks.saveCrossSigningKeys;
                                        if (!_context12.t2) {
                                            _context12.next = 58;
                                            break;
                                        }
                                        _context12.next = 57;
                                        return this.isCrossSigningReady();
                                    case 57:
                                        _context12.t2 = _context12.sent;
                                    case 58:
                                        _context12.t1 = _context12.t2;
                                        if (!_context12.t1) {
                                            _context12.next = 66;
                                            break;
                                        }
                                        _context12.t3 = newKeyId;
                                        if (_context12.t3) {
                                            _context12.next = 65;
                                            break;
                                        }
                                        _context12.next = 64;
                                        return this._crossSigningInfo.isStoredInSecretStorage(secretStorage);
                                    case 64:
                                        _context12.t3 = !_context12.sent;
                                    case 65:
                                        _context12.t1 = _context12.t3;
                                    case 66:
                                        if (!_context12.t1) {
                                            _context12.next = 73;
                                            break;
                                        }
                                        _logger.logger.log("Copying cross-signing private keys from cache to secret storage");
                                        _context12.next = 70;
                                        return this._crossSigningInfo.getCrossSigningKeysFromCache();
                                    case 70:
                                        crossSigningPrivateKeys = _context12.sent;
                                        _context12.next = 73;
                                        return _CrossSigning.CrossSigningInfo.storeInSecretStorage(crossSigningPrivateKeys, secretStorage);
                                    case 73:
                                        if (!(setupNewKeyBackup && !keyBackupInfo)) {
                                            _context12.next = 87;
                                            break;
                                        }
                                        _logger.logger.log("Creating new message key backup version");
                                        _context12.next = 77;
                                        return this._baseApis.prepareKeyBackupVersion(null, {
                                            secureSecretStorage: false
                                        });
                                    case 77:
                                        info = _context12.sent;
                                        _privateKey = (0, _recoverykey.decodeRecoveryKey)(info.recovery_key);
                                        _context12.next = 81;
                                        return secretStorage.store("m.megolm_backup.v1", olmlib.encodeBase64(_privateKey));
                                    case 81:
                                        data = {
                                            algorithm: info.algorithm,
                                            auth_data: info.auth_data
                                        };
                                        _context12.next = 84;
                                        return signKeyBackupWithCrossSigning(data.auth_data);
                                    case 84:
                                        _context12.next = 86;
                                        return this._signObject(data.auth_data);
                                    case 86:
                                        builder.addSessionBackup(data);
                                    case 87:
                                        _context12.next = 89;
                                        return secretStorage.get('m.megolm_backup.v1');
                                    case 89:
                                        sessionBackupKey = _context12.sent;
                                        if (!sessionBackupKey) {
                                            _context12.next = 99;
                                            break;
                                        }
                                        _logger.logger.info("Got session backup key from secret storage: caching");
                                        fixedBackupKey = fixBackupKey(sessionBackupKey);
                                        if (!fixedBackupKey) {
                                            _context12.next = 96;
                                            break;
                                        }
                                        _context12.next = 96;
                                        return secretStorage.store("m.megolm_backup.v1", fixedBackupKey, [newKeyId || oldKeyId]);
                                    case 96:
                                        decodedBackupKey = new Uint8Array(olmlib.decodeBase64(fixedBackupKey || sessionBackupKey));
                                        _context12.next = 99;
                                        return builder.addSessionBackupPrivateKeyToCache(decodedBackupKey);
                                    case 99:
                                        operation = builder.buildOperation();
                                        _context12.next = 102;
                                        return operation.apply(this);
                                    case 102:
                                        _context12.next = 104;
                                        return builder.persist(this);
                                    case 104:
                                        _logger.logger.log("Secure Secret Storage ready");
                                    case 105:
                                    case "end":
                                        return _context12.stop();
                                }
                            }
                        }, _callee12, this);
                    }));
                    function fixBackupKey(key) {
                        if (typeof key !== "string" || key.indexOf(",") < 0) {
                            return null;
                        }
                        var fixedKey = Uint8Array.from(key.split(","), function (x) {
                            return parseInt(x);
                        });
                        return olmlib.encodeBase64(fixedKey);
                    }
                    Crypto.prototype.addSecretStorageKey = function (algorithm, opts, keyID) {
                        return this._secretStorage.addKey(algorithm, opts, keyID);
                    };
                    Crypto.prototype.hasSecretStorageKey = function (keyID) {
                        return this._secretStorage.hasKey(keyID);
                    };
                    Crypto.prototype.getSecretStorageKey = function (keyID) {
                        return this._secretStorage.getKey(keyID);
                    };
                    Crypto.prototype.storeSecret = function (name, secret, keys) {
                        return this._secretStorage.store(name, secret, keys);
                    };
                    Crypto.prototype.getSecret = function (name) {
                        return this._secretStorage.get(name);
                    };
                    Crypto.prototype.isSecretStored = function (name, checkKey) {
                        return this._secretStorage.isStored(name, checkKey);
                    };
                    Crypto.prototype.requestSecret = function (name, devices) {
                        if (!devices) {
                            devices = Object.keys(this._deviceList.getRawStoredDevicesForUser(this._userId));
                        }
                        return this._secretStorage.request(name, devices);
                    };
                    Crypto.prototype.getDefaultSecretStorageKeyId = function () {
                        return this._secretStorage.getDefaultKeyId();
                    };
                    Crypto.prototype.setDefaultSecretStorageKeyId = function (k) {
                        return this._secretStorage.setDefaultKeyId(k);
                    };
                    Crypto.prototype.checkSecretStorageKey = function (key, info) {
                        return this._secretStorage.checkKey(key, info);
                    };
                    Crypto.prototype.checkSecretStoragePrivateKey = function (privateKey, expectedPublicKey) {
                        var decryption = null;
                        try {
                            decryption = new global.Olm.PkDecryption();
                            var gotPubkey = decryption.init_with_private_key(privateKey);
                            return gotPubkey === expectedPublicKey;
                        }
                        finally {
                            if (decryption)
                                decryption.free();
                        }
                    };
                    Crypto.prototype.getSessionBackupPrivateKey = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee13() {
                        var _this5 = this;
                        var key, pickleKey, decrypted;
                        return _regenerator["default"].wrap(function _callee13$(_context13) {
                            while (1) {
                                switch (_context13.prev = _context13.next) {
                                    case 0:
                                        _context13.next = 2;
                                        return new Promise(function (resolve) {
                                            _this5._cryptoStore.doTxn('readonly', [_indexeddbCryptoStore.IndexedDBCryptoStore.STORE_ACCOUNT], function (txn) {
                                                _this5._cryptoStore.getSecretStorePrivateKey(txn, resolve, "m.megolm_backup.v1");
                                            });
                                        });
                                    case 2:
                                        key = _context13.sent;
                                        if (!(key && typeof key === "string")) {
                                            _context13.next = 7;
                                            break;
                                        }
                                        key = new Uint8Array(olmlib.decodeBase64(fixBackupKey(key) || key));
                                        _context13.next = 7;
                                        return this.storeSessionBackupPrivateKey(key);
                                    case 7:
                                        if (!(key && key.ciphertext)) {
                                            _context13.next = 13;
                                            break;
                                        }
                                        pickleKey = Buffer.from(this._olmDevice._pickleKey);
                                        _context13.next = 11;
                                        return (0, _aes.decryptAES)(key, pickleKey, "m.megolm_backup.v1");
                                    case 11:
                                        decrypted = _context13.sent;
                                        key = olmlib.decodeBase64(decrypted);
                                    case 13:
                                        return _context13.abrupt("return", key);
                                    case 14:
                                    case "end":
                                        return _context13.stop();
                                }
                            }
                        }, _callee13, this);
                    }));
                    Crypto.prototype.storeSessionBackupPrivateKey = function () {
                        var _ref19 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee14(key) {
                            var _this6 = this;
                            var pickleKey;
                            return _regenerator["default"].wrap(function _callee14$(_context14) {
                                while (1) {
                                    switch (_context14.prev = _context14.next) {
                                        case 0:
                                            if (key instanceof Uint8Array) {
                                                _context14.next = 2;
                                                break;
                                            }
                                            throw new Error("storeSessionBackupPrivateKey expects Uint8Array, got ".concat(key));
                                        case 2:
                                            pickleKey = Buffer.from(this._olmDevice._pickleKey);
                                            _context14.next = 5;
                                            return (0, _aes.encryptAES)(olmlib.encodeBase64(key), pickleKey, "m.megolm_backup.v1");
                                        case 5:
                                            key = _context14.sent;
                                            return _context14.abrupt("return", this._cryptoStore.doTxn('readwrite', [_indexeddbCryptoStore.IndexedDBCryptoStore.STORE_ACCOUNT], function (txn) {
                                                _this6._cryptoStore.storeSecretStorePrivateKey(txn, "m.megolm_backup.v1", key);
                                            }));
                                        case 7:
                                        case "end":
                                            return _context14.stop();
                                    }
                                }
                            }, _callee14, this);
                        }));
                        return function (_x9) {
                            return _ref19.apply(this, arguments);
                        };
                    }();
                    Crypto.prototype.checkCrossSigningPrivateKey = function (privateKey, expectedPublicKey) {
                        var signing = null;
                        try {
                            signing = new global.Olm.PkSigning();
                            var gotPubkey = signing.init_with_seed(privateKey);
                            return gotPubkey === expectedPublicKey;
                        }
                        finally {
                            if (signing)
                                signing.free();
                        }
                    };
                    Crypto.prototype._afterCrossSigningLocalKeyChange = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee15() {
                        var _this7 = this;
                        var device, signedDevice, upload, shouldUpgradeCb, users, _i2, _Object$entries, _Object$entries$_i, userId, crossSigningInfo, upgradeInfo, usersToUpgrade, _iterator3, _step3, _userId;
                        return _regenerator["default"].wrap(function _callee15$(_context15) {
                            while (1) {
                                switch (_context15.prev = _context15.next) {
                                    case 0:
                                        _logger.logger.info("Starting cross-signing key change post-processing");
                                        device = this._deviceList.getStoredDevice(this._userId, this._deviceId);
                                        _context15.next = 4;
                                        return this._crossSigningInfo.signDevice(this._userId, device);
                                    case 4:
                                        signedDevice = _context15.sent;
                                        _logger.logger.info("Starting background key sig upload for ".concat(this._deviceId));
                                        upload = function upload(_ref21) {
                                            var shouldEmit = _ref21.shouldEmit;
                                            return _this7._baseApis.uploadKeySignatures((0, _defineProperty2["default"])({}, _this7._userId, (0, _defineProperty2["default"])({}, _this7._deviceId, signedDevice))).then(function (response) {
                                                var _ref22 = response || {}, failures = _ref22.failures;
                                                if (Object.keys(failures || []).length > 0) {
                                                    if (shouldEmit) {
                                                        _this7._baseApis.emit("crypto.keySignatureUploadFailure", failures, "_afterCrossSigningLocalKeyChange", upload);
                                                    }
                                                    throw new _errors.KeySignatureUploadError("Key upload failed", {
                                                        failures: failures
                                                    });
                                                }
                                                _logger.logger.info("Finished background key sig upload for ".concat(_this7._deviceId));
                                            })["catch"](function (e) {
                                                _logger.logger.error("Error during background key sig upload for ".concat(_this7._deviceId), e);
                                            });
                                        };
                                        upload({
                                            shouldEmit: true
                                        });
                                        shouldUpgradeCb = this._baseApis._cryptoCallbacks.shouldUpgradeDeviceVerifications;
                                        if (!shouldUpgradeCb) {
                                            _context15.next = 53;
                                            break;
                                        }
                                        _logger.logger.info("Starting device verification upgrade");
                                        users = {};
                                        _i2 = 0, _Object$entries = Object.entries(this._deviceList._crossSigningInfo);
                                    case 13:
                                        if (!(_i2 < _Object$entries.length)) {
                                            _context15.next = 22;
                                            break;
                                        }
                                        _Object$entries$_i = (0, _slicedToArray2["default"])(_Object$entries[_i2], 2), userId = _Object$entries$_i[0], crossSigningInfo = _Object$entries$_i[1];
                                        _context15.next = 17;
                                        return this._checkForDeviceVerificationUpgrade(userId, _CrossSigning.CrossSigningInfo.fromStorage(crossSigningInfo, userId));
                                    case 17:
                                        upgradeInfo = _context15.sent;
                                        if (upgradeInfo) {
                                            users[userId] = upgradeInfo;
                                        }
                                    case 19:
                                        _i2++;
                                        _context15.next = 13;
                                        break;
                                    case 22:
                                        if (!(Object.keys(users).length > 0)) {
                                            _context15.next = 52;
                                            break;
                                        }
                                        _logger.logger.info("Found ".concat(Object.keys(users).length, " verif users to upgrade"));
                                        _context15.prev = 24;
                                        _context15.next = 27;
                                        return shouldUpgradeCb({
                                            users: users
                                        });
                                    case 27:
                                        usersToUpgrade = _context15.sent;
                                        if (!usersToUpgrade) {
                                            _context15.next = 47;
                                            break;
                                        }
                                        _iterator3 = _createForOfIteratorHelper(usersToUpgrade);
                                        _context15.prev = 30;
                                        _iterator3.s();
                                    case 32:
                                        if ((_step3 = _iterator3.n()).done) {
                                            _context15.next = 39;
                                            break;
                                        }
                                        _userId = _step3.value;
                                        if (!(_userId in users)) {
                                            _context15.next = 37;
                                            break;
                                        }
                                        _context15.next = 37;
                                        return this._baseApis.setDeviceVerified(_userId, users[_userId].crossSigningInfo.getId());
                                    case 37:
                                        _context15.next = 32;
                                        break;
                                    case 39:
                                        _context15.next = 44;
                                        break;
                                    case 41:
                                        _context15.prev = 41;
                                        _context15.t0 = _context15["catch"](30);
                                        _iterator3.e(_context15.t0);
                                    case 44:
                                        _context15.prev = 44;
                                        _iterator3.f();
                                        return _context15.finish(44);
                                    case 47:
                                        _context15.next = 52;
                                        break;
                                    case 49:
                                        _context15.prev = 49;
                                        _context15.t1 = _context15["catch"](24);
                                        _logger.logger.log("shouldUpgradeDeviceVerifications threw an error: not upgrading", _context15.t1);
                                    case 52:
                                        _logger.logger.info("Finished device verification upgrade");
                                    case 53:
                                        _logger.logger.info("Finished cross-signing key change post-processing");
                                    case 54:
                                    case "end":
                                        return _context15.stop();
                                }
                            }
                        }, _callee15, this, [[24, 49], [30, 41, 44, 47]]);
                    }));
                    Crypto.prototype._checkForDeviceVerificationUpgrade = function () {
                        var _ref23 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee16(userId, crossSigningInfo) {
                            var trustLevel, devices, deviceIds;
                            return _regenerator["default"].wrap(function _callee16$(_context16) {
                                while (1) {
                                    switch (_context16.prev = _context16.next) {
                                        case 0:
                                            trustLevel = this._crossSigningInfo.checkUserTrust(crossSigningInfo);
                                            if (!(crossSigningInfo.firstUse && !trustLevel.verified)) {
                                                _context16.next = 8;
                                                break;
                                            }
                                            devices = this._deviceList.getRawStoredDevicesForUser(userId);
                                            _context16.next = 5;
                                            return this._checkForValidDeviceSignature(userId, crossSigningInfo.keys.master, devices);
                                        case 5:
                                            deviceIds = _context16.sent;
                                            if (!deviceIds.length) {
                                                _context16.next = 8;
                                                break;
                                            }
                                            return _context16.abrupt("return", {
                                                devices: deviceIds.map(function (deviceId) {
                                                    return _deviceinfo.DeviceInfo.fromStorage(devices[deviceId], deviceId);
                                                }),
                                                crossSigningInfo: crossSigningInfo
                                            });
                                        case 8:
                                        case "end":
                                            return _context16.stop();
                                    }
                                }
                            }, _callee16, this);
                        }));
                        return function (_x10, _x11) {
                            return _ref23.apply(this, arguments);
                        };
                    }();
                    Crypto.prototype._checkForValidDeviceSignature = function () {
                        var _ref24 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee17(userId, key, devices) {
                            var deviceIds, _i3, _Object$keys2, signame, _signame$split, _signame$split2, deviceId;
                            return _regenerator["default"].wrap(function _callee17$(_context17) {
                                while (1) {
                                    switch (_context17.prev = _context17.next) {
                                        case 0:
                                            deviceIds = [];
                                            if (!(devices && key.signatures && key.signatures[userId])) {
                                                _context17.next = 18;
                                                break;
                                            }
                                            _i3 = 0, _Object$keys2 = Object.keys(key.signatures[userId]);
                                        case 3:
                                            if (!(_i3 < _Object$keys2.length)) {
                                                _context17.next = 18;
                                                break;
                                            }
                                            signame = _Object$keys2[_i3];
                                            _signame$split = signame.split(':', 2), _signame$split2 = (0, _slicedToArray2["default"])(_signame$split, 2), deviceId = _signame$split2[1];
                                            if (!(deviceId in devices && devices[deviceId].verified === DeviceVerification.VERIFIED)) {
                                                _context17.next = 15;
                                                break;
                                            }
                                            _context17.prev = 7;
                                            _context17.next = 10;
                                            return olmlib.verifySignature(this._olmDevice, key, userId, deviceId, devices[deviceId].keys[signame]);
                                        case 10:
                                            deviceIds.push(deviceId);
                                            _context17.next = 15;
                                            break;
                                        case 13:
                                            _context17.prev = 13;
                                            _context17.t0 = _context17["catch"](7);
                                        case 15:
                                            _i3++;
                                            _context17.next = 3;
                                            break;
                                        case 18:
                                            return _context17.abrupt("return", deviceIds);
                                        case 19:
                                        case "end":
                                            return _context17.stop();
                                    }
                                }
                            }, _callee17, this, [[7, 13]]);
                        }));
                        return function (_x12, _x13, _x14) {
                            return _ref24.apply(this, arguments);
                        };
                    }();
                    Crypto.prototype.getCrossSigningId = function (type) {
                        return this._crossSigningInfo.getId(type);
                    };
                    Crypto.prototype.getStoredCrossSigningForUser = function (userId) {
                        return this._deviceList.getStoredCrossSigningForUser(userId);
                    };
                    Crypto.prototype.checkUserTrust = function (userId) {
                        var userCrossSigning = this._deviceList.getStoredCrossSigningForUser(userId);
                        if (!userCrossSigning) {
                            return new _CrossSigning.UserTrustLevel(false, false, false);
                        }
                        return this._crossSigningInfo.checkUserTrust(userCrossSigning);
                    };
                    Crypto.prototype.checkDeviceTrust = function (userId, deviceId) {
                        var device = this._deviceList.getStoredDevice(userId, deviceId);
                        return this._checkDeviceInfoTrust(userId, device);
                    };
                    Crypto.prototype._checkDeviceInfoTrust = function (userId, device) {
                        var trustedLocally = !!(device && device.isVerified());
                        var userCrossSigning = this._deviceList.getStoredCrossSigningForUser(userId);
                        if (device && userCrossSigning) {
                            var trustCrossSig = this._trustCrossSignedDevices || userId === this._userId;
                            return this._crossSigningInfo.checkDeviceTrust(userCrossSigning, device, trustedLocally, trustCrossSig);
                        }
                        else {
                            return new _CrossSigning.DeviceTrustLevel(false, false, trustedLocally, false);
                        }
                    };
                    Crypto.prototype._onDeviceListUserCrossSigningUpdated = function () {
                        var _ref25 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee18(userId) {
                            var newCrossSigning, seenPubkey, currentPubkey, changed, crossSigning;
                            return _regenerator["default"].wrap(function _callee18$(_context18) {
                                while (1) {
                                    switch (_context18.prev = _context18.next) {
                                        case 0:
                                            if (!(userId === this._userId)) {
                                                _context18.next = 15;
                                                break;
                                            }
                                            newCrossSigning = this._deviceList.getStoredCrossSigningForUser(userId);
                                            seenPubkey = newCrossSigning ? newCrossSigning.getId() : null;
                                            currentPubkey = this._crossSigningInfo.getId();
                                            changed = currentPubkey !== seenPubkey;
                                            if (!(currentPubkey && seenPubkey && !changed)) {
                                                _context18.next = 10;
                                                break;
                                            }
                                            _context18.next = 8;
                                            return this.checkOwnCrossSigningTrust();
                                        case 8:
                                            _context18.next = 13;
                                            break;
                                        case 10:
                                            this._storeTrustedSelfKeys(null);
                                            this.emit("crossSigning.keysChanged", {});
                                            this.emit("userTrustStatusChanged", this._userId, this.checkUserTrust(userId));
                                        case 13:
                                            _context18.next = 20;
                                            break;
                                        case 15:
                                            _context18.next = 17;
                                            return this._checkDeviceVerifications(userId);
                                        case 17:
                                            crossSigning = this._deviceList.getStoredCrossSigningForUser(userId);
                                            if (crossSigning) {
                                                crossSigning.updateCrossSigningVerifiedBefore(this.checkUserTrust(userId).isCrossSigningVerified());
                                                this._deviceList.setRawStoredCrossSigningForUser(userId, crossSigning.toStorage());
                                            }
                                            this.emit("userTrustStatusChanged", userId, this.checkUserTrust(userId));
                                        case 20:
                                        case "end":
                                            return _context18.stop();
                                    }
                                }
                            }, _callee18, this);
                        }));
                        return function (_x15) {
                            return _ref25.apply(this, arguments);
                        };
                    }();
                    Crypto.prototype.checkOwnCrossSigningTrust = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee19() {
                        var _this8 = this;
                        var userId, newCrossSigning, seenPubkey, masterChanged, signing, ret, oldSelfSigningId, oldUserSigningId, selfSigningChanged, userSigningChanged, keySignatures, _signing, _ret, device, _signedDevice, _signing2, _ret2, masterKey, deviceSig, keysToUpload, _upload;
                        return _regenerator["default"].wrap(function _callee19$(_context19) {
                            while (1) {
                                switch (_context19.prev = _context19.next) {
                                    case 0:
                                        userId = this._userId;
                                        _context19.next = 3;
                                        return this.downloadKeys([this._userId]);
                                    case 3:
                                        newCrossSigning = this._deviceList.getStoredCrossSigningForUser(userId);
                                        if (newCrossSigning) {
                                            _context19.next = 7;
                                            break;
                                        }
                                        _logger.logger.error("Got cross-signing update event for user " + userId + " but no new cross-signing information found!");
                                        return _context19.abrupt("return");
                                    case 7:
                                        seenPubkey = newCrossSigning.getId();
                                        masterChanged = this._crossSigningInfo.getId() !== seenPubkey;
                                        if (!masterChanged) {
                                            _context19.next = 27;
                                            break;
                                        }
                                        _logger.logger.info("Got new master public key", seenPubkey);
                                        _logger.logger.info("Attempting to retrieve cross-signing master private key");
                                        signing = null;
                                        _context19.prev = 13;
                                        _context19.next = 16;
                                        return this._crossSigningInfo.getCrossSigningKey('master', seenPubkey);
                                    case 16:
                                        ret = _context19.sent;
                                        signing = ret[1];
                                        _logger.logger.info("Got cross-signing master private key");
                                        _context19.next = 24;
                                        break;
                                    case 21:
                                        _context19.prev = 21;
                                        _context19.t0 = _context19["catch"](13);
                                        _logger.logger.error("Cross-signing master private key not available", _context19.t0);
                                    case 24:
                                        _context19.prev = 24;
                                        if (signing)
                                            signing.free();
                                        return _context19.finish(24);
                                    case 27:
                                        oldSelfSigningId = this._crossSigningInfo.getId("self_signing");
                                        oldUserSigningId = this._crossSigningInfo.getId("user_signing");
                                        this._storeTrustedSelfKeys(newCrossSigning.keys);
                                        selfSigningChanged = oldSelfSigningId !== newCrossSigning.getId("self_signing");
                                        userSigningChanged = oldUserSigningId !== newCrossSigning.getId("user_signing");
                                        keySignatures = {};
                                        if (!selfSigningChanged) {
                                            _context19.next = 56;
                                            break;
                                        }
                                        _logger.logger.info("Got new self-signing key", newCrossSigning.getId("self_signing"));
                                        _logger.logger.info("Attempting to retrieve cross-signing self-signing private key");
                                        _signing = null;
                                        _context19.prev = 37;
                                        _context19.next = 40;
                                        return this._crossSigningInfo.getCrossSigningKey("self_signing", newCrossSigning.getId("self_signing"));
                                    case 40:
                                        _ret = _context19.sent;
                                        _signing = _ret[1];
                                        _logger.logger.info("Got cross-signing self-signing private key");
                                        _context19.next = 48;
                                        break;
                                    case 45:
                                        _context19.prev = 45;
                                        _context19.t1 = _context19["catch"](37);
                                        _logger.logger.error("Cross-signing self-signing private key not available", _context19.t1);
                                    case 48:
                                        _context19.prev = 48;
                                        if (_signing)
                                            _signing.free();
                                        return _context19.finish(48);
                                    case 51:
                                        device = this._deviceList.getStoredDevice(this._userId, this._deviceId);
                                        _context19.next = 54;
                                        return this._crossSigningInfo.signDevice(this._userId, device);
                                    case 54:
                                        _signedDevice = _context19.sent;
                                        keySignatures[this._deviceId] = _signedDevice;
                                    case 56:
                                        if (!userSigningChanged) {
                                            _context19.next = 74;
                                            break;
                                        }
                                        _logger.logger.info("Got new user-signing key", newCrossSigning.getId("user_signing"));
                                        _logger.logger.info("Attempting to retrieve cross-signing user-signing private key");
                                        _signing2 = null;
                                        _context19.prev = 60;
                                        _context19.next = 63;
                                        return this._crossSigningInfo.getCrossSigningKey("user_signing", newCrossSigning.getId("user_signing"));
                                    case 63:
                                        _ret2 = _context19.sent;
                                        _signing2 = _ret2[1];
                                        _logger.logger.info("Got cross-signing user-signing private key");
                                        _context19.next = 71;
                                        break;
                                    case 68:
                                        _context19.prev = 68;
                                        _context19.t2 = _context19["catch"](60);
                                        _logger.logger.error("Cross-signing user-signing private key not available", _context19.t2);
                                    case 71:
                                        _context19.prev = 71;
                                        if (_signing2)
                                            _signing2.free();
                                        return _context19.finish(71);
                                    case 74:
                                        if (!masterChanged) {
                                            _context19.next = 80;
                                            break;
                                        }
                                        masterKey = this._crossSigningInfo.keys.master;
                                        _context19.next = 78;
                                        return this._signObject(masterKey);
                                    case 78:
                                        deviceSig = masterKey.signatures[this._userId]["ed25519:" + this._deviceId];
                                        keySignatures[this._crossSigningInfo.getId()] = Object.assign({}, masterKey, {
                                            signatures: (0, _defineProperty2["default"])({}, this._userId, (0, _defineProperty2["default"])({}, "ed25519:" + this._deviceId, deviceSig))
                                        });
                                    case 80:
                                        keysToUpload = Object.keys(keySignatures);
                                        if (keysToUpload.length) {
                                            _upload = function _upload(_ref27) {
                                                var shouldEmit = _ref27.shouldEmit;
                                                _logger.logger.info("Starting background key sig upload for ".concat(keysToUpload));
                                                return _this8._baseApis.uploadKeySignatures((0, _defineProperty2["default"])({}, _this8._userId, keySignatures)).then(function (response) {
                                                    var _ref28 = response || {}, failures = _ref28.failures;
                                                    _logger.logger.info("Finished background key sig upload for ".concat(keysToUpload));
                                                    if (Object.keys(failures || []).length > 0) {
                                                        if (shouldEmit) {
                                                            _this8._baseApis.emit("crypto.keySignatureUploadFailure", failures, "checkOwnCrossSigningTrust", _upload);
                                                        }
                                                        throw new _errors.KeySignatureUploadError("Key upload failed", {
                                                            failures: failures
                                                        });
                                                    }
                                                })["catch"](function (e) {
                                                    _logger.logger.error("Error during background key sig upload for ".concat(keysToUpload), e);
                                                });
                                            };
                                            _upload({
                                                shouldEmit: true
                                            });
                                        }
                                        this.emit("userTrustStatusChanged", userId, this.checkUserTrust(userId));
                                        if (!masterChanged) {
                                            _context19.next = 87;
                                            break;
                                        }
                                        this._baseApis.emit("crossSigning.keysChanged", {});
                                        _context19.next = 87;
                                        return this._afterCrossSigningLocalKeyChange();
                                    case 87:
                                        _context19.next = 89;
                                        return this.checkKeyBackup();
                                    case 89:
                                    case "end":
                                        return _context19.stop();
                                }
                            }
                        }, _callee19, this, [[13, 21, 24, 27], [37, 45, 48, 51], [60, 68, 71, 74]]);
                    }));
                    Crypto.prototype._storeTrustedSelfKeys = function () {
                        var _ref29 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee20(keys) {
                            var _this9 = this;
                            return _regenerator["default"].wrap(function _callee20$(_context20) {
                                while (1) {
                                    switch (_context20.prev = _context20.next) {
                                        case 0:
                                            if (keys) {
                                                this._crossSigningInfo.setKeys(keys);
                                            }
                                            else {
                                                this._crossSigningInfo.clearKeys();
                                            }
                                            _context20.next = 3;
                                            return this._cryptoStore.doTxn('readwrite', [_indexeddbCryptoStore.IndexedDBCryptoStore.STORE_ACCOUNT], function (txn) {
                                                _this9._cryptoStore.storeCrossSigningKeys(txn, _this9._crossSigningInfo.keys);
                                            });
                                        case 3:
                                        case "end":
                                            return _context20.stop();
                                    }
                                }
                            }, _callee20, this);
                        }));
                        return function (_x16) {
                            return _ref29.apply(this, arguments);
                        };
                    }();
                    Crypto.prototype._checkDeviceVerifications = function () {
                        var _ref30 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee21(userId) {
                            var shouldUpgradeCb, crossSigningInfo, upgradeInfo, usersToUpgrade;
                            return _regenerator["default"].wrap(function _callee21$(_context21) {
                                while (1) {
                                    switch (_context21.prev = _context21.next) {
                                        case 0:
                                            shouldUpgradeCb = this._baseApis._cryptoCallbacks.shouldUpgradeDeviceVerifications;
                                            if (shouldUpgradeCb) {
                                                _context21.next = 3;
                                                break;
                                            }
                                            return _context21.abrupt("return");
                                        case 3:
                                            _logger.logger.info("Starting device verification upgrade for ".concat(userId));
                                            if (!this._crossSigningInfo.keys.user_signing) {
                                                _context21.next = 17;
                                                break;
                                            }
                                            crossSigningInfo = this._deviceList.getStoredCrossSigningForUser(userId);
                                            if (!crossSigningInfo) {
                                                _context21.next = 17;
                                                break;
                                            }
                                            _context21.next = 9;
                                            return this._checkForDeviceVerificationUpgrade(userId, crossSigningInfo);
                                        case 9:
                                            upgradeInfo = _context21.sent;
                                            if (!upgradeInfo) {
                                                _context21.next = 17;
                                                break;
                                            }
                                            _context21.next = 13;
                                            return shouldUpgradeCb({
                                                users: (0, _defineProperty2["default"])({}, userId, upgradeInfo)
                                            });
                                        case 13:
                                            usersToUpgrade = _context21.sent;
                                            if (!usersToUpgrade.includes(userId)) {
                                                _context21.next = 17;
                                                break;
                                            }
                                            _context21.next = 17;
                                            return this._baseApis.setDeviceVerified(userId, crossSigningInfo.getId());
                                        case 17:
                                            _logger.logger.info("Finished device verification upgrade for ".concat(userId));
                                        case 18:
                                        case "end":
                                            return _context21.stop();
                                    }
                                }
                            }, _callee21, this);
                        }));
                        return function (_x17) {
                            return _ref30.apply(this, arguments);
                        };
                    }();
                    Crypto.prototype._checkAndStartKeyBackup = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee22() {
                        var backupInfo, trustInfo;
                        return _regenerator["default"].wrap(function _callee22$(_context22) {
                            while (1) {
                                switch (_context22.prev = _context22.next) {
                                    case 0:
                                        _logger.logger.log("Checking key backup status...");
                                        if (!this._baseApis.isGuest()) {
                                            _context22.next = 5;
                                            break;
                                        }
                                        _logger.logger.log("Skipping key backup check since user is guest");
                                        this._checkedForBackup = true;
                                        return _context22.abrupt("return", null);
                                    case 5:
                                        _context22.prev = 5;
                                        _context22.next = 8;
                                        return this._baseApis.getKeyBackupVersion();
                                    case 8:
                                        backupInfo = _context22.sent;
                                        _context22.next = 16;
                                        break;
                                    case 11:
                                        _context22.prev = 11;
                                        _context22.t0 = _context22["catch"](5);
                                        _logger.logger.log("Error checking for active key backup", _context22.t0);
                                        if (_context22.t0.httpStatus === 404) {
                                            this._checkedForBackup = true;
                                        }
                                        return _context22.abrupt("return", null);
                                    case 16:
                                        this._checkedForBackup = true;
                                        _context22.next = 19;
                                        return this.isKeyBackupTrusted(backupInfo);
                                    case 19:
                                        trustInfo = _context22.sent;
                                        if (!(trustInfo.usable && !this.backupInfo)) {
                                            _context22.next = 25;
                                            break;
                                        }
                                        _logger.logger.log("Found usable key backup v" + backupInfo.version + ": enabling key backups");
                                        this._baseApis.enableKeyBackup(backupInfo);
                                        _context22.next = 44;
                                        break;
                                    case 25:
                                        if (!(!trustInfo.usable && this.backupInfo)) {
                                            _context22.next = 30;
                                            break;
                                        }
                                        _logger.logger.log("No usable key backup: disabling key backup");
                                        this._baseApis.disableKeyBackup();
                                        _context22.next = 44;
                                        break;
                                    case 30:
                                        if (!(!trustInfo.usable && !this.backupInfo)) {
                                            _context22.next = 34;
                                            break;
                                        }
                                        _logger.logger.log("No usable key backup: not enabling key backup");
                                        _context22.next = 44;
                                        break;
                                    case 34:
                                        if (!(trustInfo.usable && this.backupInfo)) {
                                            _context22.next = 44;
                                            break;
                                        }
                                        if (!(backupInfo.version !== this.backupInfo.version)) {
                                            _context22.next = 43;
                                            break;
                                        }
                                        _logger.logger.log("On backup version " + this.backupInfo.version + " but found " + "version " + backupInfo.version + ": switching.");
                                        this._baseApis.disableKeyBackup();
                                        this._baseApis.enableKeyBackup(backupInfo);
                                        _context22.next = 41;
                                        return this.scheduleAllGroupSessionsForBackup();
                                    case 41:
                                        _context22.next = 44;
                                        break;
                                    case 43:
                                        _logger.logger.log("Backup version " + backupInfo.version + " still current");
                                    case 44:
                                        return _context22.abrupt("return", {
                                            backupInfo: backupInfo,
                                            trustInfo: trustInfo
                                        });
                                    case 45:
                                    case "end":
                                        return _context22.stop();
                                }
                            }
                        }, _callee22, this, [[5, 11]]);
                    }));
                    Crypto.prototype.setTrustedBackupPubKey = function () {
                        var _ref32 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee23(trustedPubKey) {
                            return _regenerator["default"].wrap(function _callee23$(_context23) {
                                while (1) {
                                    switch (_context23.prev = _context23.next) {
                                        case 0:
                                            this._sessionStore.setLocalTrustedBackupPubKey(trustedPubKey);
                                            _context23.next = 3;
                                            return this.checkKeyBackup();
                                        case 3:
                                        case "end":
                                            return _context23.stop();
                                    }
                                }
                            }, _callee23, this);
                        }));
                        return function (_x18) {
                            return _ref32.apply(this, arguments);
                        };
                    }();
                    Crypto.prototype.checkKeyBackup = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee24() {
                        return _regenerator["default"].wrap(function _callee24$(_context24) {
                            while (1) {
                                switch (_context24.prev = _context24.next) {
                                    case 0:
                                        this._checkedForBackup = false;
                                        return _context24.abrupt("return", this._checkAndStartKeyBackup());
                                    case 2:
                                    case "end":
                                        return _context24.stop();
                                }
                            }
                        }, _callee24, this);
                    }));
                    Crypto.prototype.isKeyBackupTrusted = function () {
                        var _ref34 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee25(backupInfo) {
                            var ret, trustedPubkey, mySigs, _i4, _Object$keys3, keyId, keyIdParts, sigInfo, crossSigningId, device;
                            return _regenerator["default"].wrap(function _callee25$(_context25) {
                                while (1) {
                                    switch (_context25.prev = _context25.next) {
                                        case 0:
                                            ret = {
                                                usable: false,
                                                trusted_locally: false,
                                                sigs: []
                                            };
                                            if (!(!backupInfo || !backupInfo.algorithm || !backupInfo.auth_data || !backupInfo.auth_data.public_key || !backupInfo.auth_data.signatures)) {
                                                _context25.next = 4;
                                                break;
                                            }
                                            _logger.logger.info("Key backup is absent or missing required data");
                                            return _context25.abrupt("return", ret);
                                        case 4:
                                            trustedPubkey = this._sessionStore.getLocalTrustedBackupPubKey();
                                            if (backupInfo.auth_data.public_key === trustedPubkey) {
                                                _logger.logger.info("Backup public key " + trustedPubkey + " is trusted locally");
                                                ret.trusted_locally = true;
                                            }
                                            mySigs = backupInfo.auth_data.signatures[this._userId] || [];
                                            _i4 = 0, _Object$keys3 = Object.keys(mySigs);
                                        case 8:
                                            if (!(_i4 < _Object$keys3.length)) {
                                                _context25.next = 54;
                                                break;
                                            }
                                            keyId = _Object$keys3[_i4];
                                            keyIdParts = keyId.split(':');
                                            if (!(keyIdParts[0] !== 'ed25519')) {
                                                _context25.next = 14;
                                                break;
                                            }
                                            _logger.logger.log("Ignoring unknown signature type: " + keyIdParts[0]);
                                            return _context25.abrupt("continue", 51);
                                        case 14:
                                            sigInfo = {
                                                deviceId: keyIdParts[1]
                                            };
                                            crossSigningId = this._crossSigningInfo.getId();
                                            if (!(crossSigningId === sigInfo.deviceId)) {
                                                _context25.next = 30;
                                                break;
                                            }
                                            sigInfo.crossSigningId = true;
                                            _context25.prev = 18;
                                            _context25.next = 21;
                                            return olmlib.verifySignature(this._olmDevice, backupInfo.auth_data, this._userId, sigInfo.deviceId, crossSigningId);
                                        case 21:
                                            sigInfo.valid = true;
                                            _context25.next = 28;
                                            break;
                                        case 24:
                                            _context25.prev = 24;
                                            _context25.t0 = _context25["catch"](18);
                                            _logger.logger.warning("Bad signature from cross signing key " + crossSigningId, _context25.t0);
                                            sigInfo.valid = false;
                                        case 28:
                                            ret.sigs.push(sigInfo);
                                            return _context25.abrupt("continue", 51);
                                        case 30:
                                            device = this._deviceList.getStoredDevice(this._userId, sigInfo.deviceId);
                                            if (!device) {
                                                _context25.next = 48;
                                                break;
                                            }
                                            sigInfo.device = device;
                                            _context25.next = 35;
                                            return this.checkDeviceTrust(this._userId, sigInfo.deviceId);
                                        case 35:
                                            sigInfo.deviceTrust = _context25.sent;
                                            _context25.prev = 36;
                                            _context25.next = 39;
                                            return olmlib.verifySignature(this._olmDevice, backupInfo.auth_data, this._userId, device.deviceId, device.getFingerprint());
                                        case 39:
                                            sigInfo.valid = true;
                                            _context25.next = 46;
                                            break;
                                        case 42:
                                            _context25.prev = 42;
                                            _context25.t1 = _context25["catch"](36);
                                            _logger.logger.info("Bad signature from key ID " + keyId + " userID " + this._userId + " device ID " + device.deviceId + " fingerprint: " + device.getFingerprint(), backupInfo.auth_data, _context25.t1);
                                            sigInfo.valid = false;
                                        case 46:
                                            _context25.next = 50;
                                            break;
                                        case 48:
                                            sigInfo.valid = null;
                                            _logger.logger.info("Ignoring signature from unknown key " + keyId);
                                        case 50:
                                            ret.sigs.push(sigInfo);
                                        case 51:
                                            _i4++;
                                            _context25.next = 8;
                                            break;
                                        case 54:
                                            ret.usable = ret.sigs.some(function (s) {
                                                return s.valid && (s.device && s.deviceTrust.isVerified() || s.crossSigningId);
                                            });
                                            ret.usable |= ret.trusted_locally;
                                            return _context25.abrupt("return", ret);
                                        case 57:
                                        case "end":
                                            return _context25.stop();
                                    }
                                }
                            }, _callee25, this, [[18, 24], [36, 42]]);
                        }));
                        return function (_x19) {
                            return _ref34.apply(this, arguments);
                        };
                    }();
                    Crypto.prototype.enableLazyLoading = function () {
                        this._lazyLoadMembers = true;
                    };
                    Crypto.prototype.registerEventHandlers = function (eventEmitter) {
                        var crypto = this;
                        eventEmitter.on("RoomMember.membership", function (event, member, oldMembership) {
                            try {
                                crypto._onRoomMembership(event, member, oldMembership);
                            }
                            catch (e) {
                                _logger.logger.error("Error handling membership change:", e);
                            }
                        });
                        eventEmitter.on("toDeviceEvent", crypto._onToDeviceEvent.bind(crypto));
                        var timelineHandler = crypto._onTimelineEvent.bind(crypto);
                        eventEmitter.on("Room.timeline", timelineHandler);
                        eventEmitter.on("Event.decrypted", timelineHandler);
                    };
                    Crypto.prototype.start = function () {
                        this._outgoingRoomKeyRequestManager.start();
                    };
                    Crypto.prototype.stop = function () {
                        this._outgoingRoomKeyRequestManager.stop();
                        this._deviceList.stop();
                        this._dehydrationManager.stop();
                    };
                    Crypto.getOlmVersion = function () {
                        return _OlmDevice.OlmDevice.getOlmVersion();
                    };
                    Crypto.prototype.getDeviceEd25519Key = function () {
                        return this._olmDevice.deviceEd25519Key;
                    };
                    Crypto.prototype.getDeviceCurve25519Key = function () {
                        return this._olmDevice.deviceCurve25519Key;
                    };
                    Crypto.prototype.setGlobalBlacklistUnverifiedDevices = function (value) {
                        this._globalBlacklistUnverifiedDevices = value;
                    };
                    Crypto.prototype.getGlobalBlacklistUnverifiedDevices = function () {
                        return this._globalBlacklistUnverifiedDevices;
                    };
                    Crypto.prototype.setGlobalErrorOnUnknownDevices = function (value) {
                        this._globalErrorOnUnknownDevices = value;
                    };
                    Crypto.prototype.getGlobalErrorOnUnknownDevices = function () {
                        return this._globalErrorOnUnknownDevices;
                    };
                    Crypto.prototype.uploadDeviceKeys = function () {
                        var crypto = this;
                        var userId = crypto._userId;
                        var deviceId = crypto._deviceId;
                        var deviceKeys = {
                            algorithms: crypto._supportedAlgorithms,
                            device_id: deviceId,
                            keys: crypto._deviceKeys,
                            user_id: userId
                        };
                        return crypto._signObject(deviceKeys).then(function () {
                            return crypto._baseApis.uploadKeysRequest({
                                device_keys: deviceKeys
                            });
                        });
                    };
                    Crypto.prototype.updateOneTimeKeyCount = function (currentCount) {
                        if (isFinite(currentCount)) {
                            this._oneTimeKeyCount = currentCount;
                        }
                        else {
                            throw new TypeError("Parameter for updateOneTimeKeyCount has to be a number");
                        }
                    };
                    Crypto.prototype.setNeedsNewFallback = function (needsNewFallback) {
                        this._needsNewFallback = !!needsNewFallback;
                    };
                    Crypto.prototype.getNeedsNewFallback = function () {
                        return this._needsNewFallback;
                    };
                    function _maybeUploadOneTimeKeys(crypto) {
                        var uploadPeriod = 1000 * 60;
                        var maxKeysPerCycle = 5;
                        if (crypto._oneTimeKeyCheckInProgress) {
                            return;
                        }
                        var now = Date.now();
                        if (crypto._lastOneTimeKeyCheck !== null && now - crypto._lastOneTimeKeyCheck < uploadPeriod) {
                            return;
                        }
                        crypto._lastOneTimeKeyCheck = now;
                        var maxOneTimeKeys = crypto._olmDevice.maxNumberOfOneTimeKeys();
                        var keyLimit = Math.floor(maxOneTimeKeys / 2);
                        function uploadLoop(_x20) {
                            return _uploadLoop.apply(this, arguments);
                        }
                        function _uploadLoop() {
                            _uploadLoop = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee26(keyCount) {
                                var keysThisLoop, res;
                                return _regenerator["default"].wrap(function _callee26$(_context26) {
                                    while (1) {
                                        switch (_context26.prev = _context26.next) {
                                            case 0:
                                                if (!(keyLimit > keyCount || crypto.getNeedsNewFallback())) {
                                                    _context26.next = 21;
                                                    break;
                                                }
                                                if (!(keyLimit > keyCount)) {
                                                    _context26.next = 6;
                                                    break;
                                                }
                                                _logger.logger.info("generating oneTimeKeys");
                                                keysThisLoop = Math.min(keyLimit - keyCount, maxKeysPerCycle);
                                                _context26.next = 6;
                                                return crypto._olmDevice.generateOneTimeKeys(keysThisLoop);
                                            case 6:
                                                if (!crypto.getNeedsNewFallback()) {
                                                    _context26.next = 10;
                                                    break;
                                                }
                                                _logger.logger.info("generating fallback key");
                                                _context26.next = 10;
                                                return crypto._olmDevice.generateFallbackKey();
                                            case 10:
                                                _logger.logger.info("calling _uploadOneTimeKeys");
                                                _context26.next = 13;
                                                return _uploadOneTimeKeys(crypto);
                                            case 13:
                                                res = _context26.sent;
                                                if (!(res.one_time_key_counts && res.one_time_key_counts.signed_curve25519)) {
                                                    _context26.next = 18;
                                                    break;
                                                }
                                                keyCount = res.one_time_key_counts.signed_curve25519;
                                                _context26.next = 19;
                                                break;
                                            case 18:
                                                throw new Error("response for uploading keys does not contain " + "one_time_key_counts.signed_curve25519");
                                            case 19:
                                                _context26.next = 0;
                                                break;
                                            case 21:
                                            case "end":
                                                return _context26.stop();
                                        }
                                    }
                                }, _callee26);
                            }));
                            return _uploadLoop.apply(this, arguments);
                        }
                        crypto._oneTimeKeyCheckInProgress = true;
                        Promise.resolve().then(function () {
                            if (crypto._oneTimeKeyCount !== undefined) {
                                return Promise.resolve(crypto._oneTimeKeyCount);
                            }
                            return crypto._baseApis.uploadKeysRequest({}).then(function (res) {
                                return res.one_time_key_counts.signed_curve25519 || 0;
                            });
                        }).then(function (keyCount) {
                            return uploadLoop(keyCount);
                        })["catch"](function (e) {
                            _logger.logger.error("Error uploading one-time keys", e.stack || e);
                        })["finally"](function () {
                            crypto._oneTimeKeyCount = undefined;
                            crypto._oneTimeKeyCheckInProgress = false;
                        });
                    }
                    function _uploadOneTimeKeys(_x21) {
                        return _uploadOneTimeKeys2.apply(this, arguments);
                    }
                    function _uploadOneTimeKeys2() {
                        _uploadOneTimeKeys2 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee55(crypto) {
                            var promises, fallbackJson, fallbackKeys, _i6, _Object$entries2, _Object$entries2$_i, keyId, key, k, oneTimeKeys, oneTimeJson, _keyId, _k, res;
                            return _regenerator["default"].wrap(function _callee55$(_context55) {
                                while (1) {
                                    switch (_context55.prev = _context55.next) {
                                        case 0:
                                            promises = [];
                                            fallbackJson = {};
                                            if (!crypto.getNeedsNewFallback()) {
                                                _context55.next = 8;
                                                break;
                                            }
                                            _context55.next = 5;
                                            return crypto._olmDevice.getFallbackKey();
                                        case 5:
                                            fallbackKeys = _context55.sent;
                                            for (_i6 = 0, _Object$entries2 = Object.entries(fallbackKeys.curve25519); _i6 < _Object$entries2.length; _i6++) {
                                                _Object$entries2$_i = (0, _slicedToArray2["default"])(_Object$entries2[_i6], 2), keyId = _Object$entries2$_i[0], key = _Object$entries2$_i[1];
                                                k = {
                                                    key: key,
                                                    fallback: true
                                                };
                                                fallbackJson["signed_curve25519:" + keyId] = k;
                                                promises.push(crypto._signObject(k));
                                            }
                                            crypto.setNeedsNewFallback(false);
                                        case 8:
                                            _context55.next = 10;
                                            return crypto._olmDevice.getOneTimeKeys();
                                        case 10:
                                            oneTimeKeys = _context55.sent;
                                            oneTimeJson = {};
                                            for (_keyId in oneTimeKeys.curve25519) {
                                                if (oneTimeKeys.curve25519.hasOwnProperty(_keyId)) {
                                                    _k = {
                                                        key: oneTimeKeys.curve25519[_keyId]
                                                    };
                                                    oneTimeJson["signed_curve25519:" + _keyId] = _k;
                                                    promises.push(crypto._signObject(_k));
                                                }
                                            }
                                            _context55.next = 15;
                                            return Promise.all(promises);
                                        case 15:
                                            _context55.next = 17;
                                            return crypto._baseApis.uploadKeysRequest({
                                                "one_time_keys": oneTimeJson,
                                                "org.matrix.msc2732.fallback_keys": fallbackJson
                                            });
                                        case 17:
                                            res = _context55.sent;
                                            _context55.next = 20;
                                            return crypto._olmDevice.markKeysAsPublished();
                                        case 20:
                                            return _context55.abrupt("return", res);
                                        case 21:
                                        case "end":
                                            return _context55.stop();
                                    }
                                }
                            }, _callee55);
                        }));
                        return _uploadOneTimeKeys2.apply(this, arguments);
                    }
                    Crypto.prototype.downloadKeys = function (userIds, forceDownload) {
                        return this._deviceList.downloadKeys(userIds, forceDownload);
                    };
                    Crypto.prototype.getStoredDevicesForUser = function (userId) {
                        return this._deviceList.getStoredDevicesForUser(userId);
                    };
                    Crypto.prototype.getStoredDevice = function (userId, deviceId) {
                        return this._deviceList.getStoredDevice(userId, deviceId);
                    };
                    Crypto.prototype.saveDeviceList = function (delay) {
                        return this._deviceList.saveIfDirty(delay);
                    };
                    Crypto.prototype.setDeviceVerification = function () {
                        var _ref35 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee29(userId, deviceId, verified, blocked, known) {
                            var _this10 = this;
                            var xsk, device, _upload2, devices, dev, verificationStatus, knownStatus, _device, deviceTrust, _upload3, deviceObj;
                            return _regenerator["default"].wrap(function _callee29$(_context29) {
                                while (1) {
                                    switch (_context29.prev = _context29.next) {
                                        case 0:
                                            if (verified === undefined)
                                                verified = null;
                                            if (blocked === undefined)
                                                blocked = null;
                                            if (known === undefined)
                                                known = null;
                                            xsk = this._deviceList.getStoredCrossSigningForUser(userId);
                                            if (!(xsk && xsk.getId() === deviceId)) {
                                                _context29.next = 23;
                                                break;
                                            }
                                            if (!(blocked !== null || known !== null)) {
                                                _context29.next = 7;
                                                break;
                                            }
                                            throw new Error("Cannot set blocked or known for a cross-signing key");
                                        case 7:
                                            if (verified) {
                                                _context29.next = 9;
                                                break;
                                            }
                                            throw new Error("Cannot set a cross-signing key as unverified");
                                        case 9:
                                            if (!this._crossSigningInfo.getId() && userId === this._crossSigningInfo.userId) {
                                                this._storeTrustedSelfKeys(xsk.keys);
                                                this.emit("userTrustStatusChanged", this._userId, this.checkUserTrust(userId));
                                            }
                                            if (!(userId !== this._userId)) {
                                                _context29.next = 22;
                                                break;
                                            }
                                            _logger.logger.info("Master key " + xsk.getId() + " for " + userId + " marked verified. Signing...");
                                            _context29.next = 14;
                                            return this._crossSigningInfo.signUser(xsk);
                                        case 14:
                                            device = _context29.sent;
                                            if (!device) {
                                                _context29.next = 19;
                                                break;
                                            }
                                            _upload2 = function () {
                                                var _ref37 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee27(_ref36) {
                                                    var shouldEmit, response, _ref38, failures;
                                                    return _regenerator["default"].wrap(function _callee27$(_context27) {
                                                        while (1) {
                                                            switch (_context27.prev = _context27.next) {
                                                                case 0:
                                                                    shouldEmit = _ref36.shouldEmit;
                                                                    _logger.logger.info("Uploading signature for " + userId + "...");
                                                                    _context27.next = 4;
                                                                    return _this10._baseApis.uploadKeySignatures((0, _defineProperty2["default"])({}, userId, (0, _defineProperty2["default"])({}, deviceId, device)));
                                                                case 4:
                                                                    response = _context27.sent;
                                                                    _ref38 = response || {}, failures = _ref38.failures;
                                                                    if (!(Object.keys(failures || []).length > 0)) {
                                                                        _context27.next = 9;
                                                                        break;
                                                                    }
                                                                    if (shouldEmit) {
                                                                        _this10._baseApis.emit("crypto.keySignatureUploadFailure", failures, "setDeviceVerification", _upload2);
                                                                    }
                                                                    throw new _errors.KeySignatureUploadError("Key upload failed", {
                                                                        failures: failures
                                                                    });
                                                                case 9:
                                                                case "end":
                                                                    return _context27.stop();
                                                            }
                                                        }
                                                    }, _callee27);
                                                }));
                                                return function _upload2(_x27) {
                                                    return _ref37.apply(this, arguments);
                                                };
                                            }();
                                            _context29.next = 19;
                                            return _upload2({
                                                shouldEmit: true
                                            });
                                        case 19:
                                            return _context29.abrupt("return", device);
                                        case 22:
                                            return _context29.abrupt("return", xsk);
                                        case 23:
                                            devices = this._deviceList.getRawStoredDevicesForUser(userId);
                                            if (!(!devices || !devices[deviceId])) {
                                                _context29.next = 26;
                                                break;
                                            }
                                            throw new Error("Unknown device " + userId + ":" + deviceId);
                                        case 26:
                                            dev = devices[deviceId];
                                            verificationStatus = dev.verified;
                                            if (verified) {
                                                verificationStatus = DeviceVerification.VERIFIED;
                                            }
                                            else if (verified !== null && verificationStatus == DeviceVerification.VERIFIED) {
                                                verificationStatus = DeviceVerification.UNVERIFIED;
                                            }
                                            if (blocked) {
                                                verificationStatus = DeviceVerification.BLOCKED;
                                            }
                                            else if (blocked !== null && verificationStatus == DeviceVerification.BLOCKED) {
                                                verificationStatus = DeviceVerification.UNVERIFIED;
                                            }
                                            knownStatus = dev.known;
                                            if (known !== null) {
                                                knownStatus = known;
                                            }
                                            if (dev.verified !== verificationStatus || dev.known !== knownStatus) {
                                                dev.verified = verificationStatus;
                                                dev.known = knownStatus;
                                                this._deviceList.storeDevicesForUser(userId, devices);
                                                this._deviceList.saveIfDirty();
                                            }
                                            if (!(verified && userId === this._userId)) {
                                                _context29.next = 47;
                                                break;
                                            }
                                            _logger.logger.info("Own device " + deviceId + " marked verified: signing");
                                            deviceTrust = this.checkDeviceTrust(userId, deviceId);
                                            if (!deviceTrust.isCrossSigningVerified()) {
                                                _context29.next = 40;
                                                break;
                                            }
                                            _logger.logger.log("Own device ".concat(deviceId, " already cross-signing verified"));
                                            _context29.next = 43;
                                            break;
                                        case 40:
                                            _context29.next = 42;
                                            return this._crossSigningInfo.signDevice(userId, _deviceinfo.DeviceInfo.fromStorage(dev, deviceId));
                                        case 42:
                                            _device = _context29.sent;
                                        case 43:
                                            if (!_device) {
                                                _context29.next = 47;
                                                break;
                                            }
                                            _upload3 = function () {
                                                var _ref40 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee28(_ref39) {
                                                    var shouldEmit, response, _ref41, failures;
                                                    return _regenerator["default"].wrap(function _callee28$(_context28) {
                                                        while (1) {
                                                            switch (_context28.prev = _context28.next) {
                                                                case 0:
                                                                    shouldEmit = _ref39.shouldEmit;
                                                                    _logger.logger.info("Uploading signature for " + deviceId);
                                                                    _context28.next = 4;
                                                                    return _this10._baseApis.uploadKeySignatures((0, _defineProperty2["default"])({}, userId, (0, _defineProperty2["default"])({}, deviceId, _device)));
                                                                case 4:
                                                                    response = _context28.sent;
                                                                    _ref41 = response || {}, failures = _ref41.failures;
                                                                    if (!(Object.keys(failures || []).length > 0)) {
                                                                        _context28.next = 9;
                                                                        break;
                                                                    }
                                                                    if (shouldEmit) {
                                                                        _this10._baseApis.emit("crypto.keySignatureUploadFailure", failures, "setDeviceVerification", _upload3);
                                                                    }
                                                                    throw new _errors.KeySignatureUploadError("Key upload failed", {
                                                                        failures: failures
                                                                    });
                                                                case 9:
                                                                case "end":
                                                                    return _context28.stop();
                                                            }
                                                        }
                                                    }, _callee28);
                                                }));
                                                return function _upload3(_x28) {
                                                    return _ref40.apply(this, arguments);
                                                };
                                            }();
                                            _context29.next = 47;
                                            return _upload3({
                                                shouldEmit: true
                                            });
                                        case 47:
                                            deviceObj = _deviceinfo.DeviceInfo.fromStorage(dev, deviceId);
                                            this.emit("deviceVerificationChanged", userId, deviceId, deviceObj);
                                            return _context29.abrupt("return", deviceObj);
                                        case 50:
                                        case "end":
                                            return _context29.stop();
                                    }
                                }
                            }, _callee29, this);
                        }));
                        return function (_x22, _x23, _x24, _x25, _x26) {
                            return _ref35.apply(this, arguments);
                        };
                    }();
                    Crypto.prototype.findVerificationRequestDMInProgress = function (roomId) {
                        return this._inRoomVerificationRequests.findRequestInProgress(roomId);
                    };
                    Crypto.prototype.getVerificationRequestsToDeviceInProgress = function (userId) {
                        return this._toDeviceVerificationRequests.getRequestsInProgress(userId);
                    };
                    Crypto.prototype.requestVerificationDM = function (userId, roomId) {
                        var existingRequest = this._inRoomVerificationRequests.findRequestInProgress(roomId);
                        if (existingRequest) {
                            return Promise.resolve(existingRequest);
                        }
                        var channel = new _InRoomChannel.InRoomChannel(this._baseApis, roomId, userId);
                        return this._requestVerificationWithChannel(userId, channel, this._inRoomVerificationRequests);
                    };
                    Crypto.prototype.requestVerification = function (userId, devices) {
                        if (!devices) {
                            devices = Object.keys(this._deviceList.getRawStoredDevicesForUser(userId));
                        }
                        var existingRequest = this._toDeviceVerificationRequests.findRequestInProgress(userId, devices);
                        if (existingRequest) {
                            return Promise.resolve(existingRequest);
                        }
                        var channel = new _ToDeviceChannel.ToDeviceChannel(this._baseApis, userId, devices, _ToDeviceChannel.ToDeviceChannel.makeTransactionId());
                        return this._requestVerificationWithChannel(userId, channel, this._toDeviceVerificationRequests);
                    };
                    Crypto.prototype._requestVerificationWithChannel = function () {
                        var _ref42 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee30(userId, channel, requestsMap) {
                            var request, racingRequest;
                            return _regenerator["default"].wrap(function _callee30$(_context30) {
                                while (1) {
                                    switch (_context30.prev = _context30.next) {
                                        case 0:
                                            request = new _VerificationRequest.VerificationRequest(channel, this._verificationMethods, this._baseApis);
                                            if (channel.transactionId) {
                                                requestsMap.setRequestByChannel(channel, request);
                                            }
                                            _context30.next = 4;
                                            return request.sendRequest();
                                        case 4:
                                            racingRequest = requestsMap.getRequestByChannel(channel);
                                            if (racingRequest) {
                                                request = racingRequest;
                                            }
                                            else {
                                                _logger.logger.log("Crypto: adding new request to " + "requestsByTxnId with id ".concat(channel.transactionId, " ").concat(channel.roomId));
                                                requestsMap.setRequestByChannel(channel, request);
                                            }
                                            return _context30.abrupt("return", request);
                                        case 7:
                                        case "end":
                                            return _context30.stop();
                                    }
                                }
                            }, _callee30, this);
                        }));
                        return function (_x29, _x30, _x31) {
                            return _ref42.apply(this, arguments);
                        };
                    }();
                    Crypto.prototype.beginKeyVerification = function (method, userId, deviceId) {
                        var transactionId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
                        var request;
                        if (transactionId) {
                            request = this._toDeviceVerificationRequests.getRequestBySenderAndTxnId(userId, transactionId);
                            if (!request) {
                                throw new Error("No request found for user ".concat(userId, " with ") + "transactionId ".concat(transactionId));
                            }
                        }
                        else {
                            transactionId = _ToDeviceChannel.ToDeviceChannel.makeTransactionId();
                            var channel = new _ToDeviceChannel.ToDeviceChannel(this._baseApis, userId, [deviceId], transactionId, deviceId);
                            request = new _VerificationRequest.VerificationRequest(channel, this._verificationMethods, this._baseApis);
                            this._toDeviceVerificationRequests.setRequestBySenderAndTxnId(userId, transactionId, request);
                        }
                        return request.beginKeyVerification(method, {
                            userId: userId,
                            deviceId: deviceId
                        });
                    };
                    Crypto.prototype.legacyDeviceVerification = function () {
                        var _ref43 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee31(userId, deviceId, method) {
                            var transactionId, channel, request, verifier;
                            return _regenerator["default"].wrap(function _callee31$(_context31) {
                                while (1) {
                                    switch (_context31.prev = _context31.next) {
                                        case 0:
                                            transactionId = _ToDeviceChannel.ToDeviceChannel.makeTransactionId();
                                            channel = new _ToDeviceChannel.ToDeviceChannel(this._baseApis, userId, [deviceId], transactionId, deviceId);
                                            request = new _VerificationRequest.VerificationRequest(channel, this._verificationMethods, this._baseApis);
                                            this._toDeviceVerificationRequests.setRequestBySenderAndTxnId(userId, transactionId, request);
                                            verifier = request.beginKeyVerification(method, {
                                                userId: userId,
                                                deviceId: deviceId
                                            });
                                            _context31.next = 7;
                                            return Promise.race([verifier.verify(), request.waitFor(function (r) {
                                                    return r.started;
                                                })]);
                                        case 7:
                                            return _context31.abrupt("return", request);
                                        case 8:
                                        case "end":
                                            return _context31.stop();
                                    }
                                }
                            }, _callee31, this);
                        }));
                        return function (_x32, _x33, _x34) {
                            return _ref43.apply(this, arguments);
                        };
                    }();
                    Crypto.prototype.getOlmSessionsForUser = function () {
                        var _ref44 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee32(userId) {
                            var devices, result, j, device, deviceKey, sessions;
                            return _regenerator["default"].wrap(function _callee32$(_context32) {
                                while (1) {
                                    switch (_context32.prev = _context32.next) {
                                        case 0:
                                            devices = this.getStoredDevicesForUser(userId) || [];
                                            result = {};
                                            j = 0;
                                        case 3:
                                            if (!(j < devices.length)) {
                                                _context32.next = 13;
                                                break;
                                            }
                                            device = devices[j];
                                            deviceKey = device.getIdentityKey();
                                            _context32.next = 8;
                                            return this._olmDevice.getSessionInfoForDevice(deviceKey);
                                        case 8:
                                            sessions = _context32.sent;
                                            result[device.deviceId] = {
                                                deviceIdKey: deviceKey,
                                                sessions: sessions
                                            };
                                        case 10:
                                            ++j;
                                            _context32.next = 3;
                                            break;
                                        case 13:
                                            return _context32.abrupt("return", result);
                                        case 14:
                                        case "end":
                                            return _context32.stop();
                                    }
                                }
                            }, _callee32, this);
                        }));
                        return function (_x35) {
                            return _ref44.apply(this, arguments);
                        };
                    }();
                    Crypto.prototype.getEventSenderDeviceInfo = function (event) {
                        var senderKey = event.getSenderKey();
                        var algorithm = event.getWireContent().algorithm;
                        if (!senderKey || !algorithm) {
                            return null;
                        }
                        var forwardingChain = event.getForwardingCurve25519KeyChain();
                        if (forwardingChain.length > 0) {
                            return null;
                        }
                        if (event.isKeySourceUntrusted()) {
                            return null;
                        }
                        var device = this._deviceList.getDeviceByIdentityKey(algorithm, senderKey);
                        if (device === null) {
                            return null;
                        }
                        var claimedKey = event.getClaimedEd25519Key();
                        if (!claimedKey) {
                            _logger.logger.warn("Event " + event.getId() + " claims no ed25519 key: " + "cannot verify sending device");
                            return null;
                        }
                        if (claimedKey !== device.getFingerprint()) {
                            _logger.logger.warn("Event " + event.getId() + " claims ed25519 key " + claimedKey + " but sender device has key " + device.getFingerprint());
                            return null;
                        }
                        return device;
                    };
                    Crypto.prototype.getEventEncryptionInfo = function (event) {
                        var ret = {};
                        ret.senderKey = event.getSenderKey();
                        ret.algorithm = event.getWireContent().algorithm;
                        if (!ret.senderKey || !ret.algorithm) {
                            ret.encrypted = false;
                            return ret;
                        }
                        ret.encrypted = true;
                        var forwardingChain = event.getForwardingCurve25519KeyChain();
                        if (forwardingChain.length > 0 || event.isKeySourceUntrusted()) {
                            ret.authenticated = false;
                        }
                        else {
                            ret.authenticated = true;
                        }
                        ret.sender = this._deviceList.getDeviceByIdentityKey(ret.algorithm, ret.senderKey);
                        var claimedKey = event.getClaimedEd25519Key();
                        if (!claimedKey) {
                            _logger.logger.warn("Event " + event.getId() + " claims no ed25519 key: " + "cannot verify sending device");
                            ret.mismatchedSender = true;
                        }
                        if (ret.sender && claimedKey !== ret.sender.getFingerprint()) {
                            _logger.logger.warn("Event " + event.getId() + " claims ed25519 key " + claimedKey + "but sender device has key " + ret.sender.getFingerprint());
                            ret.mismatchedSender = true;
                        }
                        return ret;
                    };
                    Crypto.prototype.forceDiscardSession = function (roomId) {
                        var alg = this._roomEncryptors[roomId];
                        if (alg === undefined)
                            throw new Error("Room not encrypted");
                        if (alg.forceDiscardSession === undefined) {
                            throw new Error("Room encryption algorithm doesn't support session discarding");
                        }
                        alg.forceDiscardSession();
                    };
                    Crypto.prototype.setRoomEncryption = function () {
                        var _ref45 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee33(roomId, config, inhibitDeviceQuery) {
                            var existingConfig, existingAlg, storeConfigPromise, AlgClass, alg;
                            return _regenerator["default"].wrap(function _callee33$(_context33) {
                                while (1) {
                                    switch (_context33.prev = _context33.next) {
                                        case 0:
                                            if (config.algorithm) {
                                                _context33.next = 3;
                                                break;
                                            }
                                            _logger.logger.log("Ignoring setRoomEncryption with no algorithm");
                                            return _context33.abrupt("return");
                                        case 3:
                                            existingConfig = this._roomList.getRoomEncryption(roomId);
                                            if (!existingConfig) {
                                                _context33.next = 8;
                                                break;
                                            }
                                            if (!(JSON.stringify(existingConfig) != JSON.stringify(config))) {
                                                _context33.next = 8;
                                                break;
                                            }
                                            _logger.logger.error("Ignoring m.room.encryption event which requests " + "a change of config in " + roomId);
                                            return _context33.abrupt("return");
                                        case 8:
                                            existingAlg = this._roomEncryptors[roomId];
                                            if (!existingAlg) {
                                                _context33.next = 11;
                                                break;
                                            }
                                            return _context33.abrupt("return");
                                        case 11:
                                            storeConfigPromise = null;
                                            if (!existingConfig) {
                                                storeConfigPromise = this._roomList.setRoomEncryption(roomId, config);
                                            }
                                            AlgClass = algorithms.ENCRYPTION_CLASSES[config.algorithm];
                                            if (AlgClass) {
                                                _context33.next = 16;
                                                break;
                                            }
                                            throw new Error("Unable to encrypt with " + config.algorithm);
                                        case 16:
                                            alg = new AlgClass({
                                                userId: this._userId,
                                                deviceId: this._deviceId,
                                                crypto: this,
                                                olmDevice: this._olmDevice,
                                                baseApis: this._baseApis,
                                                roomId: roomId,
                                                config: config
                                            });
                                            this._roomEncryptors[roomId] = alg;
                                            if (!storeConfigPromise) {
                                                _context33.next = 21;
                                                break;
                                            }
                                            _context33.next = 21;
                                            return storeConfigPromise;
                                        case 21:
                                            if (this._lazyLoadMembers) {
                                                _context33.next = 28;
                                                break;
                                            }
                                            _logger.logger.log("Enabling encryption in " + roomId + "; " + "starting to track device lists for all users therein");
                                            _context33.next = 25;
                                            return this.trackRoomDevices(roomId);
                                        case 25:
                                            if (!this.inhibitDeviceQuery) {
                                                this._deviceList.refreshOutdatedDeviceLists();
                                            }
                                            _context33.next = 29;
                                            break;
                                        case 28:
                                            _logger.logger.log("Enabling encryption in " + roomId);
                                        case 29:
                                        case "end":
                                            return _context33.stop();
                                    }
                                }
                            }, _callee33, this);
                        }));
                        return function (_x36, _x37, _x38) {
                            return _ref45.apply(this, arguments);
                        };
                    }();
                    Crypto.prototype.trackRoomDevices = function (roomId) {
                        var _this11 = this;
                        var trackMembers = function () {
                            var _ref46 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee34() {
                                var room, members;
                                return _regenerator["default"].wrap(function _callee34$(_context34) {
                                    while (1) {
                                        switch (_context34.prev = _context34.next) {
                                            case 0:
                                                if (_this11._roomEncryptors[roomId]) {
                                                    _context34.next = 2;
                                                    break;
                                                }
                                                return _context34.abrupt("return");
                                            case 2:
                                                room = _this11._clientStore.getRoom(roomId);
                                                if (room) {
                                                    _context34.next = 5;
                                                    break;
                                                }
                                                throw new Error("Unable to start tracking devices in unknown room ".concat(roomId));
                                            case 5:
                                                _logger.logger.log("Starting to track devices for room ".concat(roomId, " ..."));
                                                _context34.next = 8;
                                                return room.getEncryptionTargetMembers();
                                            case 8:
                                                members = _context34.sent;
                                                members.forEach(function (m) {
                                                    _this11._deviceList.startTrackingDeviceList(m.userId);
                                                });
                                            case 10:
                                            case "end":
                                                return _context34.stop();
                                        }
                                    }
                                }, _callee34);
                            }));
                            return function trackMembers() {
                                return _ref46.apply(this, arguments);
                            };
                        }();
                        var promise = this._roomDeviceTrackingState[roomId];
                        if (!promise) {
                            promise = trackMembers();
                            this._roomDeviceTrackingState[roomId] = promise["catch"](function (err) {
                                _this11._roomDeviceTrackingState[roomId] = null;
                                throw err;
                            });
                        }
                        return promise;
                    };
                    Crypto.prototype.ensureOlmSessionsForUsers = function (users) {
                        var devicesByUser = {};
                        for (var i = 0; i < users.length; ++i) {
                            var userId = users[i];
                            devicesByUser[userId] = [];
                            var devices = this.getStoredDevicesForUser(userId) || [];
                            for (var j = 0; j < devices.length; ++j) {
                                var deviceInfo = devices[j];
                                var key = deviceInfo.getIdentityKey();
                                if (key == this._olmDevice.deviceCurve25519Key) {
                                    continue;
                                }
                                if (deviceInfo.verified == DeviceVerification.BLOCKED) {
                                    continue;
                                }
                                devicesByUser[userId].push(deviceInfo);
                            }
                        }
                        return olmlib.ensureOlmSessionsForDevices(this._olmDevice, this._baseApis, devicesByUser);
                    };
                    Crypto.prototype.exportRoomKeys = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee35() {
                        var _this12 = this;
                        var exportedSessions;
                        return _regenerator["default"].wrap(function _callee35$(_context35) {
                            while (1) {
                                switch (_context35.prev = _context35.next) {
                                    case 0:
                                        exportedSessions = [];
                                        _context35.next = 3;
                                        return this._cryptoStore.doTxn('readonly', [_indexeddbCryptoStore.IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS], function (txn) {
                                            _this12._cryptoStore.getAllEndToEndInboundGroupSessions(txn, function (s) {
                                                if (s === null)
                                                    return;
                                                var sess = _this12._olmDevice.exportInboundGroupSession(s.senderKey, s.sessionId, s.sessionData);
                                                delete sess.first_known_index;
                                                sess.algorithm = olmlib.MEGOLM_ALGORITHM;
                                                exportedSessions.push(sess);
                                            });
                                        });
                                    case 3:
                                        return _context35.abrupt("return", exportedSessions);
                                    case 4:
                                    case "end":
                                        return _context35.stop();
                                }
                            }
                        }, _callee35, this);
                    }));
                    Crypto.prototype.importRoomKeys = function (keys) {
                        var _this13 = this;
                        var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                        var successes = 0;
                        var failures = 0;
                        var total = keys.length;
                        function updateProgress() {
                            opts.progressCallback({
                                stage: "load_keys",
                                successes: successes,
                                failures: failures,
                                total: total
                            });
                        }
                        return Promise.all(keys.map(function (key) {
                            if (!key.room_id || !key.algorithm) {
                                _logger.logger.warn("ignoring room key entry with missing fields", key);
                                failures++;
                                if (opts.progressCallback) {
                                    updateProgress();
                                }
                                return null;
                            }
                            var alg = _this13._getRoomDecryptor(key.room_id, key.algorithm);
                            return alg.importRoomKey(key, opts)["finally"](function (r) {
                                successes++;
                                if (opts.progressCallback) {
                                    updateProgress();
                                }
                            });
                        }));
                    };
                    Crypto.prototype.scheduleKeyBackupSend = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee36() {
                        var maxDelay, delay, numFailures, numBackedUp, _args36 = arguments;
                        return _regenerator["default"].wrap(function _callee36$(_context36) {
                            while (1) {
                                switch (_context36.prev = _context36.next) {
                                    case 0:
                                        maxDelay = _args36.length > 0 && _args36[0] !== undefined ? _args36[0] : 10000;
                                        if (!this._sendingBackups) {
                                            _context36.next = 3;
                                            break;
                                        }
                                        return _context36.abrupt("return");
                                    case 3:
                                        this._sendingBackups = true;
                                        _context36.prev = 4;
                                        delay = Math.random() * maxDelay;
                                        _context36.next = 8;
                                        return (0, utils.sleep)(delay);
                                    case 8:
                                        numFailures = 0;
                                    case 9:
                                        if (!1) {
                                            _context36.next = 36;
                                            break;
                                        }
                                        if (this.backupKey) {
                                            _context36.next = 12;
                                            break;
                                        }
                                        return _context36.abrupt("return");
                                    case 12:
                                        _context36.prev = 12;
                                        _context36.next = 15;
                                        return this._backupPendingKeys(KEY_BACKUP_KEYS_PER_REQUEST);
                                    case 15:
                                        numBackedUp = _context36.sent;
                                        if (!(numBackedUp === 0)) {
                                            _context36.next = 18;
                                            break;
                                        }
                                        return _context36.abrupt("return");
                                    case 18:
                                        numFailures = 0;
                                        _context36.next = 31;
                                        break;
                                    case 21:
                                        _context36.prev = 21;
                                        _context36.t0 = _context36["catch"](12);
                                        numFailures++;
                                        _logger.logger.log("Key backup request failed", _context36.t0);
                                        if (!_context36.t0.data) {
                                            _context36.next = 31;
                                            break;
                                        }
                                        if (!(_context36.t0.data.errcode == 'M_NOT_FOUND' || _context36.t0.data.errcode == 'M_WRONG_ROOM_KEYS_VERSION')) {
                                            _context36.next = 31;
                                            break;
                                        }
                                        _context36.next = 29;
                                        return this.checkKeyBackup();
                                    case 29:
                                        this.emit("crypto.keyBackupFailed", _context36.t0.data.errcode);
                                        throw _context36.t0;
                                    case 31:
                                        if (!numFailures) {
                                            _context36.next = 34;
                                            break;
                                        }
                                        _context36.next = 34;
                                        return (0, utils.sleep)(1000 * Math.pow(2, Math.min(numFailures - 1, 4)));
                                    case 34:
                                        _context36.next = 9;
                                        break;
                                    case 36:
                                        _context36.prev = 36;
                                        this._sendingBackups = false;
                                        return _context36.finish(36);
                                    case 39:
                                    case "end":
                                        return _context36.stop();
                                }
                            }
                        }, _callee36, this, [[4, , 36, 39], [12, 21]]);
                    }));
                    Crypto.prototype._backupPendingKeys = function () {
                        var _ref49 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee37(limit) {
                            var sessions, remaining, data, _iterator4, _step4, session, roomId, sessionData, firstKnownIndex, encrypted, forwardedCount, userId, device, verified;
                            return _regenerator["default"].wrap(function _callee37$(_context37) {
                                while (1) {
                                    switch (_context37.prev = _context37.next) {
                                        case 0:
                                            _context37.next = 2;
                                            return this._cryptoStore.getSessionsNeedingBackup(limit);
                                        case 2:
                                            sessions = _context37.sent;
                                            if (sessions.length) {
                                                _context37.next = 5;
                                                break;
                                            }
                                            return _context37.abrupt("return", 0);
                                        case 5:
                                            _context37.next = 7;
                                            return this._cryptoStore.countSessionsNeedingBackup();
                                        case 7:
                                            remaining = _context37.sent;
                                            this.emit("crypto.keyBackupSessionsRemaining", remaining);
                                            data = {};
                                            _iterator4 = _createForOfIteratorHelper(sessions);
                                            _context37.prev = 11;
                                            _iterator4.s();
                                        case 13:
                                            if ((_step4 = _iterator4.n()).done) {
                                                _context37.next = 33;
                                                break;
                                            }
                                            session = _step4.value;
                                            roomId = session.sessionData.room_id;
                                            if (data[roomId] === undefined) {
                                                data[roomId] = {
                                                    sessions: {}
                                                };
                                            }
                                            _context37.next = 19;
                                            return this._olmDevice.exportInboundGroupSession(session.senderKey, session.sessionId, session.sessionData);
                                        case 19:
                                            sessionData = _context37.sent;
                                            sessionData.algorithm = olmlib.MEGOLM_ALGORITHM;
                                            delete sessionData.session_id;
                                            delete sessionData.room_id;
                                            firstKnownIndex = sessionData.first_known_index;
                                            delete sessionData.first_known_index;
                                            encrypted = this.backupKey.encrypt(JSON.stringify(sessionData));
                                            forwardedCount = (sessionData.forwarding_curve25519_key_chain || []).length;
                                            userId = this._deviceList.getUserByIdentityKey(olmlib.MEGOLM_ALGORITHM, session.senderKey);
                                            device = this._deviceList.getDeviceByIdentityKey(olmlib.MEGOLM_ALGORITHM, session.senderKey);
                                            verified = this._checkDeviceInfoTrust(userId, device).isVerified();
                                            data[roomId]['sessions'][session.sessionId] = {
                                                first_message_index: firstKnownIndex,
                                                forwarded_count: forwardedCount,
                                                is_verified: verified,
                                                session_data: encrypted
                                            };
                                        case 31:
                                            _context37.next = 13;
                                            break;
                                        case 33:
                                            _context37.next = 38;
                                            break;
                                        case 35:
                                            _context37.prev = 35;
                                            _context37.t0 = _context37["catch"](11);
                                            _iterator4.e(_context37.t0);
                                        case 38:
                                            _context37.prev = 38;
                                            _iterator4.f();
                                            return _context37.finish(38);
                                        case 41:
                                            _context37.next = 43;
                                            return this._baseApis.sendKeyBackup(undefined, undefined, this.backupInfo.version, {
                                                rooms: data
                                            });
                                        case 43:
                                            _context37.next = 45;
                                            return this._cryptoStore.unmarkSessionsNeedingBackup(sessions);
                                        case 45:
                                            _context37.next = 47;
                                            return this._cryptoStore.countSessionsNeedingBackup();
                                        case 47:
                                            remaining = _context37.sent;
                                            this.emit("crypto.keyBackupSessionsRemaining", remaining);
                                            return _context37.abrupt("return", sessions.length);
                                        case 50:
                                        case "end":
                                            return _context37.stop();
                                    }
                                }
                            }, _callee37, this, [[11, 35, 38, 41]]);
                        }));
                        return function (_x39) {
                            return _ref49.apply(this, arguments);
                        };
                    }();
                    Crypto.prototype.backupGroupSession = function () {
                        var _ref50 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee38(roomId, senderKey, forwardingCurve25519KeyChain, sessionId, sessionKey, keysClaimed, exportFormat) {
                            return _regenerator["default"].wrap(function _callee38$(_context38) {
                                while (1) {
                                    switch (_context38.prev = _context38.next) {
                                        case 0:
                                            _context38.next = 2;
                                            return this._cryptoStore.markSessionsNeedingBackup([{
                                                    senderKey: senderKey,
                                                    sessionId: sessionId
                                                }]);
                                        case 2:
                                            if (this.backupInfo) {
                                                this.scheduleKeyBackupSend();
                                            }
                                        case 3:
                                        case "end":
                                            return _context38.stop();
                                    }
                                }
                            }, _callee38, this);
                        }));
                        return function (_x40, _x41, _x42, _x43, _x44, _x45, _x46) {
                            return _ref50.apply(this, arguments);
                        };
                    }();
                    Crypto.prototype.scheduleAllGroupSessionsForBackup = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee39() {
                        return _regenerator["default"].wrap(function _callee39$(_context39) {
                            while (1) {
                                switch (_context39.prev = _context39.next) {
                                    case 0:
                                        _context39.next = 2;
                                        return this.flagAllGroupSessionsForBackup();
                                    case 2:
                                        this.scheduleKeyBackupSend(0);
                                    case 3:
                                    case "end":
                                        return _context39.stop();
                                }
                            }
                        }, _callee39, this);
                    }));
                    Crypto.prototype.flagAllGroupSessionsForBackup = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee40() {
                        var _this14 = this;
                        var remaining;
                        return _regenerator["default"].wrap(function _callee40$(_context40) {
                            while (1) {
                                switch (_context40.prev = _context40.next) {
                                    case 0:
                                        _context40.next = 2;
                                        return this._cryptoStore.doTxn('readwrite', [_indexeddbCryptoStore.IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS, _indexeddbCryptoStore.IndexedDBCryptoStore.STORE_BACKUP], function (txn) {
                                            _this14._cryptoStore.getAllEndToEndInboundGroupSessions(txn, function (session) {
                                                if (session !== null) {
                                                    _this14._cryptoStore.markSessionsNeedingBackup([session], txn);
                                                }
                                            });
                                        });
                                    case 2:
                                        _context40.next = 4;
                                        return this._cryptoStore.countSessionsNeedingBackup();
                                    case 4:
                                        remaining = _context40.sent;
                                        this.emit("crypto.keyBackupSessionsRemaining", remaining);
                                        return _context40.abrupt("return", remaining);
                                    case 7:
                                    case "end":
                                        return _context40.stop();
                                }
                            }
                        }, _callee40, this);
                    }));
                    Crypto.prototype.countSessionsNeedingBackup = function () {
                        return this._cryptoStore.countSessionsNeedingBackup();
                    };
                    Crypto.prototype.prepareToEncrypt = function (room) {
                        var roomId = room.roomId;
                        var alg = this._roomEncryptors[roomId];
                        if (alg) {
                            alg.prepareToEncrypt(room);
                        }
                    };
                    Crypto.prototype.encryptEvent = function () {
                        var _ref53 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee41(event, room) {
                            var roomId, alg, content, mRelatesTo, encryptedContent;
                            return _regenerator["default"].wrap(function _callee41$(_context41) {
                                while (1) {
                                    switch (_context41.prev = _context41.next) {
                                        case 0:
                                            if (room) {
                                                _context41.next = 2;
                                                break;
                                            }
                                            throw new Error("Cannot send encrypted messages in unknown rooms");
                                        case 2:
                                            roomId = event.getRoomId();
                                            alg = this._roomEncryptors[roomId];
                                            if (alg) {
                                                _context41.next = 6;
                                                break;
                                            }
                                            throw new Error("Room was previously configured to use encryption, but is " + "no longer. Perhaps the homeserver is hiding the " + "configuration event.");
                                        case 6:
                                            if (!this._roomDeviceTrackingState[roomId]) {
                                                this.trackRoomDevices(roomId);
                                            }
                                            _context41.next = 9;
                                            return this._roomDeviceTrackingState[roomId];
                                        case 9:
                                            content = event.getContent();
                                            mRelatesTo = content['m.relates_to'];
                                            if (mRelatesTo) {
                                                content = Object.assign({}, content);
                                                delete content['m.relates_to'];
                                            }
                                            _context41.next = 14;
                                            return alg.encryptMessage(room, event.getType(), content);
                                        case 14:
                                            encryptedContent = _context41.sent;
                                            if (mRelatesTo) {
                                                encryptedContent['m.relates_to'] = mRelatesTo;
                                            }
                                            event.makeEncrypted("m.room.encrypted", encryptedContent, this._olmDevice.deviceCurve25519Key, this._olmDevice.deviceEd25519Key);
                                        case 17:
                                        case "end":
                                            return _context41.stop();
                                    }
                                }
                            }, _callee41, this);
                        }));
                        return function (_x47, _x48) {
                            return _ref53.apply(this, arguments);
                        };
                    }();
                    Crypto.prototype.decryptEvent = function () {
                        var _ref54 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee42(event) {
                            var redactionEvent, decryptedEvent, content, alg;
                            return _regenerator["default"].wrap(function _callee42$(_context42) {
                                while (1) {
                                    switch (_context42.prev = _context42.next) {
                                        case 0:
                                            if (!event.isRedacted()) {
                                                _context42.next = 8;
                                                break;
                                            }
                                            redactionEvent = new _event.MatrixEvent(event.getUnsigned().redacted_because);
                                            _context42.next = 4;
                                            return this.decryptEvent(redactionEvent);
                                        case 4:
                                            decryptedEvent = _context42.sent;
                                            return _context42.abrupt("return", {
                                                clearEvent: {
                                                    room_id: event.getRoomId(),
                                                    type: "m.room.message",
                                                    content: {},
                                                    unsigned: {
                                                        redacted_because: decryptedEvent.clearEvent
                                                    }
                                                }
                                            });
                                        case 8:
                                            content = event.getWireContent();
                                            alg = this._getRoomDecryptor(event.getRoomId(), content.algorithm);
                                            _context42.next = 12;
                                            return alg.decryptEvent(event);
                                        case 12:
                                            return _context42.abrupt("return", _context42.sent);
                                        case 13:
                                        case "end":
                                            return _context42.stop();
                                    }
                                }
                            }, _callee42, this);
                        }));
                        return function (_x49) {
                            return _ref54.apply(this, arguments);
                        };
                    }();
                    Crypto.prototype.handleDeviceListChanges = function () {
                        var _ref55 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee43(syncData, syncDeviceLists) {
                            return _regenerator["default"].wrap(function _callee43$(_context43) {
                                while (1) {
                                    switch (_context43.prev = _context43.next) {
                                        case 0:
                                            if (syncData.oldSyncToken) {
                                                _context43.next = 2;
                                                break;
                                            }
                                            return _context43.abrupt("return");
                                        case 2:
                                            _context43.next = 4;
                                            return this._evalDeviceListChanges(syncDeviceLists);
                                        case 4:
                                        case "end":
                                            return _context43.stop();
                                    }
                                }
                            }, _callee43, this);
                        }));
                        return function (_x50, _x51) {
                            return _ref55.apply(this, arguments);
                        };
                    }();
                    Crypto.prototype.requestRoomKey = function (requestBody, recipients) {
                        var _this15 = this;
                        var resend = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
                        return this._outgoingRoomKeyRequestManager.queueRoomKeyRequest(requestBody, recipients, resend).then(function () {
                            if (_this15._sendKeyRequestsImmediately) {
                                _this15._outgoingRoomKeyRequestManager.sendQueuedRequests();
                            }
                        })["catch"](function (e) {
                            _logger.logger.error('Error requesting key for event', e);
                        });
                    };
                    Crypto.prototype.cancelRoomKeyRequest = function (requestBody) {
                        this._outgoingRoomKeyRequestManager.cancelRoomKeyRequest(requestBody)["catch"](function (e) {
                            _logger.logger.warn("Error clearing pending room key requests", e);
                        });
                    };
                    Crypto.prototype.cancelAndResendAllOutgoingKeyRequests = function () {
                        return this._outgoingRoomKeyRequestManager.cancelAndResendAllOutgoingRequests();
                    };
                    Crypto.prototype.onCryptoEvent = function () {
                        var _ref56 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee44(event) {
                            var roomId, content;
                            return _regenerator["default"].wrap(function _callee44$(_context44) {
                                while (1) {
                                    switch (_context44.prev = _context44.next) {
                                        case 0:
                                            roomId = event.getRoomId();
                                            content = event.getContent();
                                            _context44.prev = 2;
                                            _context44.next = 5;
                                            return this.setRoomEncryption(roomId, content, true);
                                        case 5:
                                            _context44.next = 10;
                                            break;
                                        case 7:
                                            _context44.prev = 7;
                                            _context44.t0 = _context44["catch"](2);
                                            _logger.logger.error("Error configuring encryption in room " + roomId + ":", _context44.t0);
                                        case 10:
                                        case "end":
                                            return _context44.stop();
                                    }
                                }
                            }, _callee44, this, [[2, 7]]);
                        }));
                        return function (_x52) {
                            return _ref56.apply(this, arguments);
                        };
                    }();
                    Crypto.prototype.onSyncWillProcess = function () {
                        var _ref57 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee45(syncData) {
                            return _regenerator["default"].wrap(function _callee45$(_context45) {
                                while (1) {
                                    switch (_context45.prev = _context45.next) {
                                        case 0:
                                            if (!syncData.oldSyncToken) {
                                                _logger.logger.log("Initial sync performed - resetting device tracking state");
                                                this._deviceList.stopTrackingAllDeviceLists();
                                                this._deviceList.startTrackingDeviceList(this._userId);
                                                this._roomDeviceTrackingState = {};
                                            }
                                            this._sendKeyRequestsImmediately = false;
                                        case 2:
                                        case "end":
                                            return _context45.stop();
                                    }
                                }
                            }, _callee45, this);
                        }));
                        return function (_x53) {
                            return _ref57.apply(this, arguments);
                        };
                    }();
                    Crypto.prototype.onSyncCompleted = function () {
                        var _ref58 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee46(syncData) {
                            var nextSyncToken;
                            return _regenerator["default"].wrap(function _callee46$(_context46) {
                                while (1) {
                                    switch (_context46.prev = _context46.next) {
                                        case 0:
                                            nextSyncToken = syncData.nextSyncToken;
                                            this._deviceList.setSyncToken(syncData.nextSyncToken);
                                            this._deviceList.saveIfDirty();
                                            this._deviceList.lastKnownSyncToken = nextSyncToken;
                                            this._deviceList.startTrackingDeviceList(this._userId);
                                            this._deviceList.refreshOutdatedDeviceLists();
                                            if (!syncData.catchingUp) {
                                                _maybeUploadOneTimeKeys(this);
                                                this._processReceivedRoomKeyRequests();
                                                this._outgoingRoomKeyRequestManager.sendQueuedRequests();
                                                this._sendKeyRequestsImmediately = true;
                                            }
                                        case 7:
                                        case "end":
                                            return _context46.stop();
                                    }
                                }
                            }, _callee46, this);
                        }));
                        return function (_x54) {
                            return _ref58.apply(this, arguments);
                        };
                    }();
                    Crypto.prototype._evalDeviceListChanges = function () {
                        var _ref59 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee47(deviceLists) {
                            var _this16 = this;
                            var e2eUserIds;
                            return _regenerator["default"].wrap(function _callee47$(_context47) {
                                while (1) {
                                    switch (_context47.prev = _context47.next) {
                                        case 0:
                                            if (deviceLists.changed && Array.isArray(deviceLists.changed)) {
                                                deviceLists.changed.forEach(function (u) {
                                                    _this16._deviceList.invalidateUserDeviceList(u);
                                                });
                                            }
                                            if (!(deviceLists.left && Array.isArray(deviceLists.left) && deviceLists.left.length)) {
                                                _context47.next = 8;
                                                break;
                                            }
                                            _context47.t0 = Set;
                                            _context47.next = 5;
                                            return this._getTrackedE2eUsers();
                                        case 5:
                                            _context47.t1 = _context47.sent;
                                            e2eUserIds = new _context47.t0(_context47.t1);
                                            deviceLists.left.forEach(function (u) {
                                                if (!e2eUserIds.has(u)) {
                                                    _this16._deviceList.stopTrackingDeviceList(u);
                                                }
                                            });
                                        case 8:
                                        case "end":
                                            return _context47.stop();
                                    }
                                }
                            }, _callee47, this);
                        }));
                        return function (_x55) {
                            return _ref59.apply(this, arguments);
                        };
                    }();
                    Crypto.prototype._getTrackedE2eUsers = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee48() {
                        var e2eUserIds, _iterator5, _step5, room, members, _iterator6, _step6, member;
                        return _regenerator["default"].wrap(function _callee48$(_context48) {
                            while (1) {
                                switch (_context48.prev = _context48.next) {
                                    case 0:
                                        e2eUserIds = [];
                                        _iterator5 = _createForOfIteratorHelper(this._getTrackedE2eRooms());
                                        _context48.prev = 2;
                                        _iterator5.s();
                                    case 4:
                                        if ((_step5 = _iterator5.n()).done) {
                                            _context48.next = 13;
                                            break;
                                        }
                                        room = _step5.value;
                                        _context48.next = 8;
                                        return room.getEncryptionTargetMembers();
                                    case 8:
                                        members = _context48.sent;
                                        _iterator6 = _createForOfIteratorHelper(members);
                                        try {
                                            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                                                member = _step6.value;
                                                e2eUserIds.push(member.userId);
                                            }
                                        }
                                        catch (err) {
                                            _iterator6.e(err);
                                        }
                                        finally {
                                            _iterator6.f();
                                        }
                                    case 11:
                                        _context48.next = 4;
                                        break;
                                    case 13:
                                        _context48.next = 18;
                                        break;
                                    case 15:
                                        _context48.prev = 15;
                                        _context48.t0 = _context48["catch"](2);
                                        _iterator5.e(_context48.t0);
                                    case 18:
                                        _context48.prev = 18;
                                        _iterator5.f();
                                        return _context48.finish(18);
                                    case 21:
                                        return _context48.abrupt("return", e2eUserIds);
                                    case 22:
                                    case "end":
                                        return _context48.stop();
                                }
                            }
                        }, _callee48, this, [[2, 15, 18, 21]]);
                    }));
                    Crypto.prototype._getTrackedE2eRooms = function () {
                        var _this17 = this;
                        return this._clientStore.getRooms().filter(function (room) {
                            var alg = _this17._roomEncryptors[room.roomId];
                            if (!alg) {
                                return false;
                            }
                            if (!_this17._roomDeviceTrackingState[room.roomId]) {
                                return false;
                            }
                            var myMembership = room.getMyMembership();
                            return myMembership === "join" || myMembership === "invite";
                        });
                    };
                    Crypto.prototype._onToDeviceEvent = function (event) {
                        var _this18 = this;
                        try {
                            _logger.logger.log("received to_device ".concat(event.getType(), " from: ") + "".concat(event.getSender(), " id: ").concat(event.getId()));
                            if (event.getType() == "m.room_key" || event.getType() == "m.forwarded_room_key") {
                                this._onRoomKeyEvent(event);
                            }
                            else if (event.getType() == "m.room_key_request") {
                                this._onRoomKeyRequestEvent(event);
                            }
                            else if (event.getType() === "m.secret.request") {
                                this._secretStorage._onRequestReceived(event);
                            }
                            else if (event.getType() === "m.secret.send") {
                                this._secretStorage._onSecretReceived(event);
                            }
                            else if (event.getType() === "org.matrix.room_key.withheld") {
                                this._onRoomKeyWithheldEvent(event);
                            }
                            else if (event.getContent().transaction_id) {
                                this._onKeyVerificationMessage(event);
                            }
                            else if (event.getContent().msgtype === "m.bad.encrypted") {
                                this._onToDeviceBadEncrypted(event);
                            }
                            else if (event.isBeingDecrypted()) {
                                event.once('Event.decrypted', function (ev) {
                                    _this18._onToDeviceEvent(ev);
                                });
                            }
                        }
                        catch (e) {
                            _logger.logger.error("Error handling toDeviceEvent:", e);
                        }
                    };
                    Crypto.prototype._onRoomKeyEvent = function (event) {
                        var content = event.getContent();
                        if (!content.room_id || !content.algorithm) {
                            _logger.logger.error("key event is missing fields");
                            return;
                        }
                        if (!this._checkedForBackup) {
                            this._checkAndStartKeyBackup();
                        }
                        var alg = this._getRoomDecryptor(content.room_id, content.algorithm);
                        alg.onRoomKeyEvent(event);
                    };
                    Crypto.prototype._onRoomKeyWithheldEvent = function (event) {
                        var content = event.getContent();
                        if (content.code !== "m.no_olm" && (!content.room_id || !content.session_id) || !content.algorithm || !content.sender_key) {
                            _logger.logger.error("key withheld event is missing fields");
                            return;
                        }
                        _logger.logger.info("Got room key withheld event from ".concat(event.getSender(), " (").concat(content.sender_key, ") ") + "for ".concat(content.algorithm, "/").concat(content.room_id, "/").concat(content.session_id, " ") + "with reason ".concat(content.code, " (").concat(content.reason, ")"));
                        var alg = this._getRoomDecryptor(content.room_id, content.algorithm);
                        if (alg.onRoomKeyWithheldEvent) {
                            alg.onRoomKeyWithheldEvent(event);
                        }
                        if (!content.room_id) {
                            var roomDecryptors = this._getRoomDecryptors(content.algorithm);
                            var _iterator7 = _createForOfIteratorHelper(roomDecryptors), _step7;
                            try {
                                for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
                                    var decryptor = _step7.value;
                                    decryptor.retryDecryptionFromSender(content.sender_key);
                                }
                            }
                            catch (err) {
                                _iterator7.e(err);
                            }
                            finally {
                                _iterator7.f();
                            }
                        }
                    };
                    Crypto.prototype._onKeyVerificationMessage = function (event) {
                        var _this19 = this;
                        if (!_ToDeviceChannel.ToDeviceChannel.validateEvent(event, this._baseApis)) {
                            return;
                        }
                        var createRequest = function createRequest(event) {
                            if (!_ToDeviceChannel.ToDeviceChannel.canCreateRequest(_ToDeviceChannel.ToDeviceChannel.getEventType(event))) {
                                return;
                            }
                            var content = event.getContent();
                            var deviceId = content && content.from_device;
                            if (!deviceId) {
                                return;
                            }
                            var userId = event.getSender();
                            var channel = new _ToDeviceChannel.ToDeviceChannel(_this19._baseApis, userId, [deviceId]);
                            return new _VerificationRequest.VerificationRequest(channel, _this19._verificationMethods, _this19._baseApis);
                        };
                        this._handleVerificationEvent(event, this._toDeviceVerificationRequests, createRequest);
                    };
                    Crypto.prototype._onTimelineEvent = function (event, room, atStart, removed) {
                        var _this20 = this;
                        var _ref61 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {}, liveEvent = _ref61.liveEvent;
                        if (!_InRoomChannel.InRoomChannel.validateEvent(event, this._baseApis)) {
                            return;
                        }
                        var createRequest = function createRequest(event) {
                            var channel = new _InRoomChannel.InRoomChannel(_this20._baseApis, event.getRoomId());
                            return new _VerificationRequest.VerificationRequest(channel, _this20._verificationMethods, _this20._baseApis);
                        };
                        this._handleVerificationEvent(event, this._inRoomVerificationRequests, createRequest, liveEvent);
                    };
                    Crypto.prototype._handleVerificationEvent = function () {
                        var _ref62 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee49(event, requestsMap, createRequest) {
                            var isLiveEvent, request, isNewRequest, shouldEmit, _args49 = arguments;
                            return _regenerator["default"].wrap(function _callee49$(_context49) {
                                while (1) {
                                    switch (_context49.prev = _context49.next) {
                                        case 0:
                                            isLiveEvent = _args49.length > 3 && _args49[3] !== undefined ? _args49[3] : true;
                                            request = requestsMap.getRequest(event);
                                            isNewRequest = false;
                                            if (request) {
                                                _context49.next = 10;
                                                break;
                                            }
                                            request = createRequest(event);
                                            if (request) {
                                                _context49.next = 8;
                                                break;
                                            }
                                            _logger.logger.log("Crypto: could not find VerificationRequest for " + "".concat(event.getType(), ", and could not create one, so ignoring."));
                                            return _context49.abrupt("return");
                                        case 8:
                                            isNewRequest = true;
                                            requestsMap.setRequest(event, request);
                                        case 10:
                                            event.setVerificationRequest(request);
                                            _context49.prev = 11;
                                            _context49.next = 14;
                                            return request.channel.handleEvent(event, request, isLiveEvent);
                                        case 14:
                                            _context49.next = 19;
                                            break;
                                        case 16:
                                            _context49.prev = 16;
                                            _context49.t0 = _context49["catch"](11);
                                            _logger.logger.error("error while handling verification event: " + _context49.t0.message);
                                        case 19:
                                            shouldEmit = isNewRequest && !request.initiatedByMe && !request.invalid &&
                                                !request.observeOnly;
                                            if (shouldEmit) {
                                                this._baseApis.emit("crypto.verification.request", request);
                                            }
                                        case 21:
                                        case "end":
                                            return _context49.stop();
                                    }
                                }
                            }, _callee49, this, [[11, 16]]);
                        }));
                        return function (_x56, _x57, _x58) {
                            return _ref62.apply(this, arguments);
                        };
                    }();
                    Crypto.prototype._onToDeviceBadEncrypted = function () {
                        var _ref63 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee50(event) {
                            var _this21 = this;
                            var content, sender, algorithm, deviceKey, retryDecryption, lastNewSessionForced, device, devicesByUser, encryptedContent, requestsToResend, _iterator9, _step9, keyReq;
                            return _regenerator["default"].wrap(function _callee50$(_context50) {
                                while (1) {
                                    switch (_context50.prev = _context50.next) {
                                        case 0:
                                            content = event.getWireContent();
                                            sender = event.getSender();
                                            algorithm = content.algorithm;
                                            deviceKey = content.sender_key;
                                            retryDecryption = function retryDecryption() {
                                                var roomDecryptors = _this21._getRoomDecryptors(olmlib.MEGOLM_ALGORITHM);
                                                var _iterator8 = _createForOfIteratorHelper(roomDecryptors), _step8;
                                                try {
                                                    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
                                                        var decryptor = _step8.value;
                                                        decryptor.retryDecryptionFromSender(deviceKey);
                                                    }
                                                }
                                                catch (err) {
                                                    _iterator8.e(err);
                                                }
                                                finally {
                                                    _iterator8.f();
                                                }
                                            };
                                            if (!(sender === undefined || deviceKey === undefined || deviceKey === undefined)) {
                                                _context50.next = 7;
                                                break;
                                            }
                                            return _context50.abrupt("return");
                                        case 7:
                                            this._lastNewSessionForced[sender] = this._lastNewSessionForced[sender] || {};
                                            lastNewSessionForced = this._lastNewSessionForced[sender][deviceKey] || 0;
                                            if (!(lastNewSessionForced + MIN_FORCE_SESSION_INTERVAL_MS > Date.now())) {
                                                _context50.next = 15;
                                                break;
                                            }
                                            _logger.logger.debug("New session already forced with device " + sender + ":" + deviceKey + " at " + lastNewSessionForced + ": not forcing another");
                                            _context50.next = 13;
                                            return this._olmDevice.recordSessionProblem(deviceKey, "wedged", true);
                                        case 13:
                                            retryDecryption();
                                            return _context50.abrupt("return");
                                        case 15:
                                            device = this._deviceList.getDeviceByIdentityKey(algorithm, deviceKey);
                                            if (device) {
                                                _context50.next = 26;
                                                break;
                                            }
                                            _context50.next = 19;
                                            return this.downloadKeys([sender], false);
                                        case 19:
                                            device = this._deviceList.getDeviceByIdentityKey(algorithm, deviceKey);
                                            if (device) {
                                                _context50.next = 26;
                                                break;
                                            }
                                            _logger.logger.info("Couldn't find device for identity key " + deviceKey + ": not re-establishing session");
                                            _context50.next = 24;
                                            return this._olmDevice.recordSessionProblem(deviceKey, "wedged", false);
                                        case 24:
                                            retryDecryption();
                                            return _context50.abrupt("return");
                                        case 26:
                                            devicesByUser = {};
                                            devicesByUser[sender] = [device];
                                            _context50.next = 30;
                                            return olmlib.ensureOlmSessionsForDevices(this._olmDevice, this._baseApis, devicesByUser, true);
                                        case 30:
                                            this._lastNewSessionForced[sender][deviceKey] = Date.now();
                                            encryptedContent = {
                                                algorithm: olmlib.OLM_ALGORITHM,
                                                sender_key: this._olmDevice.deviceCurve25519Key,
                                                ciphertext: {}
                                            };
                                            _context50.next = 34;
                                            return olmlib.encryptMessageForDevice(encryptedContent.ciphertext, this._userId, this._deviceId, this._olmDevice, sender, device, {
                                                type: "m.dummy"
                                            });
                                        case 34:
                                            _context50.next = 36;
                                            return this._olmDevice.recordSessionProblem(deviceKey, "wedged", true);
                                        case 36:
                                            retryDecryption();
                                            _context50.next = 39;
                                            return this._baseApis.sendToDevice("m.room.encrypted", (0, _defineProperty2["default"])({}, sender, (0, _defineProperty2["default"])({}, device.deviceId, encryptedContent)));
                                        case 39:
                                            _context50.next = 41;
                                            return this._outgoingRoomKeyRequestManager.getOutgoingSentRoomKeyRequest(sender, device.deviceId);
                                        case 41:
                                            requestsToResend = _context50.sent;
                                            _iterator9 = _createForOfIteratorHelper(requestsToResend);
                                            try {
                                                for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
                                                    keyReq = _step9.value;
                                                    this.requestRoomKey(keyReq.requestBody, keyReq.recipients, true);
                                                }
                                            }
                                            catch (err) {
                                                _iterator9.e(err);
                                            }
                                            finally {
                                                _iterator9.f();
                                            }
                                        case 44:
                                        case "end":
                                            return _context50.stop();
                                    }
                                }
                            }, _callee50, this);
                        }));
                        return function (_x59) {
                            return _ref63.apply(this, arguments);
                        };
                    }();
                    Crypto.prototype._onRoomMembership = function (event, member, oldMembership) {
                        var roomId = member.roomId;
                        var alg = this._roomEncryptors[roomId];
                        if (!alg) {
                            return;
                        }
                        if (this._roomDeviceTrackingState[roomId]) {
                            if (member.membership == 'join') {
                                _logger.logger.log('Join event for ' + member.userId + ' in ' + roomId);
                                this._deviceList.startTrackingDeviceList(member.userId);
                            }
                            else if (member.membership == 'invite' && this._clientStore.getRoom(roomId).shouldEncryptForInvitedMembers()) {
                                _logger.logger.log('Invite event for ' + member.userId + ' in ' + roomId);
                                this._deviceList.startTrackingDeviceList(member.userId);
                            }
                        }
                        alg.onRoomMembership(event, member, oldMembership);
                    };
                    Crypto.prototype._onRoomKeyRequestEvent = function (event) {
                        var content = event.getContent();
                        if (content.action === "request") {
                            var req = new IncomingRoomKeyRequest(event);
                            this._receivedRoomKeyRequests.push(req);
                        }
                        else if (content.action === "request_cancellation") {
                            var _req = new IncomingRoomKeyRequestCancellation(event);
                            this._receivedRoomKeyRequestCancellations.push(_req);
                        }
                    };
                    Crypto.prototype._processReceivedRoomKeyRequests = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee51() {
                        var _this22 = this;
                        var requests, cancellations;
                        return _regenerator["default"].wrap(function _callee51$(_context51) {
                            while (1) {
                                switch (_context51.prev = _context51.next) {
                                    case 0:
                                        if (!this._processingRoomKeyRequests) {
                                            _context51.next = 2;
                                            break;
                                        }
                                        return _context51.abrupt("return");
                                    case 2:
                                        this._processingRoomKeyRequests = true;
                                        _context51.prev = 3;
                                        requests = this._receivedRoomKeyRequests;
                                        this._receivedRoomKeyRequests = [];
                                        cancellations = this._receivedRoomKeyRequestCancellations;
                                        this._receivedRoomKeyRequestCancellations = [];
                                        _context51.next = 10;
                                        return Promise.all(requests.map(function (req) {
                                            return _this22._processReceivedRoomKeyRequest(req);
                                        }));
                                    case 10:
                                        _context51.next = 12;
                                        return Promise.all(cancellations.map(function (cancellation) {
                                            return _this22._processReceivedRoomKeyRequestCancellation(cancellation);
                                        }));
                                    case 12:
                                        _context51.next = 17;
                                        break;
                                    case 14:
                                        _context51.prev = 14;
                                        _context51.t0 = _context51["catch"](3);
                                        _logger.logger.error("Error processing room key requsts: ".concat(_context51.t0));
                                    case 17:
                                        _context51.prev = 17;
                                        this._processingRoomKeyRequests = false;
                                        return _context51.finish(17);
                                    case 20:
                                    case "end":
                                        return _context51.stop();
                                }
                            }
                        }, _callee51, this, [[3, 14, 17, 20]]);
                    }));
                    Crypto.prototype._processReceivedRoomKeyRequest = function () {
                        var _ref65 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee52(req) {
                            var userId, deviceId, body, roomId, alg, encryptor, device, decryptor;
                            return _regenerator["default"].wrap(function _callee52$(_context52) {
                                while (1) {
                                    switch (_context52.prev = _context52.next) {
                                        case 0:
                                            userId = req.userId;
                                            deviceId = req.deviceId;
                                            body = req.requestBody;
                                            roomId = body.room_id;
                                            alg = body.algorithm;
                                            _logger.logger.log("m.room_key_request from ".concat(userId, ":").concat(deviceId) + " for ".concat(roomId, " / ").concat(body.session_id, " (id ").concat(req.requestId, ")"));
                                            if (!(userId !== this._userId)) {
                                                _context52.next = 24;
                                                break;
                                            }
                                            if (this._roomEncryptors[roomId]) {
                                                _context52.next = 10;
                                                break;
                                            }
                                            _logger.logger.debug("room key request for unencrypted room ".concat(roomId));
                                            return _context52.abrupt("return");
                                        case 10:
                                            encryptor = this._roomEncryptors[roomId];
                                            device = this._deviceList.getStoredDevice(userId, deviceId);
                                            if (device) {
                                                _context52.next = 15;
                                                break;
                                            }
                                            _logger.logger.debug("Ignoring keyshare for unknown device ".concat(userId, ":").concat(deviceId));
                                            return _context52.abrupt("return");
                                        case 15:
                                            _context52.prev = 15;
                                            _context52.next = 18;
                                            return encryptor.reshareKeyWithDevice(body.sender_key, body.session_id, userId, device);
                                        case 18:
                                            _context52.next = 23;
                                            break;
                                        case 20:
                                            _context52.prev = 20;
                                            _context52.t0 = _context52["catch"](15);
                                            _logger.logger.warn("Failed to re-share keys for session " + body.session_id + " with device " + userId + ":" + device.deviceId, _context52.t0);
                                        case 23:
                                            return _context52.abrupt("return");
                                        case 24:
                                            if (!(deviceId === this._deviceId)) {
                                                _context52.next = 27;
                                                break;
                                            }
                                            _logger.logger.log("Ignoring room key request from ourselves");
                                            return _context52.abrupt("return");
                                        case 27:
                                            if (this._roomDecryptors[roomId]) {
                                                _context52.next = 30;
                                                break;
                                            }
                                            _logger.logger.log("room key request for unencrypted room ".concat(roomId));
                                            return _context52.abrupt("return");
                                        case 30:
                                            decryptor = this._roomDecryptors[roomId][alg];
                                            if (decryptor) {
                                                _context52.next = 34;
                                                break;
                                            }
                                            _logger.logger.log("room key request for unknown alg ".concat(alg, " in room ").concat(roomId));
                                            return _context52.abrupt("return");
                                        case 34:
                                            _context52.next = 36;
                                            return decryptor.hasKeysForKeyRequest(req);
                                        case 36:
                                            if (_context52.sent) {
                                                _context52.next = 39;
                                                break;
                                            }
                                            _logger.logger.log("room key request for unknown session ".concat(roomId, " / ") + body.session_id);
                                            return _context52.abrupt("return");
                                        case 39:
                                            req.share = function () {
                                                decryptor.shareKeysWithDevice(req);
                                            };
                                            if (!this.checkDeviceTrust(userId, deviceId).isVerified()) {
                                                _context52.next = 44;
                                                break;
                                            }
                                            _logger.logger.log('device is already verified: sharing keys');
                                            req.share();
                                            return _context52.abrupt("return");
                                        case 44:
                                            this.emit("crypto.roomKeyRequest", req);
                                        case 45:
                                        case "end":
                                            return _context52.stop();
                                    }
                                }
                            }, _callee52, this, [[15, 20]]);
                        }));
                        return function (_x60) {
                            return _ref65.apply(this, arguments);
                        };
                    }();
                    Crypto.prototype._processReceivedRoomKeyRequestCancellation = function () {
                        var _ref66 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee53(cancellation) {
                            return _regenerator["default"].wrap(function _callee53$(_context53) {
                                while (1) {
                                    switch (_context53.prev = _context53.next) {
                                        case 0:
                                            _logger.logger.log("m.room_key_request cancellation for ".concat(cancellation.userId, ":") + "".concat(cancellation.deviceId, " (id ").concat(cancellation.requestId, ")"));
                                            this.emit("crypto.roomKeyRequestCancellation", cancellation);
                                        case 2:
                                        case "end":
                                            return _context53.stop();
                                    }
                                }
                            }, _callee53, this);
                        }));
                        return function (_x61) {
                            return _ref66.apply(this, arguments);
                        };
                    }();
                    Crypto.prototype._getRoomDecryptor = function (roomId, algorithm) {
                        var decryptors;
                        var alg;
                        roomId = roomId || null;
                        if (roomId) {
                            decryptors = this._roomDecryptors[roomId];
                            if (!decryptors) {
                                this._roomDecryptors[roomId] = decryptors = {};
                            }
                            alg = decryptors[algorithm];
                            if (alg) {
                                return alg;
                            }
                        }
                        var AlgClass = algorithms.DECRYPTION_CLASSES[algorithm];
                        if (!AlgClass) {
                            throw new algorithms.DecryptionError('UNKNOWN_ENCRYPTION_ALGORITHM', 'Unknown encryption algorithm "' + algorithm + '".');
                        }
                        alg = new AlgClass({
                            userId: this._userId,
                            crypto: this,
                            olmDevice: this._olmDevice,
                            baseApis: this._baseApis,
                            roomId: roomId
                        });
                        if (decryptors) {
                            decryptors[algorithm] = alg;
                        }
                        return alg;
                    };
                    Crypto.prototype._getRoomDecryptors = function (algorithm) {
                        var decryptors = [];
                        for (var _i5 = 0, _Object$values = Object.values(this._roomDecryptors); _i5 < _Object$values.length; _i5++) {
                            var d = _Object$values[_i5];
                            if (algorithm in d) {
                                decryptors.push(d[algorithm]);
                            }
                        }
                        return decryptors;
                    };
                    Crypto.prototype._signObject = function () {
                        var _ref67 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee54(obj) {
                            var sigs, unsigned;
                            return _regenerator["default"].wrap(function _callee54$(_context54) {
                                while (1) {
                                    switch (_context54.prev = _context54.next) {
                                        case 0:
                                            sigs = obj.signatures || {};
                                            unsigned = obj.unsigned;
                                            delete obj.signatures;
                                            delete obj.unsigned;
                                            sigs[this._userId] = sigs[this._userId] || {};
                                            _context54.next = 7;
                                            return this._olmDevice.sign(_anotherJson["default"].stringify(obj));
                                        case 7:
                                            sigs[this._userId]["ed25519:" + this._deviceId] = _context54.sent;
                                            obj.signatures = sigs;
                                            if (unsigned !== undefined)
                                                obj.unsigned = unsigned;
                                        case 10:
                                        case "end":
                                            return _context54.stop();
                                    }
                                }
                            }, _callee54, this);
                        }));
                        return function (_x62) {
                            return _ref67.apply(this, arguments);
                        };
                    }();
                    var IncomingRoomKeyRequest = function IncomingRoomKeyRequest(event) {
                        (0, _classCallCheck2["default"])(this, IncomingRoomKeyRequest);
                        var content = event.getContent();
                        this.userId = event.getSender();
                        this.deviceId = content.requesting_device_id;
                        this.requestId = content.request_id;
                        this.requestBody = content.body || {};
                        this.share = function () {
                            throw new Error("don't know how to share keys for this request yet");
                        };
                    };
                    var IncomingRoomKeyRequestCancellation = function IncomingRoomKeyRequestCancellation(event) {
                        (0, _classCallCheck2["default"])(this, IncomingRoomKeyRequestCancellation);
                        var content = event.getContent();
                        this.userId = event.getSender();
                        this.deviceId = content.requesting_device_id;
                        this.requestId = content.request_id;
                    };
                }).call(this);
            }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, require("buffer").Buffer);
        }, { "../ReEmitter": 54, "../errors": 91, "../logger": 97, "../models/event": 102, "../utils": 125, "./CrossSigning": 61, "./DeviceList": 62, "./EncryptionSetup": 63, "./OlmDevice": 64, "./OutgoingRoomKeyRequestManager": 65, "./SecretStorage": 67, "./aes": 68, "./algorithms": 70, "./dehydration": 73, "./deviceinfo": 74, "./key_passphrase": 76, "./olmlib": 77, "./recoverykey": 78, "./store/indexeddb-crypto-store": 80, "./verification/IllegalMethod": 85, "./verification/QRCode": 86, "./verification/SAS": 87, "./verification/request/InRoomChannel": 88, "./verification/request/ToDeviceChannel": 89, "./verification/request/VerificationRequest": 90, "@babel/runtime/helpers/asyncToGenerator": 5, "@babel/runtime/helpers/classCallCheck": 6, "@babel/runtime/helpers/defineProperty": 9, "@babel/runtime/helpers/interopRequireDefault": 12, "@babel/runtime/helpers/interopRequireWildcard": 13, "@babel/runtime/helpers/slicedToArray": 22, "@babel/runtime/regenerator": 27, "another-json": 28, "buffer": 34, "events": 36 }], 76: [function (require, module, exports) {
            (function (global) {
                (function () {
                    "use strict";
                    var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
                    Object.defineProperty(exports, "__esModule", {
                        value: true
                    });
                    exports.keyFromAuthData = keyFromAuthData;
                    exports.keyFromPassphrase = keyFromPassphrase;
                    exports.deriveKey = deriveKey;
                    var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
                    var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
                    var _randomstring = require("../randomstring");
                    var DEFAULT_ITERATIONS = 500000;
                    var DEFAULT_BITSIZE = 256;
                    function keyFromAuthData(_x, _x2) {
                        return _keyFromAuthData.apply(this, arguments);
                    }
                    function _keyFromAuthData() {
                        _keyFromAuthData = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee(authData, password) {
                            return _regenerator["default"].wrap(function _callee$(_context) {
                                while (1) {
                                    switch (_context.prev = _context.next) {
                                        case 0:
                                            if (global.Olm) {
                                                _context.next = 2;
                                                break;
                                            }
                                            throw new Error("Olm is not available");
                                        case 2:
                                            if (!(!authData.private_key_salt || !authData.private_key_iterations)) {
                                                _context.next = 4;
                                                break;
                                            }
                                            throw new Error("Salt and/or iterations not found: " + "this backup cannot be restored with a passphrase");
                                        case 4:
                                            _context.next = 6;
                                            return deriveKey(password, authData.private_key_salt, authData.private_key_iterations, authData.private_key_bits || DEFAULT_BITSIZE);
                                        case 6:
                                            return _context.abrupt("return", _context.sent);
                                        case 7:
                                        case "end":
                                            return _context.stop();
                                    }
                                }
                            }, _callee);
                        }));
                        return _keyFromAuthData.apply(this, arguments);
                    }
                    function keyFromPassphrase(_x3) {
                        return _keyFromPassphrase.apply(this, arguments);
                    }
                    function _keyFromPassphrase() {
                        _keyFromPassphrase = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee2(password) {
                            var salt, key;
                            return _regenerator["default"].wrap(function _callee2$(_context2) {
                                while (1) {
                                    switch (_context2.prev = _context2.next) {
                                        case 0:
                                            if (global.Olm) {
                                                _context2.next = 2;
                                                break;
                                            }
                                            throw new Error("Olm is not available");
                                        case 2:
                                            salt = (0, _randomstring.randomString)(32);
                                            _context2.next = 5;
                                            return deriveKey(password, salt, DEFAULT_ITERATIONS, DEFAULT_BITSIZE);
                                        case 5:
                                            key = _context2.sent;
                                            return _context2.abrupt("return", {
                                                key: key,
                                                salt: salt,
                                                iterations: DEFAULT_ITERATIONS
                                            });
                                        case 7:
                                        case "end":
                                            return _context2.stop();
                                    }
                                }
                            }, _callee2);
                        }));
                        return _keyFromPassphrase.apply(this, arguments);
                    }
                    function deriveKey(_x4, _x5, _x6) {
                        return _deriveKey.apply(this, arguments);
                    }
                    function _deriveKey() {
                        _deriveKey = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee3(password, salt, iterations) {
                            var numBits, subtleCrypto, TextEncoder, key, keybits, _args3 = arguments;
                            return _regenerator["default"].wrap(function _callee3$(_context3) {
                                while (1) {
                                    switch (_context3.prev = _context3.next) {
                                        case 0:
                                            numBits = _args3.length > 3 && _args3[3] !== undefined ? _args3[3] : DEFAULT_BITSIZE;
                                            subtleCrypto = global.crypto.subtle;
                                            TextEncoder = global.TextEncoder;
                                            if (!(!subtleCrypto || !TextEncoder)) {
                                                _context3.next = 5;
                                                break;
                                            }
                                            throw new Error("Password-based backup is not avaiable on this platform");
                                        case 5:
                                            _context3.next = 7;
                                            return subtleCrypto.importKey('raw', new TextEncoder().encode(password), {
                                                name: 'PBKDF2'
                                            }, false, ['deriveBits']);
                                        case 7:
                                            key = _context3.sent;
                                            _context3.next = 10;
                                            return subtleCrypto.deriveBits({
                                                name: 'PBKDF2',
                                                salt: new TextEncoder().encode(salt),
                                                iterations: iterations,
                                                hash: 'SHA-512'
                                            }, key, numBits);
                                        case 10:
                                            keybits = _context3.sent;
                                            return _context3.abrupt("return", new Uint8Array(keybits));
                                        case 12:
                                        case "end":
                                            return _context3.stop();
                                    }
                                }
                            }, _callee3);
                        }));
                        return _deriveKey.apply(this, arguments);
                    }
                }).call(this);
            }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, { "../randomstring": 112, "@babel/runtime/helpers/asyncToGenerator": 5, "@babel/runtime/helpers/interopRequireDefault": 12, "@babel/runtime/regenerator": 27 }], 77: [function (require, module, exports) {
            (function (global, Buffer) {
                (function () {
                    "use strict";
                    var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
                    var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
                    Object.defineProperty(exports, "__esModule", {
                        value: true
                    });
                    exports.encryptMessageForDevice = encryptMessageForDevice;
                    exports.getExistingOlmSessions = getExistingOlmSessions;
                    exports.ensureOlmSessionsForDevices = ensureOlmSessionsForDevices;
                    exports.verifySignature = verifySignature;
                    exports.pkSign = pkSign;
                    exports.pkVerify = pkVerify;
                    exports.encodeBase64 = encodeBase64;
                    exports.encodeUnpaddedBase64 = encodeUnpaddedBase64;
                    exports.decodeBase64 = decodeBase64;
                    exports.MEGOLM_BACKUP_ALGORITHM = exports.MEGOLM_ALGORITHM = exports.OLM_ALGORITHM = void 0;
                    var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
                    var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
                    var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
                    var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
                    var _logger = require("../logger");
                    var utils = _interopRequireWildcard(require("../utils"));
                    var _anotherJson = _interopRequireDefault(require("another-json"));
                    function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
                        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                            if (it)
                                o = it;
                            var i = 0;
                            var F = function F() { };
                            return { s: F, n: function n() { if (i >= o.length)
                                    return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F };
                        }
                        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                    } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try {
                            if (!normalCompletion && it["return"] != null)
                                it["return"]();
                        }
                        finally {
                            if (didErr)
                                throw err;
                        } } }; }
                    function _unsupportedIterableToArray(o, minLen) { if (!o)
                        return; if (typeof o === "string")
                        return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor)
                        n = o.constructor.name; if (n === "Map" || n === "Set")
                        return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                        return _arrayLikeToArray(o, minLen); }
                    function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length)
                        len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) {
                        arr2[i] = arr[i];
                    } return arr2; }
                    var OLM_ALGORITHM = "m.olm.v1.curve25519-aes-sha2";
                    exports.OLM_ALGORITHM = OLM_ALGORITHM;
                    var MEGOLM_ALGORITHM = "m.megolm.v1.aes-sha2";
                    exports.MEGOLM_ALGORITHM = MEGOLM_ALGORITHM;
                    var MEGOLM_BACKUP_ALGORITHM = "m.megolm_backup.v1.curve25519-aes-sha2";
                    exports.MEGOLM_BACKUP_ALGORITHM = MEGOLM_BACKUP_ALGORITHM;
                    function encryptMessageForDevice(_x, _x2, _x3, _x4, _x5, _x6, _x7) {
                        return _encryptMessageForDevice.apply(this, arguments);
                    }
                    function _encryptMessageForDevice() {
                        _encryptMessageForDevice = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee(resultsObject, ourUserId, ourDeviceId, olmDevice, recipientUserId, recipientDevice, payloadFields) {
                            var deviceKey, sessionId, payload;
                            return _regenerator["default"].wrap(function _callee$(_context) {
                                while (1) {
                                    switch (_context.prev = _context.next) {
                                        case 0:
                                            deviceKey = recipientDevice.getIdentityKey();
                                            _context.next = 3;
                                            return olmDevice.getSessionIdForDevice(deviceKey);
                                        case 3:
                                            sessionId = _context.sent;
                                            if (!(sessionId === null)) {
                                                _context.next = 6;
                                                break;
                                            }
                                            return _context.abrupt("return");
                                        case 6:
                                            _logger.logger.log("Using sessionid " + sessionId + " for device " + recipientUserId + ":" + recipientDevice.deviceId);
                                            payload = {
                                                sender: ourUserId,
                                                sender_device: ourDeviceId,
                                                keys: {
                                                    "ed25519": olmDevice.deviceEd25519Key
                                                },
                                                recipient: recipientUserId,
                                                recipient_keys: {
                                                    "ed25519": recipientDevice.getFingerprint()
                                                }
                                            };
                                            utils.extend(payload, payloadFields);
                                            _context.next = 11;
                                            return olmDevice.encryptMessage(deviceKey, sessionId, JSON.stringify(payload));
                                        case 11:
                                            resultsObject[deviceKey] = _context.sent;
                                        case 12:
                                        case "end":
                                            return _context.stop();
                                    }
                                }
                            }, _callee);
                        }));
                        return _encryptMessageForDevice.apply(this, arguments);
                    }
                    function getExistingOlmSessions(_x8, _x9, _x10) {
                        return _getExistingOlmSessions.apply(this, arguments);
                    }
                    function _getExistingOlmSessions() {
                        _getExistingOlmSessions = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee3(olmDevice, baseApis, devicesByUser) {
                            var devicesWithoutSession, sessions, promises, _loop, _i, _Object$entries;
                            return _regenerator["default"].wrap(function _callee3$(_context3) {
                                while (1) {
                                    switch (_context3.prev = _context3.next) {
                                        case 0:
                                            devicesWithoutSession = {};
                                            sessions = {};
                                            promises = [];
                                            _loop = function _loop() {
                                                var _Object$entries$_i = (0, _slicedToArray2["default"])(_Object$entries[_i], 2), userId = _Object$entries$_i[0], devices = _Object$entries$_i[1];
                                                var _iterator = _createForOfIteratorHelper(devices), _step;
                                                try {
                                                    var _loop2 = function _loop2() {
                                                        var deviceInfo = _step.value;
                                                        var deviceId = deviceInfo.deviceId;
                                                        var key = deviceInfo.getIdentityKey();
                                                        promises.push((0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee2() {
                                                            var sessionId;
                                                            return _regenerator["default"].wrap(function _callee2$(_context2) {
                                                                while (1) {
                                                                    switch (_context2.prev = _context2.next) {
                                                                        case 0:
                                                                            _context2.next = 2;
                                                                            return olmDevice.getSessionIdForDevice(key, true);
                                                                        case 2:
                                                                            sessionId = _context2.sent;
                                                                            if (sessionId === null) {
                                                                                devicesWithoutSession[userId] = devicesWithoutSession[userId] || [];
                                                                                devicesWithoutSession[userId].push(deviceInfo);
                                                                            }
                                                                            else {
                                                                                sessions[userId] = sessions[userId] || {};
                                                                                sessions[userId][deviceId] = {
                                                                                    device: deviceInfo,
                                                                                    sessionId: sessionId
                                                                                };
                                                                            }
                                                                        case 4:
                                                                        case "end":
                                                                            return _context2.stop();
                                                                    }
                                                                }
                                                            }, _callee2);
                                                        }))());
                                                    };
                                                    for (_iterator.s(); !(_step = _iterator.n()).done;) {
                                                        _loop2();
                                                    }
                                                }
                                                catch (err) {
                                                    _iterator.e(err);
                                                }
                                                finally {
                                                    _iterator.f();
                                                }
                                            };
                                            for (_i = 0, _Object$entries = Object.entries(devicesByUser); _i < _Object$entries.length; _i++) {
                                                _loop();
                                            }
                                            _context3.next = 7;
                                            return Promise.all(promises);
                                        case 7:
                                            return _context3.abrupt("return", [devicesWithoutSession, sessions]);
                                        case 8:
                                        case "end":
                                            return _context3.stop();
                                    }
                                }
                            }, _callee3);
                        }));
                        return _getExistingOlmSessions.apply(this, arguments);
                    }
                    function ensureOlmSessionsForDevices(_x11, _x12, _x13, _x14, _x15, _x16, _x17) {
                        return _ensureOlmSessionsForDevices.apply(this, arguments);
                    }
                    function _ensureOlmSessionsForDevices() {
                        _ensureOlmSessionsForDevices = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee4(olmDevice, baseApis, devicesByUser, force, otkTimeout, failedServers, log) {
                            var devicesWithoutSession, result, resolveSession, _i2, _Object$entries2, _Object$entries2$_i, devices, _iterator2, _step2, _loop3, _ret, _i3, _Object$entries3, _Object$entries3$_i, userId, _devices, _iterator3, _step3, deviceInfo, deviceId, key, forWhom, sessionId, oneTimeKeyAlgorithm, res, taskDetail, _i4, _Object$values, resolver, _failedServers, otkResult, promises, _loop4, _i5, _Object$entries4;
                            return _regenerator["default"].wrap(function _callee4$(_context4) {
                                while (1) {
                                    switch (_context4.prev = _context4.next) {
                                        case 0:
                                            if (typeof force === "number") {
                                                log = failedServers;
                                                failedServers = otkTimeout;
                                                otkTimeout = force;
                                                force = false;
                                            }
                                            if (!log) {
                                                log = _logger.logger;
                                            }
                                            devicesWithoutSession = [];
                                            result = {};
                                            resolveSession = {};
                                            _i2 = 0, _Object$entries2 = Object.entries(devicesByUser);
                                        case 6:
                                            if (!(_i2 < _Object$entries2.length)) {
                                                _context4.next = 29;
                                                break;
                                            }
                                            _Object$entries2$_i = (0, _slicedToArray2["default"])(_Object$entries2[_i2], 2), devices = _Object$entries2$_i[1];
                                            _iterator2 = _createForOfIteratorHelper(devices);
                                            _context4.prev = 9;
                                            _loop3 = function _loop3() {
                                                var deviceInfo = _step2.value;
                                                var key = deviceInfo.getIdentityKey();
                                                if (key === olmDevice.deviceCurve25519Key) {
                                                    return "continue";
                                                }
                                                if (!olmDevice._sessionsInProgress[key]) {
                                                    olmDevice._sessionsInProgress[key] = new Promise(function (resolve) {
                                                        resolveSession[key] = function () {
                                                            delete olmDevice._sessionsInProgress[key];
                                                            resolve.apply(void 0, arguments);
                                                        };
                                                    });
                                                }
                                            };
                                            _iterator2.s();
                                        case 12:
                                            if ((_step2 = _iterator2.n()).done) {
                                                _context4.next = 18;
                                                break;
                                            }
                                            _ret = _loop3();
                                            if (!(_ret === "continue")) {
                                                _context4.next = 16;
                                                break;
                                            }
                                            return _context4.abrupt("continue", 16);
                                        case 16:
                                            _context4.next = 12;
                                            break;
                                        case 18:
                                            _context4.next = 23;
                                            break;
                                        case 20:
                                            _context4.prev = 20;
                                            _context4.t0 = _context4["catch"](9);
                                            _iterator2.e(_context4.t0);
                                        case 23:
                                            _context4.prev = 23;
                                            _iterator2.f();
                                            return _context4.finish(23);
                                        case 26:
                                            _i2++;
                                            _context4.next = 6;
                                            break;
                                        case 29:
                                            _i3 = 0, _Object$entries3 = Object.entries(devicesByUser);
                                        case 30:
                                            if (!(_i3 < _Object$entries3.length)) {
                                                _context4.next = 64;
                                                break;
                                            }
                                            _Object$entries3$_i = (0, _slicedToArray2["default"])(_Object$entries3[_i3], 2), userId = _Object$entries3$_i[0], _devices = _Object$entries3$_i[1];
                                            result[userId] = {};
                                            _iterator3 = _createForOfIteratorHelper(_devices);
                                            _context4.prev = 34;
                                            _iterator3.s();
                                        case 36:
                                            if ((_step3 = _iterator3.n()).done) {
                                                _context4.next = 53;
                                                break;
                                            }
                                            deviceInfo = _step3.value;
                                            deviceId = deviceInfo.deviceId;
                                            key = deviceInfo.getIdentityKey();
                                            if (!(key === olmDevice.deviceCurve25519Key)) {
                                                _context4.next = 44;
                                                break;
                                            }
                                            log.info("Attempted to start session with ourself! Ignoring");
                                            result[userId][deviceId] = {
                                                device: deviceInfo,
                                                sessionId: null
                                            };
                                            return _context4.abrupt("continue", 51);
                                        case 44:
                                            forWhom = "for ".concat(key, " (").concat(userId, ":").concat(deviceId, ")");
                                            _context4.next = 47;
                                            return olmDevice.getSessionIdForDevice(key, resolveSession[key], log);
                                        case 47:
                                            sessionId = _context4.sent;
                                            if (sessionId !== null && resolveSession[key]) {
                                                resolveSession[key]();
                                            }
                                            if (sessionId === null || force) {
                                                if (force) {
                                                    log.info("Forcing new Olm session ".concat(forWhom));
                                                }
                                                else {
                                                    log.info("Making new Olm session ".concat(forWhom));
                                                }
                                                devicesWithoutSession.push([userId, deviceId]);
                                            }
                                            result[userId][deviceId] = {
                                                device: deviceInfo,
                                                sessionId: sessionId
                                            };
                                        case 51:
                                            _context4.next = 36;
                                            break;
                                        case 53:
                                            _context4.next = 58;
                                            break;
                                        case 55:
                                            _context4.prev = 55;
                                            _context4.t1 = _context4["catch"](34);
                                            _iterator3.e(_context4.t1);
                                        case 58:
                                            _context4.prev = 58;
                                            _iterator3.f();
                                            return _context4.finish(58);
                                        case 61:
                                            _i3++;
                                            _context4.next = 30;
                                            break;
                                        case 64:
                                            if (!(devicesWithoutSession.length === 0)) {
                                                _context4.next = 66;
                                                break;
                                            }
                                            return _context4.abrupt("return", result);
                                        case 66:
                                            oneTimeKeyAlgorithm = "signed_curve25519";
                                            taskDetail = "one-time keys for ".concat(devicesWithoutSession.length, " devices");
                                            _context4.prev = 68;
                                            log.debug("Claiming ".concat(taskDetail));
                                            _context4.next = 72;
                                            return baseApis.claimOneTimeKeys(devicesWithoutSession, oneTimeKeyAlgorithm, otkTimeout);
                                        case 72:
                                            res = _context4.sent;
                                            log.debug("Claimed ".concat(taskDetail));
                                            _context4.next = 81;
                                            break;
                                        case 76:
                                            _context4.prev = 76;
                                            _context4.t2 = _context4["catch"](68);
                                            for (_i4 = 0, _Object$values = Object.values(resolveSession); _i4 < _Object$values.length; _i4++) {
                                                resolver = _Object$values[_i4];
                                                resolver();
                                            }
                                            log.log("Failed to claim ".concat(taskDetail), _context4.t2, devicesWithoutSession);
                                            throw _context4.t2;
                                        case 81:
                                            if (failedServers && "failures" in res) {
                                                (_failedServers = failedServers).push.apply(_failedServers, (0, _toConsumableArray2["default"])(Object.keys(res.failures)));
                                            }
                                            otkResult = res.one_time_keys || {};
                                            promises = [];
                                            _loop4 = function _loop4() {
                                                var _Object$entries4$_i = (0, _slicedToArray2["default"])(_Object$entries4[_i5], 2), userId = _Object$entries4$_i[0], devices = _Object$entries4$_i[1];
                                                var userRes = otkResult[userId] || {};
                                                var _loop5 = function _loop5(j) {
                                                    var deviceInfo = devices[j];
                                                    var deviceId = deviceInfo.deviceId;
                                                    var key = deviceInfo.getIdentityKey();
                                                    if (key === olmDevice.deviceCurve25519Key) {
                                                        return "continue";
                                                    }
                                                    if (result[userId][deviceId].sessionId && !force) {
                                                        return "continue";
                                                    }
                                                    var deviceRes = userRes[deviceId] || {};
                                                    var oneTimeKey = null;
                                                    for (var keyId in deviceRes) {
                                                        if (keyId.indexOf(oneTimeKeyAlgorithm + ":") === 0) {
                                                            oneTimeKey = deviceRes[keyId];
                                                        }
                                                    }
                                                    if (!oneTimeKey) {
                                                        log.warn("No one-time keys (alg=".concat(oneTimeKeyAlgorithm, ") ") + "for device ".concat(userId, ":").concat(deviceId));
                                                        if (resolveSession[key]) {
                                                            resolveSession[key]();
                                                        }
                                                        return "continue";
                                                    }
                                                    promises.push(_verifyKeyAndStartSession(olmDevice, oneTimeKey, userId, deviceInfo).then(function (sid) {
                                                        if (resolveSession[key]) {
                                                            resolveSession[key](sid);
                                                        }
                                                        result[userId][deviceId].sessionId = sid;
                                                    }, function (e) {
                                                        if (resolveSession[key]) {
                                                            resolveSession[key]();
                                                        }
                                                        throw e;
                                                    }));
                                                };
                                                for (var j = 0; j < devices.length; j++) {
                                                    var _ret2 = _loop5(j);
                                                    if (_ret2 === "continue")
                                                        continue;
                                                }
                                            };
                                            for (_i5 = 0, _Object$entries4 = Object.entries(devicesByUser); _i5 < _Object$entries4.length; _i5++) {
                                                _loop4();
                                            }
                                            taskDetail = "Olm sessions for ".concat(promises.length, " devices");
                                            log.debug("Starting ".concat(taskDetail));
                                            _context4.next = 90;
                                            return Promise.all(promises);
                                        case 90:
                                            log.debug("Started ".concat(taskDetail));
                                            return _context4.abrupt("return", result);
                                        case 92:
                                        case "end":
                                            return _context4.stop();
                                    }
                                }
                            }, _callee4, null, [[9, 20, 23, 26], [34, 55, 58, 61], [68, 76]]);
                        }));
                        return _ensureOlmSessionsForDevices.apply(this, arguments);
                    }
                    function _verifyKeyAndStartSession(_x18, _x19, _x20, _x21) {
                        return _verifyKeyAndStartSession2.apply(this, arguments);
                    }
                    function _verifyKeyAndStartSession2() {
                        _verifyKeyAndStartSession2 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee5(olmDevice, oneTimeKey, userId, deviceInfo) {
                            var deviceId, sid;
                            return _regenerator["default"].wrap(function _callee5$(_context5) {
                                while (1) {
                                    switch (_context5.prev = _context5.next) {
                                        case 0:
                                            deviceId = deviceInfo.deviceId;
                                            _context5.prev = 1;
                                            _context5.next = 4;
                                            return verifySignature(olmDevice, oneTimeKey, userId, deviceId, deviceInfo.getFingerprint());
                                        case 4:
                                            _context5.next = 10;
                                            break;
                                        case 6:
                                            _context5.prev = 6;
                                            _context5.t0 = _context5["catch"](1);
                                            _logger.logger.error("Unable to verify signature on one-time key for device " + userId + ":" + deviceId + ":", _context5.t0);
                                            return _context5.abrupt("return", null);
                                        case 10:
                                            _context5.prev = 10;
                                            _context5.next = 13;
                                            return olmDevice.createOutboundSession(deviceInfo.getIdentityKey(), oneTimeKey.key);
                                        case 13:
                                            sid = _context5.sent;
                                            _context5.next = 20;
                                            break;
                                        case 16:
                                            _context5.prev = 16;
                                            _context5.t1 = _context5["catch"](10);
                                            _logger.logger.error("Error starting olm session with device " + userId + ":" + deviceId + ": " + _context5.t1);
                                            return _context5.abrupt("return", null);
                                        case 20:
                                            _logger.logger.log("Started new olm sessionid " + sid + " for device " + userId + ":" + deviceId);
                                            return _context5.abrupt("return", sid);
                                        case 22:
                                        case "end":
                                            return _context5.stop();
                                    }
                                }
                            }, _callee5, null, [[1, 6], [10, 16]]);
                        }));
                        return _verifyKeyAndStartSession2.apply(this, arguments);
                    }
                    function verifySignature(_x22, _x23, _x24, _x25, _x26) {
                        return _verifySignature.apply(this, arguments);
                    }
                    function _verifySignature() {
                        _verifySignature = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee6(olmDevice, obj, signingUserId, signingDeviceId, signingKey) {
                            var signKeyId, signatures, userSigs, signature, mangledObj, json;
                            return _regenerator["default"].wrap(function _callee6$(_context6) {
                                while (1) {
                                    switch (_context6.prev = _context6.next) {
                                        case 0:
                                            signKeyId = "ed25519:" + signingDeviceId;
                                            signatures = obj.signatures || {};
                                            userSigs = signatures[signingUserId] || {};
                                            signature = userSigs[signKeyId];
                                            if (signature) {
                                                _context6.next = 6;
                                                break;
                                            }
                                            throw Error("No signature");
                                        case 6:
                                            mangledObj = Object.assign({}, obj);
                                            delete mangledObj.unsigned;
                                            delete mangledObj.signatures;
                                            json = _anotherJson["default"].stringify(mangledObj);
                                            olmDevice.verifySignature(signingKey, json, signature);
                                        case 11:
                                        case "end":
                                            return _context6.stop();
                                    }
                                }
                            }, _callee6);
                        }));
                        return _verifySignature.apply(this, arguments);
                    }
                    function pkSign(obj, key, userId, pubkey) {
                        var createdKey = false;
                        if (key instanceof Uint8Array) {
                            var keyObj = new global.Olm.PkSigning();
                            pubkey = keyObj.init_with_seed(key);
                            key = keyObj;
                            createdKey = true;
                        }
                        var sigs = obj.signatures || {};
                        delete obj.signatures;
                        var unsigned = obj.unsigned;
                        if (obj.unsigned)
                            delete obj.unsigned;
                        try {
                            var mysigs = sigs[userId] || {};
                            sigs[userId] = mysigs;
                            return mysigs['ed25519:' + pubkey] = key.sign(_anotherJson["default"].stringify(obj));
                        }
                        finally {
                            obj.signatures = sigs;
                            if (unsigned)
                                obj.unsigned = unsigned;
                            if (createdKey) {
                                key.free();
                            }
                        }
                    }
                    function pkVerify(obj, pubkey, userId) {
                        var keyId = "ed25519:" + pubkey;
                        if (!(obj.signatures && obj.signatures[userId] && obj.signatures[userId][keyId])) {
                            throw new Error("No signature");
                        }
                        var signature = obj.signatures[userId][keyId];
                        var util = new global.Olm.Utility();
                        var sigs = obj.signatures;
                        delete obj.signatures;
                        var unsigned = obj.unsigned;
                        if (obj.unsigned)
                            delete obj.unsigned;
                        try {
                            util.ed25519_verify(pubkey, _anotherJson["default"].stringify(obj), signature);
                        }
                        finally {
                            obj.signatures = sigs;
                            if (unsigned)
                                obj.unsigned = unsigned;
                            util.free();
                        }
                    }
                    function encodeBase64(uint8Array) {
                        return Buffer.from(uint8Array).toString("base64");
                    }
                    function encodeUnpaddedBase64(uint8Array) {
                        return encodeBase64(uint8Array).replace(/=+$/g, '');
                    }
                    function decodeBase64(base64) {
                        return Buffer.from(base64, "base64");
                    }
                }).call(this);
            }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, require("buffer").Buffer);
        }, { "../logger": 97, "../utils": 125, "@babel/runtime/helpers/asyncToGenerator": 5, "@babel/runtime/helpers/interopRequireDefault": 12, "@babel/runtime/helpers/interopRequireWildcard": 13, "@babel/runtime/helpers/slicedToArray": 22, "@babel/runtime/helpers/toConsumableArray": 23, "@babel/runtime/regenerator": 27, "another-json": 28, "buffer": 34 }], 78: [function (require, module, exports) {
            (function (global, Buffer) {
                (function () {
                    "use strict";
                    var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
                    Object.defineProperty(exports, "__esModule", {
                        value: true
                    });
                    exports.encodeRecoveryKey = encodeRecoveryKey;
                    exports.decodeRecoveryKey = decodeRecoveryKey;
                    var _bs = _interopRequireDefault(require("bs58"));
                    function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
                        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                            if (it)
                                o = it;
                            var i = 0;
                            var F = function F() { };
                            return { s: F, n: function n() { if (i >= o.length)
                                    return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F };
                        }
                        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                    } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try {
                            if (!normalCompletion && it["return"] != null)
                                it["return"]();
                        }
                        finally {
                            if (didErr)
                                throw err;
                        } } }; }
                    function _unsupportedIterableToArray(o, minLen) { if (!o)
                        return; if (typeof o === "string")
                        return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor)
                        n = o.constructor.name; if (n === "Map" || n === "Set")
                        return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                        return _arrayLikeToArray(o, minLen); }
                    function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length)
                        len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) {
                        arr2[i] = arr[i];
                    } return arr2; }
                    var OLM_RECOVERY_KEY_PREFIX = [0x8B, 0x01];
                    function encodeRecoveryKey(key) {
                        var buf = new Buffer(OLM_RECOVERY_KEY_PREFIX.length + key.length + 1);
                        buf.set(OLM_RECOVERY_KEY_PREFIX, 0);
                        buf.set(key, OLM_RECOVERY_KEY_PREFIX.length);
                        var parity = 0;
                        for (var i = 0; i < buf.length - 1; ++i) {
                            parity ^= buf[i];
                        }
                        buf[buf.length - 1] = parity;
                        var base58key = _bs["default"].encode(buf);
                        return base58key.match(/.{1,4}/g).join(" ");
                    }
                    function decodeRecoveryKey(recoverykey) {
                        var result = _bs["default"].decode(recoverykey.replace(/ /g, ''));
                        var parity = 0;
                        var _iterator = _createForOfIteratorHelper(result), _step;
                        try {
                            for (_iterator.s(); !(_step = _iterator.n()).done;) {
                                var b = _step.value;
                                parity ^= b;
                            }
                        }
                        catch (err) {
                            _iterator.e(err);
                        }
                        finally {
                            _iterator.f();
                        }
                        if (parity !== 0) {
                            throw new Error("Incorrect parity");
                        }
                        for (var i = 0; i < OLM_RECOVERY_KEY_PREFIX.length; ++i) {
                            if (result[i] !== OLM_RECOVERY_KEY_PREFIX[i]) {
                                throw new Error("Incorrect prefix");
                            }
                        }
                        if (result.length !== OLM_RECOVERY_KEY_PREFIX.length + global.Olm.PRIVATE_KEY_LENGTH + 1) {
                            throw new Error("Incorrect length");
                        }
                        return Uint8Array.from(result.slice(OLM_RECOVERY_KEY_PREFIX.length, OLM_RECOVERY_KEY_PREFIX.length + global.Olm.PRIVATE_KEY_LENGTH));
                    }
                }).call(this);
            }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, require("buffer").Buffer);
        }, { "@babel/runtime/helpers/interopRequireDefault": 12, "bs58": 33, "buffer": 34 }], 79: [function (require, module, exports) {
            "use strict";
            var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
            var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.upgradeDatabase = upgradeDatabase;
            exports.Backend = exports.VERSION = void 0;
            var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
            var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
            var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
            var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
            var _logger = require("../../logger");
            var utils = _interopRequireWildcard(require("../../utils"));
            function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
                if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                    if (it)
                        o = it;
                    var i = 0;
                    var F = function F() { };
                    return { s: F, n: function n() { if (i >= o.length)
                            return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try {
                    if (!normalCompletion && it["return"] != null)
                        it["return"]();
                }
                finally {
                    if (didErr)
                        throw err;
                } } }; }
            function _unsupportedIterableToArray(o, minLen) { if (!o)
                return; if (typeof o === "string")
                return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor)
                n = o.constructor.name; if (n === "Map" || n === "Set")
                return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return _arrayLikeToArray(o, minLen); }
            function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length)
                len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
            } return arr2; }
            var VERSION = 9;
            exports.VERSION = VERSION;
            var PROFILE_TRANSACTIONS = false;
            var Backend = function () {
                function Backend(db) {
                    var _this = this;
                    (0, _classCallCheck2["default"])(this, Backend);
                    this._db = db;
                    this._nextTxnId = 0;
                    db.onversionchange = function (ev) {
                        _logger.logger.log("versionchange for indexeddb ".concat(_this._dbName, ": closing"));
                        db.close();
                    };
                }
                (0, _createClass2["default"])(Backend, [{
                        key: "getOrAddOutgoingRoomKeyRequest",
                        value: function getOrAddOutgoingRoomKeyRequest(request) {
                            var _this2 = this;
                            var requestBody = request.requestBody;
                            return new Promise(function (resolve, reject) {
                                var txn = _this2._db.transaction("outgoingRoomKeyRequests", "readwrite");
                                txn.onerror = reject;
                                _this2._getOutgoingRoomKeyRequest(txn, requestBody, function (existing) {
                                    if (existing) {
                                        _logger.logger.log("already have key request outstanding for " + "".concat(requestBody.room_id, " / ").concat(requestBody.session_id, ": ") + "not sending another");
                                        resolve(existing);
                                        return;
                                    }
                                    _logger.logger.log("enqueueing key request for ".concat(requestBody.room_id, " / ") + requestBody.session_id);
                                    txn.oncomplete = function () {
                                        resolve(request);
                                    };
                                    var store = txn.objectStore("outgoingRoomKeyRequests");
                                    store.add(request);
                                });
                            });
                        }
                    }, {
                        key: "getOutgoingRoomKeyRequest",
                        value: function getOutgoingRoomKeyRequest(requestBody) {
                            var _this3 = this;
                            return new Promise(function (resolve, reject) {
                                var txn = _this3._db.transaction("outgoingRoomKeyRequests", "readonly");
                                txn.onerror = reject;
                                _this3._getOutgoingRoomKeyRequest(txn, requestBody, function (existing) {
                                    resolve(existing);
                                });
                            });
                        }
                    }, {
                        key: "_getOutgoingRoomKeyRequest",
                        value: function _getOutgoingRoomKeyRequest(txn, requestBody, callback) {
                            var store = txn.objectStore("outgoingRoomKeyRequests");
                            var idx = store.index("session");
                            var cursorReq = idx.openCursor([requestBody.room_id, requestBody.session_id]);
                            cursorReq.onsuccess = function (ev) {
                                var cursor = ev.target.result;
                                if (!cursor) {
                                    callback(null);
                                    return;
                                }
                                var existing = cursor.value;
                                if (utils.deepCompare(existing.requestBody, requestBody)) {
                                    callback(existing);
                                    return;
                                }
                                cursor["continue"]();
                            };
                        }
                    }, {
                        key: "getOutgoingRoomKeyRequestByState",
                        value: function getOutgoingRoomKeyRequestByState(wantedStates) {
                            if (wantedStates.length === 0) {
                                return Promise.resolve(null);
                            }
                            var stateIndex = 0;
                            var result;
                            function onsuccess(ev) {
                                var cursor = ev.target.result;
                                if (cursor) {
                                    result = cursor.value;
                                    return;
                                }
                                stateIndex++;
                                if (stateIndex >= wantedStates.length) {
                                    return;
                                }
                                var wantedState = wantedStates[stateIndex];
                                var cursorReq = ev.target.source.openCursor(wantedState);
                                cursorReq.onsuccess = onsuccess;
                            }
                            var txn = this._db.transaction("outgoingRoomKeyRequests", "readonly");
                            var store = txn.objectStore("outgoingRoomKeyRequests");
                            var wantedState = wantedStates[stateIndex];
                            var cursorReq = store.index("state").openCursor(wantedState);
                            cursorReq.onsuccess = onsuccess;
                            return promiseifyTxn(txn).then(function () {
                                return result;
                            });
                        }
                    }, {
                        key: "getAllOutgoingRoomKeyRequestsByState",
                        value: function getAllOutgoingRoomKeyRequestsByState(wantedState) {
                            var _this4 = this;
                            return new Promise(function (resolve, reject) {
                                var txn = _this4._db.transaction("outgoingRoomKeyRequests", "readonly");
                                var store = txn.objectStore("outgoingRoomKeyRequests");
                                var index = store.index("state");
                                var request = index.getAll(wantedState);
                                request.onsuccess = function (ev) {
                                    return resolve(ev.target.result);
                                };
                                request.onerror = function (ev) {
                                    return reject(ev.target.error);
                                };
                            });
                        }
                    }, {
                        key: "getOutgoingRoomKeyRequestsByTarget",
                        value: function getOutgoingRoomKeyRequestsByTarget(userId, deviceId, wantedStates) {
                            var stateIndex = 0;
                            var results = [];
                            function onsuccess(ev) {
                                var cursor = ev.target.result;
                                if (cursor) {
                                    var keyReq = cursor.value;
                                    if (keyReq.recipients.includes({
                                        userId: userId,
                                        deviceId: deviceId
                                    })) {
                                        results.push(keyReq);
                                    }
                                    cursor["continue"]();
                                }
                                else {
                                    stateIndex++;
                                    if (stateIndex >= wantedStates.length) {
                                        return;
                                    }
                                    var _wantedState = wantedStates[stateIndex];
                                    var _cursorReq = ev.target.source.openCursor(_wantedState);
                                    _cursorReq.onsuccess = onsuccess;
                                }
                            }
                            var txn = this._db.transaction("outgoingRoomKeyRequests", "readonly");
                            var store = txn.objectStore("outgoingRoomKeyRequests");
                            var wantedState = wantedStates[stateIndex];
                            var cursorReq = store.index("state").openCursor(wantedState);
                            cursorReq.onsuccess = onsuccess;
                            return promiseifyTxn(txn).then(function () {
                                return results;
                            });
                        }
                    }, {
                        key: "updateOutgoingRoomKeyRequest",
                        value: function updateOutgoingRoomKeyRequest(requestId, expectedState, updates) {
                            var result = null;
                            function onsuccess(ev) {
                                var cursor = ev.target.result;
                                if (!cursor) {
                                    return;
                                }
                                var data = cursor.value;
                                if (data.state != expectedState) {
                                    _logger.logger.warn("Cannot update room key request from ".concat(expectedState, " ") + "as it was already updated to ".concat(data.state));
                                    return;
                                }
                                Object.assign(data, updates);
                                cursor.update(data);
                                result = data;
                            }
                            var txn = this._db.transaction("outgoingRoomKeyRequests", "readwrite");
                            var cursorReq = txn.objectStore("outgoingRoomKeyRequests").openCursor(requestId);
                            cursorReq.onsuccess = onsuccess;
                            return promiseifyTxn(txn).then(function () {
                                return result;
                            });
                        }
                    }, {
                        key: "deleteOutgoingRoomKeyRequest",
                        value: function deleteOutgoingRoomKeyRequest(requestId, expectedState) {
                            var txn = this._db.transaction("outgoingRoomKeyRequests", "readwrite");
                            var cursorReq = txn.objectStore("outgoingRoomKeyRequests").openCursor(requestId);
                            cursorReq.onsuccess = function (ev) {
                                var cursor = ev.target.result;
                                if (!cursor) {
                                    return;
                                }
                                var data = cursor.value;
                                if (data.state != expectedState) {
                                    _logger.logger.warn("Cannot delete room key request in state ".concat(data.state, " ") + "(expected ".concat(expectedState, ")"));
                                    return;
                                }
                                cursor["delete"]();
                            };
                            return promiseifyTxn(txn);
                        }
                    }, {
                        key: "getAccount",
                        value: function getAccount(txn, func) {
                            var objectStore = txn.objectStore("account");
                            var getReq = objectStore.get("-");
                            getReq.onsuccess = function () {
                                try {
                                    func(getReq.result || null);
                                }
                                catch (e) {
                                    abortWithException(txn, e);
                                }
                            };
                        }
                    }, {
                        key: "storeAccount",
                        value: function storeAccount(txn, newData) {
                            var objectStore = txn.objectStore("account");
                            objectStore.put(newData, "-");
                        }
                    }, {
                        key: "getCrossSigningKeys",
                        value: function getCrossSigningKeys(txn, func) {
                            var objectStore = txn.objectStore("account");
                            var getReq = objectStore.get("crossSigningKeys");
                            getReq.onsuccess = function () {
                                try {
                                    func(getReq.result || null);
                                }
                                catch (e) {
                                    abortWithException(txn, e);
                                }
                            };
                        }
                    }, {
                        key: "getSecretStorePrivateKey",
                        value: function getSecretStorePrivateKey(txn, func, type) {
                            var objectStore = txn.objectStore("account");
                            var getReq = objectStore.get("ssss_cache:".concat(type));
                            getReq.onsuccess = function () {
                                try {
                                    func(getReq.result || null);
                                }
                                catch (e) {
                                    abortWithException(txn, e);
                                }
                            };
                        }
                    }, {
                        key: "storeCrossSigningKeys",
                        value: function storeCrossSigningKeys(txn, keys) {
                            var objectStore = txn.objectStore("account");
                            objectStore.put(keys, "crossSigningKeys");
                        }
                    }, {
                        key: "storeSecretStorePrivateKey",
                        value: function storeSecretStorePrivateKey(txn, type, key) {
                            var objectStore = txn.objectStore("account");
                            objectStore.put(key, "ssss_cache:".concat(type));
                        }
                    }, {
                        key: "countEndToEndSessions",
                        value: function countEndToEndSessions(txn, func) {
                            var objectStore = txn.objectStore("sessions");
                            var countReq = objectStore.count();
                            countReq.onsuccess = function () {
                                try {
                                    func(countReq.result);
                                }
                                catch (e) {
                                    abortWithException(txn, e);
                                }
                            };
                        }
                    }, {
                        key: "getEndToEndSessions",
                        value: function getEndToEndSessions(deviceKey, txn, func) {
                            var objectStore = txn.objectStore("sessions");
                            var idx = objectStore.index("deviceKey");
                            var getReq = idx.openCursor(deviceKey);
                            var results = {};
                            getReq.onsuccess = function () {
                                var cursor = getReq.result;
                                if (cursor) {
                                    results[cursor.value.sessionId] = {
                                        session: cursor.value.session,
                                        lastReceivedMessageTs: cursor.value.lastReceivedMessageTs
                                    };
                                    cursor["continue"]();
                                }
                                else {
                                    try {
                                        func(results);
                                    }
                                    catch (e) {
                                        abortWithException(txn, e);
                                    }
                                }
                            };
                        }
                    }, {
                        key: "getEndToEndSession",
                        value: function getEndToEndSession(deviceKey, sessionId, txn, func) {
                            var objectStore = txn.objectStore("sessions");
                            var getReq = objectStore.get([deviceKey, sessionId]);
                            getReq.onsuccess = function () {
                                try {
                                    if (getReq.result) {
                                        func({
                                            session: getReq.result.session,
                                            lastReceivedMessageTs: getReq.result.lastReceivedMessageTs
                                        });
                                    }
                                    else {
                                        func(null);
                                    }
                                }
                                catch (e) {
                                    abortWithException(txn, e);
                                }
                            };
                        }
                    }, {
                        key: "getAllEndToEndSessions",
                        value: function getAllEndToEndSessions(txn, func) {
                            var objectStore = txn.objectStore("sessions");
                            var getReq = objectStore.openCursor();
                            getReq.onsuccess = function () {
                                try {
                                    var cursor = getReq.result;
                                    if (cursor) {
                                        func(cursor.value);
                                        cursor["continue"]();
                                    }
                                    else {
                                        func(null);
                                    }
                                }
                                catch (e) {
                                    abortWithException(txn, e);
                                }
                            };
                        }
                    }, {
                        key: "storeEndToEndSession",
                        value: function storeEndToEndSession(deviceKey, sessionId, sessionInfo, txn) {
                            var objectStore = txn.objectStore("sessions");
                            objectStore.put({
                                deviceKey: deviceKey,
                                sessionId: sessionId,
                                session: sessionInfo.session,
                                lastReceivedMessageTs: sessionInfo.lastReceivedMessageTs
                            });
                        }
                    }, {
                        key: "storeEndToEndSessionProblem",
                        value: function () {
                            var _storeEndToEndSessionProblem = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee(deviceKey, type, fixed) {
                                var txn, objectStore;
                                return _regenerator["default"].wrap(function _callee$(_context) {
                                    while (1) {
                                        switch (_context.prev = _context.next) {
                                            case 0:
                                                txn = this._db.transaction("session_problems", "readwrite");
                                                objectStore = txn.objectStore("session_problems");
                                                objectStore.put({
                                                    deviceKey: deviceKey,
                                                    type: type,
                                                    fixed: fixed,
                                                    time: Date.now()
                                                });
                                                return _context.abrupt("return", promiseifyTxn(txn));
                                            case 4:
                                            case "end":
                                                return _context.stop();
                                        }
                                    }
                                }, _callee, this);
                            }));
                            function storeEndToEndSessionProblem(_x, _x2, _x3) {
                                return _storeEndToEndSessionProblem.apply(this, arguments);
                            }
                            return storeEndToEndSessionProblem;
                        }()
                    }, {
                        key: "getEndToEndSessionProblem",
                        value: function () {
                            var _getEndToEndSessionProblem = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee2(deviceKey, timestamp) {
                                var result, txn, objectStore, index, req;
                                return _regenerator["default"].wrap(function _callee2$(_context2) {
                                    while (1) {
                                        switch (_context2.prev = _context2.next) {
                                            case 0:
                                                txn = this._db.transaction("session_problems", "readwrite");
                                                objectStore = txn.objectStore("session_problems");
                                                index = objectStore.index("deviceKey");
                                                req = index.getAll(deviceKey);
                                                req.onsuccess = function (event) {
                                                    var problems = req.result;
                                                    if (!problems.length) {
                                                        result = null;
                                                        return;
                                                    }
                                                    problems.sort(function (a, b) {
                                                        return a.time - b.time;
                                                    });
                                                    var lastProblem = problems[problems.length - 1];
                                                    var _iterator = _createForOfIteratorHelper(problems), _step;
                                                    try {
                                                        for (_iterator.s(); !(_step = _iterator.n()).done;) {
                                                            var problem = _step.value;
                                                            if (problem.time > timestamp) {
                                                                result = Object.assign({}, problem, {
                                                                    fixed: lastProblem.fixed
                                                                });
                                                                return;
                                                            }
                                                        }
                                                    }
                                                    catch (err) {
                                                        _iterator.e(err);
                                                    }
                                                    finally {
                                                        _iterator.f();
                                                    }
                                                    if (lastProblem.fixed) {
                                                        result = null;
                                                    }
                                                    else {
                                                        result = lastProblem;
                                                    }
                                                };
                                                _context2.next = 7;
                                                return promiseifyTxn(txn);
                                            case 7:
                                                return _context2.abrupt("return", result);
                                            case 8:
                                            case "end":
                                                return _context2.stop();
                                        }
                                    }
                                }, _callee2, this);
                            }));
                            function getEndToEndSessionProblem(_x4, _x5) {
                                return _getEndToEndSessionProblem.apply(this, arguments);
                            }
                            return getEndToEndSessionProblem;
                        }()
                    }, {
                        key: "filterOutNotifiedErrorDevices",
                        value: function () {
                            var _filterOutNotifiedErrorDevices = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee3(devices) {
                                var txn, objectStore, ret;
                                return _regenerator["default"].wrap(function _callee3$(_context3) {
                                    while (1) {
                                        switch (_context3.prev = _context3.next) {
                                            case 0:
                                                txn = this._db.transaction("notified_error_devices", "readwrite");
                                                objectStore = txn.objectStore("notified_error_devices");
                                                ret = [];
                                                _context3.next = 5;
                                                return Promise.all(devices.map(function (device) {
                                                    return new Promise(function (resolve) {
                                                        var userId = device.userId, deviceInfo = device.deviceInfo;
                                                        var getReq = objectStore.get([userId, deviceInfo.deviceId]);
                                                        getReq.onsuccess = function () {
                                                            if (!getReq.result) {
                                                                objectStore.put({
                                                                    userId: userId,
                                                                    deviceId: deviceInfo.deviceId
                                                                });
                                                                ret.push(device);
                                                            }
                                                            resolve();
                                                        };
                                                    });
                                                }));
                                            case 5:
                                                return _context3.abrupt("return", ret);
                                            case 6:
                                            case "end":
                                                return _context3.stop();
                                        }
                                    }
                                }, _callee3, this);
                            }));
                            function filterOutNotifiedErrorDevices(_x6) {
                                return _filterOutNotifiedErrorDevices.apply(this, arguments);
                            }
                            return filterOutNotifiedErrorDevices;
                        }()
                    }, {
                        key: "getEndToEndInboundGroupSession",
                        value: function getEndToEndInboundGroupSession(senderCurve25519Key, sessionId, txn, func) {
                            var session = false;
                            var withheld = false;
                            var objectStore = txn.objectStore("inbound_group_sessions");
                            var getReq = objectStore.get([senderCurve25519Key, sessionId]);
                            getReq.onsuccess = function () {
                                try {
                                    if (getReq.result) {
                                        session = getReq.result.session;
                                    }
                                    else {
                                        session = null;
                                    }
                                    if (withheld !== false) {
                                        func(session, withheld);
                                    }
                                }
                                catch (e) {
                                    abortWithException(txn, e);
                                }
                            };
                            var withheldObjectStore = txn.objectStore("inbound_group_sessions_withheld");
                            var withheldGetReq = withheldObjectStore.get([senderCurve25519Key, sessionId]);
                            withheldGetReq.onsuccess = function () {
                                try {
                                    if (withheldGetReq.result) {
                                        withheld = withheldGetReq.result.session;
                                    }
                                    else {
                                        withheld = null;
                                    }
                                    if (session !== false) {
                                        func(session, withheld);
                                    }
                                }
                                catch (e) {
                                    abortWithException(txn, e);
                                }
                            };
                        }
                    }, {
                        key: "getAllEndToEndInboundGroupSessions",
                        value: function getAllEndToEndInboundGroupSessions(txn, func) {
                            var objectStore = txn.objectStore("inbound_group_sessions");
                            var getReq = objectStore.openCursor();
                            getReq.onsuccess = function () {
                                var cursor = getReq.result;
                                if (cursor) {
                                    try {
                                        func({
                                            senderKey: cursor.value.senderCurve25519Key,
                                            sessionId: cursor.value.sessionId,
                                            sessionData: cursor.value.session
                                        });
                                    }
                                    catch (e) {
                                        abortWithException(txn, e);
                                    }
                                    cursor["continue"]();
                                }
                                else {
                                    try {
                                        func(null);
                                    }
                                    catch (e) {
                                        abortWithException(txn, e);
                                    }
                                }
                            };
                        }
                    }, {
                        key: "addEndToEndInboundGroupSession",
                        value: function addEndToEndInboundGroupSession(senderCurve25519Key, sessionId, sessionData, txn) {
                            var objectStore = txn.objectStore("inbound_group_sessions");
                            var addReq = objectStore.add({
                                senderCurve25519Key: senderCurve25519Key,
                                sessionId: sessionId,
                                session: sessionData
                            });
                            addReq.onerror = function (ev) {
                                if (addReq.error.name === 'ConstraintError') {
                                    ev.stopPropagation();
                                    ev.preventDefault();
                                    _logger.logger.log("Ignoring duplicate inbound group session: " + senderCurve25519Key + " / " + sessionId);
                                }
                                else {
                                    abortWithException(txn, new Error("Failed to add inbound group session: " + addReq.error));
                                }
                            };
                        }
                    }, {
                        key: "storeEndToEndInboundGroupSession",
                        value: function storeEndToEndInboundGroupSession(senderCurve25519Key, sessionId, sessionData, txn) {
                            var objectStore = txn.objectStore("inbound_group_sessions");
                            objectStore.put({
                                senderCurve25519Key: senderCurve25519Key,
                                sessionId: sessionId,
                                session: sessionData
                            });
                        }
                    }, {
                        key: "storeEndToEndInboundGroupSessionWithheld",
                        value: function storeEndToEndInboundGroupSessionWithheld(senderCurve25519Key, sessionId, sessionData, txn) {
                            var objectStore = txn.objectStore("inbound_group_sessions_withheld");
                            objectStore.put({
                                senderCurve25519Key: senderCurve25519Key,
                                sessionId: sessionId,
                                session: sessionData
                            });
                        }
                    }, {
                        key: "getEndToEndDeviceData",
                        value: function getEndToEndDeviceData(txn, func) {
                            var objectStore = txn.objectStore("device_data");
                            var getReq = objectStore.get("-");
                            getReq.onsuccess = function () {
                                try {
                                    func(getReq.result || null);
                                }
                                catch (e) {
                                    abortWithException(txn, e);
                                }
                            };
                        }
                    }, {
                        key: "storeEndToEndDeviceData",
                        value: function storeEndToEndDeviceData(deviceData, txn) {
                            var objectStore = txn.objectStore("device_data");
                            objectStore.put(deviceData, "-");
                        }
                    }, {
                        key: "storeEndToEndRoom",
                        value: function storeEndToEndRoom(roomId, roomInfo, txn) {
                            var objectStore = txn.objectStore("rooms");
                            objectStore.put(roomInfo, roomId);
                        }
                    }, {
                        key: "getEndToEndRooms",
                        value: function getEndToEndRooms(txn, func) {
                            var rooms = {};
                            var objectStore = txn.objectStore("rooms");
                            var getReq = objectStore.openCursor();
                            getReq.onsuccess = function () {
                                var cursor = getReq.result;
                                if (cursor) {
                                    rooms[cursor.key] = cursor.value;
                                    cursor["continue"]();
                                }
                                else {
                                    try {
                                        func(rooms);
                                    }
                                    catch (e) {
                                        abortWithException(txn, e);
                                    }
                                }
                            };
                        }
                    }, {
                        key: "getSessionsNeedingBackup",
                        value: function getSessionsNeedingBackup(limit) {
                            var _this5 = this;
                            return new Promise(function (resolve, reject) {
                                var sessions = [];
                                var txn = _this5._db.transaction(["sessions_needing_backup", "inbound_group_sessions"], "readonly");
                                txn.onerror = reject;
                                txn.oncomplete = function () {
                                    resolve(sessions);
                                };
                                var objectStore = txn.objectStore("sessions_needing_backup");
                                var sessionStore = txn.objectStore("inbound_group_sessions");
                                var getReq = objectStore.openCursor();
                                getReq.onsuccess = function () {
                                    var cursor = getReq.result;
                                    if (cursor) {
                                        var sessionGetReq = sessionStore.get(cursor.key);
                                        sessionGetReq.onsuccess = function () {
                                            sessions.push({
                                                senderKey: sessionGetReq.result.senderCurve25519Key,
                                                sessionId: sessionGetReq.result.sessionId,
                                                sessionData: sessionGetReq.result.session
                                            });
                                        };
                                        if (!limit || sessions.length < limit) {
                                            cursor["continue"]();
                                        }
                                    }
                                };
                            });
                        }
                    }, {
                        key: "countSessionsNeedingBackup",
                        value: function countSessionsNeedingBackup(txn) {
                            if (!txn) {
                                txn = this._db.transaction("sessions_needing_backup", "readonly");
                            }
                            var objectStore = txn.objectStore("sessions_needing_backup");
                            return new Promise(function (resolve, reject) {
                                var req = objectStore.count();
                                req.onerror = reject;
                                req.onsuccess = function () {
                                    return resolve(req.result);
                                };
                            });
                        }
                    }, {
                        key: "unmarkSessionsNeedingBackup",
                        value: function unmarkSessionsNeedingBackup(sessions, txn) {
                            if (!txn) {
                                txn = this._db.transaction("sessions_needing_backup", "readwrite");
                            }
                            var objectStore = txn.objectStore("sessions_needing_backup");
                            return Promise.all(sessions.map(function (session) {
                                return new Promise(function (resolve, reject) {
                                    var req = objectStore["delete"]([session.senderKey, session.sessionId]);
                                    req.onsuccess = resolve;
                                    req.onerror = reject;
                                });
                            }));
                        }
                    }, {
                        key: "markSessionsNeedingBackup",
                        value: function markSessionsNeedingBackup(sessions, txn) {
                            if (!txn) {
                                txn = this._db.transaction("sessions_needing_backup", "readwrite");
                            }
                            var objectStore = txn.objectStore("sessions_needing_backup");
                            return Promise.all(sessions.map(function (session) {
                                return new Promise(function (resolve, reject) {
                                    var req = objectStore.put({
                                        senderCurve25519Key: session.senderKey,
                                        sessionId: session.sessionId
                                    });
                                    req.onsuccess = resolve;
                                    req.onerror = reject;
                                });
                            }));
                        }
                    }, {
                        key: "doTxn",
                        value: function doTxn(mode, stores, func) {
                            var log = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _logger.logger;
                            var startTime;
                            var description;
                            if (PROFILE_TRANSACTIONS) {
                                var txnId = this._nextTxnId++;
                                startTime = Date.now();
                                description = "".concat(mode, " crypto store transaction ").concat(txnId, " in ").concat(stores);
                                log.debug("Starting ".concat(description));
                            }
                            var txn = this._db.transaction(stores, mode);
                            var promise = promiseifyTxn(txn);
                            var result = func(txn);
                            if (PROFILE_TRANSACTIONS) {
                                promise.then(function () {
                                    var elapsedTime = Date.now() - startTime;
                                    log.debug("Finished ".concat(description, ", took ").concat(elapsedTime, " ms"));
                                }, function () {
                                    var elapsedTime = Date.now() - startTime;
                                    log.error("Failed ".concat(description, ", took ").concat(elapsedTime, " ms"));
                                });
                            }
                            return promise.then(function () {
                                return result;
                            });
                        }
                    }]);
                return Backend;
            }();
            exports.Backend = Backend;
            function upgradeDatabase(db, oldVersion) {
                _logger.logger.log("Upgrading IndexedDBCryptoStore from version ".concat(oldVersion) + " to ".concat(VERSION));
                if (oldVersion < 1) {
                    createDatabase(db);
                }
                if (oldVersion < 2) {
                    db.createObjectStore("account");
                }
                if (oldVersion < 3) {
                    var sessionsStore = db.createObjectStore("sessions", {
                        keyPath: ["deviceKey", "sessionId"]
                    });
                    sessionsStore.createIndex("deviceKey", "deviceKey");
                }
                if (oldVersion < 4) {
                    db.createObjectStore("inbound_group_sessions", {
                        keyPath: ["senderCurve25519Key", "sessionId"]
                    });
                }
                if (oldVersion < 5) {
                    db.createObjectStore("device_data");
                }
                if (oldVersion < 6) {
                    db.createObjectStore("rooms");
                }
                if (oldVersion < 7) {
                    db.createObjectStore("sessions_needing_backup", {
                        keyPath: ["senderCurve25519Key", "sessionId"]
                    });
                }
                if (oldVersion < 8) {
                    db.createObjectStore("inbound_group_sessions_withheld", {
                        keyPath: ["senderCurve25519Key", "sessionId"]
                    });
                }
                if (oldVersion < 9) {
                    var problemsStore = db.createObjectStore("session_problems", {
                        keyPath: ["deviceKey", "time"]
                    });
                    problemsStore.createIndex("deviceKey", "deviceKey");
                    db.createObjectStore("notified_error_devices", {
                        keyPath: ["userId", "deviceId"]
                    });
                }
            }
            function createDatabase(db) {
                var outgoingRoomKeyRequestsStore = db.createObjectStore("outgoingRoomKeyRequests", {
                    keyPath: "requestId"
                });
                outgoingRoomKeyRequestsStore.createIndex("session", ["requestBody.room_id", "requestBody.session_id"]);
                outgoingRoomKeyRequestsStore.createIndex("state", "state");
            }
            function abortWithException(txn, e) {
                txn._mx_abortexception = e;
                try {
                    txn.abort();
                }
                catch (e) {
                }
            }
            function promiseifyTxn(txn) {
                return new Promise(function (resolve, reject) {
                    txn.oncomplete = function () {
                        if (txn._mx_abortexception !== undefined) {
                            reject(txn._mx_abortexception);
                        }
                        resolve();
                    };
                    txn.onerror = function (event) {
                        if (txn._mx_abortexception !== undefined) {
                            reject(txn._mx_abortexception);
                        }
                        else {
                            _logger.logger.log("Error performing indexeddb txn", event);
                            reject(event.target.error);
                        }
                    };
                    txn.onabort = function (event) {
                        if (txn._mx_abortexception !== undefined) {
                            reject(txn._mx_abortexception);
                        }
                        else {
                            _logger.logger.log("Error performing indexeddb txn", event);
                            reject(event.target.error);
                        }
                    };
                });
            }
        }, { "../../logger": 97, "../../utils": 125, "@babel/runtime/helpers/asyncToGenerator": 5, "@babel/runtime/helpers/classCallCheck": 6, "@babel/runtime/helpers/createClass": 8, "@babel/runtime/helpers/interopRequireDefault": 12, "@babel/runtime/helpers/interopRequireWildcard": 13, "@babel/runtime/regenerator": 27 }], 80: [function (require, module, exports) {
            (function (global) {
                (function () {
                    "use strict";
                    var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
                    var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
                    Object.defineProperty(exports, "__esModule", {
                        value: true
                    });
                    exports.IndexedDBCryptoStore = void 0;
                    var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
                    var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
                    var _logger = require("../../logger");
                    var _localStorageCryptoStore = require("./localStorage-crypto-store");
                    var _memoryCryptoStore = require("./memory-crypto-store");
                    var IndexedDBCryptoStoreBackend = _interopRequireWildcard(require("./indexeddb-crypto-store-backend"));
                    var _errors = require("../../errors");
                    var IndexedDBHelpers = _interopRequireWildcard(require("../../indexeddb-helpers"));
                    var IndexedDBCryptoStore = function () {
                        function IndexedDBCryptoStore(indexedDB, dbName) {
                            (0, _classCallCheck2["default"])(this, IndexedDBCryptoStore);
                            this._indexedDB = indexedDB;
                            this._dbName = dbName;
                            this._backendPromise = null;
                            this._backend = null;
                        }
                        (0, _createClass2["default"])(IndexedDBCryptoStore, [{
                                key: "startup",
                                value: function startup() {
                                    var _this = this;
                                    if (this._backendPromise) {
                                        return this._backendPromise;
                                    }
                                    this._backendPromise = new Promise(function (resolve, reject) {
                                        if (!_this._indexedDB) {
                                            reject(new Error('no indexeddb support available'));
                                            return;
                                        }
                                        _logger.logger.log("connecting to indexeddb ".concat(_this._dbName));
                                        var req = _this._indexedDB.open(_this._dbName, IndexedDBCryptoStoreBackend.VERSION);
                                        req.onupgradeneeded = function (ev) {
                                            var db = ev.target.result;
                                            var oldVersion = ev.oldVersion;
                                            IndexedDBCryptoStoreBackend.upgradeDatabase(db, oldVersion);
                                        };
                                        req.onblocked = function () {
                                            _logger.logger.log("can't yet open IndexedDBCryptoStore because it is open elsewhere");
                                        };
                                        req.onerror = function (ev) {
                                            _logger.logger.log("Error connecting to indexeddb", ev);
                                            reject(ev.target.error);
                                        };
                                        req.onsuccess = function (r) {
                                            var db = r.target.result;
                                            _logger.logger.log("connected to indexeddb ".concat(_this._dbName));
                                            resolve(new IndexedDBCryptoStoreBackend.Backend(db));
                                        };
                                    }).then(function (backend) {
                                        return backend.doTxn('readonly', [IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS, IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS_WITHHELD], function (txn) {
                                            backend.getEndToEndInboundGroupSession('', '', txn, function () { });
                                        }).then(function () {
                                            return backend;
                                        });
                                    })["catch"](function (e) {
                                        if (e.name === 'VersionError') {
                                            _logger.logger.warn("Crypto DB is too new for us to use!", e);
                                            throw new _errors.InvalidCryptoStoreError(_errors.InvalidCryptoStoreError.TOO_NEW);
                                        }
                                        _logger.logger.warn("unable to connect to indexeddb ".concat(_this._dbName) + ": falling back to localStorage store: ".concat(e));
                                        try {
                                            return new _localStorageCryptoStore.LocalStorageCryptoStore(global.localStorage);
                                        }
                                        catch (e) {
                                            _logger.logger.warn("unable to open localStorage: falling back to in-memory store: ".concat(e));
                                            return new _memoryCryptoStore.MemoryCryptoStore();
                                        }
                                    }).then(function (backend) {
                                        _this._backend = backend;
                                    });
                                    return this._backendPromise;
                                }
                            }, {
                                key: "deleteAllData",
                                value: function deleteAllData() {
                                    var _this2 = this;
                                    return new Promise(function (resolve, reject) {
                                        if (!_this2._indexedDB) {
                                            reject(new Error('no indexeddb support available'));
                                            return;
                                        }
                                        _logger.logger.log("Removing indexeddb instance: ".concat(_this2._dbName));
                                        var req = _this2._indexedDB.deleteDatabase(_this2._dbName);
                                        req.onblocked = function () {
                                            _logger.logger.log("can't yet delete IndexedDBCryptoStore because it is open elsewhere");
                                        };
                                        req.onerror = function (ev) {
                                            _logger.logger.log("Error deleting data from indexeddb", ev);
                                            reject(ev.target.error);
                                        };
                                        req.onsuccess = function () {
                                            _logger.logger.log("Removed indexeddb instance: ".concat(_this2._dbName));
                                            resolve();
                                        };
                                    })["catch"](function (e) {
                                        _logger.logger.warn("unable to delete IndexedDBCryptoStore: ".concat(e));
                                    });
                                }
                            }, {
                                key: "getOrAddOutgoingRoomKeyRequest",
                                value: function getOrAddOutgoingRoomKeyRequest(request) {
                                    return this._backend.getOrAddOutgoingRoomKeyRequest(request);
                                }
                            }, {
                                key: "getOutgoingRoomKeyRequest",
                                value: function getOutgoingRoomKeyRequest(requestBody) {
                                    return this._backend.getOutgoingRoomKeyRequest(requestBody);
                                }
                            }, {
                                key: "getOutgoingRoomKeyRequestByState",
                                value: function getOutgoingRoomKeyRequestByState(wantedStates) {
                                    return this._backend.getOutgoingRoomKeyRequestByState(wantedStates);
                                }
                            }, {
                                key: "getAllOutgoingRoomKeyRequestsByState",
                                value: function getAllOutgoingRoomKeyRequestsByState(wantedState) {
                                    return this._backend.getAllOutgoingRoomKeyRequestsByState(wantedState);
                                }
                            }, {
                                key: "getOutgoingRoomKeyRequestsByTarget",
                                value: function getOutgoingRoomKeyRequestsByTarget(userId, deviceId, wantedStates) {
                                    return this._backend.getOutgoingRoomKeyRequestsByTarget(userId, deviceId, wantedStates);
                                }
                            }, {
                                key: "updateOutgoingRoomKeyRequest",
                                value: function updateOutgoingRoomKeyRequest(requestId, expectedState, updates) {
                                    return this._backend.updateOutgoingRoomKeyRequest(requestId, expectedState, updates);
                                }
                            }, {
                                key: "deleteOutgoingRoomKeyRequest",
                                value: function deleteOutgoingRoomKeyRequest(requestId, expectedState) {
                                    return this._backend.deleteOutgoingRoomKeyRequest(requestId, expectedState);
                                }
                            }, {
                                key: "getAccount",
                                value: function getAccount(txn, func) {
                                    this._backend.getAccount(txn, func);
                                }
                            }, {
                                key: "storeAccount",
                                value: function storeAccount(txn, newData) {
                                    this._backend.storeAccount(txn, newData);
                                }
                            }, {
                                key: "getCrossSigningKeys",
                                value: function getCrossSigningKeys(txn, func) {
                                    this._backend.getCrossSigningKeys(txn, func);
                                }
                            }, {
                                key: "getSecretStorePrivateKey",
                                value: function getSecretStorePrivateKey(txn, func, type) {
                                    this._backend.getSecretStorePrivateKey(txn, func, type);
                                }
                            }, {
                                key: "storeCrossSigningKeys",
                                value: function storeCrossSigningKeys(txn, keys) {
                                    this._backend.storeCrossSigningKeys(txn, keys);
                                }
                            }, {
                                key: "storeSecretStorePrivateKey",
                                value: function storeSecretStorePrivateKey(txn, type, key) {
                                    this._backend.storeSecretStorePrivateKey(txn, type, key);
                                }
                            }, {
                                key: "countEndToEndSessions",
                                value: function countEndToEndSessions(txn, func) {
                                    this._backend.countEndToEndSessions(txn, func);
                                }
                            }, {
                                key: "getEndToEndSession",
                                value: function getEndToEndSession(deviceKey, sessionId, txn, func) {
                                    this._backend.getEndToEndSession(deviceKey, sessionId, txn, func);
                                }
                            }, {
                                key: "getEndToEndSessions",
                                value: function getEndToEndSessions(deviceKey, txn, func) {
                                    this._backend.getEndToEndSessions(deviceKey, txn, func);
                                }
                            }, {
                                key: "getAllEndToEndSessions",
                                value: function getAllEndToEndSessions(txn, func) {
                                    this._backend.getAllEndToEndSessions(txn, func);
                                }
                            }, {
                                key: "storeEndToEndSession",
                                value: function storeEndToEndSession(deviceKey, sessionId, sessionInfo, txn) {
                                    this._backend.storeEndToEndSession(deviceKey, sessionId, sessionInfo, txn);
                                }
                            }, {
                                key: "storeEndToEndSessionProblem",
                                value: function storeEndToEndSessionProblem(deviceKey, type, fixed) {
                                    return this._backend.storeEndToEndSessionProblem(deviceKey, type, fixed);
                                }
                            }, {
                                key: "getEndToEndSessionProblem",
                                value: function getEndToEndSessionProblem(deviceKey, timestamp) {
                                    return this._backend.getEndToEndSessionProblem(deviceKey, timestamp);
                                }
                            }, {
                                key: "filterOutNotifiedErrorDevices",
                                value: function filterOutNotifiedErrorDevices(devices) {
                                    return this._backend.filterOutNotifiedErrorDevices(devices);
                                }
                            }, {
                                key: "getEndToEndInboundGroupSession",
                                value: function getEndToEndInboundGroupSession(senderCurve25519Key, sessionId, txn, func) {
                                    this._backend.getEndToEndInboundGroupSession(senderCurve25519Key, sessionId, txn, func);
                                }
                            }, {
                                key: "getAllEndToEndInboundGroupSessions",
                                value: function getAllEndToEndInboundGroupSessions(txn, func) {
                                    this._backend.getAllEndToEndInboundGroupSessions(txn, func);
                                }
                            }, {
                                key: "addEndToEndInboundGroupSession",
                                value: function addEndToEndInboundGroupSession(senderCurve25519Key, sessionId, sessionData, txn) {
                                    this._backend.addEndToEndInboundGroupSession(senderCurve25519Key, sessionId, sessionData, txn);
                                }
                            }, {
                                key: "storeEndToEndInboundGroupSession",
                                value: function storeEndToEndInboundGroupSession(senderCurve25519Key, sessionId, sessionData, txn) {
                                    this._backend.storeEndToEndInboundGroupSession(senderCurve25519Key, sessionId, sessionData, txn);
                                }
                            }, {
                                key: "storeEndToEndInboundGroupSessionWithheld",
                                value: function storeEndToEndInboundGroupSessionWithheld(senderCurve25519Key, sessionId, sessionData, txn) {
                                    this._backend.storeEndToEndInboundGroupSessionWithheld(senderCurve25519Key, sessionId, sessionData, txn);
                                }
                            }, {
                                key: "storeEndToEndDeviceData",
                                value: function storeEndToEndDeviceData(deviceData, txn) {
                                    this._backend.storeEndToEndDeviceData(deviceData, txn);
                                }
                            }, {
                                key: "getEndToEndDeviceData",
                                value: function getEndToEndDeviceData(txn, func) {
                                    this._backend.getEndToEndDeviceData(txn, func);
                                }
                            }, {
                                key: "storeEndToEndRoom",
                                value: function storeEndToEndRoom(roomId, roomInfo, txn) {
                                    this._backend.storeEndToEndRoom(roomId, roomInfo, txn);
                                }
                            }, {
                                key: "getEndToEndRooms",
                                value: function getEndToEndRooms(txn, func) {
                                    this._backend.getEndToEndRooms(txn, func);
                                }
                            }, {
                                key: "getSessionsNeedingBackup",
                                value: function getSessionsNeedingBackup(limit) {
                                    return this._backend.getSessionsNeedingBackup(limit);
                                }
                            }, {
                                key: "countSessionsNeedingBackup",
                                value: function countSessionsNeedingBackup(txn) {
                                    return this._backend.countSessionsNeedingBackup(txn);
                                }
                            }, {
                                key: "unmarkSessionsNeedingBackup",
                                value: function unmarkSessionsNeedingBackup(sessions, txn) {
                                    return this._backend.unmarkSessionsNeedingBackup(sessions, txn);
                                }
                            }, {
                                key: "markSessionsNeedingBackup",
                                value: function markSessionsNeedingBackup(sessions, txn) {
                                    return this._backend.markSessionsNeedingBackup(sessions, txn);
                                }
                            }, {
                                key: "doTxn",
                                value: function doTxn(mode, stores, func, log) {
                                    return this._backend.doTxn(mode, stores, func, log);
                                }
                            }], [{
                                key: "exists",
                                value: function exists(indexedDB, dbName) {
                                    return IndexedDBHelpers.exists(indexedDB, dbName);
                                }
                            }]);
                        return IndexedDBCryptoStore;
                    }();
                    exports.IndexedDBCryptoStore = IndexedDBCryptoStore;
                    IndexedDBCryptoStore.STORE_ACCOUNT = 'account';
                    IndexedDBCryptoStore.STORE_SESSIONS = 'sessions';
                    IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS = 'inbound_group_sessions';
                    IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS_WITHHELD = 'inbound_group_sessions_withheld';
                    IndexedDBCryptoStore.STORE_DEVICE_DATA = 'device_data';
                    IndexedDBCryptoStore.STORE_ROOMS = 'rooms';
                    IndexedDBCryptoStore.STORE_BACKUP = 'sessions_needing_backup';
                }).call(this);
            }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, { "../../errors": 91, "../../indexeddb-helpers": 95, "../../logger": 97, "./indexeddb-crypto-store-backend": 79, "./localStorage-crypto-store": 81, "./memory-crypto-store": 82, "@babel/runtime/helpers/classCallCheck": 6, "@babel/runtime/helpers/createClass": 8, "@babel/runtime/helpers/interopRequireDefault": 12, "@babel/runtime/helpers/interopRequireWildcard": 13 }], 81: [function (require, module, exports) {
            "use strict";
            var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.LocalStorageCryptoStore = void 0;
            var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
            var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
            var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
            var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
            var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
            var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
            var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
            var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
            var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
            var _logger = require("../../logger");
            var _memoryCryptoStore = require("./memory-crypto-store");
            function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
                if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                    if (it)
                        o = it;
                    var i = 0;
                    var F = function F() { };
                    return { s: F, n: function n() { if (i >= o.length)
                            return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try {
                    if (!normalCompletion && it["return"] != null)
                        it["return"]();
                }
                finally {
                    if (didErr)
                        throw err;
                } } }; }
            function _unsupportedIterableToArray(o, minLen) { if (!o)
                return; if (typeof o === "string")
                return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor)
                n = o.constructor.name; if (n === "Map" || n === "Set")
                return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return _arrayLikeToArray(o, minLen); }
            function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length)
                len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
            } return arr2; }
            function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) {
                var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor;
                result = Reflect.construct(Super, arguments, NewTarget);
            }
            else {
                result = Super.apply(this, arguments);
            } return (0, _possibleConstructorReturn2["default"])(this, result); }; }
            function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct)
                return false; if (Reflect.construct.sham)
                return false; if (typeof Proxy === "function")
                return true; try {
                Date.prototype.toString.call(Reflect.construct(Date, [], function () { }));
                return true;
            }
            catch (e) {
                return false;
            } }
            var E2E_PREFIX = "crypto.";
            var KEY_END_TO_END_ACCOUNT = E2E_PREFIX + "account";
            var KEY_CROSS_SIGNING_KEYS = E2E_PREFIX + "cross_signing_keys";
            var KEY_NOTIFIED_ERROR_DEVICES = E2E_PREFIX + "notified_error_devices";
            var KEY_DEVICE_DATA = E2E_PREFIX + "device_data";
            var KEY_INBOUND_SESSION_PREFIX = E2E_PREFIX + "inboundgroupsessions/";
            var KEY_INBOUND_SESSION_WITHHELD_PREFIX = E2E_PREFIX + "inboundgroupsessions.withheld/";
            var KEY_ROOMS_PREFIX = E2E_PREFIX + "rooms/";
            var KEY_SESSIONS_NEEDING_BACKUP = E2E_PREFIX + "sessionsneedingbackup";
            function keyEndToEndSessions(deviceKey) {
                return E2E_PREFIX + "sessions/" + deviceKey;
            }
            function keyEndToEndSessionProblems(deviceKey) {
                return E2E_PREFIX + "session.problems/" + deviceKey;
            }
            function keyEndToEndInboundGroupSession(senderKey, sessionId) {
                return KEY_INBOUND_SESSION_PREFIX + senderKey + "/" + sessionId;
            }
            function keyEndToEndInboundGroupSessionWithheld(senderKey, sessionId) {
                return KEY_INBOUND_SESSION_WITHHELD_PREFIX + senderKey + "/" + sessionId;
            }
            function keyEndToEndRoomsPrefix(roomId) {
                return KEY_ROOMS_PREFIX + roomId;
            }
            var LocalStorageCryptoStore = function (_MemoryCryptoStore) {
                (0, _inherits2["default"])(LocalStorageCryptoStore, _MemoryCryptoStore);
                var _super = _createSuper(LocalStorageCryptoStore);
                function LocalStorageCryptoStore(webStore) {
                    var _this;
                    (0, _classCallCheck2["default"])(this, LocalStorageCryptoStore);
                    _this = _super.call(this);
                    _this.store = webStore;
                    return _this;
                }
                (0, _createClass2["default"])(LocalStorageCryptoStore, [{
                        key: "countEndToEndSessions",
                        value: function countEndToEndSessions(txn, func) {
                            var count = 0;
                            for (var i = 0; i < this.store.length; ++i) {
                                if (this.store.key(i).startsWith(keyEndToEndSessions('')))
                                    ++count;
                            }
                            func(count);
                        }
                    }, {
                        key: "_getEndToEndSessions",
                        value: function _getEndToEndSessions(deviceKey, txn, func) {
                            var sessions = getJsonItem(this.store, keyEndToEndSessions(deviceKey));
                            var fixedSessions = {};
                            for (var _i = 0, _Object$entries = Object.entries(sessions || {}); _i < _Object$entries.length; _i++) {
                                var _Object$entries$_i = (0, _slicedToArray2["default"])(_Object$entries[_i], 2), sid = _Object$entries$_i[0], val = _Object$entries$_i[1];
                                if (typeof val === 'string') {
                                    fixedSessions[sid] = {
                                        session: val
                                    };
                                }
                                else {
                                    fixedSessions[sid] = val;
                                }
                            }
                            return fixedSessions;
                        }
                    }, {
                        key: "getEndToEndSession",
                        value: function getEndToEndSession(deviceKey, sessionId, txn, func) {
                            var sessions = this._getEndToEndSessions(deviceKey);
                            func(sessions[sessionId] || {});
                        }
                    }, {
                        key: "getEndToEndSessions",
                        value: function getEndToEndSessions(deviceKey, txn, func) {
                            func(this._getEndToEndSessions(deviceKey) || {});
                        }
                    }, {
                        key: "getAllEndToEndSessions",
                        value: function getAllEndToEndSessions(txn, func) {
                            for (var i = 0; i < this.store.length; ++i) {
                                if (this.store.key(i).startsWith(keyEndToEndSessions(''))) {
                                    var deviceKey = this.store.key(i).split('/')[1];
                                    for (var _i2 = 0, _Object$values = Object.values(this._getEndToEndSessions(deviceKey)); _i2 < _Object$values.length; _i2++) {
                                        var sess = _Object$values[_i2];
                                        func(sess);
                                    }
                                }
                            }
                        }
                    }, {
                        key: "storeEndToEndSession",
                        value: function storeEndToEndSession(deviceKey, sessionId, sessionInfo, txn) {
                            var sessions = this._getEndToEndSessions(deviceKey) || {};
                            sessions[sessionId] = sessionInfo;
                            setJsonItem(this.store, keyEndToEndSessions(deviceKey), sessions);
                        }
                    }, {
                        key: "storeEndToEndSessionProblem",
                        value: function () {
                            var _storeEndToEndSessionProblem = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee(deviceKey, type, fixed) {
                                var key, problems;
                                return _regenerator["default"].wrap(function _callee$(_context) {
                                    while (1) {
                                        switch (_context.prev = _context.next) {
                                            case 0:
                                                key = keyEndToEndSessionProblems(deviceKey);
                                                problems = getJsonItem(this.store, key) || [];
                                                problems.push({
                                                    type: type,
                                                    fixed: fixed,
                                                    time: Date.now()
                                                });
                                                problems.sort(function (a, b) {
                                                    return a.time - b.time;
                                                });
                                                setJsonItem(this.store, key, problems);
                                            case 5:
                                            case "end":
                                                return _context.stop();
                                        }
                                    }
                                }, _callee, this);
                            }));
                            function storeEndToEndSessionProblem(_x, _x2, _x3) {
                                return _storeEndToEndSessionProblem.apply(this, arguments);
                            }
                            return storeEndToEndSessionProblem;
                        }()
                    }, {
                        key: "getEndToEndSessionProblem",
                        value: function () {
                            var _getEndToEndSessionProblem = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee2(deviceKey, timestamp) {
                                var key, problems, lastProblem, _iterator, _step, problem;
                                return _regenerator["default"].wrap(function _callee2$(_context2) {
                                    while (1) {
                                        switch (_context2.prev = _context2.next) {
                                            case 0:
                                                key = keyEndToEndSessionProblems(deviceKey);
                                                problems = getJsonItem(this.store, key) || [];
                                                if (problems.length) {
                                                    _context2.next = 4;
                                                    break;
                                                }
                                                return _context2.abrupt("return", null);
                                            case 4:
                                                lastProblem = problems[problems.length - 1];
                                                _iterator = _createForOfIteratorHelper(problems);
                                                _context2.prev = 6;
                                                _iterator.s();
                                            case 8:
                                                if ((_step = _iterator.n()).done) {
                                                    _context2.next = 14;
                                                    break;
                                                }
                                                problem = _step.value;
                                                if (!(problem.time > timestamp)) {
                                                    _context2.next = 12;
                                                    break;
                                                }
                                                return _context2.abrupt("return", Object.assign({}, problem, {
                                                    fixed: lastProblem.fixed
                                                }));
                                            case 12:
                                                _context2.next = 8;
                                                break;
                                            case 14:
                                                _context2.next = 19;
                                                break;
                                            case 16:
                                                _context2.prev = 16;
                                                _context2.t0 = _context2["catch"](6);
                                                _iterator.e(_context2.t0);
                                            case 19:
                                                _context2.prev = 19;
                                                _iterator.f();
                                                return _context2.finish(19);
                                            case 22:
                                                if (!lastProblem.fixed) {
                                                    _context2.next = 26;
                                                    break;
                                                }
                                                return _context2.abrupt("return", null);
                                            case 26:
                                                return _context2.abrupt("return", lastProblem);
                                            case 27:
                                            case "end":
                                                return _context2.stop();
                                        }
                                    }
                                }, _callee2, this, [[6, 16, 19, 22]]);
                            }));
                            function getEndToEndSessionProblem(_x4, _x5) {
                                return _getEndToEndSessionProblem.apply(this, arguments);
                            }
                            return getEndToEndSessionProblem;
                        }()
                    }, {
                        key: "filterOutNotifiedErrorDevices",
                        value: function () {
                            var _filterOutNotifiedErrorDevices = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee3(devices) {
                                var notifiedErrorDevices, ret, _iterator2, _step2, device, userId, deviceInfo;
                                return _regenerator["default"].wrap(function _callee3$(_context3) {
                                    while (1) {
                                        switch (_context3.prev = _context3.next) {
                                            case 0:
                                                notifiedErrorDevices = getJsonItem(this.store, KEY_NOTIFIED_ERROR_DEVICES) || {};
                                                ret = [];
                                                _iterator2 = _createForOfIteratorHelper(devices);
                                                try {
                                                    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                                                        device = _step2.value;
                                                        userId = device.userId, deviceInfo = device.deviceInfo;
                                                        if (userId in notifiedErrorDevices) {
                                                            if (!(deviceInfo.deviceId in notifiedErrorDevices[userId])) {
                                                                ret.push(device);
                                                                notifiedErrorDevices[userId][deviceInfo.deviceId] = true;
                                                            }
                                                        }
                                                        else {
                                                            ret.push(device);
                                                            notifiedErrorDevices[userId] = (0, _defineProperty2["default"])({}, deviceInfo.deviceId, true);
                                                        }
                                                    }
                                                }
                                                catch (err) {
                                                    _iterator2.e(err);
                                                }
                                                finally {
                                                    _iterator2.f();
                                                }
                                                setJsonItem(this.store, KEY_NOTIFIED_ERROR_DEVICES, notifiedErrorDevices);
                                                return _context3.abrupt("return", ret);
                                            case 6:
                                            case "end":
                                                return _context3.stop();
                                        }
                                    }
                                }, _callee3, this);
                            }));
                            function filterOutNotifiedErrorDevices(_x6) {
                                return _filterOutNotifiedErrorDevices.apply(this, arguments);
                            }
                            return filterOutNotifiedErrorDevices;
                        }()
                    }, {
                        key: "getEndToEndInboundGroupSession",
                        value: function getEndToEndInboundGroupSession(senderCurve25519Key, sessionId, txn, func) {
                            func(getJsonItem(this.store, keyEndToEndInboundGroupSession(senderCurve25519Key, sessionId)), getJsonItem(this.store, keyEndToEndInboundGroupSessionWithheld(senderCurve25519Key, sessionId)));
                        }
                    }, {
                        key: "getAllEndToEndInboundGroupSessions",
                        value: function getAllEndToEndInboundGroupSessions(txn, func) {
                            for (var i = 0; i < this.store.length; ++i) {
                                var key = this.store.key(i);
                                if (key.startsWith(KEY_INBOUND_SESSION_PREFIX)) {
                                    func({
                                        senderKey: key.substr(KEY_INBOUND_SESSION_PREFIX.length, 43),
                                        sessionId: key.substr(KEY_INBOUND_SESSION_PREFIX.length + 44),
                                        sessionData: getJsonItem(this.store, key)
                                    });
                                }
                            }
                            func(null);
                        }
                    }, {
                        key: "addEndToEndInboundGroupSession",
                        value: function addEndToEndInboundGroupSession(senderCurve25519Key, sessionId, sessionData, txn) {
                            var existing = getJsonItem(this.store, keyEndToEndInboundGroupSession(senderCurve25519Key, sessionId));
                            if (!existing) {
                                this.storeEndToEndInboundGroupSession(senderCurve25519Key, sessionId, sessionData, txn);
                            }
                        }
                    }, {
                        key: "storeEndToEndInboundGroupSession",
                        value: function storeEndToEndInboundGroupSession(senderCurve25519Key, sessionId, sessionData, txn) {
                            setJsonItem(this.store, keyEndToEndInboundGroupSession(senderCurve25519Key, sessionId), sessionData);
                        }
                    }, {
                        key: "storeEndToEndInboundGroupSessionWithheld",
                        value: function storeEndToEndInboundGroupSessionWithheld(senderCurve25519Key, sessionId, sessionData, txn) {
                            setJsonItem(this.store, keyEndToEndInboundGroupSessionWithheld(senderCurve25519Key, sessionId), sessionData);
                        }
                    }, {
                        key: "getEndToEndDeviceData",
                        value: function getEndToEndDeviceData(txn, func) {
                            func(getJsonItem(this.store, KEY_DEVICE_DATA));
                        }
                    }, {
                        key: "storeEndToEndDeviceData",
                        value: function storeEndToEndDeviceData(deviceData, txn) {
                            setJsonItem(this.store, KEY_DEVICE_DATA, deviceData);
                        }
                    }, {
                        key: "storeEndToEndRoom",
                        value: function storeEndToEndRoom(roomId, roomInfo, txn) {
                            setJsonItem(this.store, keyEndToEndRoomsPrefix(roomId), roomInfo);
                        }
                    }, {
                        key: "getEndToEndRooms",
                        value: function getEndToEndRooms(txn, func) {
                            var result = {};
                            var prefix = keyEndToEndRoomsPrefix('');
                            for (var i = 0; i < this.store.length; ++i) {
                                var key = this.store.key(i);
                                if (key.startsWith(prefix)) {
                                    var roomId = key.substr(prefix.length);
                                    result[roomId] = getJsonItem(this.store, key);
                                }
                            }
                            func(result);
                        }
                    }, {
                        key: "getSessionsNeedingBackup",
                        value: function getSessionsNeedingBackup(limit) {
                            var _this2 = this;
                            var sessionsNeedingBackup = getJsonItem(this.store, KEY_SESSIONS_NEEDING_BACKUP) || {};
                            var sessions = [];
                            for (var session in sessionsNeedingBackup) {
                                if (Object.prototype.hasOwnProperty.call(sessionsNeedingBackup, session)) {
                                    var _ret = function () {
                                        var senderKey = session.substr(0, 43);
                                        var sessionId = session.substr(44);
                                        _this2.getEndToEndInboundGroupSession(senderKey, sessionId, null, function (sessionData) {
                                            sessions.push({
                                                senderKey: senderKey,
                                                sessionId: sessionId,
                                                sessionData: sessionData
                                            });
                                        });
                                        if (limit && session.length >= limit) {
                                            return "break";
                                        }
                                    }();
                                    if (_ret === "break")
                                        break;
                                }
                            }
                            return Promise.resolve(sessions);
                        }
                    }, {
                        key: "countSessionsNeedingBackup",
                        value: function countSessionsNeedingBackup() {
                            var sessionsNeedingBackup = getJsonItem(this.store, KEY_SESSIONS_NEEDING_BACKUP) || {};
                            return Promise.resolve(Object.keys(sessionsNeedingBackup).length);
                        }
                    }, {
                        key: "unmarkSessionsNeedingBackup",
                        value: function unmarkSessionsNeedingBackup(sessions) {
                            var sessionsNeedingBackup = getJsonItem(this.store, KEY_SESSIONS_NEEDING_BACKUP) || {};
                            var _iterator3 = _createForOfIteratorHelper(sessions), _step3;
                            try {
                                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                                    var session = _step3.value;
                                    delete sessionsNeedingBackup[session.senderKey + '/' + session.sessionId];
                                }
                            }
                            catch (err) {
                                _iterator3.e(err);
                            }
                            finally {
                                _iterator3.f();
                            }
                            setJsonItem(this.store, KEY_SESSIONS_NEEDING_BACKUP, sessionsNeedingBackup);
                            return Promise.resolve();
                        }
                    }, {
                        key: "markSessionsNeedingBackup",
                        value: function markSessionsNeedingBackup(sessions) {
                            var sessionsNeedingBackup = getJsonItem(this.store, KEY_SESSIONS_NEEDING_BACKUP) || {};
                            var _iterator4 = _createForOfIteratorHelper(sessions), _step4;
                            try {
                                for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                                    var session = _step4.value;
                                    sessionsNeedingBackup[session.senderKey + '/' + session.sessionId] = true;
                                }
                            }
                            catch (err) {
                                _iterator4.e(err);
                            }
                            finally {
                                _iterator4.f();
                            }
                            setJsonItem(this.store, KEY_SESSIONS_NEEDING_BACKUP, sessionsNeedingBackup);
                            return Promise.resolve();
                        }
                    }, {
                        key: "deleteAllData",
                        value: function deleteAllData() {
                            this.store.removeItem(KEY_END_TO_END_ACCOUNT);
                            return Promise.resolve();
                        }
                    }, {
                        key: "getAccount",
                        value: function getAccount(txn, func) {
                            var account = getJsonItem(this.store, KEY_END_TO_END_ACCOUNT);
                            func(account);
                        }
                    }, {
                        key: "storeAccount",
                        value: function storeAccount(txn, newData) {
                            setJsonItem(this.store, KEY_END_TO_END_ACCOUNT, newData);
                        }
                    }, {
                        key: "getCrossSigningKeys",
                        value: function getCrossSigningKeys(txn, func) {
                            var keys = getJsonItem(this.store, KEY_CROSS_SIGNING_KEYS);
                            func(keys);
                        }
                    }, {
                        key: "getSecretStorePrivateKey",
                        value: function getSecretStorePrivateKey(txn, func, type) {
                            var key = getJsonItem(this.store, E2E_PREFIX + "ssss_cache.".concat(type));
                            func(key);
                        }
                    }, {
                        key: "storeCrossSigningKeys",
                        value: function storeCrossSigningKeys(txn, keys) {
                            setJsonItem(this.store, KEY_CROSS_SIGNING_KEYS, keys);
                        }
                    }, {
                        key: "storeSecretStorePrivateKey",
                        value: function storeSecretStorePrivateKey(txn, type, key) {
                            setJsonItem(this.store, E2E_PREFIX + "ssss_cache.".concat(type), key);
                        }
                    }, {
                        key: "doTxn",
                        value: function doTxn(mode, stores, func) {
                            return Promise.resolve(func(null));
                        }
                    }], [{
                        key: "exists",
                        value: function exists(webStore) {
                            var length = webStore.length;
                            for (var i = 0; i < length; i++) {
                                if (webStore.key(i).startsWith(E2E_PREFIX)) {
                                    return true;
                                }
                            }
                            return false;
                        }
                    }]);
                return LocalStorageCryptoStore;
            }(_memoryCryptoStore.MemoryCryptoStore);
            exports.LocalStorageCryptoStore = LocalStorageCryptoStore;
            function getJsonItem(store, key) {
                try {
                    return JSON.parse(store.getItem(key));
                }
                catch (e) {
                    _logger.logger.log("Error: Failed to get key %s: %s", key, e.stack || e);
                    _logger.logger.log(e.stack);
                }
                return null;
            }
            function setJsonItem(store, key, val) {
                store.setItem(key, JSON.stringify(val));
            }
        }, { "../../logger": 97, "./memory-crypto-store": 82, "@babel/runtime/helpers/asyncToGenerator": 5, "@babel/runtime/helpers/classCallCheck": 6, "@babel/runtime/helpers/createClass": 8, "@babel/runtime/helpers/defineProperty": 9, "@babel/runtime/helpers/getPrototypeOf": 10, "@babel/runtime/helpers/inherits": 11, "@babel/runtime/helpers/interopRequireDefault": 12, "@babel/runtime/helpers/possibleConstructorReturn": 20, "@babel/runtime/helpers/slicedToArray": 22, "@babel/runtime/regenerator": 27 }], 82: [function (require, module, exports) {
            "use strict";
            var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
            var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.MemoryCryptoStore = void 0;
            var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
            var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
            var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
            var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
            var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
            var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
            var _logger = require("../../logger");
            var utils = _interopRequireWildcard(require("../../utils"));
            function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly)
                    symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; });
                keys.push.apply(keys, symbols);
            } return keys; }
            function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                    ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); });
                }
                else if (Object.getOwnPropertyDescriptors) {
                    Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                }
                else {
                    ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); });
                }
            } return target; }
            function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
                if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                    if (it)
                        o = it;
                    var i = 0;
                    var F = function F() { };
                    return { s: F, n: function n() { if (i >= o.length)
                            return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try {
                    if (!normalCompletion && it["return"] != null)
                        it["return"]();
                }
                finally {
                    if (didErr)
                        throw err;
                } } }; }
            function _unsupportedIterableToArray(o, minLen) { if (!o)
                return; if (typeof o === "string")
                return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor)
                n = o.constructor.name; if (n === "Map" || n === "Set")
                return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return _arrayLikeToArray(o, minLen); }
            function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length)
                len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
            } return arr2; }
            var MemoryCryptoStore = function () {
                function MemoryCryptoStore() {
                    (0, _classCallCheck2["default"])(this, MemoryCryptoStore);
                    this._outgoingRoomKeyRequests = [];
                    this._account = null;
                    this._crossSigningKeys = null;
                    this._privateKeys = {};
                    this._backupKeys = {};
                    this._sessions = {};
                    this._sessionProblems = {};
                    this._notifiedErrorDevices = {};
                    this._inboundGroupSessions = {};
                    this._inboundGroupSessionsWithheld = {};
                    this._deviceData = null;
                    this._rooms = {};
                    this._sessionsNeedingBackup = {};
                }
                (0, _createClass2["default"])(MemoryCryptoStore, [{
                        key: "startup",
                        value: function () {
                            var _startup = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee() {
                                return _regenerator["default"].wrap(function _callee$(_context) {
                                    while (1) {
                                        switch (_context.prev = _context.next) {
                                            case 0:
                                                return _context.abrupt("return", this);
                                            case 1:
                                            case "end":
                                                return _context.stop();
                                        }
                                    }
                                }, _callee, this);
                            }));
                            function startup() {
                                return _startup.apply(this, arguments);
                            }
                            return startup;
                        }()
                    }, {
                        key: "deleteAllData",
                        value: function deleteAllData() {
                            return Promise.resolve();
                        }
                    }, {
                        key: "getOrAddOutgoingRoomKeyRequest",
                        value: function getOrAddOutgoingRoomKeyRequest(request) {
                            var _this = this;
                            var requestBody = request.requestBody;
                            return utils.promiseTry(function () {
                                var existing = _this._getOutgoingRoomKeyRequest(requestBody);
                                if (existing) {
                                    _logger.logger.log("already have key request outstanding for " + "".concat(requestBody.room_id, " / ").concat(requestBody.session_id, ": ") + "not sending another");
                                    return existing;
                                }
                                _logger.logger.log("enqueueing key request for ".concat(requestBody.room_id, " / ") + requestBody.session_id);
                                _this._outgoingRoomKeyRequests.push(request);
                                return request;
                            });
                        }
                    }, {
                        key: "getOutgoingRoomKeyRequest",
                        value: function getOutgoingRoomKeyRequest(requestBody) {
                            return Promise.resolve(this._getOutgoingRoomKeyRequest(requestBody));
                        }
                    }, {
                        key: "_getOutgoingRoomKeyRequest",
                        value: function _getOutgoingRoomKeyRequest(requestBody) {
                            var _iterator = _createForOfIteratorHelper(this._outgoingRoomKeyRequests), _step;
                            try {
                                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                                    var existing = _step.value;
                                    if (utils.deepCompare(existing.requestBody, requestBody)) {
                                        return existing;
                                    }
                                }
                            }
                            catch (err) {
                                _iterator.e(err);
                            }
                            finally {
                                _iterator.f();
                            }
                            return null;
                        }
                    }, {
                        key: "getOutgoingRoomKeyRequestByState",
                        value: function getOutgoingRoomKeyRequestByState(wantedStates) {
                            var _iterator2 = _createForOfIteratorHelper(this._outgoingRoomKeyRequests), _step2;
                            try {
                                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                                    var req = _step2.value;
                                    var _iterator3 = _createForOfIteratorHelper(wantedStates), _step3;
                                    try {
                                        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                                            var state = _step3.value;
                                            if (req.state === state) {
                                                return Promise.resolve(req);
                                            }
                                        }
                                    }
                                    catch (err) {
                                        _iterator3.e(err);
                                    }
                                    finally {
                                        _iterator3.f();
                                    }
                                }
                            }
                            catch (err) {
                                _iterator2.e(err);
                            }
                            finally {
                                _iterator2.f();
                            }
                            return Promise.resolve(null);
                        }
                    }, {
                        key: "getAllOutgoingRoomKeyRequestsByState",
                        value: function getAllOutgoingRoomKeyRequestsByState(wantedState) {
                            return Promise.resolve(this._outgoingRoomKeyRequests.filter(function (r) {
                                return r.state == wantedState;
                            }));
                        }
                    }, {
                        key: "getOutgoingRoomKeyRequestsByTarget",
                        value: function getOutgoingRoomKeyRequestsByTarget(userId, deviceId, wantedStates) {
                            var results = [];
                            var _iterator4 = _createForOfIteratorHelper(this._outgoingRoomKeyRequests), _step4;
                            try {
                                for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                                    var req = _step4.value;
                                    var _iterator5 = _createForOfIteratorHelper(wantedStates), _step5;
                                    try {
                                        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                                            var state = _step5.value;
                                            if (req.state === state && req.recipients.includes({
                                                userId: userId,
                                                deviceId: deviceId
                                            })) {
                                                results.push(req);
                                            }
                                        }
                                    }
                                    catch (err) {
                                        _iterator5.e(err);
                                    }
                                    finally {
                                        _iterator5.f();
                                    }
                                }
                            }
                            catch (err) {
                                _iterator4.e(err);
                            }
                            finally {
                                _iterator4.f();
                            }
                            return Promise.resolve(results);
                        }
                    }, {
                        key: "updateOutgoingRoomKeyRequest",
                        value: function updateOutgoingRoomKeyRequest(requestId, expectedState, updates) {
                            var _iterator6 = _createForOfIteratorHelper(this._outgoingRoomKeyRequests), _step6;
                            try {
                                for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                                    var req = _step6.value;
                                    if (req.requestId !== requestId) {
                                        continue;
                                    }
                                    if (req.state != expectedState) {
                                        _logger.logger.warn("Cannot update room key request from ".concat(expectedState, " ") + "as it was already updated to ".concat(req.state));
                                        return Promise.resolve(null);
                                    }
                                    Object.assign(req, updates);
                                    return Promise.resolve(req);
                                }
                            }
                            catch (err) {
                                _iterator6.e(err);
                            }
                            finally {
                                _iterator6.f();
                            }
                            return Promise.resolve(null);
                        }
                    }, {
                        key: "deleteOutgoingRoomKeyRequest",
                        value: function deleteOutgoingRoomKeyRequest(requestId, expectedState) {
                            for (var i = 0; i < this._outgoingRoomKeyRequests.length; i++) {
                                var req = this._outgoingRoomKeyRequests[i];
                                if (req.requestId !== requestId) {
                                    continue;
                                }
                                if (req.state != expectedState) {
                                    _logger.logger.warn("Cannot delete room key request in state ".concat(req.state, " ") + "(expected ".concat(expectedState, ")"));
                                    return Promise.resolve(null);
                                }
                                this._outgoingRoomKeyRequests.splice(i, 1);
                                return Promise.resolve(req);
                            }
                            return Promise.resolve(null);
                        }
                    }, {
                        key: "getAccount",
                        value: function getAccount(txn, func) {
                            func(this._account);
                        }
                    }, {
                        key: "storeAccount",
                        value: function storeAccount(txn, newData) {
                            this._account = newData;
                        }
                    }, {
                        key: "getCrossSigningKeys",
                        value: function getCrossSigningKeys(txn, func) {
                            func(this._crossSigningKeys);
                        }
                    }, {
                        key: "getSecretStorePrivateKey",
                        value: function getSecretStorePrivateKey(txn, func, type) {
                            var result = this._privateKeys[type];
                            return func(result || null);
                        }
                    }, {
                        key: "storeCrossSigningKeys",
                        value: function storeCrossSigningKeys(txn, keys) {
                            this._crossSigningKeys = keys;
                        }
                    }, {
                        key: "storeSecretStorePrivateKey",
                        value: function storeSecretStorePrivateKey(txn, type, key) {
                            this._privateKeys[type] = key;
                        }
                    }, {
                        key: "countEndToEndSessions",
                        value: function countEndToEndSessions(txn, func) {
                            return Object.keys(this._sessions).length;
                        }
                    }, {
                        key: "getEndToEndSession",
                        value: function getEndToEndSession(deviceKey, sessionId, txn, func) {
                            var deviceSessions = this._sessions[deviceKey] || {};
                            func(deviceSessions[sessionId] || null);
                        }
                    }, {
                        key: "getEndToEndSessions",
                        value: function getEndToEndSessions(deviceKey, txn, func) {
                            func(this._sessions[deviceKey] || {});
                        }
                    }, {
                        key: "getAllEndToEndSessions",
                        value: function getAllEndToEndSessions(txn, func) {
                            Object.entries(this._sessions).forEach(function (_ref) {
                                var _ref2 = (0, _slicedToArray2["default"])(_ref, 2), deviceKey = _ref2[0], deviceSessions = _ref2[1];
                                Object.entries(deviceSessions).forEach(function (_ref3) {
                                    var _ref4 = (0, _slicedToArray2["default"])(_ref3, 2), sessionId = _ref4[0], session = _ref4[1];
                                    func(_objectSpread(_objectSpread({}, session), {}, {
                                        deviceKey: deviceKey,
                                        sessionId: sessionId
                                    }));
                                });
                            });
                        }
                    }, {
                        key: "storeEndToEndSession",
                        value: function storeEndToEndSession(deviceKey, sessionId, sessionInfo, txn) {
                            var deviceSessions = this._sessions[deviceKey];
                            if (deviceSessions === undefined) {
                                deviceSessions = {};
                                this._sessions[deviceKey] = deviceSessions;
                            }
                            deviceSessions[sessionId] = sessionInfo;
                        }
                    }, {
                        key: "storeEndToEndSessionProblem",
                        value: function () {
                            var _storeEndToEndSessionProblem = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee2(deviceKey, type, fixed) {
                                var problems;
                                return _regenerator["default"].wrap(function _callee2$(_context2) {
                                    while (1) {
                                        switch (_context2.prev = _context2.next) {
                                            case 0:
                                                problems = this._sessionProblems[deviceKey] = this._sessionProblems[deviceKey] || [];
                                                problems.push({
                                                    type: type,
                                                    fixed: fixed,
                                                    time: Date.now()
                                                });
                                                problems.sort(function (a, b) {
                                                    return a.time - b.time;
                                                });
                                            case 3:
                                            case "end":
                                                return _context2.stop();
                                        }
                                    }
                                }, _callee2, this);
                            }));
                            function storeEndToEndSessionProblem(_x, _x2, _x3) {
                                return _storeEndToEndSessionProblem.apply(this, arguments);
                            }
                            return storeEndToEndSessionProblem;
                        }()
                    }, {
                        key: "getEndToEndSessionProblem",
                        value: function () {
                            var _getEndToEndSessionProblem = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee3(deviceKey, timestamp) {
                                var problems, lastProblem, _iterator7, _step7, problem;
                                return _regenerator["default"].wrap(function _callee3$(_context3) {
                                    while (1) {
                                        switch (_context3.prev = _context3.next) {
                                            case 0:
                                                problems = this._sessionProblems[deviceKey] || [];
                                                if (problems.length) {
                                                    _context3.next = 3;
                                                    break;
                                                }
                                                return _context3.abrupt("return", null);
                                            case 3:
                                                lastProblem = problems[problems.length - 1];
                                                _iterator7 = _createForOfIteratorHelper(problems);
                                                _context3.prev = 5;
                                                _iterator7.s();
                                            case 7:
                                                if ((_step7 = _iterator7.n()).done) {
                                                    _context3.next = 13;
                                                    break;
                                                }
                                                problem = _step7.value;
                                                if (!(problem.time > timestamp)) {
                                                    _context3.next = 11;
                                                    break;
                                                }
                                                return _context3.abrupt("return", Object.assign({}, problem, {
                                                    fixed: lastProblem.fixed
                                                }));
                                            case 11:
                                                _context3.next = 7;
                                                break;
                                            case 13:
                                                _context3.next = 18;
                                                break;
                                            case 15:
                                                _context3.prev = 15;
                                                _context3.t0 = _context3["catch"](5);
                                                _iterator7.e(_context3.t0);
                                            case 18:
                                                _context3.prev = 18;
                                                _iterator7.f();
                                                return _context3.finish(18);
                                            case 21:
                                                if (!lastProblem.fixed) {
                                                    _context3.next = 25;
                                                    break;
                                                }
                                                return _context3.abrupt("return", null);
                                            case 25:
                                                return _context3.abrupt("return", lastProblem);
                                            case 26:
                                            case "end":
                                                return _context3.stop();
                                        }
                                    }
                                }, _callee3, this, [[5, 15, 18, 21]]);
                            }));
                            function getEndToEndSessionProblem(_x4, _x5) {
                                return _getEndToEndSessionProblem.apply(this, arguments);
                            }
                            return getEndToEndSessionProblem;
                        }()
                    }, {
                        key: "filterOutNotifiedErrorDevices",
                        value: function () {
                            var _filterOutNotifiedErrorDevices = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee4(devices) {
                                var notifiedErrorDevices, ret, _iterator8, _step8, device, userId, deviceInfo;
                                return _regenerator["default"].wrap(function _callee4$(_context4) {
                                    while (1) {
                                        switch (_context4.prev = _context4.next) {
                                            case 0:
                                                notifiedErrorDevices = this._notifiedErrorDevices;
                                                ret = [];
                                                _iterator8 = _createForOfIteratorHelper(devices);
                                                try {
                                                    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
                                                        device = _step8.value;
                                                        userId = device.userId, deviceInfo = device.deviceInfo;
                                                        if (userId in notifiedErrorDevices) {
                                                            if (!(deviceInfo.deviceId in notifiedErrorDevices[userId])) {
                                                                ret.push(device);
                                                                notifiedErrorDevices[userId][deviceInfo.deviceId] = true;
                                                            }
                                                        }
                                                        else {
                                                            ret.push(device);
                                                            notifiedErrorDevices[userId] = (0, _defineProperty2["default"])({}, deviceInfo.deviceId, true);
                                                        }
                                                    }
                                                }
                                                catch (err) {
                                                    _iterator8.e(err);
                                                }
                                                finally {
                                                    _iterator8.f();
                                                }
                                                return _context4.abrupt("return", ret);
                                            case 5:
                                            case "end":
                                                return _context4.stop();
                                        }
                                    }
                                }, _callee4, this);
                            }));
                            function filterOutNotifiedErrorDevices(_x6) {
                                return _filterOutNotifiedErrorDevices.apply(this, arguments);
                            }
                            return filterOutNotifiedErrorDevices;
                        }()
                    }, {
                        key: "getEndToEndInboundGroupSession",
                        value: function getEndToEndInboundGroupSession(senderCurve25519Key, sessionId, txn, func) {
                            var k = senderCurve25519Key + '/' + sessionId;
                            func(this._inboundGroupSessions[k] || null, this._inboundGroupSessionsWithheld[k] || null);
                        }
                    }, {
                        key: "getAllEndToEndInboundGroupSessions",
                        value: function getAllEndToEndInboundGroupSessions(txn, func) {
                            for (var _i = 0, _Object$keys = Object.keys(this._inboundGroupSessions); _i < _Object$keys.length; _i++) {
                                var key = _Object$keys[_i];
                                func({
                                    senderKey: key.substr(0, 43),
                                    sessionId: key.substr(44),
                                    sessionData: this._inboundGroupSessions[key]
                                });
                            }
                            func(null);
                        }
                    }, {
                        key: "addEndToEndInboundGroupSession",
                        value: function addEndToEndInboundGroupSession(senderCurve25519Key, sessionId, sessionData, txn) {
                            var k = senderCurve25519Key + '/' + sessionId;
                            if (this._inboundGroupSessions[k] === undefined) {
                                this._inboundGroupSessions[k] = sessionData;
                            }
                        }
                    }, {
                        key: "storeEndToEndInboundGroupSession",
                        value: function storeEndToEndInboundGroupSession(senderCurve25519Key, sessionId, sessionData, txn) {
                            this._inboundGroupSessions[senderCurve25519Key + '/' + sessionId] = sessionData;
                        }
                    }, {
                        key: "storeEndToEndInboundGroupSessionWithheld",
                        value: function storeEndToEndInboundGroupSessionWithheld(senderCurve25519Key, sessionId, sessionData, txn) {
                            var k = senderCurve25519Key + '/' + sessionId;
                            this._inboundGroupSessionsWithheld[k] = sessionData;
                        }
                    }, {
                        key: "getEndToEndDeviceData",
                        value: function getEndToEndDeviceData(txn, func) {
                            func(this._deviceData);
                        }
                    }, {
                        key: "storeEndToEndDeviceData",
                        value: function storeEndToEndDeviceData(deviceData, txn) {
                            this._deviceData = deviceData;
                        }
                    }, {
                        key: "storeEndToEndRoom",
                        value: function storeEndToEndRoom(roomId, roomInfo, txn) {
                            this._rooms[roomId] = roomInfo;
                        }
                    }, {
                        key: "getEndToEndRooms",
                        value: function getEndToEndRooms(txn, func) {
                            func(this._rooms);
                        }
                    }, {
                        key: "getSessionsNeedingBackup",
                        value: function getSessionsNeedingBackup(limit) {
                            var sessions = [];
                            for (var session in this._sessionsNeedingBackup) {
                                if (this._inboundGroupSessions[session]) {
                                    sessions.push({
                                        senderKey: session.substr(0, 43),
                                        sessionId: session.substr(44),
                                        sessionData: this._inboundGroupSessions[session]
                                    });
                                    if (limit && session.length >= limit) {
                                        break;
                                    }
                                }
                            }
                            return Promise.resolve(sessions);
                        }
                    }, {
                        key: "countSessionsNeedingBackup",
                        value: function countSessionsNeedingBackup() {
                            return Promise.resolve(Object.keys(this._sessionsNeedingBackup).length);
                        }
                    }, {
                        key: "unmarkSessionsNeedingBackup",
                        value: function unmarkSessionsNeedingBackup(sessions) {
                            var _iterator9 = _createForOfIteratorHelper(sessions), _step9;
                            try {
                                for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
                                    var session = _step9.value;
                                    var sessionKey = session.senderKey + '/' + session.sessionId;
                                    delete this._sessionsNeedingBackup[sessionKey];
                                }
                            }
                            catch (err) {
                                _iterator9.e(err);
                            }
                            finally {
                                _iterator9.f();
                            }
                            return Promise.resolve();
                        }
                    }, {
                        key: "markSessionsNeedingBackup",
                        value: function markSessionsNeedingBackup(sessions) {
                            var _iterator10 = _createForOfIteratorHelper(sessions), _step10;
                            try {
                                for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
                                    var session = _step10.value;
                                    var sessionKey = session.senderKey + '/' + session.sessionId;
                                    this._sessionsNeedingBackup[sessionKey] = true;
                                }
                            }
                            catch (err) {
                                _iterator10.e(err);
                            }
                            finally {
                                _iterator10.f();
                            }
                            return Promise.resolve();
                        }
                    }, {
                        key: "doTxn",
                        value: function doTxn(mode, stores, func) {
                            return Promise.resolve(func(null));
                        }
                    }]);
                return MemoryCryptoStore;
            }();
            exports.MemoryCryptoStore = MemoryCryptoStore;
        }, { "../../logger": 97, "../../utils": 125, "@babel/runtime/helpers/asyncToGenerator": 5, "@babel/runtime/helpers/classCallCheck": 6, "@babel/runtime/helpers/createClass": 8, "@babel/runtime/helpers/defineProperty": 9, "@babel/runtime/helpers/interopRequireDefault": 12, "@babel/runtime/helpers/interopRequireWildcard": 13, "@babel/runtime/helpers/slicedToArray": 22, "@babel/runtime/regenerator": 27 }], 83: [function (require, module, exports) {
            "use strict";
            var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.VerificationBase = exports.SwitchStartEventError = void 0;
            var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
            var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
            var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
            var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
            var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
            var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
            var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
            var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
            var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
            var _wrapNativeSuper2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapNativeSuper"));
            var _event = require("../../models/event");
            var _events = require("events");
            var _logger = require("../../logger");
            var _deviceinfo = require("../deviceinfo");
            var _Error2 = require("./Error");
            var _CrossSigning = require("../CrossSigning");
            function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) {
                var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor;
                result = Reflect.construct(Super, arguments, NewTarget);
            }
            else {
                result = Super.apply(this, arguments);
            } return (0, _possibleConstructorReturn2["default"])(this, result); }; }
            function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct)
                return false; if (Reflect.construct.sham)
                return false; if (typeof Proxy === "function")
                return true; try {
                Date.prototype.toString.call(Reflect.construct(Date, [], function () { }));
                return true;
            }
            catch (e) {
                return false;
            } }
            var timeoutException = new Error("Verification timed out");
            var SwitchStartEventError = function (_Error) {
                (0, _inherits2["default"])(SwitchStartEventError, _Error);
                var _super = _createSuper(SwitchStartEventError);
                function SwitchStartEventError(startEvent) {
                    var _this;
                    (0, _classCallCheck2["default"])(this, SwitchStartEventError);
                    _this = _super.call(this);
                    _this.startEvent = startEvent;
                    return _this;
                }
                return SwitchStartEventError;
            }((0, _wrapNativeSuper2["default"])(Error));
            exports.SwitchStartEventError = SwitchStartEventError;
            var VerificationBase = function (_EventEmitter) {
                (0, _inherits2["default"])(VerificationBase, _EventEmitter);
                var _super2 = _createSuper(VerificationBase);
                function VerificationBase(channel, baseApis, userId, deviceId, startEvent, request) {
                    var _this2;
                    (0, _classCallCheck2["default"])(this, VerificationBase);
                    _this2 = _super2.call(this);
                    _this2._channel = channel;
                    _this2._baseApis = baseApis;
                    _this2.userId = userId;
                    _this2.deviceId = deviceId;
                    _this2.startEvent = startEvent;
                    _this2.request = request;
                    _this2.cancelled = false;
                    _this2._done = false;
                    _this2._promise = null;
                    _this2._transactionTimeoutTimer = null;
                    return _this2;
                }
                (0, _createClass2["default"])(VerificationBase, [{
                        key: "_resetTimer",
                        value: function _resetTimer() {
                            var _this3 = this;
                            _logger.logger.info("Refreshing/starting the verification transaction timeout timer");
                            if (this._transactionTimeoutTimer !== null) {
                                clearTimeout(this._transactionTimeoutTimer);
                            }
                            this._transactionTimeoutTimer = setTimeout(function () {
                                if (!_this3._done && !_this3.cancelled) {
                                    _logger.logger.info("Triggering verification timeout");
                                    _this3.cancel(timeoutException);
                                }
                            }, 10 * 60 * 1000);
                        }
                    }, {
                        key: "_endTimer",
                        value: function _endTimer() {
                            if (this._transactionTimeoutTimer !== null) {
                                clearTimeout(this._transactionTimeoutTimer);
                                this._transactionTimeoutTimer = null;
                            }
                        }
                    }, {
                        key: "_send",
                        value: function _send(type, uncompletedContent) {
                            return this._channel.send(type, uncompletedContent);
                        }
                    }, {
                        key: "_waitForEvent",
                        value: function _waitForEvent(type) {
                            var _this4 = this;
                            if (this._done) {
                                return Promise.reject(new Error("Verification is already done"));
                            }
                            var existingEvent = this.request.getEventFromOtherParty(type);
                            if (existingEvent) {
                                return Promise.resolve(existingEvent);
                            }
                            this._expectedEvent = type;
                            return new Promise(function (resolve, reject) {
                                _this4._resolveEvent = resolve;
                                _this4._rejectEvent = reject;
                            });
                        }
                    }, {
                        key: "canSwitchStartEvent",
                        value: function canSwitchStartEvent() {
                            return false;
                        }
                    }, {
                        key: "switchStartEvent",
                        value: function switchStartEvent(event) {
                            if (this.canSwitchStartEvent(event)) {
                                _logger.logger.log("Verification Base: switching verification start event", {
                                    restartingFlow: !!this._rejectEvent
                                });
                                if (this._rejectEvent) {
                                    var reject = this._rejectEvent;
                                    this._rejectEvent = undefined;
                                    reject(new SwitchStartEventError(event));
                                }
                                else {
                                    this.startEvent = event;
                                }
                            }
                        }
                    }, {
                        key: "handleEvent",
                        value: function handleEvent(e) {
                            if (this._done) {
                                return;
                            }
                            else if (e.getType() === this._expectedEvent) {
                                if (this._expectedEvent !== "m.key.verification.done") {
                                    this._expectedEvent = undefined;
                                    this._rejectEvent = undefined;
                                    this._resetTimer();
                                    this._resolveEvent(e);
                                }
                            }
                            else if (e.getType() === "m.key.verification.cancel") {
                                var reject = this._reject;
                                this._reject = undefined;
                                if (reject) {
                                    var content = e.getContent();
                                    var reason = content.reason, code = content.code;
                                    reject(new Error("Other side cancelled verification " + "because ".concat(reason, " (").concat(code, ")")));
                                }
                            }
                            else if (this._expectedEvent) {
                                var exception = new Error("Unexpected message: expecting " + this._expectedEvent + " but got " + e.getType());
                                this._expectedEvent = undefined;
                                if (this._rejectEvent) {
                                    var _reject = this._rejectEvent;
                                    this._rejectEvent = undefined;
                                    _reject(exception);
                                }
                                this.cancel(exception);
                            }
                        }
                    }, {
                        key: "done",
                        value: function done() {
                            this._endTimer();
                            if (!this._done) {
                                this.request.onVerifierFinished();
                                this._resolve();
                                return (0, _CrossSigning.requestKeysDuringVerification)(this._baseApis, this.userId, this.deviceId);
                            }
                        }
                    }, {
                        key: "cancel",
                        value: function cancel(e) {
                            this._endTimer();
                            if (!this._done) {
                                this.cancelled = true;
                                this.request.onVerifierCancelled();
                                if (this.userId && this.deviceId) {
                                    if (e === timeoutException) {
                                        var timeoutEvent = (0, _Error2.newTimeoutError)();
                                        this._send(timeoutEvent.getType(), timeoutEvent.getContent());
                                    }
                                    else if (e instanceof _event.MatrixEvent) {
                                        var sender = e.getSender();
                                        if (sender !== this.userId) {
                                            var content = e.getContent();
                                            if (e.getType() === "m.key.verification.cancel") {
                                                content.code = content.code || "m.unknown";
                                                content.reason = content.reason || content.body || "Unknown reason";
                                                this._send("m.key.verification.cancel", content);
                                            }
                                            else {
                                                this._send("m.key.verification.cancel", {
                                                    code: "m.unknown",
                                                    reason: content.body || "Unknown reason"
                                                });
                                            }
                                        }
                                    }
                                    else {
                                        this._send("m.key.verification.cancel", {
                                            code: "m.unknown",
                                            reason: e.toString()
                                        });
                                    }
                                }
                                if (this._promise !== null) {
                                    if (this._reject)
                                        this._reject(e);
                                }
                                else {
                                    this._promise = Promise.reject(e);
                                }
                                this.emit('cancel', e);
                            }
                        }
                    }, {
                        key: "verify",
                        value: function verify() {
                            var _this5 = this;
                            if (this._promise)
                                return this._promise;
                            this._promise = new Promise(function (resolve, reject) {
                                _this5._resolve = function () {
                                    _this5._done = true;
                                    _this5._endTimer();
                                    resolve.apply(void 0, arguments);
                                };
                                _this5._reject = function () {
                                    _this5._done = true;
                                    _this5._endTimer();
                                    reject.apply(void 0, arguments);
                                };
                            });
                            if (this._doVerification && !this._started) {
                                this._started = true;
                                this._resetTimer();
                                Promise.resolve(this._doVerification()).then(this.done.bind(this), this.cancel.bind(this));
                            }
                            return this._promise;
                        }
                    }, {
                        key: "_verifyKeys",
                        value: function () {
                            var _verifyKeys2 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee(userId, keys, verifier) {
                                var verifiedDevices, _i, _Object$entries, _Object$entries$_i, keyId, keyInfo, deviceId, device, crossSigningInfo, _i2, _verifiedDevices, _deviceId;
                                return _regenerator["default"].wrap(function _callee$(_context) {
                                    while (1) {
                                        switch (_context.prev = _context.next) {
                                            case 0:
                                                verifiedDevices = [];
                                                _i = 0, _Object$entries = Object.entries(keys);
                                            case 2:
                                                if (!(_i < _Object$entries.length)) {
                                                    _context.next = 23;
                                                    break;
                                                }
                                                _Object$entries$_i = (0, _slicedToArray2["default"])(_Object$entries[_i], 2), keyId = _Object$entries$_i[0], keyInfo = _Object$entries$_i[1];
                                                deviceId = keyId.split(':', 2)[1];
                                                device = this._baseApis.getStoredDevice(userId, deviceId);
                                                if (!device) {
                                                    _context.next = 12;
                                                    break;
                                                }
                                                _context.next = 9;
                                                return verifier(keyId, device, keyInfo);
                                            case 9:
                                                verifiedDevices.push(deviceId);
                                                _context.next = 20;
                                                break;
                                            case 12:
                                                crossSigningInfo = this._baseApis._crypto._deviceList.getStoredCrossSigningForUser(userId);
                                                if (!(crossSigningInfo && crossSigningInfo.getId() === deviceId)) {
                                                    _context.next = 19;
                                                    break;
                                                }
                                                _context.next = 16;
                                                return verifier(keyId, _deviceinfo.DeviceInfo.fromStorage({
                                                    keys: (0, _defineProperty2["default"])({}, keyId, deviceId)
                                                }, deviceId), keyInfo);
                                            case 16:
                                                verifiedDevices.push(deviceId);
                                                _context.next = 20;
                                                break;
                                            case 19:
                                                _logger.logger.warn("verification: Could not find device ".concat(deviceId, " to verify"));
                                            case 20:
                                                _i++;
                                                _context.next = 2;
                                                break;
                                            case 23:
                                                if (verifiedDevices.length) {
                                                    _context.next = 25;
                                                    break;
                                                }
                                                throw new Error("No devices could be verified");
                                            case 25:
                                                _logger.logger.info("Verification completed! Marking devices verified: ", verifiedDevices);
                                                _i2 = 0, _verifiedDevices = verifiedDevices;
                                            case 27:
                                                if (!(_i2 < _verifiedDevices.length)) {
                                                    _context.next = 34;
                                                    break;
                                                }
                                                _deviceId = _verifiedDevices[_i2];
                                                _context.next = 31;
                                                return this._baseApis.setDeviceVerified(userId, _deviceId);
                                            case 31:
                                                _i2++;
                                                _context.next = 27;
                                                break;
                                            case 34:
                                            case "end":
                                                return _context.stop();
                                        }
                                    }
                                }, _callee, this);
                            }));
                            function _verifyKeys(_x, _x2, _x3) {
                                return _verifyKeys2.apply(this, arguments);
                            }
                            return _verifyKeys;
                        }()
                    }, {
                        key: "initiatedByMe",
                        get: function get() {
                            if (!this.startEvent) {
                                return true;
                            }
                            var sender = this.startEvent.getSender();
                            var content = this.startEvent.getContent();
                            return sender === this._baseApis.getUserId() && content.from_device === this._baseApis.getDeviceId();
                        }
                    }]);
                return VerificationBase;
            }(_events.EventEmitter);
            exports.VerificationBase = VerificationBase;
        }, { "../../logger": 97, "../../models/event": 102, "../CrossSigning": 61, "../deviceinfo": 74, "./Error": 84, "@babel/runtime/helpers/asyncToGenerator": 5, "@babel/runtime/helpers/classCallCheck": 6, "@babel/runtime/helpers/createClass": 8, "@babel/runtime/helpers/defineProperty": 9, "@babel/runtime/helpers/getPrototypeOf": 10, "@babel/runtime/helpers/inherits": 11, "@babel/runtime/helpers/interopRequireDefault": 12, "@babel/runtime/helpers/possibleConstructorReturn": 20, "@babel/runtime/helpers/slicedToArray": 22, "@babel/runtime/helpers/wrapNativeSuper": 26, "@babel/runtime/regenerator": 27, "events": 36 }], 84: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.newVerificationError = newVerificationError;
            exports.errorFactory = errorFactory;
            exports.errorFromEvent = errorFromEvent;
            exports.newInvalidMessageError = exports.newUserMismatchError = exports.newKeyMismatchError = exports.newUnexpectedMessageError = exports.newUnknownMethodError = exports.newUnknownTransactionError = exports.newTimeoutError = exports.newUserCancelledError = void 0;
            var _event = require("../../models/event");
            function newVerificationError(code, reason, extradata) {
                var content = Object.assign({}, {
                    code: code,
                    reason: reason
                }, extradata);
                return new _event.MatrixEvent({
                    type: "m.key.verification.cancel",
                    content: content
                });
            }
            function errorFactory(code, reason) {
                return function (extradata) {
                    return newVerificationError(code, reason, extradata);
                };
            }
            var newUserCancelledError = errorFactory("m.user", "Cancelled by user");
            exports.newUserCancelledError = newUserCancelledError;
            var newTimeoutError = errorFactory("m.timeout", "Timed out");
            exports.newTimeoutError = newTimeoutError;
            var newUnknownTransactionError = errorFactory("m.unknown_transaction", "Unknown transaction");
            exports.newUnknownTransactionError = newUnknownTransactionError;
            var newUnknownMethodError = errorFactory("m.unknown_method", "Unknown method");
            exports.newUnknownMethodError = newUnknownMethodError;
            var newUnexpectedMessageError = errorFactory("m.unexpected_message", "Unexpected message");
            exports.newUnexpectedMessageError = newUnexpectedMessageError;
            var newKeyMismatchError = errorFactory("m.key_mismatch", "Key mismatch");
            exports.newKeyMismatchError = newKeyMismatchError;
            var newUserMismatchError = errorFactory("m.user_error", "User mismatch");
            exports.newUserMismatchError = newUserMismatchError;
            var newInvalidMessageError = errorFactory("m.invalid_message", "Invalid message");
            exports.newInvalidMessageError = newInvalidMessageError;
            function errorFromEvent(event) {
                var content = event.getContent();
                if (content) {
                    var code = content.code, reason = content.reason;
                    return {
                        code: code,
                        reason: reason
                    };
                }
                else {
                    return {
                        code: "Unknown error",
                        reason: "m.unknown"
                    };
                }
            }
        }, { "../../models/event": 102 }], 85: [function (require, module, exports) {
            "use strict";
            var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.IllegalMethod = void 0;
            var _construct2 = _interopRequireDefault(require("@babel/runtime/helpers/construct"));
            var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
            var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
            var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
            var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
            var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
            var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
            var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
            var _Base2 = require("./Base");
            function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) {
                var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor;
                result = Reflect.construct(Super, arguments, NewTarget);
            }
            else {
                result = Super.apply(this, arguments);
            } return (0, _possibleConstructorReturn2["default"])(this, result); }; }
            function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct)
                return false; if (Reflect.construct.sham)
                return false; if (typeof Proxy === "function")
                return true; try {
                Date.prototype.toString.call(Reflect.construct(Date, [], function () { }));
                return true;
            }
            catch (e) {
                return false;
            } }
            var IllegalMethod = function (_Base) {
                (0, _inherits2["default"])(IllegalMethod, _Base);
                var _super = _createSuper(IllegalMethod);
                function IllegalMethod() {
                    (0, _classCallCheck2["default"])(this, IllegalMethod);
                    return _super.apply(this, arguments);
                }
                (0, _createClass2["default"])(IllegalMethod, [{
                        key: "_doVerification",
                        value: function () {
                            var _doVerification2 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee() {
                                return _regenerator["default"].wrap(function _callee$(_context) {
                                    while (1) {
                                        switch (_context.prev = _context.next) {
                                            case 0:
                                                throw new Error("Verification is not possible with this method");
                                            case 1:
                                            case "end":
                                                return _context.stop();
                                        }
                                    }
                                }, _callee);
                            }));
                            function _doVerification() {
                                return _doVerification2.apply(this, arguments);
                            }
                            return _doVerification;
                        }()
                    }], [{
                        key: "factory",
                        value: function factory() {
                            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                                args[_key] = arguments[_key];
                            }
                            return (0, _construct2["default"])(IllegalMethod, args);
                        }
                    }, {
                        key: "NAME",
                        get: function get() {
                            return "org.matrix.illegal_method";
                        }
                    }]);
                return IllegalMethod;
            }(_Base2.VerificationBase);
            exports.IllegalMethod = IllegalMethod;
        }, { "./Base": 83, "@babel/runtime/helpers/asyncToGenerator": 5, "@babel/runtime/helpers/classCallCheck": 6, "@babel/runtime/helpers/construct": 7, "@babel/runtime/helpers/createClass": 8, "@babel/runtime/helpers/getPrototypeOf": 10, "@babel/runtime/helpers/inherits": 11, "@babel/runtime/helpers/interopRequireDefault": 12, "@babel/runtime/helpers/possibleConstructorReturn": 20, "@babel/runtime/regenerator": 27 }], 86: [function (require, module, exports) {
            (function (global, Buffer) {
                (function () {
                    "use strict";
                    var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
                    Object.defineProperty(exports, "__esModule", {
                        value: true
                    });
                    exports.QRCodeData = exports.ReciprocateQRCode = exports.SCAN_QR_CODE_METHOD = exports.SHOW_QR_CODE_METHOD = void 0;
                    var _construct2 = _interopRequireDefault(require("@babel/runtime/helpers/construct"));
                    var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
                    var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
                    var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
                    var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
                    var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
                    var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
                    var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
                    var _Base2 = require("./Base");
                    var _Error = require("./Error");
                    var _olmlib = require("../olmlib");
                    var _logger = require("../../logger");
                    function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) {
                        var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor;
                        result = Reflect.construct(Super, arguments, NewTarget);
                    }
                    else {
                        result = Super.apply(this, arguments);
                    } return (0, _possibleConstructorReturn2["default"])(this, result); }; }
                    function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct)
                        return false; if (Reflect.construct.sham)
                        return false; if (typeof Proxy === "function")
                        return true; try {
                        Date.prototype.toString.call(Reflect.construct(Date, [], function () { }));
                        return true;
                    }
                    catch (e) {
                        return false;
                    } }
                    var SHOW_QR_CODE_METHOD = "m.qr_code.show.v1";
                    exports.SHOW_QR_CODE_METHOD = SHOW_QR_CODE_METHOD;
                    var SCAN_QR_CODE_METHOD = "m.qr_code.scan.v1";
                    exports.SCAN_QR_CODE_METHOD = SCAN_QR_CODE_METHOD;
                    var ReciprocateQRCode = function (_Base) {
                        (0, _inherits2["default"])(ReciprocateQRCode, _Base);
                        var _super = _createSuper(ReciprocateQRCode);
                        function ReciprocateQRCode() {
                            (0, _classCallCheck2["default"])(this, ReciprocateQRCode);
                            return _super.apply(this, arguments);
                        }
                        (0, _createClass2["default"])(ReciprocateQRCode, [{
                                key: "_doVerification",
                                value: function () {
                                    var _doVerification2 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee() {
                                        var _this = this;
                                        var qrCodeData, keys, masterKey, deviceId, _masterKey;
                                        return _regenerator["default"].wrap(function _callee$(_context) {
                                            while (1) {
                                                switch (_context.prev = _context.next) {
                                                    case 0:
                                                        if (this.startEvent) {
                                                            _context.next = 2;
                                                            break;
                                                        }
                                                        throw new Error("It is not currently possible to start verification" + "with this method yet.");
                                                    case 2:
                                                        qrCodeData = this.request.qrCodeData;
                                                        if (!(this.startEvent.getContent()['secret'] !== qrCodeData.encodedSharedSecret)) {
                                                            _context.next = 5;
                                                            break;
                                                        }
                                                        throw (0, _Error.newKeyMismatchError)();
                                                    case 5:
                                                        _context.next = 7;
                                                        return new Promise(function (resolve, reject) {
                                                            _this.reciprocateQREvent = {
                                                                confirm: resolve,
                                                                cancel: function cancel() {
                                                                    return reject((0, _Error.newUserCancelledError)());
                                                                }
                                                            };
                                                            _this.emit("show_reciprocate_qr", _this.reciprocateQREvent);
                                                        });
                                                    case 7:
                                                        keys = {};
                                                        _context.t0 = qrCodeData.mode;
                                                        _context.next = _context.t0 === MODE_VERIFY_OTHER_USER ? 11 : _context.t0 === MODE_VERIFY_SELF_TRUSTED ? 14 : _context.t0 === MODE_VERIFY_SELF_UNTRUSTED ? 17 : 20;
                                                        break;
                                                    case 11:
                                                        masterKey = qrCodeData.otherUserMasterKey;
                                                        keys["ed25519:".concat(masterKey)] = masterKey;
                                                        return _context.abrupt("break", 20);
                                                    case 14:
                                                        deviceId = this.request.targetDevice.deviceId;
                                                        keys["ed25519:".concat(deviceId)] = qrCodeData.otherDeviceKey;
                                                        return _context.abrupt("break", 20);
                                                    case 17:
                                                        _masterKey = qrCodeData.myMasterKey;
                                                        keys["ed25519:".concat(_masterKey)] = _masterKey;
                                                        return _context.abrupt("break", 20);
                                                    case 20:
                                                        _context.next = 22;
                                                        return this._verifyKeys(this.userId, keys, function (keyId, device, keyInfo) {
                                                            var targetKey = keys[keyId];
                                                            if (!targetKey)
                                                                throw (0, _Error.newKeyMismatchError)();
                                                            if (keyInfo !== targetKey) {
                                                                _logger.logger.error("key ID from key info does not match");
                                                                throw (0, _Error.newKeyMismatchError)();
                                                            }
                                                            for (var deviceKeyId in device.keys) {
                                                                if (!deviceKeyId.startsWith("ed25519"))
                                                                    continue;
                                                                var deviceTargetKey = keys[deviceKeyId];
                                                                if (!deviceTargetKey)
                                                                    throw (0, _Error.newKeyMismatchError)();
                                                                if (device.keys[deviceKeyId] !== deviceTargetKey) {
                                                                    _logger.logger.error("master key does not match");
                                                                    throw (0, _Error.newKeyMismatchError)();
                                                                }
                                                            }
                                                        });
                                                    case 22:
                                                    case "end":
                                                        return _context.stop();
                                                }
                                            }
                                        }, _callee, this);
                                    }));
                                    function _doVerification() {
                                        return _doVerification2.apply(this, arguments);
                                    }
                                    return _doVerification;
                                }()
                            }], [{
                                key: "factory",
                                value: function factory() {
                                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                                        args[_key] = arguments[_key];
                                    }
                                    return (0, _construct2["default"])(ReciprocateQRCode, args);
                                }
                            }, {
                                key: "NAME",
                                get: function get() {
                                    return "m.reciprocate.v1";
                                }
                            }]);
                        return ReciprocateQRCode;
                    }(_Base2.VerificationBase);
                    exports.ReciprocateQRCode = ReciprocateQRCode;
                    var CODE_VERSION = 0x02;
                    var BINARY_PREFIX = "MATRIX";
                    var MODE_VERIFY_OTHER_USER = 0x00;
                    var MODE_VERIFY_SELF_TRUSTED = 0x01;
                    var MODE_VERIFY_SELF_UNTRUSTED = 0x02;
                    var QRCodeData = function () {
                        function QRCodeData(mode, sharedSecret, otherUserMasterKey, otherDeviceKey, myMasterKey, buffer) {
                            (0, _classCallCheck2["default"])(this, QRCodeData);
                            this._sharedSecret = sharedSecret;
                            this._mode = mode;
                            this._otherUserMasterKey = otherUserMasterKey;
                            this._otherDeviceKey = otherDeviceKey;
                            this._myMasterKey = myMasterKey;
                            this._buffer = buffer;
                        }
                        (0, _createClass2["default"])(QRCodeData, [{
                                key: "buffer",
                                get: function get() {
                                    return this._buffer;
                                }
                            }, {
                                key: "mode",
                                get: function get() {
                                    return this._mode;
                                }
                            }, {
                                key: "otherDeviceKey",
                                get: function get() {
                                    return this._otherDeviceKey;
                                }
                            }, {
                                key: "otherUserMasterKey",
                                get: function get() {
                                    return this._otherUserMasterKey;
                                }
                            }, {
                                key: "myMasterKey",
                                get: function get() {
                                    return this._myMasterKey;
                                }
                            }, {
                                key: "encodedSharedSecret",
                                get: function get() {
                                    return this._sharedSecret;
                                }
                            }], [{
                                key: "create",
                                value: function () {
                                    var _create = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee2(request, client) {
                                        var sharedSecret, mode, otherUserMasterKey, otherDeviceKey, myMasterKey, otherUserCrossSigningInfo, myUserId, myCrossSigningInfo, qrData, buffer;
                                        return _regenerator["default"].wrap(function _callee2$(_context2) {
                                            while (1) {
                                                switch (_context2.prev = _context2.next) {
                                                    case 0:
                                                        sharedSecret = QRCodeData._generateSharedSecret();
                                                        mode = QRCodeData._determineMode(request, client);
                                                        otherUserMasterKey = null;
                                                        otherDeviceKey = null;
                                                        myMasterKey = null;
                                                        if (!(mode === MODE_VERIFY_OTHER_USER)) {
                                                            _context2.next = 10;
                                                            break;
                                                        }
                                                        otherUserCrossSigningInfo = client.getStoredCrossSigningForUser(request.otherUserId);
                                                        otherUserMasterKey = otherUserCrossSigningInfo.getId("master");
                                                        _context2.next = 17;
                                                        break;
                                                    case 10:
                                                        if (!(mode === MODE_VERIFY_SELF_TRUSTED)) {
                                                            _context2.next = 16;
                                                            break;
                                                        }
                                                        _context2.next = 13;
                                                        return QRCodeData._getOtherDeviceKey(request, client);
                                                    case 13:
                                                        otherDeviceKey = _context2.sent;
                                                        _context2.next = 17;
                                                        break;
                                                    case 16:
                                                        if (mode === MODE_VERIFY_SELF_UNTRUSTED) {
                                                            myUserId = client.getUserId();
                                                            myCrossSigningInfo = client.getStoredCrossSigningForUser(myUserId);
                                                            myMasterKey = myCrossSigningInfo.getId("master");
                                                        }
                                                    case 17:
                                                        qrData = QRCodeData._generateQrData(request, client, mode, sharedSecret, otherUserMasterKey, otherDeviceKey, myMasterKey);
                                                        buffer = QRCodeData._generateBuffer(qrData);
                                                        return _context2.abrupt("return", new QRCodeData(mode, sharedSecret, otherUserMasterKey, otherDeviceKey, myMasterKey, buffer));
                                                    case 20:
                                                    case "end":
                                                        return _context2.stop();
                                                }
                                            }
                                        }, _callee2);
                                    }));
                                    function create(_x, _x2) {
                                        return _create.apply(this, arguments);
                                    }
                                    return create;
                                }()
                            }, {
                                key: "_generateSharedSecret",
                                value: function _generateSharedSecret() {
                                    var secretBytes = new Uint8Array(11);
                                    global.crypto.getRandomValues(secretBytes);
                                    return (0, _olmlib.encodeUnpaddedBase64)(secretBytes);
                                }
                            }, {
                                key: "_getOtherDeviceKey",
                                value: function () {
                                    var _getOtherDeviceKey2 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee3(request, client) {
                                        var myUserId, otherDevice, otherDeviceId, device, key;
                                        return _regenerator["default"].wrap(function _callee3$(_context3) {
                                            while (1) {
                                                switch (_context3.prev = _context3.next) {
                                                    case 0:
                                                        myUserId = client.getUserId();
                                                        otherDevice = request.targetDevice;
                                                        otherDeviceId = otherDevice ? otherDevice.deviceId : null;
                                                        device = client.getStoredDevice(myUserId, otherDeviceId);
                                                        if (device) {
                                                            _context3.next = 6;
                                                            break;
                                                        }
                                                        throw new Error("could not find device " + otherDeviceId);
                                                    case 6:
                                                        key = device.getFingerprint();
                                                        return _context3.abrupt("return", key);
                                                    case 8:
                                                    case "end":
                                                        return _context3.stop();
                                                }
                                            }
                                        }, _callee3);
                                    }));
                                    function _getOtherDeviceKey(_x3, _x4) {
                                        return _getOtherDeviceKey2.apply(this, arguments);
                                    }
                                    return _getOtherDeviceKey;
                                }()
                            }, {
                                key: "_determineMode",
                                value: function _determineMode(request, client) {
                                    var myUserId = client.getUserId();
                                    var otherUserId = request.otherUserId;
                                    var mode = MODE_VERIFY_OTHER_USER;
                                    if (myUserId === otherUserId) {
                                        var myTrust = client.checkUserTrust(myUserId);
                                        if (myTrust.isCrossSigningVerified()) {
                                            mode = MODE_VERIFY_SELF_TRUSTED;
                                        }
                                        else {
                                            mode = MODE_VERIFY_SELF_UNTRUSTED;
                                        }
                                    }
                                    return mode;
                                }
                            }, {
                                key: "_generateQrData",
                                value: function _generateQrData(request, client, mode, encodedSharedSecret, otherUserMasterKey, otherDeviceKey, myMasterKey) {
                                    var myUserId = client.getUserId();
                                    var transactionId = request.channel.transactionId;
                                    var qrData = {
                                        prefix: BINARY_PREFIX,
                                        version: CODE_VERSION,
                                        mode: mode,
                                        transactionId: transactionId,
                                        firstKeyB64: '',
                                        secondKeyB64: '',
                                        secretB64: encodedSharedSecret
                                    };
                                    var myCrossSigningInfo = client.getStoredCrossSigningForUser(myUserId);
                                    if (mode === MODE_VERIFY_OTHER_USER) {
                                        qrData.firstKeyB64 = myCrossSigningInfo.getId("master");
                                        qrData.secondKeyB64 = otherUserMasterKey;
                                    }
                                    else if (mode === MODE_VERIFY_SELF_TRUSTED) {
                                        qrData.firstKeyB64 = myCrossSigningInfo.getId("master");
                                        qrData.secondKeyB64 = otherDeviceKey;
                                    }
                                    else if (mode === MODE_VERIFY_SELF_UNTRUSTED) {
                                        qrData.firstKeyB64 = client.getDeviceEd25519Key();
                                        qrData.secondKeyB64 = myMasterKey;
                                    }
                                    return qrData;
                                }
                            }, {
                                key: "_generateBuffer",
                                value: function _generateBuffer(qrData) {
                                    var buf = Buffer.alloc(0);
                                    var appendByte = function appendByte(b) {
                                        var tmpBuf = Buffer.from([b]);
                                        buf = Buffer.concat([buf, tmpBuf]);
                                    };
                                    var appendInt = function appendInt(i) {
                                        var tmpBuf = Buffer.alloc(2);
                                        tmpBuf.writeInt16BE(i, 0);
                                        buf = Buffer.concat([buf, tmpBuf]);
                                    };
                                    var appendStr = function appendStr(s, enc) {
                                        var withLengthPrefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
                                        var tmpBuf = Buffer.from(s, enc);
                                        if (withLengthPrefix)
                                            appendInt(tmpBuf.byteLength);
                                        buf = Buffer.concat([buf, tmpBuf]);
                                    };
                                    var appendEncBase64 = function appendEncBase64(b64) {
                                        var b = (0, _olmlib.decodeBase64)(b64);
                                        var tmpBuf = Buffer.from(b);
                                        buf = Buffer.concat([buf, tmpBuf]);
                                    };
                                    appendStr(qrData.prefix, "ascii", false);
                                    appendByte(qrData.version);
                                    appendByte(qrData.mode);
                                    appendStr(qrData.transactionId, "utf-8");
                                    appendEncBase64(qrData.firstKeyB64);
                                    appendEncBase64(qrData.secondKeyB64);
                                    appendEncBase64(qrData.secretB64);
                                    return buf;
                                }
                            }]);
                        return QRCodeData;
                    }();
                    exports.QRCodeData = QRCodeData;
                }).call(this);
            }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, require("buffer").Buffer);
        }, { "../../logger": 97, "../olmlib": 77, "./Base": 83, "./Error": 84, "@babel/runtime/helpers/asyncToGenerator": 5, "@babel/runtime/helpers/classCallCheck": 6, "@babel/runtime/helpers/construct": 7, "@babel/runtime/helpers/createClass": 8, "@babel/runtime/helpers/getPrototypeOf": 10, "@babel/runtime/helpers/inherits": 11, "@babel/runtime/helpers/interopRequireDefault": 12, "@babel/runtime/helpers/possibleConstructorReturn": 20, "@babel/runtime/regenerator": 27, "buffer": 34 }], 87: [function (require, module, exports) {
            (function (global) {
                (function () {
                    "use strict";
                    var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
                    Object.defineProperty(exports, "__esModule", {
                        value: true
                    });
                    exports.SAS = void 0;
                    var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
                    var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
                    var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
                    var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
                    var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
                    var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
                    var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
                    var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
                    var _Base2 = require("./Base");
                    var _anotherJson = _interopRequireDefault(require("another-json"));
                    var _Error = require("./Error");
                    var _logger = require("../../logger");
                    function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) {
                        var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor;
                        result = Reflect.construct(Super, arguments, NewTarget);
                    }
                    else {
                        result = Super.apply(this, arguments);
                    } return (0, _possibleConstructorReturn2["default"])(this, result); }; }
                    function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct)
                        return false; if (Reflect.construct.sham)
                        return false; if (typeof Proxy === "function")
                        return true; try {
                        Date.prototype.toString.call(Reflect.construct(Date, [], function () { }));
                        return true;
                    }
                    catch (e) {
                        return false;
                    } }
                    function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
                        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                            if (it)
                                o = it;
                            var i = 0;
                            var F = function F() { };
                            return { s: F, n: function n() { if (i >= o.length)
                                    return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F };
                        }
                        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                    } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try {
                            if (!normalCompletion && it["return"] != null)
                                it["return"]();
                        }
                        finally {
                            if (didErr)
                                throw err;
                        } } }; }
                    function _unsupportedIterableToArray(o, minLen) { if (!o)
                        return; if (typeof o === "string")
                        return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor)
                        n = o.constructor.name; if (n === "Map" || n === "Set")
                        return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                        return _arrayLikeToArray(o, minLen); }
                    function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length)
                        len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) {
                        arr2[i] = arr[i];
                    } return arr2; }
                    var START_TYPE = "m.key.verification.start";
                    var EVENTS = ["m.key.verification.accept", "m.key.verification.key", "m.key.verification.mac"];
                    var olmutil;
                    var newMismatchedSASError = (0, _Error.errorFactory)("m.mismatched_sas", "Mismatched short authentication string");
                    var newMismatchedCommitmentError = (0, _Error.errorFactory)("m.mismatched_commitment", "Mismatched commitment");
                    function generateDecimalSas(sasBytes) {
                        return [(sasBytes[0] << 5 | sasBytes[1] >> 3) + 1000, ((sasBytes[1] & 0x7) << 10 | sasBytes[2] << 2 | sasBytes[3] >> 6) + 1000, ((sasBytes[3] & 0x3f) << 7 | sasBytes[4] >> 1) + 1000];
                    }
                    var emojiMapping = [["", "dog"],
                        ["", "cat"],
                        ["", "lion"],
                        ["", "horse"],
                        ["", "unicorn"],
                        ["", "pig"],
                        ["", "elephant"],
                        ["", "rabbit"],
                        ["", "panda"],
                        ["", "rooster"],
                        ["", "penguin"],
                        ["", "turtle"],
                        ["", "fish"],
                        ["", "octopus"],
                        ["", "butterfly"],
                        ["", "flower"],
                        ["", "tree"],
                        ["", "cactus"],
                        ["", "mushroom"],
                        ["", "globe"],
                        ["", "moon"],
                        ["", "cloud"],
                        ["", "fire"],
                        ["", "banana"],
                        ["", "apple"],
                        ["", "strawberry"],
                        ["", "corn"],
                        ["", "pizza"],
                        ["", "cake"],
                        ["", "heart"],
                        ["", "smiley"],
                        ["", "robot"],
                        ["", "hat"],
                        ["", "glasses"],
                        ["", "spanner"],
                        ["", "santa"],
                        ["", "thumbs up"],
                        ["", "umbrella"],
                        ["", "hourglass"],
                        ["", "clock"],
                        ["", "gift"],
                        ["", "light bulb"],
                        ["", "book"],
                        ["", "pencil"],
                        ["", "paperclip"],
                        ["", "scissors"],
                        ["", "lock"],
                        ["", "key"],
                        ["", "hammer"],
                        ["", "telephone"],
                        ["", "flag"],
                        ["", "train"],
                        ["", "bicycle"],
                        ["", "aeroplane"],
                        ["", "rocket"],
                        ["", "trophy"],
                        ["", "ball"],
                        ["", "guitar"],
                        ["", "trumpet"],
                        ["", "bell"],
                        ["", "anchor"],
                        ["", "headphones"],
                        ["", "folder"],
                        ["", "pin"]
                    ];
                    function generateEmojiSas(sasBytes) {
                        var emojis = [
                            sasBytes[0] >> 2, (sasBytes[0] & 0x3) << 4 | sasBytes[1] >> 4, (sasBytes[1] & 0xf) << 2 | sasBytes[2] >> 6, sasBytes[2] & 0x3f, sasBytes[3] >> 2, (sasBytes[3] & 0x3) << 4 | sasBytes[4] >> 4, (sasBytes[4] & 0xf) << 2 | sasBytes[5] >> 6
                        ];
                        return emojis.map(function (num) {
                            return emojiMapping[num];
                        });
                    }
                    var sasGenerators = {
                        decimal: generateDecimalSas,
                        emoji: generateEmojiSas
                    };
                    function generateSas(sasBytes, methods) {
                        var sas = {};
                        var _iterator = _createForOfIteratorHelper(methods), _step;
                        try {
                            for (_iterator.s(); !(_step = _iterator.n()).done;) {
                                var method = _step.value;
                                if (method in sasGenerators) {
                                    sas[method] = sasGenerators[method](sasBytes);
                                }
                            }
                        }
                        catch (err) {
                            _iterator.e(err);
                        }
                        finally {
                            _iterator.f();
                        }
                        return sas;
                    }
                    var macMethods = {
                        "hkdf-hmac-sha256": "calculate_mac",
                        "hmac-sha256": "calculate_mac_long_kdf"
                    };
                    function calculateMAC(olmSAS, method) {
                        return function () {
                            var macFunction = olmSAS[macMethods[method]];
                            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                                args[_key] = arguments[_key];
                            }
                            var mac = macFunction.apply(olmSAS, args);
                            _logger.logger.log("SAS calculateMAC:", method, args, mac);
                            return mac;
                        };
                    }
                    var calculateKeyAgreement = {
                        "curve25519-hkdf-sha256": function curve25519HkdfSha256(sas, olmSAS, bytes) {
                            var ourInfo = "".concat(sas._baseApis.getUserId(), "|").concat(sas._baseApis.deviceId, "|") + "".concat(sas.ourSASPubKey, "|");
                            var theirInfo = "".concat(sas.userId, "|").concat(sas.deviceId, "|").concat(sas.theirSASPubKey, "|");
                            var sasInfo = "MATRIX_KEY_VERIFICATION_SAS|" + (sas.initiatedByMe ? ourInfo + theirInfo : theirInfo + ourInfo) + sas._channel.transactionId;
                            return olmSAS.generate_bytes(sasInfo, bytes);
                        },
                        "curve25519": function curve25519(sas, olmSAS, bytes) {
                            var ourInfo = "".concat(sas._baseApis.getUserId()).concat(sas._baseApis.deviceId);
                            var theirInfo = "".concat(sas.userId).concat(sas.deviceId);
                            var sasInfo = "MATRIX_KEY_VERIFICATION_SAS" + (sas.initiatedByMe ? ourInfo + theirInfo : theirInfo + ourInfo) + sas._channel.transactionId;
                            return olmSAS.generate_bytes(sasInfo, bytes);
                        }
                    };
                    var KEY_AGREEMENT_LIST = ["curve25519-hkdf-sha256", "curve25519"];
                    var HASHES_LIST = ["sha256"];
                    var MAC_LIST = ["hkdf-hmac-sha256", "hmac-sha256"];
                    var SAS_LIST = Object.keys(sasGenerators);
                    var KEY_AGREEMENT_SET = new Set(KEY_AGREEMENT_LIST);
                    var HASHES_SET = new Set(HASHES_LIST);
                    var MAC_SET = new Set(MAC_LIST);
                    var SAS_SET = new Set(SAS_LIST);
                    function intersection(anArray, aSet) {
                        return anArray instanceof Array ? anArray.filter(function (x) {
                            return aSet.has(x);
                        }) : [];
                    }
                    var SAS = function (_Base) {
                        (0, _inherits2["default"])(SAS, _Base);
                        var _super = _createSuper(SAS);
                        function SAS() {
                            (0, _classCallCheck2["default"])(this, SAS);
                            return _super.apply(this, arguments);
                        }
                        (0, _createClass2["default"])(SAS, [{
                                key: "_doVerification",
                                value: function () {
                                    var _doVerification2 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee() {
                                        var retry;
                                        return _regenerator["default"].wrap(function _callee$(_context) {
                                            while (1) {
                                                switch (_context.prev = _context.next) {
                                                    case 0:
                                                        _context.next = 2;
                                                        return global.Olm.init();
                                                    case 2:
                                                        olmutil = olmutil || new global.Olm.Utility();
                                                        _context.next = 5;
                                                        return this._baseApis.downloadKeys([this.userId]);
                                                    case 5:
                                                        retry = false;
                                                    case 6:
                                                        _context.prev = 6;
                                                        if (!this.initiatedByMe) {
                                                            _context.next = 13;
                                                            break;
                                                        }
                                                        _context.next = 10;
                                                        return this._doSendVerification();
                                                    case 10:
                                                        return _context.abrupt("return", _context.sent);
                                                    case 13:
                                                        _context.next = 15;
                                                        return this._doRespondVerification();
                                                    case 15:
                                                        return _context.abrupt("return", _context.sent);
                                                    case 16:
                                                        _context.next = 26;
                                                        break;
                                                    case 18:
                                                        _context.prev = 18;
                                                        _context.t0 = _context["catch"](6);
                                                        if (!(_context.t0 instanceof _Base2.SwitchStartEventError)) {
                                                            _context.next = 25;
                                                            break;
                                                        }
                                                        this.startEvent = _context.t0.startEvent;
                                                        retry = true;
                                                        _context.next = 26;
                                                        break;
                                                    case 25:
                                                        throw _context.t0;
                                                    case 26:
                                                        if (retry) {
                                                            _context.next = 6;
                                                            break;
                                                        }
                                                    case 27:
                                                    case "end":
                                                        return _context.stop();
                                                }
                                            }
                                        }, _callee, this, [[6, 18]]);
                                    }));
                                    function _doVerification() {
                                        return _doVerification2.apply(this, arguments);
                                    }
                                    return _doVerification;
                                }()
                            }, {
                                key: "canSwitchStartEvent",
                                value: function canSwitchStartEvent(event) {
                                    if (event.getType() !== START_TYPE) {
                                        return false;
                                    }
                                    var content = event.getContent();
                                    return content && content.method === SAS.NAME && this._waitingForAccept;
                                }
                            }, {
                                key: "_sendStart",
                                value: function () {
                                    var _sendStart2 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee2() {
                                        var startContent;
                                        return _regenerator["default"].wrap(function _callee2$(_context2) {
                                            while (1) {
                                                switch (_context2.prev = _context2.next) {
                                                    case 0:
                                                        startContent = this._channel.completeContent(START_TYPE, {
                                                            method: SAS.NAME,
                                                            from_device: this._baseApis.deviceId,
                                                            key_agreement_protocols: KEY_AGREEMENT_LIST,
                                                            hashes: HASHES_LIST,
                                                            message_authentication_codes: MAC_LIST,
                                                            short_authentication_string: SAS_LIST
                                                        });
                                                        _context2.next = 3;
                                                        return this._channel.sendCompleted(START_TYPE, startContent);
                                                    case 3:
                                                        return _context2.abrupt("return", startContent);
                                                    case 4:
                                                    case "end":
                                                        return _context2.stop();
                                                }
                                            }
                                        }, _callee2, this);
                                    }));
                                    function _sendStart() {
                                        return _sendStart2.apply(this, arguments);
                                    }
                                    return _sendStart;
                                }()
                            }, {
                                key: "_doSendVerification",
                                value: function () {
                                    var _doSendVerification2 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee4() {
                                        var _this = this;
                                        var startContent, e, content, sasMethods, keyAgreement, macMethod, hashCommitment, olmSAS, commitmentStr, sasBytes, verifySAS, _yield$Promise$all, _yield$Promise$all2;
                                        return _regenerator["default"].wrap(function _callee4$(_context4) {
                                            while (1) {
                                                switch (_context4.prev = _context4.next) {
                                                    case 0:
                                                        this._waitingForAccept = true;
                                                        if (!this.startEvent) {
                                                            _context4.next = 5;
                                                            break;
                                                        }
                                                        startContent = this._channel.completedContentFromEvent(this.startEvent);
                                                        _context4.next = 8;
                                                        break;
                                                    case 5:
                                                        _context4.next = 7;
                                                        return this._sendStart();
                                                    case 7:
                                                        startContent = _context4.sent;
                                                    case 8:
                                                        if (this.initiatedByMe) {
                                                            _context4.next = 10;
                                                            break;
                                                        }
                                                        throw new _Base2.SwitchStartEventError(this.startEvent);
                                                    case 10:
                                                        _context4.prev = 10;
                                                        _context4.next = 13;
                                                        return this._waitForEvent("m.key.verification.accept");
                                                    case 13:
                                                        e = _context4.sent;
                                                    case 14:
                                                        _context4.prev = 14;
                                                        this._waitingForAccept = false;
                                                        return _context4.finish(14);
                                                    case 17:
                                                        content = e.getContent();
                                                        sasMethods = intersection(content.short_authentication_string, SAS_SET);
                                                        if (KEY_AGREEMENT_SET.has(content.key_agreement_protocol) && HASHES_SET.has(content.hash) && MAC_SET.has(content.message_authentication_code) && sasMethods.length) {
                                                            _context4.next = 21;
                                                            break;
                                                        }
                                                        throw (0, _Error.newUnknownMethodError)();
                                                    case 21:
                                                        if (!(typeof content.commitment !== "string")) {
                                                            _context4.next = 23;
                                                            break;
                                                        }
                                                        throw (0, _Error.newInvalidMessageError)();
                                                    case 23:
                                                        keyAgreement = content.key_agreement_protocol;
                                                        macMethod = content.message_authentication_code;
                                                        hashCommitment = content.commitment;
                                                        olmSAS = new global.Olm.SAS();
                                                        _context4.prev = 27;
                                                        this.ourSASPubKey = olmSAS.get_pubkey();
                                                        _context4.next = 31;
                                                        return this._send("m.key.verification.key", {
                                                            key: this.ourSASPubKey
                                                        });
                                                    case 31:
                                                        _context4.next = 33;
                                                        return this._waitForEvent("m.key.verification.key");
                                                    case 33:
                                                        e = _context4.sent;
                                                        content = e.getContent();
                                                        commitmentStr = content.key + _anotherJson["default"].stringify(startContent);
                                                        if (!(olmutil.sha256(commitmentStr) !== hashCommitment)) {
                                                            _context4.next = 38;
                                                            break;
                                                        }
                                                        throw newMismatchedCommitmentError();
                                                    case 38:
                                                        this.theirSASPubKey = content.key;
                                                        olmSAS.set_their_key(content.key);
                                                        sasBytes = calculateKeyAgreement[keyAgreement](this, olmSAS, 6);
                                                        verifySAS = new Promise(function (resolve, reject) {
                                                            _this.sasEvent = {
                                                                sas: generateSas(sasBytes, sasMethods),
                                                                confirm: function () {
                                                                    var _confirm = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee3() {
                                                                        return _regenerator["default"].wrap(function _callee3$(_context3) {
                                                                            while (1) {
                                                                                switch (_context3.prev = _context3.next) {
                                                                                    case 0:
                                                                                        _context3.prev = 0;
                                                                                        _context3.next = 3;
                                                                                        return _this._sendMAC(olmSAS, macMethod);
                                                                                    case 3:
                                                                                        resolve();
                                                                                        _context3.next = 9;
                                                                                        break;
                                                                                    case 6:
                                                                                        _context3.prev = 6;
                                                                                        _context3.t0 = _context3["catch"](0);
                                                                                        reject(_context3.t0);
                                                                                    case 9:
                                                                                    case "end":
                                                                                        return _context3.stop();
                                                                                }
                                                                            }
                                                                        }, _callee3, null, [[0, 6]]);
                                                                    }));
                                                                    function confirm() {
                                                                        return _confirm.apply(this, arguments);
                                                                    }
                                                                    return confirm;
                                                                }(),
                                                                cancel: function cancel() {
                                                                    return reject((0, _Error.newUserCancelledError)());
                                                                },
                                                                mismatch: function mismatch() {
                                                                    return reject(newMismatchedSASError());
                                                                }
                                                            };
                                                            _this.emit("show_sas", _this.sasEvent);
                                                        });
                                                        _context4.next = 44;
                                                        return Promise.all([this._waitForEvent("m.key.verification.mac").then(function (e) {
                                                                _this._expectedEvent = "m.key.verification.done";
                                                                return e;
                                                            }), verifySAS]);
                                                    case 44:
                                                        _yield$Promise$all = _context4.sent;
                                                        _yield$Promise$all2 = (0, _slicedToArray2["default"])(_yield$Promise$all, 1);
                                                        e = _yield$Promise$all2[0];
                                                        content = e.getContent();
                                                        _context4.next = 50;
                                                        return this._checkMAC(olmSAS, content, macMethod);
                                                    case 50:
                                                        _context4.prev = 50;
                                                        olmSAS.free();
                                                        return _context4.finish(50);
                                                    case 53:
                                                    case "end":
                                                        return _context4.stop();
                                                }
                                            }
                                        }, _callee4, this, [[10, , 14, 17], [27, , 50, 53]]);
                                    }));
                                    function _doSendVerification() {
                                        return _doSendVerification2.apply(this, arguments);
                                    }
                                    return _doSendVerification;
                                }()
                            }, {
                                key: "_doRespondVerification",
                                value: function () {
                                    var _doRespondVerification2 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee6() {
                                        var _this2 = this;
                                        var content, keyAgreement, hashMethod, macMethod, sasMethods, olmSAS, commitmentStr, e, sasBytes, verifySAS, _yield$Promise$all3, _yield$Promise$all4;
                                        return _regenerator["default"].wrap(function _callee6$(_context6) {
                                            while (1) {
                                                switch (_context6.prev = _context6.next) {
                                                    case 0:
                                                        content = this._channel.completedContentFromEvent(this.startEvent);
                                                        keyAgreement = intersection(KEY_AGREEMENT_LIST, new Set(content.key_agreement_protocols))[0];
                                                        hashMethod = intersection(HASHES_LIST, new Set(content.hashes))[0];
                                                        macMethod = intersection(MAC_LIST, new Set(content.message_authentication_codes))[0];
                                                        sasMethods = intersection(content.short_authentication_string, SAS_SET);
                                                        if (keyAgreement !== undefined && hashMethod !== undefined && macMethod !== undefined && sasMethods.length) {
                                                            _context6.next = 7;
                                                            break;
                                                        }
                                                        throw (0, _Error.newUnknownMethodError)();
                                                    case 7:
                                                        olmSAS = new global.Olm.SAS();
                                                        _context6.prev = 8;
                                                        commitmentStr = olmSAS.get_pubkey() + _anotherJson["default"].stringify(content);
                                                        _context6.next = 12;
                                                        return this._send("m.key.verification.accept", {
                                                            key_agreement_protocol: keyAgreement,
                                                            hash: hashMethod,
                                                            message_authentication_code: macMethod,
                                                            short_authentication_string: sasMethods,
                                                            commitment: olmutil.sha256(commitmentStr)
                                                        });
                                                    case 12:
                                                        _context6.next = 14;
                                                        return this._waitForEvent("m.key.verification.key");
                                                    case 14:
                                                        e = _context6.sent;
                                                        content = e.getContent();
                                                        this.theirSASPubKey = content.key;
                                                        olmSAS.set_their_key(content.key);
                                                        this.ourSASPubKey = olmSAS.get_pubkey();
                                                        _context6.next = 21;
                                                        return this._send("m.key.verification.key", {
                                                            key: this.ourSASPubKey
                                                        });
                                                    case 21:
                                                        sasBytes = calculateKeyAgreement[keyAgreement](this, olmSAS, 6);
                                                        verifySAS = new Promise(function (resolve, reject) {
                                                            _this2.sasEvent = {
                                                                sas: generateSas(sasBytes, sasMethods),
                                                                confirm: function () {
                                                                    var _confirm2 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee5() {
                                                                        return _regenerator["default"].wrap(function _callee5$(_context5) {
                                                                            while (1) {
                                                                                switch (_context5.prev = _context5.next) {
                                                                                    case 0:
                                                                                        _context5.prev = 0;
                                                                                        _context5.next = 3;
                                                                                        return _this2._sendMAC(olmSAS, macMethod);
                                                                                    case 3:
                                                                                        resolve();
                                                                                        _context5.next = 9;
                                                                                        break;
                                                                                    case 6:
                                                                                        _context5.prev = 6;
                                                                                        _context5.t0 = _context5["catch"](0);
                                                                                        reject(_context5.t0);
                                                                                    case 9:
                                                                                    case "end":
                                                                                        return _context5.stop();
                                                                                }
                                                                            }
                                                                        }, _callee5, null, [[0, 6]]);
                                                                    }));
                                                                    function confirm() {
                                                                        return _confirm2.apply(this, arguments);
                                                                    }
                                                                    return confirm;
                                                                }(),
                                                                cancel: function cancel() {
                                                                    return reject((0, _Error.newUserCancelledError)());
                                                                },
                                                                mismatch: function mismatch() {
                                                                    return reject(newMismatchedSASError());
                                                                }
                                                            };
                                                            _this2.emit("show_sas", _this2.sasEvent);
                                                        });
                                                        _context6.next = 25;
                                                        return Promise.all([this._waitForEvent("m.key.verification.mac").then(function (e) {
                                                                _this2._expectedEvent = "m.key.verification.done";
                                                                return e;
                                                            }), verifySAS]);
                                                    case 25:
                                                        _yield$Promise$all3 = _context6.sent;
                                                        _yield$Promise$all4 = (0, _slicedToArray2["default"])(_yield$Promise$all3, 1);
                                                        e = _yield$Promise$all4[0];
                                                        content = e.getContent();
                                                        _context6.next = 31;
                                                        return this._checkMAC(olmSAS, content, macMethod);
                                                    case 31:
                                                        _context6.prev = 31;
                                                        olmSAS.free();
                                                        return _context6.finish(31);
                                                    case 34:
                                                    case "end":
                                                        return _context6.stop();
                                                }
                                            }
                                        }, _callee6, this, [[8, , 31, 34]]);
                                    }));
                                    function _doRespondVerification() {
                                        return _doRespondVerification2.apply(this, arguments);
                                    }
                                    return _doRespondVerification;
                                }()
                            }, {
                                key: "_sendMAC",
                                value: function _sendMAC(olmSAS, method) {
                                    var mac = {};
                                    var keyList = [];
                                    var baseInfo = "MATRIX_KEY_VERIFICATION_MAC" + this._baseApis.getUserId() + this._baseApis.deviceId + this.userId + this.deviceId + this._channel.transactionId;
                                    var deviceKeyId = "ed25519:".concat(this._baseApis.deviceId);
                                    mac[deviceKeyId] = calculateMAC(olmSAS, method)(this._baseApis.getDeviceEd25519Key(), baseInfo + deviceKeyId);
                                    keyList.push(deviceKeyId);
                                    var crossSigningId = this._baseApis.getCrossSigningId();
                                    if (crossSigningId) {
                                        var crossSigningKeyId = "ed25519:".concat(crossSigningId);
                                        mac[crossSigningKeyId] = calculateMAC(olmSAS, method)(crossSigningId, baseInfo + crossSigningKeyId);
                                        keyList.push(crossSigningKeyId);
                                    }
                                    var keys = calculateMAC(olmSAS, method)(keyList.sort().join(","), baseInfo + "KEY_IDS");
                                    return this._send("m.key.verification.mac", {
                                        mac: mac,
                                        keys: keys
                                    });
                                }
                            }, {
                                key: "_checkMAC",
                                value: function () {
                                    var _checkMAC2 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee7(olmSAS, content, method) {
                                        var baseInfo;
                                        return _regenerator["default"].wrap(function _callee7$(_context7) {
                                            while (1) {
                                                switch (_context7.prev = _context7.next) {
                                                    case 0:
                                                        baseInfo = "MATRIX_KEY_VERIFICATION_MAC" + this.userId + this.deviceId + this._baseApis.getUserId() + this._baseApis.deviceId + this._channel.transactionId;
                                                        if (!(content.keys !== calculateMAC(olmSAS, method)(Object.keys(content.mac).sort().join(","), baseInfo + "KEY_IDS"))) {
                                                            _context7.next = 3;
                                                            break;
                                                        }
                                                        throw (0, _Error.newKeyMismatchError)();
                                                    case 3:
                                                        _context7.next = 5;
                                                        return this._verifyKeys(this.userId, content.mac, function (keyId, device, keyInfo) {
                                                            if (keyInfo !== calculateMAC(olmSAS, method)(device.keys[keyId], baseInfo + keyId)) {
                                                                throw (0, _Error.newKeyMismatchError)();
                                                            }
                                                        });
                                                    case 5:
                                                    case "end":
                                                        return _context7.stop();
                                                }
                                            }
                                        }, _callee7, this);
                                    }));
                                    function _checkMAC(_x, _x2, _x3) {
                                        return _checkMAC2.apply(this, arguments);
                                    }
                                    return _checkMAC;
                                }()
                            }, {
                                key: "events",
                                get: function get() {
                                    return EVENTS;
                                }
                            }], [{
                                key: "NAME",
                                get: function get() {
                                    return "m.sas.v1";
                                }
                            }]);
                        return SAS;
                    }(_Base2.VerificationBase);
                    exports.SAS = SAS;
                }).call(this);
            }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, { "../../logger": 97, "./Base": 83, "./Error": 84, "@babel/runtime/helpers/asyncToGenerator": 5, "@babel/runtime/helpers/classCallCheck": 6, "@babel/runtime/helpers/createClass": 8, "@babel/runtime/helpers/getPrototypeOf": 10, "@babel/runtime/helpers/inherits": 11, "@babel/runtime/helpers/interopRequireDefault": 12, "@babel/runtime/helpers/possibleConstructorReturn": 20, "@babel/runtime/helpers/slicedToArray": 22, "@babel/runtime/regenerator": 27, "another-json": 28 }], 88: [function (require, module, exports) {
            "use strict";
            var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.InRoomRequests = exports.InRoomChannel = void 0;
            var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
            var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
            var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
            var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
            var _VerificationRequest = require("./VerificationRequest");
            var _logger = require("../../../logger");
            function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
                if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                    if (it)
                        o = it;
                    var i = 0;
                    var F = function F() { };
                    return { s: F, n: function n() { if (i >= o.length)
                            return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try {
                    if (!normalCompletion && it["return"] != null)
                        it["return"]();
                }
                finally {
                    if (didErr)
                        throw err;
                } } }; }
            function _unsupportedIterableToArray(o, minLen) { if (!o)
                return; if (typeof o === "string")
                return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor)
                n = o.constructor.name; if (n === "Map" || n === "Set")
                return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return _arrayLikeToArray(o, minLen); }
            function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length)
                len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
            } return arr2; }
            var MESSAGE_TYPE = "m.room.message";
            var M_REFERENCE = "m.reference";
            var M_RELATES_TO = "m.relates_to";
            var InRoomChannel = function () {
                function InRoomChannel(client, roomId) {
                    var userId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
                    (0, _classCallCheck2["default"])(this, InRoomChannel);
                    this._client = client;
                    this._roomId = roomId;
                    this.userId = userId;
                    this._requestEventId = null;
                }
                (0, _createClass2["default"])(InRoomChannel, [{
                        key: "getTimestamp",
                        value: function getTimestamp(event) {
                            return event.getTs();
                        }
                    }, {
                        key: "handleEvent",
                        value: function () {
                            var _handleEvent = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee(event, request, isLiveEvent) {
                                var type, userId, ownUserId, sender, isRemoteEcho, isSentByUs;
                                return _regenerator["default"].wrap(function _callee$(_context) {
                                    while (1) {
                                        switch (_context.prev = _context.next) {
                                            case 0:
                                                if (!request.hasEventId(event.getId())) {
                                                    _context.next = 2;
                                                    break;
                                                }
                                                return _context.abrupt("return");
                                            case 2:
                                                type = InRoomChannel.getEventType(event);
                                                if (!(event.getRoomId() !== this._roomId)) {
                                                    _context.next = 5;
                                                    break;
                                                }
                                                return _context.abrupt("return");
                                            case 5:
                                                if (this.userId === null) {
                                                    userId = InRoomChannel.getOtherPartyUserId(event, this._client);
                                                    if (userId) {
                                                        this.userId = userId;
                                                    }
                                                }
                                                ownUserId = this._client.getUserId();
                                                sender = event.getSender();
                                                if (!(this.userId !== null)) {
                                                    _context.next = 12;
                                                    break;
                                                }
                                                if (!(sender !== ownUserId && sender !== this.userId)) {
                                                    _context.next = 12;
                                                    break;
                                                }
                                                _logger.logger.log("InRoomChannel: ignoring verification event from " + "non-participating sender ".concat(sender));
                                                return _context.abrupt("return");
                                            case 12:
                                                if (this._requestEventId === null) {
                                                    this._requestEventId = InRoomChannel.getTransactionId(event);
                                                }
                                                isRemoteEcho = !!event.getUnsigned().transaction_id;
                                                isSentByUs = event.getSender() === this._client.getUserId();
                                                _context.next = 17;
                                                return request.handleEvent(type, event, isLiveEvent, isRemoteEcho, isSentByUs);
                                            case 17:
                                                return _context.abrupt("return", _context.sent);
                                            case 18:
                                            case "end":
                                                return _context.stop();
                                        }
                                    }
                                }, _callee, this);
                            }));
                            function handleEvent(_x, _x2, _x3) {
                                return _handleEvent.apply(this, arguments);
                            }
                            return handleEvent;
                        }()
                    }, {
                        key: "completedContentFromEvent",
                        value: function completedContentFromEvent(event) {
                            var content = Object.assign({}, event.getContent());
                            content[M_RELATES_TO] = event.getRelation();
                            return content;
                        }
                    }, {
                        key: "completeContent",
                        value: function completeContent(type, content) {
                            content = Object.assign({}, content);
                            if (type === _VerificationRequest.REQUEST_TYPE || type === _VerificationRequest.READY_TYPE || type === _VerificationRequest.START_TYPE) {
                                content.from_device = this._client.getDeviceId();
                            }
                            if (type === _VerificationRequest.REQUEST_TYPE) {
                                content = {
                                    body: this._client.getUserId() + " is requesting to verify " + "your key, but your client does not support in-chat key " + "verification.  You will need to use legacy key " + "verification to verify keys.",
                                    msgtype: _VerificationRequest.REQUEST_TYPE,
                                    to: this.userId,
                                    from_device: content.from_device,
                                    methods: content.methods
                                };
                            }
                            else {
                                content[M_RELATES_TO] = {
                                    rel_type: M_REFERENCE,
                                    event_id: this.transactionId
                                };
                            }
                            return content;
                        }
                    }, {
                        key: "send",
                        value: function send(type, uncompletedContent) {
                            var content = this.completeContent(type, uncompletedContent);
                            return this.sendCompleted(type, content);
                        }
                    }, {
                        key: "sendCompleted",
                        value: function () {
                            var _sendCompleted = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee2(type, content) {
                                var sendType, response;
                                return _regenerator["default"].wrap(function _callee2$(_context2) {
                                    while (1) {
                                        switch (_context2.prev = _context2.next) {
                                            case 0:
                                                sendType = type;
                                                if (type === _VerificationRequest.REQUEST_TYPE) {
                                                    sendType = MESSAGE_TYPE;
                                                }
                                                _context2.next = 4;
                                                return this._client.sendEvent(this._roomId, sendType, content);
                                            case 4:
                                                response = _context2.sent;
                                                if (type === _VerificationRequest.REQUEST_TYPE) {
                                                    this._requestEventId = response.event_id;
                                                }
                                            case 6:
                                            case "end":
                                                return _context2.stop();
                                        }
                                    }
                                }, _callee2, this);
                            }));
                            function sendCompleted(_x4, _x5) {
                                return _sendCompleted.apply(this, arguments);
                            }
                            return sendCompleted;
                        }()
                    }, {
                        key: "receiveStartFromOtherDevices",
                        get: function get() {
                            return true;
                        }
                    }, {
                        key: "roomId",
                        get: function get() {
                            return this._roomId;
                        }
                    }, {
                        key: "transactionId",
                        get: function get() {
                            return this._requestEventId;
                        }
                    }], [{
                        key: "getOtherPartyUserId",
                        value: function getOtherPartyUserId(event, client) {
                            var type = InRoomChannel.getEventType(event);
                            if (type !== _VerificationRequest.REQUEST_TYPE) {
                                return;
                            }
                            var ownUserId = client.getUserId();
                            var sender = event.getSender();
                            var content = event.getContent();
                            var receiver = content.to;
                            if (sender === ownUserId) {
                                return receiver;
                            }
                            else if (receiver === ownUserId) {
                                return sender;
                            }
                        }
                    }, {
                        key: "canCreateRequest",
                        value: function canCreateRequest(type) {
                            return type === _VerificationRequest.REQUEST_TYPE;
                        }
                    }, {
                        key: "getTransactionId",
                        value: function getTransactionId(event) {
                            if (InRoomChannel.getEventType(event) === _VerificationRequest.REQUEST_TYPE) {
                                return event.getId();
                            }
                            else {
                                var relation = event.getRelation();
                                if (relation && relation.rel_type === M_REFERENCE) {
                                    return relation.event_id;
                                }
                            }
                        }
                    }, {
                        key: "validateEvent",
                        value: function validateEvent(event, client) {
                            var txnId = InRoomChannel.getTransactionId(event);
                            if (typeof txnId !== "string" || txnId.length === 0) {
                                return false;
                            }
                            var type = InRoomChannel.getEventType(event);
                            var content = event.getContent();
                            if (type === _VerificationRequest.REQUEST_TYPE) {
                                if (!content || typeof content.to !== "string" || !content.to.length) {
                                    _logger.logger.log("InRoomChannel: validateEvent: " + "no valid to " + (content && content.to));
                                    return false;
                                }
                                if (!InRoomChannel.getOtherPartyUserId(event, client)) {
                                    _logger.logger.log("InRoomChannel: validateEvent: " + "not directed to or sent by me: ".concat(event.getSender()) + ", ".concat(content && content.to));
                                    return false;
                                }
                            }
                            return _VerificationRequest.VerificationRequest.validateEvent(type, event, client);
                        }
                    }, {
                        key: "getEventType",
                        value: function getEventType(event) {
                            var type = event.getType();
                            if (type === MESSAGE_TYPE) {
                                var content = event.getContent();
                                if (content) {
                                    var msgtype = content.msgtype;
                                    if (msgtype === _VerificationRequest.REQUEST_TYPE) {
                                        return _VerificationRequest.REQUEST_TYPE;
                                    }
                                }
                            }
                            if (type && type !== _VerificationRequest.REQUEST_TYPE) {
                                return type;
                            }
                            else {
                                return "";
                            }
                        }
                    }]);
                return InRoomChannel;
            }();
            exports.InRoomChannel = InRoomChannel;
            var InRoomRequests = function () {
                function InRoomRequests() {
                    (0, _classCallCheck2["default"])(this, InRoomRequests);
                    this._requestsByRoomId = new Map();
                }
                (0, _createClass2["default"])(InRoomRequests, [{
                        key: "getRequest",
                        value: function getRequest(event) {
                            var roomId = event.getRoomId();
                            var txnId = InRoomChannel.getTransactionId(event);
                            return this._getRequestByTxnId(roomId, txnId);
                        }
                    }, {
                        key: "getRequestByChannel",
                        value: function getRequestByChannel(channel) {
                            return this._getRequestByTxnId(channel.roomId, channel.transactionId);
                        }
                    }, {
                        key: "_getRequestByTxnId",
                        value: function _getRequestByTxnId(roomId, txnId) {
                            var requestsByTxnId = this._requestsByRoomId.get(roomId);
                            if (requestsByTxnId) {
                                return requestsByTxnId.get(txnId);
                            }
                        }
                    }, {
                        key: "setRequest",
                        value: function setRequest(event, request) {
                            this._setRequest(event.getRoomId(), InRoomChannel.getTransactionId(event), request);
                        }
                    }, {
                        key: "setRequestByChannel",
                        value: function setRequestByChannel(channel, request) {
                            this._setRequest(channel.roomId, channel.transactionId, request);
                        }
                    }, {
                        key: "_setRequest",
                        value: function _setRequest(roomId, txnId, request) {
                            var requestsByTxnId = this._requestsByRoomId.get(roomId);
                            if (!requestsByTxnId) {
                                requestsByTxnId = new Map();
                                this._requestsByRoomId.set(roomId, requestsByTxnId);
                            }
                            requestsByTxnId.set(txnId, request);
                        }
                    }, {
                        key: "removeRequest",
                        value: function removeRequest(event) {
                            var roomId = event.getRoomId();
                            var requestsByTxnId = this._requestsByRoomId.get(roomId);
                            if (requestsByTxnId) {
                                requestsByTxnId["delete"](InRoomChannel.getTransactionId(event));
                                if (requestsByTxnId.size === 0) {
                                    this._requestsByRoomId["delete"](roomId);
                                }
                            }
                        }
                    }, {
                        key: "findRequestInProgress",
                        value: function findRequestInProgress(roomId) {
                            var requestsByTxnId = this._requestsByRoomId.get(roomId);
                            if (requestsByTxnId) {
                                var _iterator = _createForOfIteratorHelper(requestsByTxnId.values()), _step;
                                try {
                                    for (_iterator.s(); !(_step = _iterator.n()).done;) {
                                        var request = _step.value;
                                        if (request.pending) {
                                            return request;
                                        }
                                    }
                                }
                                catch (err) {
                                    _iterator.e(err);
                                }
                                finally {
                                    _iterator.f();
                                }
                            }
                        }
                    }]);
                return InRoomRequests;
            }();
            exports.InRoomRequests = InRoomRequests;
        }, { "../../../logger": 97, "./VerificationRequest": 90, "@babel/runtime/helpers/asyncToGenerator": 5, "@babel/runtime/helpers/classCallCheck": 6, "@babel/runtime/helpers/createClass": 8, "@babel/runtime/helpers/interopRequireDefault": 12, "@babel/runtime/regenerator": 27 }], 89: [function (require, module, exports) {
            "use strict";
            var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.ToDeviceRequests = exports.ToDeviceChannel = void 0;
            var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
            var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
            var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
            var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
            var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
            var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
            var _randomstring = require("../../../randomstring");
            var _logger = require("../../../logger");
            var _VerificationRequest = require("./VerificationRequest");
            var _Error = require("../Error");
            var _event = require("../../../models/event");
            function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
                if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                    if (it)
                        o = it;
                    var i = 0;
                    var F = function F() { };
                    return { s: F, n: function n() { if (i >= o.length)
                            return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try {
                    if (!normalCompletion && it["return"] != null)
                        it["return"]();
                }
                finally {
                    if (didErr)
                        throw err;
                } } }; }
            function _unsupportedIterableToArray(o, minLen) { if (!o)
                return; if (typeof o === "string")
                return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor)
                n = o.constructor.name; if (n === "Map" || n === "Set")
                return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return _arrayLikeToArray(o, minLen); }
            function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length)
                len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
            } return arr2; }
            var ToDeviceChannel = function () {
                function ToDeviceChannel(client, userId, devices) {
                    var transactionId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
                    var deviceId = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
                    (0, _classCallCheck2["default"])(this, ToDeviceChannel);
                    this._client = client;
                    this.userId = userId;
                    this._devices = devices;
                    this.transactionId = transactionId;
                    this._deviceId = deviceId;
                }
                (0, _createClass2["default"])(ToDeviceChannel, [{
                        key: "isToDevices",
                        value: function isToDevices(devices) {
                            var _this = this;
                            if (devices.length === this._devices.length) {
                                var _iterator = _createForOfIteratorHelper(devices), _step;
                                try {
                                    var _loop = function _loop() {
                                        var device = _step.value;
                                        var d = _this._devices.find(function (d) {
                                            return d.deviceId === device.deviceId;
                                        });
                                        if (!d) {
                                            return {
                                                v: false
                                            };
                                        }
                                    };
                                    for (_iterator.s(); !(_step = _iterator.n()).done;) {
                                        var _ret = _loop();
                                        if ((0, _typeof2["default"])(_ret) === "object")
                                            return _ret.v;
                                    }
                                }
                                catch (err) {
                                    _iterator.e(err);
                                }
                                finally {
                                    _iterator.f();
                                }
                                return true;
                            }
                            else {
                                return false;
                            }
                        }
                    }, {
                        key: "getTimestamp",
                        value: function getTimestamp(event) {
                            var content = event.getContent();
                            return content && content.timestamp;
                        }
                    }, {
                        key: "handleEvent",
                        value: function () {
                            var _handleEvent = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee(event, request, isLiveEvent) {
                                var _this2 = this;
                                var type, content, deviceId, cancelContent, wasStarted, isStarted, isAcceptingEvent, nonChosenDevices, message;
                                return _regenerator["default"].wrap(function _callee$(_context) {
                                    while (1) {
                                        switch (_context.prev = _context.next) {
                                            case 0:
                                                type = event.getType();
                                                content = event.getContent();
                                                if (!(type === _VerificationRequest.REQUEST_TYPE || type === _VerificationRequest.READY_TYPE || type === _VerificationRequest.START_TYPE)) {
                                                    _context.next = 9;
                                                    break;
                                                }
                                                if (!this.transactionId) {
                                                    this.transactionId = content.transaction_id;
                                                }
                                                deviceId = content.from_device;
                                                if (!this._deviceId && this._devices.includes(deviceId)) {
                                                    this._deviceId = deviceId;
                                                }
                                                if (!(!this._deviceId || this._deviceId !== deviceId)) {
                                                    _context.next = 9;
                                                    break;
                                                }
                                                cancelContent = this.completeContent((0, _Error.errorFromEvent)((0, _Error.newUnexpectedMessageError)()));
                                                return _context.abrupt("return", this._sendToDevices(_VerificationRequest.CANCEL_TYPE, cancelContent, [deviceId]));
                                            case 9:
                                                wasStarted = request.phase === _VerificationRequest.PHASE_STARTED || request.phase === _VerificationRequest.PHASE_READY;
                                                _context.next = 12;
                                                return request.handleEvent(event.getType(), event, isLiveEvent, false, false);
                                            case 12:
                                                isStarted = request.phase === _VerificationRequest.PHASE_STARTED || request.phase === _VerificationRequest.PHASE_READY;
                                                isAcceptingEvent = type === _VerificationRequest.START_TYPE || type === _VerificationRequest.READY_TYPE;
                                                if (!(isAcceptingEvent && !wasStarted && isStarted && this._deviceId)) {
                                                    _context.next = 20;
                                                    break;
                                                }
                                                nonChosenDevices = this._devices.filter(function (d) {
                                                    return d !== _this2._deviceId;
                                                });
                                                if (!nonChosenDevices.length) {
                                                    _context.next = 20;
                                                    break;
                                                }
                                                message = this.completeContent({
                                                    code: "m.accepted",
                                                    reason: "Verification request accepted by another device"
                                                });
                                                _context.next = 20;
                                                return this._sendToDevices(_VerificationRequest.CANCEL_TYPE, message, nonChosenDevices);
                                            case 20:
                                            case "end":
                                                return _context.stop();
                                        }
                                    }
                                }, _callee, this);
                            }));
                            function handleEvent(_x, _x2, _x3) {
                                return _handleEvent.apply(this, arguments);
                            }
                            return handleEvent;
                        }()
                    }, {
                        key: "completedContentFromEvent",
                        value: function completedContentFromEvent(event) {
                            return event.getContent();
                        }
                    }, {
                        key: "completeContent",
                        value: function completeContent(type, content) {
                            content = Object.assign({}, content);
                            if (this.transactionId) {
                                content.transaction_id = this.transactionId;
                            }
                            if (type === _VerificationRequest.REQUEST_TYPE || type === _VerificationRequest.READY_TYPE || type === _VerificationRequest.START_TYPE) {
                                content.from_device = this._client.getDeviceId();
                            }
                            if (type === _VerificationRequest.REQUEST_TYPE) {
                                content.timestamp = Date.now();
                            }
                            return content;
                        }
                    }, {
                        key: "send",
                        value: function send(type) {
                            var uncompletedContent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                            if ((type === _VerificationRequest.REQUEST_TYPE || type === _VerificationRequest.START_TYPE) && !this.transactionId) {
                                this.transactionId = ToDeviceChannel.makeTransactionId();
                            }
                            var content = this.completeContent(type, uncompletedContent);
                            return this.sendCompleted(type, content);
                        }
                    }, {
                        key: "sendCompleted",
                        value: function () {
                            var _sendCompleted = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee2(type, content) {
                                var result, remoteEchoEvent;
                                return _regenerator["default"].wrap(function _callee2$(_context2) {
                                    while (1) {
                                        switch (_context2.prev = _context2.next) {
                                            case 0:
                                                if (!(type === _VerificationRequest.REQUEST_TYPE)) {
                                                    _context2.next = 6;
                                                    break;
                                                }
                                                _context2.next = 3;
                                                return this._sendToDevices(type, content, this._devices);
                                            case 3:
                                                result = _context2.sent;
                                                _context2.next = 9;
                                                break;
                                            case 6:
                                                _context2.next = 8;
                                                return this._sendToDevices(type, content, [this._deviceId]);
                                            case 8:
                                                result = _context2.sent;
                                            case 9:
                                                remoteEchoEvent = new _event.MatrixEvent({
                                                    sender: this._client.getUserId(),
                                                    content: content,
                                                    type: type
                                                });
                                                _context2.next = 12;
                                                return this._request.handleEvent(type, remoteEchoEvent, true, true, true);
                                            case 12:
                                                return _context2.abrupt("return", result);
                                            case 13:
                                            case "end":
                                                return _context2.stop();
                                        }
                                    }
                                }, _callee2, this);
                            }));
                            function sendCompleted(_x4, _x5) {
                                return _sendCompleted.apply(this, arguments);
                            }
                            return sendCompleted;
                        }()
                    }, {
                        key: "_sendToDevices",
                        value: function _sendToDevices(type, content, devices) {
                            if (devices.length) {
                                var msgMap = {};
                                var _iterator2 = _createForOfIteratorHelper(devices), _step2;
                                try {
                                    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                                        var deviceId = _step2.value;
                                        msgMap[deviceId] = content;
                                    }
                                }
                                catch (err) {
                                    _iterator2.e(err);
                                }
                                finally {
                                    _iterator2.f();
                                }
                                return this._client.sendToDevice(type, (0, _defineProperty2["default"])({}, this.userId, msgMap));
                            }
                            else {
                                return Promise.resolve();
                            }
                        }
                    }, {
                        key: "deviceId",
                        get: function get() {
                            return this._deviceId;
                        }
                    }], [{
                        key: "getEventType",
                        value: function getEventType(event) {
                            return event.getType();
                        }
                    }, {
                        key: "getTransactionId",
                        value: function getTransactionId(event) {
                            var content = event.getContent();
                            return content && content.transaction_id;
                        }
                    }, {
                        key: "canCreateRequest",
                        value: function canCreateRequest(type) {
                            return type === _VerificationRequest.REQUEST_TYPE || type === _VerificationRequest.START_TYPE;
                        }
                    }, {
                        key: "validateEvent",
                        value: function validateEvent(event, client) {
                            if (event.isCancelled()) {
                                _logger.logger.warn("Ignoring flagged verification request from " + event.getSender());
                                return false;
                            }
                            var content = event.getContent();
                            if (!content) {
                                _logger.logger.warn("ToDeviceChannel.validateEvent: invalid: no content");
                                return false;
                            }
                            if (!content.transaction_id) {
                                _logger.logger.warn("ToDeviceChannel.validateEvent: invalid: no transaction_id");
                                return false;
                            }
                            var type = event.getType();
                            if (type === _VerificationRequest.REQUEST_TYPE) {
                                if (!Number.isFinite(content.timestamp)) {
                                    _logger.logger.warn("ToDeviceChannel.validateEvent: invalid: no timestamp");
                                    return false;
                                }
                                if (event.getSender() === client.getUserId() && content.from_device == client.getDeviceId()) {
                                    _logger.logger.warn("ToDeviceChannel.validateEvent: invalid: from own device");
                                    return false;
                                }
                            }
                            return _VerificationRequest.VerificationRequest.validateEvent(type, event, client);
                        }
                    }, {
                        key: "makeTransactionId",
                        value: function makeTransactionId() {
                            return (0, _randomstring.randomString)(32);
                        }
                    }]);
                return ToDeviceChannel;
            }();
            exports.ToDeviceChannel = ToDeviceChannel;
            var ToDeviceRequests = function () {
                function ToDeviceRequests() {
                    (0, _classCallCheck2["default"])(this, ToDeviceRequests);
                    this._requestsByUserId = new Map();
                }
                (0, _createClass2["default"])(ToDeviceRequests, [{
                        key: "getRequest",
                        value: function getRequest(event) {
                            return this.getRequestBySenderAndTxnId(event.getSender(), ToDeviceChannel.getTransactionId(event));
                        }
                    }, {
                        key: "getRequestByChannel",
                        value: function getRequestByChannel(channel) {
                            return this.getRequestBySenderAndTxnId(channel.userId, channel.transactionId);
                        }
                    }, {
                        key: "getRequestBySenderAndTxnId",
                        value: function getRequestBySenderAndTxnId(sender, txnId) {
                            var requestsByTxnId = this._requestsByUserId.get(sender);
                            if (requestsByTxnId) {
                                return requestsByTxnId.get(txnId);
                            }
                        }
                    }, {
                        key: "setRequest",
                        value: function setRequest(event, request) {
                            this.setRequestBySenderAndTxnId(event.getSender(), ToDeviceChannel.getTransactionId(event), request);
                        }
                    }, {
                        key: "setRequestByChannel",
                        value: function setRequestByChannel(channel, request) {
                            this.setRequestBySenderAndTxnId(channel.userId, channel.transactionId, request);
                        }
                    }, {
                        key: "setRequestBySenderAndTxnId",
                        value: function setRequestBySenderAndTxnId(sender, txnId, request) {
                            var requestsByTxnId = this._requestsByUserId.get(sender);
                            if (!requestsByTxnId) {
                                requestsByTxnId = new Map();
                                this._requestsByUserId.set(sender, requestsByTxnId);
                            }
                            requestsByTxnId.set(txnId, request);
                        }
                    }, {
                        key: "removeRequest",
                        value: function removeRequest(event) {
                            var userId = event.getSender();
                            var requestsByTxnId = this._requestsByUserId.get(userId);
                            if (requestsByTxnId) {
                                requestsByTxnId["delete"](ToDeviceChannel.getTransactionId(event));
                                if (requestsByTxnId.size === 0) {
                                    this._requestsByUserId["delete"](userId);
                                }
                            }
                        }
                    }, {
                        key: "findRequestInProgress",
                        value: function findRequestInProgress(userId, devices) {
                            var requestsByTxnId = this._requestsByUserId.get(userId);
                            if (requestsByTxnId) {
                                var _iterator3 = _createForOfIteratorHelper(requestsByTxnId.values()), _step3;
                                try {
                                    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                                        var request = _step3.value;
                                        if (request.pending && request.channel.isToDevices(devices)) {
                                            return request;
                                        }
                                    }
                                }
                                catch (err) {
                                    _iterator3.e(err);
                                }
                                finally {
                                    _iterator3.f();
                                }
                            }
                        }
                    }, {
                        key: "getRequestsInProgress",
                        value: function getRequestsInProgress(userId) {
                            var requestsByTxnId = this._requestsByUserId.get(userId);
                            if (requestsByTxnId) {
                                return Array.from(requestsByTxnId.values()).filter(function (r) {
                                    return r.pending;
                                });
                            }
                            return [];
                        }
                    }]);
                return ToDeviceRequests;
            }();
            exports.ToDeviceRequests = ToDeviceRequests;
        }, { "../../../logger": 97, "../../../models/event": 102, "../../../randomstring": 112, "../Error": 84, "./VerificationRequest": 90, "@babel/runtime/helpers/asyncToGenerator": 5, "@babel/runtime/helpers/classCallCheck": 6, "@babel/runtime/helpers/createClass": 8, "@babel/runtime/helpers/defineProperty": 9, "@babel/runtime/helpers/interopRequireDefault": 12, "@babel/runtime/helpers/typeof": 24, "@babel/runtime/regenerator": 27 }], 90: [function (require, module, exports) {
            "use strict";
            var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.VerificationRequest = exports.PHASE_DONE = exports.PHASE_CANCELLED = exports.PHASE_STARTED = exports.PHASE_READY = exports.PHASE_REQUESTED = exports.PHASE_UNSENT = exports.READY_TYPE = exports.DONE_TYPE = exports.CANCEL_TYPE = exports.START_TYPE = exports.REQUEST_TYPE = exports.EVENT_PREFIX = void 0;
            var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
            var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
            var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
            var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
            var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
            var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
            var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
            var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
            var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
            var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
            var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
            var _logger = require("../../../logger");
            var _events = require("events");
            var _Error = require("../Error");
            var _QRCode = require("../QRCode");
            function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
                if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                    if (it)
                        o = it;
                    var i = 0;
                    var F = function F() { };
                    return { s: F, n: function n() { if (i >= o.length)
                            return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try {
                    if (!normalCompletion && it["return"] != null)
                        it["return"]();
                }
                finally {
                    if (didErr)
                        throw err;
                } } }; }
            function _unsupportedIterableToArray(o, minLen) { if (!o)
                return; if (typeof o === "string")
                return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor)
                n = o.constructor.name; if (n === "Map" || n === "Set")
                return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return _arrayLikeToArray(o, minLen); }
            function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length)
                len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
            } return arr2; }
            function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) {
                var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor;
                result = Reflect.construct(Super, arguments, NewTarget);
            }
            else {
                result = Super.apply(this, arguments);
            } return (0, _possibleConstructorReturn2["default"])(this, result); }; }
            function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct)
                return false; if (Reflect.construct.sham)
                return false; if (typeof Proxy === "function")
                return true; try {
                Date.prototype.toString.call(Reflect.construct(Date, [], function () { }));
                return true;
            }
            catch (e) {
                return false;
            } }
            var TIMEOUT_FROM_EVENT_TS = 10 * 60 * 1000;
            var TIMEOUT_FROM_EVENT_RECEIPT = 2 * 60 * 1000;
            var VERIFICATION_REQUEST_MARGIN = 3 * 1000;
            var EVENT_PREFIX = "m.key.verification.";
            exports.EVENT_PREFIX = EVENT_PREFIX;
            var REQUEST_TYPE = EVENT_PREFIX + "request";
            exports.REQUEST_TYPE = REQUEST_TYPE;
            var START_TYPE = EVENT_PREFIX + "start";
            exports.START_TYPE = START_TYPE;
            var CANCEL_TYPE = EVENT_PREFIX + "cancel";
            exports.CANCEL_TYPE = CANCEL_TYPE;
            var DONE_TYPE = EVENT_PREFIX + "done";
            exports.DONE_TYPE = DONE_TYPE;
            var READY_TYPE = EVENT_PREFIX + "ready";
            exports.READY_TYPE = READY_TYPE;
            var PHASE_UNSENT = 1;
            exports.PHASE_UNSENT = PHASE_UNSENT;
            var PHASE_REQUESTED = 2;
            exports.PHASE_REQUESTED = PHASE_REQUESTED;
            var PHASE_READY = 3;
            exports.PHASE_READY = PHASE_READY;
            var PHASE_STARTED = 4;
            exports.PHASE_STARTED = PHASE_STARTED;
            var PHASE_CANCELLED = 5;
            exports.PHASE_CANCELLED = PHASE_CANCELLED;
            var PHASE_DONE = 6;
            exports.PHASE_DONE = PHASE_DONE;
            var VerificationRequest = function (_EventEmitter) {
                (0, _inherits2["default"])(VerificationRequest, _EventEmitter);
                var _super = _createSuper(VerificationRequest);
                function VerificationRequest(channel, verificationMethods, client) {
                    var _this;
                    (0, _classCallCheck2["default"])(this, VerificationRequest);
                    _this = _super.call(this);
                    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_cancelOnTimeout", function () {
                        try {
                            if (_this.initiatedByMe) {
                                _this.cancel({
                                    reason: "Other party didn't accept in time",
                                    code: "m.timeout"
                                });
                            }
                            else {
                                _this.cancel({
                                    reason: "User didn't accept in time",
                                    code: "m.timeout"
                                });
                            }
                        }
                        catch (err) {
                            _logger.logger.error("Error while cancelling verification request", err);
                        }
                    });
                    _this.channel = channel;
                    _this.channel._request = (0, _assertThisInitialized2["default"])(_this);
                    _this._verificationMethods = verificationMethods;
                    _this._client = client;
                    _this._commonMethods = [];
                    _this._setPhase(PHASE_UNSENT, false);
                    _this._eventsByUs = new Map();
                    _this._eventsByThem = new Map();
                    _this._observeOnly = false;
                    _this._timeoutTimer = null;
                    _this._accepting = false;
                    _this._declining = false;
                    _this._verifierHasFinished = false;
                    _this._cancelled = false;
                    _this._chosenMethod = null;
                    _this._qrCodeData = null;
                    _this._requestReceivedAt = null;
                    return _this;
                }
                (0, _createClass2["default"])(VerificationRequest, [{
                        key: "calculateEventTimeout",
                        value: function calculateEventTimeout(event) {
                            var effectiveExpiresAt = this.channel.getTimestamp(event) + TIMEOUT_FROM_EVENT_TS;
                            if (this._requestReceivedAt && !this.initiatedByMe && this.phase <= PHASE_REQUESTED) {
                                var expiresAtByReceipt = this._requestReceivedAt + TIMEOUT_FROM_EVENT_RECEIPT;
                                effectiveExpiresAt = Math.min(effectiveExpiresAt, expiresAtByReceipt);
                            }
                            return Math.max(0, effectiveExpiresAt - Date.now());
                        }
                    }, {
                        key: "otherPartySupportsMethod",
                        value: function otherPartySupportsMethod(method) {
                            var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                            if (!force && !this.ready && !this.started) {
                                return false;
                            }
                            var theirMethodEvent = this._eventsByThem.get(REQUEST_TYPE) || this._eventsByThem.get(READY_TYPE);
                            if (!theirMethodEvent) {
                                if (this.started && this.initiatedByMe) {
                                    var myStartEvent = this._eventsByUs.get(START_TYPE);
                                    var _content = myStartEvent && myStartEvent.getContent();
                                    var myStartMethod = _content && _content.method;
                                    return method == myStartMethod;
                                }
                                return false;
                            }
                            var content = theirMethodEvent.getContent();
                            if (!content) {
                                return false;
                            }
                            var methods = content.methods;
                            if (!Array.isArray(methods)) {
                                return false;
                            }
                            return methods.includes(method);
                        }
                    }, {
                        key: "beginKeyVerification",
                        value: function beginKeyVerification(method) {
                            var targetDevice = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                            if (!this.observeOnly && !this._verifier) {
                                var validStartPhase = this.phase === PHASE_REQUESTED || this.phase === PHASE_READY || this.phase === PHASE_UNSENT && this.channel.constructor.canCreateRequest(START_TYPE);
                                if (validStartPhase) {
                                    if (this._commonMethods.length && !this._commonMethods.includes(method)) {
                                        throw (0, _Error.newUnknownMethodError)();
                                    }
                                    this._verifier = this._createVerifier(method, null, targetDevice);
                                    if (!this._verifier) {
                                        throw (0, _Error.newUnknownMethodError)();
                                    }
                                    this._chosenMethod = method;
                                }
                            }
                            return this._verifier;
                        }
                    }, {
                        key: "sendRequest",
                        value: function () {
                            var _sendRequest = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee() {
                                var methods;
                                return _regenerator["default"].wrap(function _callee$(_context) {
                                    while (1) {
                                        switch (_context.prev = _context.next) {
                                            case 0:
                                                if (!(!this.observeOnly && this._phase === PHASE_UNSENT)) {
                                                    _context.next = 4;
                                                    break;
                                                }
                                                methods = (0, _toConsumableArray2["default"])(this._verificationMethods.keys());
                                                _context.next = 4;
                                                return this.channel.send(REQUEST_TYPE, {
                                                    methods: methods
                                                });
                                            case 4:
                                            case "end":
                                                return _context.stop();
                                        }
                                    }
                                }, _callee, this);
                            }));
                            function sendRequest() {
                                return _sendRequest.apply(this, arguments);
                            }
                            return sendRequest;
                        }()
                    }, {
                        key: "cancel",
                        value: function () {
                            var _cancel = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee2() {
                                var _ref, _ref$reason, reason, _ref$code, code, _args2 = arguments;
                                return _regenerator["default"].wrap(function _callee2$(_context2) {
                                    while (1) {
                                        switch (_context2.prev = _context2.next) {
                                            case 0:
                                                _ref = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {}, _ref$reason = _ref.reason, reason = _ref$reason === void 0 ? "User declined" : _ref$reason, _ref$code = _ref.code, code = _ref$code === void 0 ? "m.user" : _ref$code;
                                                if (!(!this.observeOnly && this._phase !== PHASE_CANCELLED)) {
                                                    _context2.next = 11;
                                                    break;
                                                }
                                                this._declining = true;
                                                this.emit("change");
                                                if (!this._verifier) {
                                                    _context2.next = 8;
                                                    break;
                                                }
                                                return _context2.abrupt("return", this._verifier.cancel((0, _Error.errorFactory)(code, reason)()));
                                            case 8:
                                                this._cancellingUserId = this._client.getUserId();
                                                _context2.next = 11;
                                                return this.channel.send(CANCEL_TYPE, {
                                                    code: code,
                                                    reason: reason
                                                });
                                            case 11:
                                            case "end":
                                                return _context2.stop();
                                        }
                                    }
                                }, _callee2, this);
                            }));
                            function cancel() {
                                return _cancel.apply(this, arguments);
                            }
                            return cancel;
                        }()
                    }, {
                        key: "accept",
                        value: function () {
                            var _accept = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee3() {
                                var methods;
                                return _regenerator["default"].wrap(function _callee3$(_context3) {
                                    while (1) {
                                        switch (_context3.prev = _context3.next) {
                                            case 0:
                                                if (!(!this.observeOnly && this.phase === PHASE_REQUESTED && !this.initiatedByMe)) {
                                                    _context3.next = 6;
                                                    break;
                                                }
                                                methods = (0, _toConsumableArray2["default"])(this._verificationMethods.keys());
                                                this._accepting = true;
                                                this.emit("change");
                                                _context3.next = 6;
                                                return this.channel.send(READY_TYPE, {
                                                    methods: methods
                                                });
                                            case 6:
                                            case "end":
                                                return _context3.stop();
                                        }
                                    }
                                }, _callee3, this);
                            }));
                            function accept() {
                                return _accept.apply(this, arguments);
                            }
                            return accept;
                        }()
                    }, {
                        key: "waitFor",
                        value: function waitFor(fn) {
                            var _this2 = this;
                            return new Promise(function (resolve, reject) {
                                var check = function check() {
                                    var handled = false;
                                    if (fn(_this2)) {
                                        resolve(_this2);
                                        handled = true;
                                    }
                                    else if (_this2.cancelled) {
                                        reject(new Error("cancelled"));
                                        handled = true;
                                    }
                                    if (handled) {
                                        _this2.off("change", check);
                                    }
                                    return handled;
                                };
                                if (!check()) {
                                    _this2.on("change", check);
                                }
                            });
                        }
                    }, {
                        key: "_setPhase",
                        value: function _setPhase(phase) {
                            var notify = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
                            this._phase = phase;
                            if (notify) {
                                this.emit("change");
                            }
                        }
                    }, {
                        key: "_getEventByEither",
                        value: function _getEventByEither(type) {
                            return this._eventsByThem.get(type) || this._eventsByUs.get(type);
                        }
                    }, {
                        key: "_getEventBy",
                        value: function _getEventBy(type, byThem) {
                            if (byThem) {
                                return this._eventsByThem.get(type);
                            }
                            else {
                                return this._eventsByUs.get(type);
                            }
                        }
                    }, {
                        key: "_calculatePhaseTransitions",
                        value: function _calculatePhaseTransitions() {
                            var transitions = [{
                                    phase: PHASE_UNSENT
                                }];
                            var phase = function phase() {
                                return transitions[transitions.length - 1].phase;
                            };
                            var hasRequestByThem = this._eventsByThem.has(REQUEST_TYPE);
                            var requestEvent = this._getEventBy(REQUEST_TYPE, hasRequestByThem);
                            if (requestEvent) {
                                transitions.push({
                                    phase: PHASE_REQUESTED,
                                    event: requestEvent
                                });
                            }
                            var readyEvent = requestEvent && this._getEventBy(READY_TYPE, !hasRequestByThem);
                            if (readyEvent && phase() === PHASE_REQUESTED) {
                                transitions.push({
                                    phase: PHASE_READY,
                                    event: readyEvent
                                });
                            }
                            var startEvent;
                            if (readyEvent || !requestEvent) {
                                var theirStartEvent = this._eventsByThem.get(START_TYPE);
                                var ourStartEvent = this._eventsByUs.get(START_TYPE);
                                if (theirStartEvent && ourStartEvent) {
                                    startEvent = theirStartEvent.getSender() < ourStartEvent.getSender() ? theirStartEvent : ourStartEvent;
                                }
                                else {
                                    startEvent = theirStartEvent ? theirStartEvent : ourStartEvent;
                                }
                            }
                            else {
                                startEvent = this._getEventBy(START_TYPE, !hasRequestByThem);
                            }
                            if (startEvent) {
                                var fromRequestPhase = phase() === PHASE_REQUESTED && requestEvent.getSender() !== startEvent.getSender();
                                var fromUnsentPhase = phase() === PHASE_UNSENT && this.channel.constructor.canCreateRequest(START_TYPE);
                                if (fromRequestPhase || phase() === PHASE_READY || fromUnsentPhase) {
                                    transitions.push({
                                        phase: PHASE_STARTED,
                                        event: startEvent
                                    });
                                }
                            }
                            var ourDoneEvent = this._eventsByUs.get(DONE_TYPE);
                            if (this._verifierHasFinished || ourDoneEvent && phase() === PHASE_STARTED) {
                                transitions.push({
                                    phase: PHASE_DONE
                                });
                            }
                            var cancelEvent = this._getEventByEither(CANCEL_TYPE);
                            if ((this._cancelled || cancelEvent) && phase() !== PHASE_DONE) {
                                transitions.push({
                                    phase: PHASE_CANCELLED,
                                    event: cancelEvent
                                });
                                return transitions;
                            }
                            return transitions;
                        }
                    }, {
                        key: "_transitionToPhase",
                        value: function _transitionToPhase(transition) {
                            var _this3 = this;
                            var phase = transition.phase, event = transition.event;
                            if (phase === PHASE_REQUESTED || phase === PHASE_READY) {
                                if (!this._wasSentByOwnDevice(event)) {
                                    var content = event.getContent();
                                    this._commonMethods = content.methods.filter(function (m) {
                                        return _this3._verificationMethods.has(m);
                                    });
                                }
                            }
                            if (!this.observeOnly) {
                                if (phase === PHASE_REQUESTED || phase === PHASE_STARTED || phase === PHASE_READY) {
                                    if (this.channel.receiveStartFromOtherDevices && this._wasSentByOwnUser(event) && !this._wasSentByOwnDevice(event)) {
                                        this._observeOnly = true;
                                    }
                                }
                            }
                            if (phase === PHASE_STARTED) {
                                var _event$getContent = event.getContent(), method = _event$getContent.method;
                                if (!this._verifier && !this.observeOnly) {
                                    this._verifier = this._createVerifier(method, event);
                                    if (!this._verifier) {
                                        this.cancel({
                                            code: "m.unknown_method",
                                            reason: "Unknown method: ".concat(method)
                                        });
                                    }
                                    else {
                                        this._chosenMethod = method;
                                    }
                                }
                            }
                        }
                    }, {
                        key: "_applyPhaseTransitions",
                        value: function _applyPhaseTransitions() {
                            var _this4 = this;
                            var transitions = this._calculatePhaseTransitions();
                            var existingIdx = transitions.findIndex(function (t) {
                                return t.phase === _this4.phase;
                            });
                            var newTransitions = transitions.slice(existingIdx + 1);
                            var _iterator = _createForOfIteratorHelper(newTransitions), _step;
                            try {
                                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                                    var transition = _step.value;
                                    this._transitionToPhase(transition);
                                }
                            }
                            catch (err) {
                                _iterator.e(err);
                            }
                            finally {
                                _iterator.f();
                            }
                            return newTransitions;
                        }
                    }, {
                        key: "_isWinningStartRace",
                        value: function _isWinningStartRace(newEvent) {
                            if (newEvent.getType() !== START_TYPE) {
                                return false;
                            }
                            var oldEvent = this._verifier.startEvent;
                            var oldRaceIdentifier;
                            if (this.isSelfVerification) {
                                if (oldEvent) {
                                    var oldContent = oldEvent.getContent();
                                    oldRaceIdentifier = oldContent && oldContent.from_device;
                                }
                                else {
                                    oldRaceIdentifier = this._client.getDeviceId();
                                }
                            }
                            else {
                                if (oldEvent) {
                                    oldRaceIdentifier = oldEvent.getSender();
                                }
                                else {
                                    oldRaceIdentifier = this._client.getUserId();
                                }
                            }
                            var newRaceIdentifier;
                            if (this.isSelfVerification) {
                                var newContent = newEvent.getContent();
                                newRaceIdentifier = newContent && newContent.from_device;
                            }
                            else {
                                newRaceIdentifier = newEvent.getSender();
                            }
                            return newRaceIdentifier < oldRaceIdentifier;
                        }
                    }, {
                        key: "hasEventId",
                        value: function hasEventId(eventId) {
                            var _iterator2 = _createForOfIteratorHelper(this._eventsByUs.values()), _step2;
                            try {
                                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                                    var event = _step2.value;
                                    if (event.getId() === eventId) {
                                        return true;
                                    }
                                }
                            }
                            catch (err) {
                                _iterator2.e(err);
                            }
                            finally {
                                _iterator2.f();
                            }
                            var _iterator3 = _createForOfIteratorHelper(this._eventsByThem.values()), _step3;
                            try {
                                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                                    var _event = _step3.value;
                                    if (_event.getId() === eventId) {
                                        return true;
                                    }
                                }
                            }
                            catch (err) {
                                _iterator3.e(err);
                            }
                            finally {
                                _iterator3.f();
                            }
                            return false;
                        }
                    }, {
                        key: "handleEvent",
                        value: function () {
                            var _handleEvent = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee4(type, event, isLiveEvent, isRemoteEcho, isSentByUs) {
                                var wasObserveOnly, isDuplicateEvent, oldPhase, newTransitions, newEventWinsRace, shouldGenerateQrCode, lastTransition, phase;
                                return _regenerator["default"].wrap(function _callee4$(_context4) {
                                    while (1) {
                                        switch (_context4.prev = _context4.next) {
                                            case 0:
                                                if (!(this.done || this.cancelled)) {
                                                    _context4.next = 2;
                                                    break;
                                                }
                                                return _context4.abrupt("return");
                                            case 2:
                                                wasObserveOnly = this._observeOnly;
                                                this._adjustObserveOnly(event, isLiveEvent);
                                                if (!(!this.observeOnly && !isRemoteEcho)) {
                                                    _context4.next = 9;
                                                    break;
                                                }
                                                _context4.next = 7;
                                                return this._cancelOnError(type, event);
                                            case 7:
                                                if (!_context4.sent) {
                                                    _context4.next = 9;
                                                    break;
                                                }
                                                return _context4.abrupt("return");
                                            case 9:
                                                isDuplicateEvent = isSentByUs ? this._eventsByUs.has(type) : this._eventsByThem.has(type);
                                                if (!isDuplicateEvent) {
                                                    _context4.next = 12;
                                                    break;
                                                }
                                                return _context4.abrupt("return");
                                            case 12:
                                                oldPhase = this.phase;
                                                this._addEvent(type, event, isSentByUs);
                                                newTransitions = this._applyPhaseTransitions();
                                                _context4.prev = 15;
                                                if (this._verifier && !this.observeOnly) {
                                                    newEventWinsRace = this._isWinningStartRace(event);
                                                    if (this._verifier.canSwitchStartEvent(event) && newEventWinsRace) {
                                                        this._verifier.switchStartEvent(event);
                                                    }
                                                    else if (!isRemoteEcho) {
                                                        if (type === CANCEL_TYPE || this._verifier.events && this._verifier.events.includes(type)) {
                                                            this._verifier.handleEvent(event);
                                                        }
                                                    }
                                                }
                                                if (!newTransitions.length) {
                                                    _context4.next = 30;
                                                    break;
                                                }
                                                if (!(isLiveEvent && newTransitions.some(function (t) {
                                                    return t.phase === PHASE_READY;
                                                }))) {
                                                    _context4.next = 24;
                                                    break;
                                                }
                                                shouldGenerateQrCode = this.otherPartySupportsMethod(_QRCode.SCAN_QR_CODE_METHOD, true);
                                                if (!shouldGenerateQrCode) {
                                                    _context4.next = 24;
                                                    break;
                                                }
                                                _context4.next = 23;
                                                return _QRCode.QRCodeData.create(this, this._client);
                                            case 23:
                                                this._qrCodeData = _context4.sent;
                                            case 24:
                                                lastTransition = newTransitions[newTransitions.length - 1];
                                                phase = lastTransition.phase;
                                                this._setupTimeout(phase);
                                                this._setPhase(phase);
                                                _context4.next = 31;
                                                break;
                                            case 30:
                                                if (this._observeOnly !== wasObserveOnly) {
                                                    this.emit("change");
                                                }
                                            case 31:
                                                _context4.prev = 31;
                                                _logger.logger.log("Verification request ".concat(this.channel.transactionId, ": ") + "".concat(type, " event with id:").concat(event.getId(), ", ") + "content:".concat(JSON.stringify(event.getContent()), " ") + "deviceId:".concat(this.channel.deviceId, ", ") + "sender:".concat(event.getSender(), ", isSentByUs:").concat(isSentByUs, ", ") + "isLiveEvent:".concat(isLiveEvent, ", isRemoteEcho:").concat(isRemoteEcho, ", ") + "phase:".concat(oldPhase, "=>").concat(this.phase, ", ") + "observeOnly:".concat(wasObserveOnly, "=>").concat(this._observeOnly));
                                                return _context4.finish(31);
                                            case 34:
                                            case "end":
                                                return _context4.stop();
                                        }
                                    }
                                }, _callee4, this, [[15, , 31, 34]]);
                            }));
                            function handleEvent(_x, _x2, _x3, _x4, _x5) {
                                return _handleEvent.apply(this, arguments);
                            }
                            return handleEvent;
                        }()
                    }, {
                        key: "_setupTimeout",
                        value: function _setupTimeout(phase) {
                            var shouldTimeout = !this._timeoutTimer && !this.observeOnly && phase === PHASE_REQUESTED;
                            if (shouldTimeout) {
                                this._timeoutTimer = setTimeout(this._cancelOnTimeout, this.timeout);
                            }
                            if (this._timeoutTimer) {
                                var shouldClear = phase === PHASE_STARTED || phase === PHASE_READY || phase === PHASE_DONE || phase === PHASE_CANCELLED;
                                if (shouldClear) {
                                    clearTimeout(this._timeoutTimer);
                                    this._timeoutTimer = null;
                                }
                            }
                        }
                    }, {
                        key: "_cancelOnError",
                        value: function () {
                            var _cancelOnError2 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee5(type, event) {
                                var method, isUnexpectedRequest, isUnexpectedReady, reason;
                                return _regenerator["default"].wrap(function _callee5$(_context5) {
                                    while (1) {
                                        switch (_context5.prev = _context5.next) {
                                            case 0:
                                                if (!(type === START_TYPE)) {
                                                    _context5.next = 6;
                                                    break;
                                                }
                                                method = event.getContent().method;
                                                if (this._verificationMethods.has(method)) {
                                                    _context5.next = 6;
                                                    break;
                                                }
                                                _context5.next = 5;
                                                return this.cancel((0, _Error.errorFromEvent)((0, _Error.newUnknownMethodError)()));
                                            case 5:
                                                return _context5.abrupt("return", true);
                                            case 6:
                                                isUnexpectedRequest = type === REQUEST_TYPE && this.phase !== PHASE_UNSENT;
                                                isUnexpectedReady = type === READY_TYPE && this.phase !== PHASE_REQUESTED;
                                                if (!(this.phase !== PHASE_UNSENT && (isUnexpectedRequest || isUnexpectedReady))) {
                                                    _context5.next = 14;
                                                    break;
                                                }
                                                _logger.logger.warn("Cancelling, unexpected ".concat(type, " verification ") + "event from ".concat(event.getSender()));
                                                reason = "Unexpected ".concat(type, " event in phase ").concat(this.phase);
                                                _context5.next = 13;
                                                return this.cancel((0, _Error.errorFromEvent)((0, _Error.newUnexpectedMessageError)({
                                                    reason: reason
                                                })));
                                            case 13:
                                                return _context5.abrupt("return", true);
                                            case 14:
                                                return _context5.abrupt("return", false);
                                            case 15:
                                            case "end":
                                                return _context5.stop();
                                        }
                                    }
                                }, _callee5, this);
                            }));
                            function _cancelOnError(_x6, _x7) {
                                return _cancelOnError2.apply(this, arguments);
                            }
                            return _cancelOnError;
                        }()
                    }, {
                        key: "_adjustObserveOnly",
                        value: function _adjustObserveOnly(event, isLiveEvent) {
                            if (!isLiveEvent) {
                                this._observeOnly = true;
                            }
                            if (this.calculateEventTimeout(event) < VERIFICATION_REQUEST_MARGIN) {
                                this._observeOnly = true;
                            }
                        }
                    }, {
                        key: "_addEvent",
                        value: function _addEvent(type, event, isSentByUs) {
                            if (isSentByUs) {
                                this._eventsByUs.set(type, event);
                            }
                            else {
                                this._eventsByThem.set(type, event);
                            }
                            if (type === REQUEST_TYPE) {
                                var _iterator4 = _createForOfIteratorHelper(this._eventsByThem.entries()), _step4;
                                try {
                                    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                                        var _step4$value = (0, _slicedToArray2["default"])(_step4.value, 2), _type = _step4$value[0], _event2 = _step4$value[1];
                                        if (_event2.getSender() !== this.otherUserId) {
                                            this._eventsByThem["delete"](_type);
                                        }
                                    }
                                }
                                catch (err) {
                                    _iterator4.e(err);
                                }
                                finally {
                                    _iterator4.f();
                                }
                                this._requestReceivedAt = Date.now();
                            }
                        }
                    }, {
                        key: "_createVerifier",
                        value: function _createVerifier(method) {
                            var startEvent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                            var targetDevice = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
                            if (!targetDevice) {
                                targetDevice = this.targetDevice;
                            }
                            var _targetDevice = targetDevice, userId = _targetDevice.userId, deviceId = _targetDevice.deviceId;
                            var VerifierCtor = this._verificationMethods.get(method);
                            if (!VerifierCtor) {
                                _logger.logger.warn("could not find verifier constructor for method", method);
                                return;
                            }
                            return new VerifierCtor(this.channel, this._client, userId, deviceId, startEvent, this);
                        }
                    }, {
                        key: "_wasSentByOwnUser",
                        value: function _wasSentByOwnUser(event) {
                            return event.getSender() === this._client.getUserId();
                        }
                    }, {
                        key: "_wasSentByOwnDevice",
                        value: function _wasSentByOwnDevice(event) {
                            if (!this._wasSentByOwnUser(event)) {
                                return false;
                            }
                            var content = event.getContent();
                            if (!content || content.from_device !== this._client.getDeviceId()) {
                                return false;
                            }
                            return true;
                        }
                    }, {
                        key: "onVerifierCancelled",
                        value: function onVerifierCancelled() {
                            this._cancelled = true;
                            var newTransitions = this._applyPhaseTransitions();
                            if (newTransitions.length) {
                                this._setPhase(newTransitions[newTransitions.length - 1].phase);
                            }
                        }
                    }, {
                        key: "onVerifierFinished",
                        value: function onVerifierFinished() {
                            this.channel.send("m.key.verification.done", {});
                            this._verifierHasFinished = true;
                            var newTransitions = this._applyPhaseTransitions();
                            if (newTransitions.length) {
                                this._setPhase(newTransitions[newTransitions.length - 1].phase);
                            }
                        }
                    }, {
                        key: "getEventFromOtherParty",
                        value: function getEventFromOtherParty(type) {
                            return this._eventsByThem.get(type);
                        }
                    }, {
                        key: "invalid",
                        get: function get() {
                            return this.phase === PHASE_UNSENT;
                        }
                    }, {
                        key: "requested",
                        get: function get() {
                            return this.phase === PHASE_REQUESTED;
                        }
                    }, {
                        key: "cancelled",
                        get: function get() {
                            return this.phase === PHASE_CANCELLED;
                        }
                    }, {
                        key: "ready",
                        get: function get() {
                            return this.phase === PHASE_READY;
                        }
                    }, {
                        key: "started",
                        get: function get() {
                            return this.phase === PHASE_STARTED;
                        }
                    }, {
                        key: "done",
                        get: function get() {
                            return this.phase === PHASE_DONE;
                        }
                    }, {
                        key: "methods",
                        get: function get() {
                            return this._commonMethods;
                        }
                    }, {
                        key: "chosenMethod",
                        get: function get() {
                            return this._chosenMethod;
                        }
                    }, {
                        key: "timeout",
                        get: function get() {
                            var requestEvent = this._getEventByEither(REQUEST_TYPE);
                            if (requestEvent) {
                                return this.calculateEventTimeout(requestEvent);
                            }
                            return 0;
                        }
                    }, {
                        key: "requestEvent",
                        get: function get() {
                            return this._getEventByEither(REQUEST_TYPE);
                        }
                    }, {
                        key: "phase",
                        get: function get() {
                            return this._phase;
                        }
                    }, {
                        key: "verifier",
                        get: function get() {
                            return this._verifier;
                        }
                    }, {
                        key: "canAccept",
                        get: function get() {
                            return this.phase < PHASE_READY && !this._accepting && !this._declining;
                        }
                    }, {
                        key: "accepting",
                        get: function get() {
                            return this._accepting;
                        }
                    }, {
                        key: "declining",
                        get: function get() {
                            return this._declining;
                        }
                    }, {
                        key: "pending",
                        get: function get() {
                            return !this.observeOnly && this._phase !== PHASE_DONE && this._phase !== PHASE_CANCELLED;
                        }
                    }, {
                        key: "qrCodeData",
                        get: function get() {
                            return this._qrCodeData;
                        }
                    }, {
                        key: "initiatedByMe",
                        get: function get() {
                            var noEventsYet = this._eventsByUs.size + this._eventsByThem.size === 0;
                            if (this._phase === PHASE_UNSENT && noEventsYet) {
                                return true;
                            }
                            var hasMyRequest = this._eventsByUs.has(REQUEST_TYPE);
                            var hasTheirRequest = this._eventsByThem.has(REQUEST_TYPE);
                            if (hasMyRequest && !hasTheirRequest) {
                                return true;
                            }
                            if (!hasMyRequest && hasTheirRequest) {
                                return false;
                            }
                            var hasMyStart = this._eventsByUs.has(START_TYPE);
                            var hasTheirStart = this._eventsByThem.has(START_TYPE);
                            if (hasMyStart && !hasTheirStart) {
                                return true;
                            }
                            return false;
                        }
                    }, {
                        key: "requestingUserId",
                        get: function get() {
                            if (this.initiatedByMe) {
                                return this._client.getUserId();
                            }
                            else {
                                return this.otherUserId;
                            }
                        }
                    }, {
                        key: "receivingUserId",
                        get: function get() {
                            if (this.initiatedByMe) {
                                return this.otherUserId;
                            }
                            else {
                                return this._client.getUserId();
                            }
                        }
                    }, {
                        key: "otherUserId",
                        get: function get() {
                            return this.channel.userId;
                        }
                    }, {
                        key: "isSelfVerification",
                        get: function get() {
                            return this._client.getUserId() === this.otherUserId;
                        }
                    }, {
                        key: "cancellingUserId",
                        get: function get() {
                            var myCancel = this._eventsByUs.get(CANCEL_TYPE);
                            var theirCancel = this._eventsByThem.get(CANCEL_TYPE);
                            if (myCancel && (!theirCancel || myCancel.getId() < theirCancel.getId())) {
                                return myCancel.getSender();
                            }
                            if (theirCancel) {
                                return theirCancel.getSender();
                            }
                            return undefined;
                        }
                    }, {
                        key: "cancellationCode",
                        get: function get() {
                            var ev = this._getEventByEither(CANCEL_TYPE);
                            return ev ? ev.getContent().code : null;
                        }
                    }, {
                        key: "observeOnly",
                        get: function get() {
                            return this._observeOnly;
                        }
                    }, {
                        key: "targetDevice",
                        get: function get() {
                            var theirFirstEvent = this._eventsByThem.get(REQUEST_TYPE) || this._eventsByThem.get(READY_TYPE) || this._eventsByThem.get(START_TYPE);
                            var theirFirstContent = theirFirstEvent.getContent();
                            var fromDevice = theirFirstContent.from_device;
                            return {
                                userId: this.otherUserId,
                                deviceId: fromDevice
                            };
                        }
                    }], [{
                        key: "validateEvent",
                        value: function validateEvent(type, event, client) {
                            var content = event.getContent();
                            if (!type || !type.startsWith(EVENT_PREFIX)) {
                                return false;
                            }
                            if (!content) {
                                _logger.logger.log("VerificationRequest: validateEvent: no content");
                                return false;
                            }
                            if (type === REQUEST_TYPE || type === READY_TYPE) {
                                if (!Array.isArray(content.methods)) {
                                    _logger.logger.log("VerificationRequest: validateEvent: " + "fail because methods");
                                    return false;
                                }
                            }
                            if (type === REQUEST_TYPE || type === READY_TYPE || type === START_TYPE) {
                                if (typeof content.from_device !== "string" || content.from_device.length === 0) {
                                    _logger.logger.log("VerificationRequest: validateEvent: " + "fail because from_device");
                                    return false;
                                }
                            }
                            return true;
                        }
                    }]);
                return VerificationRequest;
            }(_events.EventEmitter);
            exports.VerificationRequest = VerificationRequest;
        }, { "../../../logger": 97, "../Error": 84, "../QRCode": 86, "@babel/runtime/helpers/assertThisInitialized": 4, "@babel/runtime/helpers/asyncToGenerator": 5, "@babel/runtime/helpers/classCallCheck": 6, "@babel/runtime/helpers/createClass": 8, "@babel/runtime/helpers/defineProperty": 9, "@babel/runtime/helpers/getPrototypeOf": 10, "@babel/runtime/helpers/inherits": 11, "@babel/runtime/helpers/interopRequireDefault": 12, "@babel/runtime/helpers/possibleConstructorReturn": 20, "@babel/runtime/helpers/slicedToArray": 22, "@babel/runtime/helpers/toConsumableArray": 23, "@babel/runtime/regenerator": 27, "events": 36 }], 91: [function (require, module, exports) {
            "use strict";
            var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.InvalidStoreError = InvalidStoreError;
            exports.InvalidCryptoStoreError = InvalidCryptoStoreError;
            exports.KeySignatureUploadError = void 0;
            var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
            var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
            var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
            var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
            var _wrapNativeSuper2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapNativeSuper"));
            function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) {
                var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor;
                result = Reflect.construct(Super, arguments, NewTarget);
            }
            else {
                result = Super.apply(this, arguments);
            } return (0, _possibleConstructorReturn2["default"])(this, result); }; }
            function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct)
                return false; if (Reflect.construct.sham)
                return false; if (typeof Proxy === "function")
                return true; try {
                Date.prototype.toString.call(Reflect.construct(Date, [], function () { }));
                return true;
            }
            catch (e) {
                return false;
            } }
            function InvalidStoreError(reason, value) {
                var message = "Store is invalid because ".concat(reason, ", ") + "please stop the client, delete all data and start the client again";
                var instance = Reflect.construct(Error, [message]);
                Reflect.setPrototypeOf(instance, Reflect.getPrototypeOf(this));
                instance.reason = reason;
                instance.value = value;
                return instance;
            }
            InvalidStoreError.TOGGLED_LAZY_LOADING = "TOGGLED_LAZY_LOADING";
            InvalidStoreError.prototype = Object.create(Error.prototype, {
                constructor: {
                    value: Error,
                    enumerable: false,
                    writable: true,
                    configurable: true
                }
            });
            Reflect.setPrototypeOf(InvalidStoreError, Error);
            function InvalidCryptoStoreError(reason) {
                var message = "Crypto store is invalid because ".concat(reason, ", ") + "please stop the client, delete all data and start the client again";
                var instance = Reflect.construct(Error, [message]);
                Reflect.setPrototypeOf(instance, Reflect.getPrototypeOf(this));
                instance.reason = reason;
                instance.name = 'InvalidCryptoStoreError';
                return instance;
            }
            InvalidCryptoStoreError.TOO_NEW = "TOO_NEW";
            InvalidCryptoStoreError.prototype = Object.create(Error.prototype, {
                constructor: {
                    value: Error,
                    enumerable: false,
                    writable: true,
                    configurable: true
                }
            });
            Reflect.setPrototypeOf(InvalidCryptoStoreError, Error);
            var KeySignatureUploadError = function (_Error) {
                (0, _inherits2["default"])(KeySignatureUploadError, _Error);
                var _super = _createSuper(KeySignatureUploadError);
                function KeySignatureUploadError(message, value) {
                    var _this;
                    (0, _classCallCheck2["default"])(this, KeySignatureUploadError);
                    _this = _super.call(this, message);
                    _this.value = value;
                    return _this;
                }
                return KeySignatureUploadError;
            }((0, _wrapNativeSuper2["default"])(Error));
            exports.KeySignatureUploadError = KeySignatureUploadError;
        }, { "@babel/runtime/helpers/classCallCheck": 6, "@babel/runtime/helpers/getPrototypeOf": 10, "@babel/runtime/helpers/inherits": 11, "@babel/runtime/helpers/interopRequireDefault": 12, "@babel/runtime/helpers/possibleConstructorReturn": 20, "@babel/runtime/helpers/wrapNativeSuper": 26 }], 92: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.FilterComponent = FilterComponent;
            function _matches_wildcard(actual_value, filter_value) {
                if (filter_value.endsWith("*")) {
                    var type_prefix = filter_value.slice(0, -1);
                    return actual_value.substr(0, type_prefix.length) === type_prefix;
                }
                else {
                    return actual_value === filter_value;
                }
            }
            function FilterComponent(filter_json) {
                this.filter_json = filter_json;
                this.types = filter_json.types || null;
                this.not_types = filter_json.not_types || [];
                this.rooms = filter_json.rooms || null;
                this.not_rooms = filter_json.not_rooms || [];
                this.senders = filter_json.senders || null;
                this.not_senders = filter_json.not_senders || [];
                this.contains_url = filter_json.contains_url || null;
            }
            FilterComponent.prototype.check = function (event) {
                return this._checkFields(event.getRoomId(), event.getSender(), event.getType(), event.getContent() ? event.getContent().url !== undefined : false);
            };
            FilterComponent.prototype._checkFields = function (room_id, sender, event_type, contains_url) {
                var literal_keys = {
                    "rooms": function rooms(v) {
                        return room_id === v;
                    },
                    "senders": function senders(v) {
                        return sender === v;
                    },
                    "types": function types(v) {
                        return _matches_wildcard(event_type, v);
                    }
                };
                var self = this;
                for (var n = 0; n < Object.keys(literal_keys).length; n++) {
                    var name = Object.keys(literal_keys)[n];
                    var match_func = literal_keys[name];
                    var not_name = "not_" + name;
                    var disallowed_values = self[not_name];
                    if (disallowed_values.filter(match_func).length > 0) {
                        return false;
                    }
                    var allowed_values = self[name];
                    if (allowed_values && allowed_values.length > 0) {
                        var anyMatch = allowed_values.some(match_func);
                        if (!anyMatch) {
                            return false;
                        }
                    }
                }
                var contains_url_filter = this.filter_json.contains_url;
                if (contains_url_filter !== undefined) {
                    if (contains_url_filter !== contains_url) {
                        return false;
                    }
                }
                return true;
            };
            FilterComponent.prototype.filter = function (events) {
                return events.filter(this.check, this);
            };
            FilterComponent.prototype.limit = function () {
                return this.filter_json.limit !== undefined ? this.filter_json.limit : 10;
            };
        }, {}], 93: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.Filter = Filter;
            var _filterComponent = require("./filter-component");
            function setProp(obj, keyNesting, val) {
                var nestedKeys = keyNesting.split(".");
                var currentObj = obj;
                for (var i = 0; i < nestedKeys.length - 1; i++) {
                    if (!currentObj[nestedKeys[i]]) {
                        currentObj[nestedKeys[i]] = {};
                    }
                    currentObj = currentObj[nestedKeys[i]];
                }
                currentObj[nestedKeys[nestedKeys.length - 1]] = val;
            }
            function Filter(userId, filterId) {
                this.userId = userId;
                this.filterId = filterId;
                this.definition = {};
            }
            Filter.LAZY_LOADING_MESSAGES_FILTER = {
                lazy_load_members: true
            };
            Filter.prototype.getFilterId = function () {
                return this.filterId;
            };
            Filter.prototype.getDefinition = function () {
                return this.definition;
            };
            Filter.prototype.setDefinition = function (definition) {
                this.definition = definition;
                var room_filter_json = definition.room;
                var room_filter_fields = {};
                if (room_filter_json) {
                    if (room_filter_json.rooms) {
                        room_filter_fields.rooms = room_filter_json.rooms;
                    }
                    if (room_filter_json.rooms) {
                        room_filter_fields.not_rooms = room_filter_json.not_rooms;
                    }
                    this._include_leave = room_filter_json.include_leave || false;
                }
                this._room_filter = new _filterComponent.FilterComponent(room_filter_fields);
                this._room_timeline_filter = new _filterComponent.FilterComponent(room_filter_json ? room_filter_json.timeline || {} : {});
            };
            Filter.prototype.getRoomTimelineFilterComponent = function () {
                return this._room_timeline_filter;
            };
            Filter.prototype.filterRoomTimeline = function (events) {
                return this._room_timeline_filter.filter(this._room_filter.filter(events));
            };
            Filter.prototype.setTimelineLimit = function (limit) {
                setProp(this.definition, "room.timeline.limit", limit);
            };
            Filter.prototype.setLazyLoadMembers = function (enabled) {
                setProp(this.definition, "room.state.lazy_load_members", !!enabled);
            };
            Filter.prototype.setIncludeLeaveRooms = function (includeLeave) {
                setProp(this.definition, "room.include_leave", includeLeave);
            };
            Filter.fromJson = function (userId, filterId, jsonObj) {
                var filter = new Filter(userId, filterId);
                filter.setDefinition(jsonObj);
                return filter;
            };
        }, { "./filter-component": 92 }], 94: [function (require, module, exports) {
            (function (global) {
                (function () {
                    "use strict";
                    var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
                    var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
                    Object.defineProperty(exports, "__esModule", {
                        value: true
                    });
                    exports.MatrixHttpApi = MatrixHttpApi;
                    exports.retryNetworkOperation = retryNetworkOperation;
                    exports.AbortError = exports.ConnectionError = exports.MatrixError = exports.PREFIX_MEDIA_R0 = exports.PREFIX_IDENTITY_V2 = exports.PREFIX_IDENTITY_V1 = exports.PREFIX_UNSTABLE = exports.PREFIX_R0 = void 0;
                    var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
                    var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
                    var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
                    var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
                    var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
                    var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
                    var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
                    var _wrapNativeSuper2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapNativeSuper"));
                    var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
                    var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
                    var _contentType = require("content-type");
                    var utils = _interopRequireWildcard(require("./utils"));
                    var _logger = require("./logger");
                    var callbacks = _interopRequireWildcard(require("./realtime-callbacks"));
                    function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) {
                        var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor;
                        result = Reflect.construct(Super, arguments, NewTarget);
                    }
                    else {
                        result = Super.apply(this, arguments);
                    } return (0, _possibleConstructorReturn2["default"])(this, result); }; }
                    function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct)
                        return false; if (Reflect.construct.sham)
                        return false; if (typeof Proxy === "function")
                        return true; try {
                        Date.prototype.toString.call(Reflect.construct(Date, [], function () { }));
                        return true;
                    }
                    catch (e) {
                        return false;
                    } }
                    function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) {
                        var symbols = Object.getOwnPropertySymbols(object);
                        if (enumerableOnly)
                            symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; });
                        keys.push.apply(keys, symbols);
                    } return keys; }
                    function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) {
                        var source = arguments[i] != null ? arguments[i] : {};
                        if (i % 2) {
                            ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); });
                        }
                        else if (Object.getOwnPropertyDescriptors) {
                            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                        }
                        else {
                            ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); });
                        }
                    } return target; }
                    var PREFIX_R0 = "/_matrix/client/r0";
                    exports.PREFIX_R0 = PREFIX_R0;
                    var PREFIX_UNSTABLE = "/_matrix/client/unstable";
                    exports.PREFIX_UNSTABLE = PREFIX_UNSTABLE;
                    var PREFIX_IDENTITY_V1 = "/_matrix/identity/api/v1";
                    exports.PREFIX_IDENTITY_V1 = PREFIX_IDENTITY_V1;
                    var PREFIX_IDENTITY_V2 = "/_matrix/identity/v2";
                    exports.PREFIX_IDENTITY_V2 = PREFIX_IDENTITY_V2;
                    var PREFIX_MEDIA_R0 = "/_matrix/media/r0";
                    exports.PREFIX_MEDIA_R0 = PREFIX_MEDIA_R0;
                    function MatrixHttpApi(event_emitter, opts) {
                        utils.checkObjectHasKeys(opts, ["baseUrl", "request", "prefix"]);
                        opts.onlyData = opts.onlyData || false;
                        this.event_emitter = event_emitter;
                        this.opts = opts;
                        this.useAuthorizationHeader = Boolean(opts.useAuthorizationHeader);
                        this.uploads = [];
                    }
                    MatrixHttpApi.prototype = {
                        setIdBaseUrl: function setIdBaseUrl(url) {
                            this.opts.idBaseUrl = url;
                        },
                        getContentUri: function getContentUri() {
                            var params = {
                                access_token: this.opts.accessToken
                            };
                            return {
                                base: this.opts.baseUrl,
                                path: "/_matrix/media/r0/upload",
                                params: params
                            };
                        },
                        uploadContent: function uploadContent(file, opts) {
                            if (utils.isFunction(opts)) {
                                opts = {
                                    callback: opts
                                };
                            }
                            else if (opts === undefined) {
                                opts = {};
                            }
                            var includeFilename = opts.includeFilename !== false;
                            var contentType = opts.type || file.type || 'application/octet-stream';
                            var fileName = opts.name || file.name;
                            var body = file;
                            if (body.stream && typeof body.stream !== "function") {
                                _logger.logger.warn("Using `file.stream` as the content to upload. Future " + "versions of the js-sdk will change this to expect `file` to " + "be the content directly.");
                                body = body.stream;
                            }
                            var rawResponse = opts.rawResponse;
                            if (rawResponse === undefined) {
                                if (global.XMLHttpRequest) {
                                    rawResponse = false;
                                }
                                else {
                                    _logger.logger.warn("Returning the raw JSON from uploadContent(). Future " + "versions of the js-sdk will change this default, to " + "return the parsed object. Set opts.rawResponse=false " + "to change this behaviour now.");
                                    rawResponse = true;
                                }
                            }
                            var onlyContentUri = opts.onlyContentUri;
                            if (!rawResponse && onlyContentUri === undefined) {
                                if (global.XMLHttpRequest) {
                                    _logger.logger.warn("Returning only the content-uri from uploadContent(). " + "Future versions of the js-sdk will change this " + "default, to return the whole response object. Set " + "opts.onlyContentUri=false to change this behaviour now.");
                                    onlyContentUri = true;
                                }
                                else {
                                    onlyContentUri = false;
                                }
                            }
                            var upload = {
                                loaded: 0,
                                total: 0
                            };
                            var promise;
                            var bodyParser = null;
                            if (!rawResponse) {
                                bodyParser = function bodyParser(rawBody) {
                                    var body = JSON.parse(rawBody);
                                    if (onlyContentUri) {
                                        body = body.content_uri;
                                        if (body === undefined) {
                                            throw Error('Bad response');
                                        }
                                    }
                                    return body;
                                };
                            }
                            if (global.XMLHttpRequest) {
                                var defer = utils.defer();
                                var xhr = new global.XMLHttpRequest();
                                upload.xhr = xhr;
                                var cb = requestCallback(defer, opts.callback, this.opts.onlyData);
                                var timeout_fn = function timeout_fn() {
                                    xhr.abort();
                                    cb(new Error('Timeout'));
                                };
                                xhr.timeout_timer = callbacks.setTimeout(timeout_fn, 30000);
                                xhr.onreadystatechange = function () {
                                    switch (xhr.readyState) {
                                        case global.XMLHttpRequest.DONE:
                                            callbacks.clearTimeout(xhr.timeout_timer);
                                            var resp;
                                            try {
                                                if (xhr.status === 0) {
                                                    throw new AbortError();
                                                }
                                                if (!xhr.responseText) {
                                                    throw new Error('No response body.');
                                                }
                                                resp = xhr.responseText;
                                                if (bodyParser) {
                                                    resp = bodyParser(resp);
                                                }
                                            }
                                            catch (err) {
                                                err.http_status = xhr.status;
                                                cb(err);
                                                return;
                                            }
                                            cb(undefined, xhr, resp);
                                            break;
                                    }
                                };
                                xhr.upload.addEventListener("progress", function (ev) {
                                    callbacks.clearTimeout(xhr.timeout_timer);
                                    upload.loaded = ev.loaded;
                                    upload.total = ev.total;
                                    xhr.timeout_timer = callbacks.setTimeout(timeout_fn, 30000);
                                    if (opts.progressHandler) {
                                        opts.progressHandler({
                                            loaded: ev.loaded,
                                            total: ev.total
                                        });
                                    }
                                });
                                var url = this.opts.baseUrl + "/_matrix/media/r0/upload";
                                var queryArgs = [];
                                if (includeFilename && fileName) {
                                    queryArgs.push("filename=" + encodeURIComponent(fileName));
                                }
                                if (!this.useAuthorizationHeader) {
                                    queryArgs.push("access_token=" + encodeURIComponent(this.opts.accessToken));
                                }
                                if (queryArgs.length > 0) {
                                    url += "?" + queryArgs.join("&");
                                }
                                xhr.open("POST", url);
                                if (this.useAuthorizationHeader) {
                                    xhr.setRequestHeader("Authorization", "Bearer " + this.opts.accessToken);
                                }
                                xhr.setRequestHeader("Content-Type", contentType);
                                xhr.send(body);
                                promise = defer.promise;
                                promise.abort = xhr.abort.bind(xhr);
                            }
                            else {
                                var queryParams = {};
                                if (includeFilename && fileName) {
                                    queryParams.filename = fileName;
                                }
                                promise = this.authedRequest(opts.callback, "POST", "/upload", queryParams, body, {
                                    prefix: "/_matrix/media/r0",
                                    headers: {
                                        "Content-Type": contentType
                                    },
                                    json: false,
                                    bodyParser: bodyParser
                                });
                            }
                            var self = this;
                            var promise0 = promise["finally"](function () {
                                for (var i = 0; i < self.uploads.length; ++i) {
                                    if (self.uploads[i] === upload) {
                                        self.uploads.splice(i, 1);
                                        return;
                                    }
                                }
                            });
                            promise0.abort = promise.abort;
                            upload.promise = promise0;
                            this.uploads.push(upload);
                            return promise0;
                        },
                        cancelUpload: function cancelUpload(promise) {
                            if (promise.abort) {
                                promise.abort();
                                return true;
                            }
                            return false;
                        },
                        getCurrentUploads: function getCurrentUploads() {
                            return this.uploads;
                        },
                        idServerRequest: function idServerRequest(callback, method, path, params, prefix, accessToken) {
                            if (!this.opts.idBaseUrl) {
                                throw new Error("No Identity Server base URL set");
                            }
                            var fullUri = this.opts.idBaseUrl + prefix + path;
                            if (callback !== undefined && !utils.isFunction(callback)) {
                                throw Error("Expected callback to be a function but got " + (0, _typeof2["default"])(callback));
                            }
                            var opts = {
                                uri: fullUri,
                                method: method,
                                withCredentials: false,
                                json: true,
                                _matrix_opts: this.opts,
                                headers: {}
                            };
                            if (method === 'GET') {
                                opts.qs = params;
                            }
                            else if ((0, _typeof2["default"])(params) === "object") {
                                opts.json = params;
                            }
                            if (accessToken) {
                                opts.headers['Authorization'] = "Bearer ".concat(accessToken);
                            }
                            var defer = utils.defer();
                            this.opts.request(opts, requestCallback(defer, callback, this.opts.onlyData));
                            return defer.promise;
                        },
                        authedRequest: function authedRequest(callback, method, path, queryParams, data, opts) {
                            if (!queryParams) {
                                queryParams = {};
                            }
                            if (this.useAuthorizationHeader) {
                                if (isFinite(opts)) {
                                    opts = {
                                        localTimeoutMs: opts
                                    };
                                }
                                if (!opts) {
                                    opts = {};
                                }
                                if (!opts.headers) {
                                    opts.headers = {};
                                }
                                if (!opts.headers.Authorization) {
                                    opts.headers.Authorization = "Bearer " + this.opts.accessToken;
                                }
                                if (queryParams.access_token) {
                                    delete queryParams.access_token;
                                }
                            }
                            else {
                                if (!queryParams.access_token) {
                                    queryParams.access_token = this.opts.accessToken;
                                }
                            }
                            var requestPromise = this.request(callback, method, path, queryParams, data, opts);
                            var self = this;
                            requestPromise["catch"](function (err) {
                                if (err.errcode == 'M_UNKNOWN_TOKEN') {
                                    self.event_emitter.emit("Session.logged_out", err);
                                }
                                else if (err.errcode == 'M_CONSENT_NOT_GIVEN') {
                                    self.event_emitter.emit("no_consent", err.message, err.data.consent_uri);
                                }
                            });
                            return requestPromise;
                        },
                        request: function request(callback, method, path, queryParams, data, opts) {
                            opts = opts || {};
                            var prefix = opts.prefix !== undefined ? opts.prefix : this.opts.prefix;
                            var fullUri = this.opts.baseUrl + prefix + path;
                            return this.requestOtherUrl(callback, method, fullUri, queryParams, data, opts);
                        },
                        requestOtherUrl: function requestOtherUrl(callback, method, uri, queryParams, data, opts) {
                            if (opts === undefined || opts === null) {
                                opts = {};
                            }
                            else if (isFinite(opts)) {
                                opts = {
                                    localTimeoutMs: opts
                                };
                            }
                            return this._request(callback, method, uri, queryParams, data, opts);
                        },
                        getUrl: function getUrl(path, queryParams, prefix) {
                            var queryString = "";
                            if (queryParams) {
                                queryString = "?" + utils.encodeParams(queryParams);
                            }
                            return this.opts.baseUrl + prefix + path + queryString;
                        },
                        _request: function _request(callback, method, uri, queryParams, data, opts) {
                            if (callback !== undefined && !utils.isFunction(callback)) {
                                throw Error("Expected callback to be a function but got " + (0, _typeof2["default"])(callback));
                            }
                            opts = opts || {};
                            var self = this;
                            if (this.opts.extraParams) {
                                queryParams = _objectSpread(_objectSpread({}, queryParams), this.opts.extraParams);
                            }
                            var headers = utils.extend({}, opts.headers || {});
                            var json = opts.json === undefined ? true : opts.json;
                            var bodyParser = opts.bodyParser;
                            if (json) {
                                if (data) {
                                    data = JSON.stringify(data);
                                    headers['content-type'] = 'application/json';
                                }
                                if (!headers['accept']) {
                                    headers['accept'] = 'application/json';
                                }
                                if (bodyParser === undefined) {
                                    bodyParser = function bodyParser(rawBody) {
                                        return JSON.parse(rawBody);
                                    };
                                }
                            }
                            var defer = utils.defer();
                            var timeoutId;
                            var timedOut = false;
                            var req;
                            var localTimeoutMs = opts.localTimeoutMs || this.opts.localTimeoutMs;
                            var resetTimeout = function resetTimeout() {
                                if (localTimeoutMs) {
                                    if (timeoutId) {
                                        callbacks.clearTimeout(timeoutId);
                                    }
                                    timeoutId = callbacks.setTimeout(function () {
                                        timedOut = true;
                                        if (req && req.abort) {
                                            req.abort();
                                        }
                                        defer.reject(new MatrixError({
                                            error: "Locally timed out waiting for a response",
                                            errcode: "ORG.MATRIX.JSSDK_TIMEOUT",
                                            timeout: localTimeoutMs
                                        }));
                                    }, localTimeoutMs);
                                }
                            };
                            resetTimeout();
                            var reqPromise = defer.promise;
                            try {
                                req = this.opts.request({
                                    uri: uri,
                                    method: method,
                                    withCredentials: false,
                                    qs: queryParams,
                                    qsStringifyOptions: opts.qsStringifyOptions,
                                    useQuerystring: true,
                                    body: data,
                                    json: false,
                                    timeout: localTimeoutMs,
                                    headers: headers || {},
                                    _matrix_opts: this.opts
                                }, function (err, response, body) {
                                    if (localTimeoutMs) {
                                        callbacks.clearTimeout(timeoutId);
                                        if (timedOut) {
                                            return;
                                        }
                                    }
                                    var handlerFn = requestCallback(defer, callback, self.opts.onlyData, bodyParser);
                                    handlerFn(err, response, body);
                                });
                                if (req) {
                                    if ('onprogress' in req) {
                                        req.onprogress = function (e) {
                                            resetTimeout();
                                        };
                                    }
                                    if (req.abort)
                                        reqPromise.abort = req.abort.bind(req);
                                }
                            }
                            catch (ex) {
                                defer.reject(ex);
                                if (callback) {
                                    callback(ex);
                                }
                            }
                            return reqPromise;
                        }
                    };
                    var requestCallback = function requestCallback(defer, userDefinedCallback, onlyData, bodyParser) {
                        userDefinedCallback = userDefinedCallback || function () { };
                        return function (err, response, body) {
                            if (err) {
                                var aborted = err.name === "AbortError" || err === "aborted";
                                if (!aborted && !(err instanceof MatrixError)) {
                                    err = new ConnectionError("request failed", err);
                                }
                            }
                            if (!err) {
                                try {
                                    if (response.statusCode >= 400) {
                                        err = parseErrorResponse(response, body);
                                    }
                                    else if (bodyParser) {
                                        body = bodyParser(body);
                                    }
                                }
                                catch (e) {
                                    err = new Error("Error parsing server response: ".concat(e));
                                }
                            }
                            if (err) {
                                defer.reject(err);
                                userDefinedCallback(err);
                            }
                            else {
                                var res = {
                                    code: response.statusCode,
                                    headers: response.headers,
                                    data: body
                                };
                                defer.resolve(onlyData ? body : res);
                                userDefinedCallback(null, onlyData ? body : res);
                            }
                        };
                    };
                    function parseErrorResponse(response, body) {
                        var httpStatus = response.statusCode;
                        var contentType = getResponseContentType(response);
                        var err;
                        if (contentType) {
                            if (contentType.type === 'application/json') {
                                var jsonBody = (0, _typeof2["default"])(body) === 'object' ? body : JSON.parse(body);
                                err = new MatrixError(jsonBody);
                            }
                            else if (contentType.type === 'text/plain') {
                                err = new Error("Server returned ".concat(httpStatus, " error: ").concat(body));
                            }
                        }
                        if (!err) {
                            err = new Error("Server returned ".concat(httpStatus, " error"));
                        }
                        err.httpStatus = httpStatus;
                        return err;
                    }
                    function getResponseContentType(response) {
                        var contentType;
                        if (response.getResponseHeader) {
                            contentType = response.getResponseHeader("Content-Type");
                        }
                        else if (response.headers) {
                            contentType = response.headers['content-type'] || null;
                        }
                        if (!contentType) {
                            return null;
                        }
                        try {
                            return (0, _contentType.parse)(contentType);
                        }
                        catch (e) {
                            throw new Error("Error parsing Content-Type '".concat(contentType, "': ").concat(e));
                        }
                    }
                    var MatrixError = function (_Error) {
                        (0, _inherits2["default"])(MatrixError, _Error);
                        var _super = _createSuper(MatrixError);
                        function MatrixError(errorJson) {
                            var _this;
                            (0, _classCallCheck2["default"])(this, MatrixError);
                            errorJson = errorJson || {};
                            _this = _super.call(this, "MatrixError: ".concat(errorJson.errcode));
                            _this.errcode = errorJson.errcode;
                            _this.name = errorJson.errcode || "Unknown error code";
                            _this.message = errorJson.error || "Unknown message";
                            _this.data = errorJson;
                            return _this;
                        }
                        return MatrixError;
                    }((0, _wrapNativeSuper2["default"])(Error));
                    exports.MatrixError = MatrixError;
                    var ConnectionError = function (_Error2) {
                        (0, _inherits2["default"])(ConnectionError, _Error2);
                        var _super2 = _createSuper(ConnectionError);
                        function ConnectionError(message) {
                            var _this2;
                            var cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
                            (0, _classCallCheck2["default"])(this, ConnectionError);
                            _this2 = _super2.call(this, message + (cause ? ": ".concat(cause.message) : ""));
                            _this2._cause = cause;
                            return _this2;
                        }
                        (0, _createClass2["default"])(ConnectionError, [{
                                key: "name",
                                get: function get() {
                                    return "ConnectionError";
                                }
                            }, {
                                key: "cause",
                                get: function get() {
                                    return this._cause;
                                }
                            }]);
                        return ConnectionError;
                    }((0, _wrapNativeSuper2["default"])(Error));
                    exports.ConnectionError = ConnectionError;
                    var AbortError = function (_Error3) {
                        (0, _inherits2["default"])(AbortError, _Error3);
                        var _super3 = _createSuper(AbortError);
                        function AbortError() {
                            (0, _classCallCheck2["default"])(this, AbortError);
                            return _super3.call(this, "Operation aborted");
                        }
                        (0, _createClass2["default"])(AbortError, [{
                                key: "name",
                                get: function get() {
                                    return "AbortError";
                                }
                            }]);
                        return AbortError;
                    }((0, _wrapNativeSuper2["default"])(Error));
                    exports.AbortError = AbortError;
                    function retryNetworkOperation(_x, _x2) {
                        return _retryNetworkOperation.apply(this, arguments);
                    }
                    function _retryNetworkOperation() {
                        _retryNetworkOperation = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee2(maxAttempts, callback) {
                            var attempts, lastConnectionError;
                            return _regenerator["default"].wrap(function _callee2$(_context2) {
                                while (1) {
                                    switch (_context2.prev = _context2.next) {
                                        case 0:
                                            attempts = 0;
                                            lastConnectionError = null;
                                        case 2:
                                            if (!(attempts < maxAttempts)) {
                                                _context2.next = 21;
                                                break;
                                            }
                                            _context2.prev = 3;
                                            if (!(attempts > 0)) {
                                                _context2.next = 6;
                                                break;
                                            }
                                            return _context2.delegateYield(_regenerator["default"].mark(function _callee() {
                                                var timeout;
                                                return _regenerator["default"].wrap(function _callee$(_context) {
                                                    while (1) {
                                                        switch (_context.prev = _context.next) {
                                                            case 0:
                                                                timeout = 1000 * Math.pow(2, attempts);
                                                                _logger.logger.log("network operation failed ".concat(attempts, " times,") + " retrying in ".concat(timeout, "ms..."));
                                                                _context.next = 4;
                                                                return new Promise(function (r) {
                                                                    return setTimeout(r, timeout);
                                                                });
                                                            case 4:
                                                            case "end":
                                                                return _context.stop();
                                                        }
                                                    }
                                                }, _callee);
                                            })(), "t0", 6);
                                        case 6:
                                            _context2.next = 8;
                                            return callback();
                                        case 8:
                                            return _context2.abrupt("return", _context2.sent);
                                        case 11:
                                            _context2.prev = 11;
                                            _context2.t1 = _context2["catch"](3);
                                            if (!(_context2.t1 instanceof ConnectionError)) {
                                                _context2.next = 18;
                                                break;
                                            }
                                            attempts += 1;
                                            lastConnectionError = _context2.t1;
                                            _context2.next = 19;
                                            break;
                                        case 18:
                                            throw _context2.t1;
                                        case 19:
                                            _context2.next = 2;
                                            break;
                                        case 21:
                                            throw lastConnectionError;
                                        case 22:
                                        case "end":
                                            return _context2.stop();
                                    }
                                }
                            }, _callee2, null, [[3, 11]]);
                        }));
                        return _retryNetworkOperation.apply(this, arguments);
                    }
                }).call(this);
            }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, { "./logger": 97, "./realtime-callbacks": 113, "./utils": 125, "@babel/runtime/helpers/asyncToGenerator": 5, "@babel/runtime/helpers/classCallCheck": 6, "@babel/runtime/helpers/createClass": 8, "@babel/runtime/helpers/defineProperty": 9, "@babel/runtime/helpers/getPrototypeOf": 10, "@babel/runtime/helpers/inherits": 11, "@babel/runtime/helpers/interopRequireDefault": 12, "@babel/runtime/helpers/interopRequireWildcard": 13, "@babel/runtime/helpers/possibleConstructorReturn": 20, "@babel/runtime/helpers/typeof": 24, "@babel/runtime/helpers/wrapNativeSuper": 26, "@babel/runtime/regenerator": 27, "content-type": 35 }], 95: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.exists = exists;
            function exists(indexedDB, dbName) {
                return new Promise(function (resolve, reject) {
                    var exists = true;
                    var req = indexedDB.open(dbName);
                    req.onupgradeneeded = function () {
                        exists = false;
                    };
                    req.onblocked = function () {
                        return reject();
                    };
                    req.onsuccess = function () {
                        var db = req.result;
                        db.close();
                        if (!exists) {
                            indexedDB.deleteDatabase(dbName);
                        }
                        resolve(exists);
                    };
                    req.onerror = function (ev) {
                        return reject(ev.target.error);
                    };
                });
            }
        }, {}], 96: [function (require, module, exports) {
            "use strict";
            var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
            var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.InteractiveAuth = InteractiveAuth;
            var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
            var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
            var _url = _interopRequireDefault(require("url"));
            var utils = _interopRequireWildcard(require("./utils"));
            var _logger = require("./logger");
            function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
                if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                    if (it)
                        o = it;
                    var i = 0;
                    var F = function F() { };
                    return { s: F, n: function n() { if (i >= o.length)
                            return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try {
                    if (!normalCompletion && it["return"] != null)
                        it["return"]();
                }
                finally {
                    if (didErr)
                        throw err;
                } } }; }
            function _unsupportedIterableToArray(o, minLen) { if (!o)
                return; if (typeof o === "string")
                return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor)
                n = o.constructor.name; if (n === "Map" || n === "Set")
                return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return _arrayLikeToArray(o, minLen); }
            function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length)
                len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
            } return arr2; }
            var EMAIL_STAGE_TYPE = "m.login.email.identity";
            var MSISDN_STAGE_TYPE = "m.login.msisdn";
            function InteractiveAuth(opts) {
                this._matrixClient = opts.matrixClient;
                this._data = opts.authData || {};
                this._requestCallback = opts.doRequest;
                this._busyChangedCallback = opts.busyChanged;
                this._stateUpdatedCallback = opts.stateUpdated || opts.startAuthStage;
                this._resolveFunc = null;
                this._rejectFunc = null;
                this._inputs = opts.inputs || {};
                this._requestEmailTokenCallback = opts.requestEmailToken;
                if (opts.sessionId)
                    this._data.session = opts.sessionId;
                this._clientSecret = opts.clientSecret || this._matrixClient.generateClientSecret();
                this._emailSid = opts.emailSid;
                if (this._emailSid === undefined)
                    this._emailSid = null;
                this._requestingEmailToken = false;
                this._chosenFlow = null;
                this._currentStage = null;
                this._submitPromise = null;
            }
            InteractiveAuth.prototype = {
                attemptAuth: function attemptAuth() {
                    var _this = this;
                    return new Promise(function (resolve, reject) {
                        _this._resolveFunc = resolve;
                        _this._rejectFunc = reject;
                        var hasFlows = _this._data && _this._data.flows;
                        if (!hasFlows) {
                            if (_this._busyChangedCallback)
                                _this._busyChangedCallback(true);
                            var auth = null;
                            if (_this._data.session) {
                                auth = {
                                    session: _this._data.session
                                };
                            }
                            _this._doRequest(auth)["finally"](function () {
                                if (_this._busyChangedCallback)
                                    _this._busyChangedCallback(false);
                            });
                        }
                        else {
                            _this._startNextAuthStage();
                        }
                    });
                },
                poll: function () {
                    var _poll = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee() {
                        var authDict, creds, idServerParsedUrl;
                        return _regenerator["default"].wrap(function _callee$(_context) {
                            while (1) {
                                switch (_context.prev = _context.next) {
                                    case 0:
                                        if (this._data.session) {
                                            _context.next = 2;
                                            break;
                                        }
                                        return _context.abrupt("return");
                                    case 2:
                                        if (this._resolveFunc) {
                                            _context.next = 4;
                                            break;
                                        }
                                        return _context.abrupt("return");
                                    case 4:
                                        if (!this._submitPromise) {
                                            _context.next = 6;
                                            break;
                                        }
                                        return _context.abrupt("return");
                                    case 6:
                                        authDict = {};
                                        if (!(this._currentStage == EMAIL_STAGE_TYPE)) {
                                            _context.next = 16;
                                            break;
                                        }
                                        if (!this._emailSid) {
                                            _context.next = 16;
                                            break;
                                        }
                                        creds = {
                                            sid: this._emailSid,
                                            client_secret: this._clientSecret
                                        };
                                        _context.next = 12;
                                        return this._matrixClient.doesServerRequireIdServerParam();
                                    case 12:
                                        if (!_context.sent) {
                                            _context.next = 15;
                                            break;
                                        }
                                        idServerParsedUrl = _url["default"].parse(this._matrixClient.getIdentityServerUrl());
                                        creds.id_server = idServerParsedUrl.host;
                                    case 15:
                                        authDict = {
                                            type: EMAIL_STAGE_TYPE,
                                            threepid_creds: creds,
                                            threepidCreds: creds
                                        };
                                    case 16:
                                        this.submitAuthDict(authDict, true);
                                    case 17:
                                    case "end":
                                        return _context.stop();
                                }
                            }
                        }, _callee, this);
                    }));
                    function poll() {
                        return _poll.apply(this, arguments);
                    }
                    return poll;
                }(),
                getSessionId: function getSessionId() {
                    return this._data ? this._data.session : undefined;
                },
                getClientSecret: function getClientSecret() {
                    return this._clientSecret;
                },
                getStageParams: function getStageParams(loginType) {
                    var params = {};
                    if (this._data && this._data.params) {
                        params = this._data.params;
                    }
                    return params[loginType];
                },
                getChosenFlow: function getChosenFlow() {
                    return this._chosenFlow;
                },
                submitAuthDict: function () {
                    var _submitAuthDict = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee2(authData, background) {
                        var auth;
                        return _regenerator["default"].wrap(function _callee2$(_context2) {
                            while (1) {
                                switch (_context2.prev = _context2.next) {
                                    case 0:
                                        if (this._resolveFunc) {
                                            _context2.next = 2;
                                            break;
                                        }
                                        throw new Error("submitAuthDict() called before attemptAuth()");
                                    case 2:
                                        if (!background && this._busyChangedCallback) {
                                            this._busyChangedCallback(true);
                                        }
                                    case 3:
                                        if (!this._submitPromise) {
                                            _context2.next = 13;
                                            break;
                                        }
                                        _context2.prev = 4;
                                        _context2.next = 7;
                                        return this._submitPromise;
                                    case 7:
                                        _context2.next = 11;
                                        break;
                                    case 9:
                                        _context2.prev = 9;
                                        _context2.t0 = _context2["catch"](4);
                                    case 11:
                                        _context2.next = 3;
                                        break;
                                    case 13:
                                        if (this._data.session) {
                                            auth = {
                                                session: this._data.session
                                            };
                                            utils.extend(auth, authData);
                                        }
                                        else {
                                            auth = authData;
                                        }
                                        _context2.prev = 14;
                                        this._submitPromise = this._doRequest(auth, background);
                                        _context2.next = 18;
                                        return this._submitPromise;
                                    case 18:
                                        _context2.prev = 18;
                                        this._submitPromise = null;
                                        if (!background && this._busyChangedCallback) {
                                            this._busyChangedCallback(false);
                                        }
                                        return _context2.finish(18);
                                    case 22:
                                    case "end":
                                        return _context2.stop();
                                }
                            }
                        }, _callee2, this, [[4, 9], [14, , 18, 22]]);
                    }));
                    function submitAuthDict(_x, _x2) {
                        return _submitAuthDict.apply(this, arguments);
                    }
                    return submitAuthDict;
                }(),
                getEmailSid: function getEmailSid() {
                    return this._emailSid;
                },
                setEmailSid: function setEmailSid(sid) {
                    this._emailSid = sid;
                },
                _doRequest: function () {
                    var _doRequest2 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee3(auth, background) {
                        var result, errorFlows, haveFlows, requestTokenResult;
                        return _regenerator["default"].wrap(function _callee3$(_context3) {
                            while (1) {
                                switch (_context3.prev = _context3.next) {
                                    case 0:
                                        _context3.prev = 0;
                                        _context3.next = 3;
                                        return this._requestCallback(auth, background);
                                    case 3:
                                        result = _context3.sent;
                                        this._resolveFunc(result);
                                        this._resolveFunc = null;
                                        this._rejectFunc = null;
                                        _context3.next = 34;
                                        break;
                                    case 9:
                                        _context3.prev = 9;
                                        _context3.t0 = _context3["catch"](0);
                                        errorFlows = _context3.t0.data ? _context3.t0.data.flows : null;
                                        haveFlows = this._data.flows || Boolean(errorFlows);
                                        if (_context3.t0.httpStatus !== 401 || !_context3.t0.data || !haveFlows) {
                                            if (!background) {
                                                this._rejectFunc(_context3.t0);
                                            }
                                            else {
                                                _logger.logger.log("Background poll request failed doing UI auth: ignoring", _context3.t0);
                                            }
                                        }
                                        if (!_context3.t0.data.flows && !_context3.t0.data.completed && !_context3.t0.data.session) {
                                            _context3.t0.data.flows = this._data.flows;
                                            _context3.t0.data.completed = this._data.completed;
                                            _context3.t0.data.session = this._data.session;
                                        }
                                        this._data = _context3.t0.data;
                                        try {
                                            this._startNextAuthStage();
                                        }
                                        catch (e) {
                                            this._rejectFunc(e);
                                            this._resolveFunc = null;
                                            this._rejectFunc = null;
                                        }
                                        if (!(!this._emailSid && !this._requestingEmailToken && this._chosenFlow.stages.includes('m.login.email.identity'))) {
                                            _context3.next = 34;
                                            break;
                                        }
                                        this._requestingEmailToken = true;
                                        _context3.prev = 19;
                                        _context3.next = 22;
                                        return this._requestEmailTokenCallback(this._inputs.emailAddress, this._clientSecret, 1, this._data.session);
                                    case 22:
                                        requestTokenResult = _context3.sent;
                                        this._emailSid = requestTokenResult.sid;
                                        _context3.next = 31;
                                        break;
                                    case 26:
                                        _context3.prev = 26;
                                        _context3.t1 = _context3["catch"](19);
                                        this._rejectFunc(_context3.t1);
                                        this._resolveFunc = null;
                                        this._rejectFunc = null;
                                    case 31:
                                        _context3.prev = 31;
                                        this._requestingEmailToken = false;
                                        return _context3.finish(31);
                                    case 34:
                                    case "end":
                                        return _context3.stop();
                                }
                            }
                        }, _callee3, this, [[0, 9], [19, 26, 31, 34]]);
                    }));
                    function _doRequest(_x3, _x4) {
                        return _doRequest2.apply(this, arguments);
                    }
                    return _doRequest;
                }(),
                _startNextAuthStage: function _startNextAuthStage() {
                    var nextStage = this._chooseStage();
                    if (!nextStage) {
                        throw new Error("No incomplete flows from the server");
                    }
                    this._currentStage = nextStage;
                    if (nextStage === 'm.login.dummy') {
                        this.submitAuthDict({
                            type: 'm.login.dummy'
                        });
                        return;
                    }
                    if (this._data && this._data.errcode || this._data.error) {
                        this._stateUpdatedCallback(nextStage, {
                            errcode: this._data.errcode || "",
                            error: this._data.error || ""
                        });
                        return;
                    }
                    var stageStatus = {};
                    if (nextStage == EMAIL_STAGE_TYPE) {
                        stageStatus.emailSid = this._emailSid;
                    }
                    this._stateUpdatedCallback(nextStage, stageStatus);
                },
                _chooseStage: function _chooseStage() {
                    if (this._chosenFlow === null) {
                        this._chosenFlow = this._chooseFlow();
                    }
                    _logger.logger.log("Active flow => %s", JSON.stringify(this._chosenFlow));
                    var nextStage = this._firstUncompletedStage(this._chosenFlow);
                    _logger.logger.log("Next stage: %s", nextStage);
                    return nextStage;
                },
                _chooseFlow: function _chooseFlow() {
                    var flows = this._data.flows || [];
                    var haveEmail = Boolean(this._inputs.emailAddress) || Boolean(this._emailSid);
                    var haveMsisdn = Boolean(this._inputs.phoneCountry) && Boolean(this._inputs.phoneNumber);
                    var _iterator = _createForOfIteratorHelper(flows), _step;
                    try {
                        for (_iterator.s(); !(_step = _iterator.n()).done;) {
                            var flow = _step.value;
                            var flowHasEmail = false;
                            var flowHasMsisdn = false;
                            var _iterator2 = _createForOfIteratorHelper(flow.stages), _step2;
                            try {
                                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                                    var stage = _step2.value;
                                    if (stage === EMAIL_STAGE_TYPE) {
                                        flowHasEmail = true;
                                    }
                                    else if (stage == MSISDN_STAGE_TYPE) {
                                        flowHasMsisdn = true;
                                    }
                                }
                            }
                            catch (err) {
                                _iterator2.e(err);
                            }
                            finally {
                                _iterator2.f();
                            }
                            if (flowHasEmail == haveEmail && flowHasMsisdn == haveMsisdn) {
                                return flow;
                            }
                        }
                    }
                    catch (err) {
                        _iterator.e(err);
                    }
                    finally {
                        _iterator.f();
                    }
                    var err = new Error("No appropriate authentication flow found");
                    err.name = 'NoAuthFlowFoundError';
                    err.required_stages = [];
                    if (haveEmail)
                        err.required_stages.push(EMAIL_STAGE_TYPE);
                    if (haveMsisdn)
                        err.required_stages.push(MSISDN_STAGE_TYPE);
                    err.available_flows = flows;
                    throw err;
                },
                _firstUncompletedStage: function _firstUncompletedStage(flow) {
                    var completed = (this._data || {}).completed || [];
                    for (var i = 0; i < flow.stages.length; ++i) {
                        var stageType = flow.stages[i];
                        if (completed.indexOf(stageType) === -1) {
                            return stageType;
                        }
                    }
                }
            };
        }, { "./logger": 97, "./utils": 125, "@babel/runtime/helpers/asyncToGenerator": 5, "@babel/runtime/helpers/interopRequireDefault": 12, "@babel/runtime/helpers/interopRequireWildcard": 13, "@babel/runtime/regenerator": 27, "url": 51 }], 97: [function (require, module, exports) {
            "use strict";
            var __importDefault = (this && this.__importDefault) || function (mod) {
                return (mod && mod.__esModule) ? mod : { "default": mod };
            };
            Object.defineProperty(exports, "__esModule", { value: true });
            exports.logger = void 0;
            const loglevel_1 = __importDefault(require("loglevel"));
            const DEFAULT_NAMESPACE = "matrix";
            loglevel_1.default.methodFactory = function (methodName, logLevel, loggerName) {
                return function (...args) {
                    if (this.prefix) {
                        args.unshift(this.prefix);
                    }
                    const supportedByConsole = methodName === "error" ||
                        methodName === "warn" ||
                        methodName === "trace" ||
                        methodName === "info";
                    if (supportedByConsole) {
                        return console[methodName](...args);
                    }
                    else {
                        return console.log(...args);
                    }
                };
            };
            exports.logger = loglevel_1.default.getLogger(DEFAULT_NAMESPACE);
            exports.logger.setLevel(loglevel_1.default.levels.DEBUG);
            function extendLogger(logger) {
                logger.withPrefix = function (prefix) {
                    const existingPrefix = this.prefix || "";
                    return getPrefixedLogger(existingPrefix + prefix);
                };
            }
            extendLogger(exports.logger);
            function getPrefixedLogger(prefix) {
                const prefixLogger = loglevel_1.default.getLogger(`${DEFAULT_NAMESPACE}-${prefix}`);
                if (prefixLogger.prefix !== prefix) {
                    extendLogger(prefixLogger);
                    prefixLogger.prefix = prefix;
                    prefixLogger.setLevel(loglevel_1.default.levels.DEBUG);
                }
                return prefixLogger;
            }
        }, { "loglevel": 38 }], 98: [function (require, module, exports) {
            (function (global) {
                (function () {
                    "use strict";
                    var __createBinding = (this && this.__createBinding) || (Object.create ? (function (o, m, k, k2) {
                        if (k2 === undefined)
                            k2 = k;
                        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
                    }) : (function (o, m, k, k2) {
                        if (k2 === undefined)
                            k2 = k;
                        o[k2] = m[k];
                    }));
                    var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function (o, v) {
                        Object.defineProperty(o, "default", { enumerable: true, value: v });
                    }) : function (o, v) {
                        o["default"] = v;
                    });
                    var __exportStar = (this && this.__exportStar) || function (m, exports) {
                        for (var p in m)
                            if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p))
                                __createBinding(exports, m, p);
                    };
                    var __importStar = (this && this.__importStar) || function (mod) {
                        if (mod && mod.__esModule)
                            return mod;
                        var result = {};
                        if (mod != null)
                            for (var k in mod)
                                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                                    __createBinding(result, mod, k);
                        __setModuleDefault(result, mod);
                        return result;
                    };
                    Object.defineProperty(exports, "__esModule", { value: true });
                    exports.createClient = exports.setCryptoStoreFactory = exports.wrapRequest = exports.getRequest = exports.request = exports.setMatrixCallVideoInput = exports.setMatrixCallAudioInput = exports.setMatrixCallAudioOutput = exports.createNewMatrixCall = exports.ContentHelpers = void 0;
                    const memory_crypto_store_1 = require("./crypto/store/memory-crypto-store");
                    const memory_1 = require("./store/memory");
                    const scheduler_1 = require("./scheduler");
                    const client_1 = require("./client");
                    __exportStar(require("./client"), exports);
                    __exportStar(require("./http-api"), exports);
                    __exportStar(require("./autodiscovery"), exports);
                    __exportStar(require("./sync-accumulator"), exports);
                    __exportStar(require("./errors"), exports);
                    __exportStar(require("./models/event"), exports);
                    __exportStar(require("./models/room"), exports);
                    __exportStar(require("./models/group"), exports);
                    __exportStar(require("./models/event-timeline"), exports);
                    __exportStar(require("./models/event-timeline-set"), exports);
                    __exportStar(require("./models/room-member"), exports);
                    __exportStar(require("./models/room-state"), exports);
                    __exportStar(require("./models/user"), exports);
                    __exportStar(require("./scheduler"), exports);
                    __exportStar(require("./filter"), exports);
                    __exportStar(require("./timeline-window"), exports);
                    __exportStar(require("./interactive-auth"), exports);
                    __exportStar(require("./service-types"), exports);
                    __exportStar(require("./store/memory"), exports);
                    __exportStar(require("./store/indexeddb"), exports);
                    __exportStar(require("./store/session/webstorage"), exports);
                    __exportStar(require("./crypto/store/memory-crypto-store"), exports);
                    __exportStar(require("./crypto/store/indexeddb-crypto-store"), exports);
                    __exportStar(require("./content-repo"), exports);
                    exports.ContentHelpers = __importStar(require("./content-helpers"));
                    var call_1 = require("./webrtc/call");
                    Object.defineProperty(exports, "createNewMatrixCall", { enumerable: true, get: function () { return call_1.createNewMatrixCall; } });
                    Object.defineProperty(exports, "setMatrixCallAudioOutput", { enumerable: true, get: function () { return call_1.setAudioOutput; } });
                    Object.defineProperty(exports, "setMatrixCallAudioInput", { enumerable: true, get: function () { return call_1.setAudioInput; } });
                    Object.defineProperty(exports, "setMatrixCallVideoInput", { enumerable: true, get: function () { return call_1.setVideoInput; } });
                    let requestInstance;
                    function request(r) {
                        requestInstance = r;
                    }
                    exports.request = request;
                    function getRequest() {
                        return requestInstance;
                    }
                    exports.getRequest = getRequest;
                    function wrapRequest(wrapper) {
                        const origRequest = requestInstance;
                        requestInstance = function (options, callback) {
                            return wrapper(origRequest, options, callback);
                        };
                    }
                    exports.wrapRequest = wrapRequest;
                    let cryptoStoreFactory = () => new memory_crypto_store_1.MemoryCryptoStore;
                    function setCryptoStoreFactory(fac) {
                        cryptoStoreFactory = fac;
                    }
                    exports.setCryptoStoreFactory = setCryptoStoreFactory;
                    function createClient(opts) {
                        if (typeof opts === "string") {
                            opts = {
                                "baseUrl": opts,
                            };
                        }
                        opts.request = opts.request || requestInstance;
                        opts.store = opts.store || new memory_1.MemoryStore({
                            localStorage: global.localStorage,
                        });
                        opts.scheduler = opts.scheduler || new scheduler_1.MatrixScheduler();
                        opts.cryptoStore = opts.cryptoStore || cryptoStoreFactory();
                        return new client_1.MatrixClient(opts);
                    }
                    exports.createClient = createClient;
                }).call(this);
            }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, { "./autodiscovery": 55, "./client": 58, "./content-helpers": 59, "./content-repo": 60, "./crypto/store/indexeddb-crypto-store": 80, "./crypto/store/memory-crypto-store": 82, "./errors": 91, "./filter": 93, "./http-api": 94, "./interactive-auth": 96, "./models/event": 102, "./models/event-timeline": 101, "./models/event-timeline-set": 100, "./models/group": 103, "./models/room": 108, "./models/room-member": 105, "./models/room-state": 106, "./models/user": 110, "./scheduler": 114, "./service-types": 115, "./store/indexeddb": 118, "./store/memory": 119, "./store/session/webstorage": 120, "./sync-accumulator": 122, "./timeline-window": 124, "./webrtc/call": 126 }], 99: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.EventContext = EventContext;
            function EventContext(ourEvent) {
                this._timeline = [ourEvent];
                this._ourEventIndex = 0;
                this._paginateTokens = {
                    b: null,
                    f: null
                };
                this._paginateRequests = {
                    b: null,
                    f: null
                };
            }
            EventContext.prototype.getEvent = function () {
                return this._timeline[this._ourEventIndex];
            };
            EventContext.prototype.getTimeline = function () {
                return this._timeline;
            };
            EventContext.prototype.getOurEventIndex = function () {
                return this._ourEventIndex;
            };
            EventContext.prototype.getPaginateToken = function (backwards) {
                return this._paginateTokens[backwards ? 'b' : 'f'];
            };
            EventContext.prototype.setPaginateToken = function (token, backwards) {
                this._paginateTokens[backwards ? 'b' : 'f'] = token;
            };
            EventContext.prototype.addEvents = function (events, atStart) {
                if (atStart) {
                    this._timeline = events.concat(this._timeline);
                    this._ourEventIndex += events.length;
                }
                else {
                    this._timeline = this._timeline.concat(events);
                }
            };
        }, {}], 100: [function (require, module, exports) {
            "use strict";
            var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.EventTimelineSet = EventTimelineSet;
            var _events = require("events");
            var _eventTimeline = require("./event-timeline");
            var _event = require("./event");
            var utils = _interopRequireWildcard(require("../utils"));
            var _logger = require("../logger");
            var _relations = require("./relations");
            var DEBUG = true;
            var debuglog;
            if (DEBUG) {
                debuglog = _logger.logger.log.bind(_logger.logger);
            }
            else {
                debuglog = function debuglog() { };
            }
            function EventTimelineSet(room, opts) {
                this.room = room;
                this._timelineSupport = Boolean(opts.timelineSupport);
                this._liveTimeline = new _eventTimeline.EventTimeline(this);
                this._unstableClientRelationAggregation = !!opts.unstableClientRelationAggregation;
                this._timelines = [this._liveTimeline];
                this._eventIdToTimeline = {};
                this._filter = opts.filter || null;
                if (this._unstableClientRelationAggregation) {
                    this._relations = {};
                }
            }
            utils.inherits(EventTimelineSet, _events.EventEmitter);
            EventTimelineSet.prototype.getTimelines = function () {
                return this._timelines;
            };
            EventTimelineSet.prototype.getFilter = function () {
                return this._filter;
            };
            EventTimelineSet.prototype.setFilter = function (filter) {
                this._filter = filter;
            };
            EventTimelineSet.prototype.getPendingEvents = function () {
                if (!this.room) {
                    return [];
                }
                if (this._filter) {
                    return this._filter.filterRoomTimeline(this.room.getPendingEvents());
                }
                else {
                    return this.room.getPendingEvents();
                }
            };
            EventTimelineSet.prototype.getLiveTimeline = function () {
                return this._liveTimeline;
            };
            EventTimelineSet.prototype.eventIdToTimeline = function (eventId) {
                return this._eventIdToTimeline[eventId];
            };
            EventTimelineSet.prototype.replaceEventId = function (oldEventId, newEventId) {
                var existingTimeline = this._eventIdToTimeline[oldEventId];
                if (existingTimeline) {
                    delete this._eventIdToTimeline[oldEventId];
                    this._eventIdToTimeline[newEventId] = existingTimeline;
                }
            };
            EventTimelineSet.prototype.resetLiveTimeline = function (backPaginationToken, forwardPaginationToken) {
                var resetAllTimelines = !this._timelineSupport || !forwardPaginationToken;
                var oldTimeline = this._liveTimeline;
                var newTimeline = resetAllTimelines ? oldTimeline.forkLive(_eventTimeline.EventTimeline.FORWARDS) : oldTimeline.fork(_eventTimeline.EventTimeline.FORWARDS);
                if (resetAllTimelines) {
                    this._timelines = [newTimeline];
                    this._eventIdToTimeline = {};
                }
                else {
                    this._timelines.push(newTimeline);
                }
                if (forwardPaginationToken) {
                    oldTimeline.setPaginationToken(forwardPaginationToken, _eventTimeline.EventTimeline.FORWARDS);
                }
                newTimeline.setPaginationToken(backPaginationToken, _eventTimeline.EventTimeline.BACKWARDS);
                this._liveTimeline = newTimeline;
                this.emit("Room.timelineReset", this.room, this, resetAllTimelines);
            };
            EventTimelineSet.prototype.getTimelineForEvent = function (eventId) {
                var res = this._eventIdToTimeline[eventId];
                return res === undefined ? null : res;
            };
            EventTimelineSet.prototype.findEventById = function (eventId) {
                var tl = this.getTimelineForEvent(eventId);
                if (!tl) {
                    return undefined;
                }
                return utils.findElement(tl.getEvents(), function (ev) {
                    return ev.getId() == eventId;
                });
            };
            EventTimelineSet.prototype.addTimeline = function () {
                if (!this._timelineSupport) {
                    throw new Error("timeline support is disabled. Set the 'timelineSupport'" + " parameter to true when creating MatrixClient to enable" + " it.");
                }
                var timeline = new _eventTimeline.EventTimeline(this);
                this._timelines.push(timeline);
                return timeline;
            };
            EventTimelineSet.prototype.addEventsToTimeline = function (events, toStartOfTimeline, timeline, paginationToken) {
                if (!timeline) {
                    throw new Error("'timeline' not specified for EventTimelineSet.addEventsToTimeline");
                }
                if (!toStartOfTimeline && timeline == this._liveTimeline) {
                    throw new Error("EventTimelineSet.addEventsToTimeline cannot be used for adding events to " + "the live timeline - use Room.addLiveEvents instead");
                }
                if (this._filter) {
                    events = this._filter.filterRoomTimeline(events);
                    if (!events.length) {
                        return;
                    }
                }
                var direction = toStartOfTimeline ? _eventTimeline.EventTimeline.BACKWARDS : _eventTimeline.EventTimeline.FORWARDS;
                var inverseDirection = toStartOfTimeline ? _eventTimeline.EventTimeline.FORWARDS : _eventTimeline.EventTimeline.BACKWARDS;
                var didUpdate = false;
                var lastEventWasNew = false;
                for (var i = 0; i < events.length; i++) {
                    var event = events[i];
                    var eventId = event.getId();
                    var existingTimeline = this._eventIdToTimeline[eventId];
                    if (!existingTimeline) {
                        this.addEventToTimeline(event, timeline, toStartOfTimeline);
                        lastEventWasNew = true;
                        didUpdate = true;
                        continue;
                    }
                    lastEventWasNew = false;
                    if (existingTimeline == timeline) {
                        debuglog("Event " + eventId + " already in timeline " + timeline);
                        continue;
                    }
                    var neighbour = timeline.getNeighbouringTimeline(direction);
                    if (neighbour) {
                        if (existingTimeline == neighbour) {
                            debuglog("Event " + eventId + " in neighbouring timeline - " + "switching to " + existingTimeline);
                        }
                        else {
                            debuglog("Event " + eventId + " already in a different " + "timeline " + existingTimeline);
                        }
                        timeline = existingTimeline;
                        continue;
                    }
                    _logger.logger.info("Already have timeline for " + eventId + " - joining timeline " + timeline + " to " + existingTimeline);
                    var existingIsLive = existingTimeline === this._liveTimeline;
                    var timelineIsLive = timeline === this._liveTimeline;
                    var backwardsIsLive = direction === _eventTimeline.EventTimeline.BACKWARDS && existingIsLive;
                    var forwardsIsLive = direction === _eventTimeline.EventTimeline.FORWARDS && timelineIsLive;
                    if (backwardsIsLive || forwardsIsLive) {
                        if (backwardsIsLive) {
                            _logger.logger.warn("Refusing to set a preceding existingTimeLine on our " + "timeline as the existingTimeLine is live (" + existingTimeline + ")");
                        }
                        if (forwardsIsLive) {
                            _logger.logger.warn("Refusing to set our preceding timeline on a existingTimeLine " + "as our timeline is live (" + timeline + ")");
                        }
                        continue;
                    }
                    timeline.setNeighbouringTimeline(existingTimeline, direction);
                    existingTimeline.setNeighbouringTimeline(timeline, inverseDirection);
                    timeline = existingTimeline;
                    didUpdate = true;
                }
                if (lastEventWasNew || !didUpdate) {
                    if (direction === _eventTimeline.EventTimeline.FORWARDS && timeline === this._liveTimeline) {
                        _logger.logger.warn({
                            lastEventWasNew: lastEventWasNew,
                            didUpdate: didUpdate
                        });
                        _logger.logger.warn("Refusing to set forwards pagination token of live timeline " + "".concat(timeline, " to ").concat(paginationToken));
                        return;
                    }
                    timeline.setPaginationToken(paginationToken, direction);
                }
            };
            EventTimelineSet.prototype.addLiveEvent = function (event, duplicateStrategy, fromCache) {
                if (this._filter) {
                    var events = this._filter.filterRoomTimeline([event]);
                    if (!events.length) {
                        return;
                    }
                }
                var timeline = this._eventIdToTimeline[event.getId()];
                if (timeline) {
                    if (duplicateStrategy === "replace") {
                        debuglog("EventTimelineSet.addLiveEvent: replacing duplicate event " + event.getId());
                        var tlEvents = timeline.getEvents();
                        for (var j = 0; j < tlEvents.length; j++) {
                            if (tlEvents[j].getId() === event.getId()) {
                                _eventTimeline.EventTimeline.setEventMetadata(event, timeline.getState(_eventTimeline.EventTimeline.FORWARDS), false);
                                if (!tlEvents[j].encryptedType) {
                                    tlEvents[j] = event;
                                }
                                break;
                            }
                        }
                    }
                    else {
                        debuglog("EventTimelineSet.addLiveEvent: ignoring duplicate event " + event.getId());
                    }
                    return;
                }
                this.addEventToTimeline(event, this._liveTimeline, false, fromCache);
            };
            EventTimelineSet.prototype.addEventToTimeline = function (event, timeline, toStartOfTimeline, fromCache) {
                var eventId = event.getId();
                timeline.addEvent(event, toStartOfTimeline);
                this._eventIdToTimeline[eventId] = timeline;
                this.setRelationsTarget(event);
                this.aggregateRelations(event);
                var data = {
                    timeline: timeline,
                    liveEvent: !toStartOfTimeline && timeline == this._liveTimeline && !fromCache
                };
                this.emit("Room.timeline", event, this.room, Boolean(toStartOfTimeline), false, data);
            };
            EventTimelineSet.prototype.handleRemoteEcho = function (localEvent, oldEventId, newEventId) {
                var existingTimeline = this._eventIdToTimeline[oldEventId];
                if (existingTimeline) {
                    delete this._eventIdToTimeline[oldEventId];
                    this._eventIdToTimeline[newEventId] = existingTimeline;
                }
                else {
                    if (this._filter) {
                        if (this._filter.filterRoomTimeline([localEvent]).length) {
                            this.addEventToTimeline(localEvent, this._liveTimeline, false);
                        }
                    }
                    else {
                        this.addEventToTimeline(localEvent, this._liveTimeline, false);
                    }
                }
            };
            EventTimelineSet.prototype.removeEvent = function (eventId) {
                var timeline = this._eventIdToTimeline[eventId];
                if (!timeline) {
                    return null;
                }
                var removed = timeline.removeEvent(eventId);
                if (removed) {
                    delete this._eventIdToTimeline[eventId];
                    var data = {
                        timeline: timeline
                    };
                    this.emit("Room.timeline", removed, this.room, undefined, true, data);
                }
                return removed;
            };
            EventTimelineSet.prototype.compareEventOrdering = function (eventId1, eventId2) {
                if (eventId1 == eventId2) {
                    return 0;
                }
                var timeline1 = this._eventIdToTimeline[eventId1];
                var timeline2 = this._eventIdToTimeline[eventId2];
                if (timeline1 === undefined) {
                    return null;
                }
                if (timeline2 === undefined) {
                    return null;
                }
                if (timeline1 === timeline2) {
                    var idx1;
                    var idx2;
                    var events = timeline1.getEvents();
                    for (var idx = 0; idx < events.length && (idx1 === undefined || idx2 === undefined); idx++) {
                        var evId = events[idx].getId();
                        if (evId == eventId1) {
                            idx1 = idx;
                        }
                        if (evId == eventId2) {
                            idx2 = idx;
                        }
                    }
                    return idx1 - idx2;
                }
                var tl = timeline1;
                while (tl) {
                    if (tl === timeline2) {
                        return -1;
                    }
                    tl = tl.getNeighbouringTimeline(_eventTimeline.EventTimeline.FORWARDS);
                }
                tl = timeline1;
                while (tl) {
                    if (tl === timeline2) {
                        return 1;
                    }
                    tl = tl.getNeighbouringTimeline(_eventTimeline.EventTimeline.BACKWARDS);
                }
                return null;
            };
            EventTimelineSet.prototype.getRelationsForEvent = function (eventId, relationType, eventType) {
                if (!this._unstableClientRelationAggregation) {
                    throw new Error("Client-side relation aggregation is disabled");
                }
                if (!eventId || !relationType || !eventType) {
                    throw new Error("Invalid arguments for `getRelationsForEvent`");
                }
                var relationsForEvent = this._relations[eventId] || {};
                var relationsWithRelType = relationsForEvent[relationType] || {};
                return relationsWithRelType[eventType];
            };
            EventTimelineSet.prototype.setRelationsTarget = function (event) {
                if (!this._unstableClientRelationAggregation) {
                    return;
                }
                var relationsForEvent = this._relations[event.getId()];
                if (!relationsForEvent) {
                    return;
                }
                var relationsWithRelType = relationsForEvent["m.replace"];
                if (!relationsWithRelType) {
                    return;
                }
                var relationsWithEventType = relationsWithRelType["m.room.message"];
                if (relationsWithEventType) {
                    relationsWithEventType.setTargetEvent(event);
                }
            };
            EventTimelineSet.prototype.aggregateRelations = function (event) {
                var _this = this;
                if (!this._unstableClientRelationAggregation) {
                    return;
                }
                if (event.isRedacted() || event.status === _event.EventStatus.CANCELLED) {
                    return;
                }
                if (event.isBeingDecrypted()) {
                    event.once("Event.decrypted", function () {
                        _this.aggregateRelations(event);
                    });
                    return;
                }
                var relation = event.getRelation();
                if (!relation) {
                    return;
                }
                var relatesToEventId = relation.event_id;
                var relationType = relation.rel_type;
                var eventType = event.getType();
                var relationsForEvent = this._relations[relatesToEventId];
                if (!relationsForEvent) {
                    relationsForEvent = this._relations[relatesToEventId] = {};
                }
                var relationsWithRelType = relationsForEvent[relationType];
                if (!relationsWithRelType) {
                    relationsWithRelType = relationsForEvent[relationType] = {};
                }
                var relationsWithEventType = relationsWithRelType[eventType];
                var isNewRelations = false;
                var relatesToEvent;
                if (!relationsWithEventType) {
                    relationsWithEventType = relationsWithRelType[eventType] = new _relations.Relations(relationType, eventType, this.room);
                    isNewRelations = true;
                    relatesToEvent = this.findEventById(relatesToEventId) || this.room.getPendingEvent(relatesToEventId);
                    if (relatesToEvent) {
                        relationsWithEventType.setTargetEvent(relatesToEvent);
                    }
                }
                relationsWithEventType.addEvent(event);
                if (isNewRelations && relatesToEvent) {
                    relatesToEvent.emit("Event.relationsCreated", relationType, eventType);
                }
            };
        }, { "../logger": 97, "../utils": 125, "./event": 102, "./event-timeline": 101, "./relations": 104, "@babel/runtime/helpers/interopRequireWildcard": 13, "events": 36 }], 101: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.EventTimeline = EventTimeline;
            var _roomState = require("./room-state");
            function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
                if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                    if (it)
                        o = it;
                    var i = 0;
                    var F = function F() { };
                    return { s: F, n: function n() { if (i >= o.length)
                            return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try {
                    if (!normalCompletion && it["return"] != null)
                        it["return"]();
                }
                finally {
                    if (didErr)
                        throw err;
                } } }; }
            function _unsupportedIterableToArray(o, minLen) { if (!o)
                return; if (typeof o === "string")
                return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor)
                n = o.constructor.name; if (n === "Map" || n === "Set")
                return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return _arrayLikeToArray(o, minLen); }
            function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length)
                len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
            } return arr2; }
            function EventTimeline(eventTimelineSet) {
                this._eventTimelineSet = eventTimelineSet;
                this._roomId = eventTimelineSet.room ? eventTimelineSet.room.roomId : null;
                this._events = [];
                this._baseIndex = 0;
                this._startState = new _roomState.RoomState(this._roomId);
                this._startState.paginationToken = null;
                this._endState = new _roomState.RoomState(this._roomId);
                this._endState.paginationToken = null;
                this._prevTimeline = null;
                this._nextTimeline = null;
                this._paginationRequests = {
                    'b': null,
                    'f': null
                };
                this._name = this._roomId + ":" + new Date().toISOString();
            }
            EventTimeline.BACKWARDS = "b";
            EventTimeline.FORWARDS = "f";
            EventTimeline.prototype.initialiseState = function (stateEvents) {
                if (this._events.length > 0) {
                    throw new Error("Cannot initialise state after events are added");
                }
                var _iterator = _createForOfIteratorHelper(stateEvents), _step;
                try {
                    for (_iterator.s(); !(_step = _iterator.n()).done;) {
                        var e = _step.value;
                        Object.freeze(e);
                    }
                }
                catch (err) {
                    _iterator.e(err);
                }
                finally {
                    _iterator.f();
                }
                this._startState.setStateEvents(stateEvents);
                this._endState.setStateEvents(stateEvents);
            };
            EventTimeline.prototype.forkLive = function (direction) {
                var forkState = this.getState(direction);
                var timeline = new EventTimeline(this._eventTimelineSet);
                timeline._startState = forkState.clone();
                timeline._endState = forkState;
                this._endState = forkState.clone();
                return timeline;
            };
            EventTimeline.prototype.fork = function (direction) {
                var forkState = this.getState(direction);
                var timeline = new EventTimeline(this._eventTimelineSet);
                timeline._startState = forkState.clone();
                timeline._endState = forkState.clone();
                return timeline;
            };
            EventTimeline.prototype.getRoomId = function () {
                return this._roomId;
            };
            EventTimeline.prototype.getFilter = function () {
                return this._eventTimelineSet.getFilter();
            };
            EventTimeline.prototype.getTimelineSet = function () {
                return this._eventTimelineSet;
            };
            EventTimeline.prototype.getBaseIndex = function () {
                return this._baseIndex;
            };
            EventTimeline.prototype.getEvents = function () {
                return this._events;
            };
            EventTimeline.prototype.getState = function (direction) {
                if (direction == EventTimeline.BACKWARDS) {
                    return this._startState;
                }
                else if (direction == EventTimeline.FORWARDS) {
                    return this._endState;
                }
                else {
                    throw new Error("Invalid direction '" + direction + "'");
                }
            };
            EventTimeline.prototype.getPaginationToken = function (direction) {
                return this.getState(direction).paginationToken;
            };
            EventTimeline.prototype.setPaginationToken = function (token, direction) {
                this.getState(direction).paginationToken = token;
            };
            EventTimeline.prototype.getNeighbouringTimeline = function (direction) {
                if (direction == EventTimeline.BACKWARDS) {
                    return this._prevTimeline;
                }
                else if (direction == EventTimeline.FORWARDS) {
                    return this._nextTimeline;
                }
                else {
                    throw new Error("Invalid direction '" + direction + "'");
                }
            };
            EventTimeline.prototype.setNeighbouringTimeline = function (neighbour, direction) {
                if (this.getNeighbouringTimeline(direction)) {
                    throw new Error("timeline already has a neighbouring timeline - " + "cannot reset neighbour (direction: " + direction + ")");
                }
                if (direction == EventTimeline.BACKWARDS) {
                    this._prevTimeline = neighbour;
                }
                else if (direction == EventTimeline.FORWARDS) {
                    this._nextTimeline = neighbour;
                }
                else {
                    throw new Error("Invalid direction '" + direction + "'");
                }
                this.setPaginationToken(null, direction);
            };
            EventTimeline.prototype.addEvent = function (event, atStart) {
                var stateContext = atStart ? this._startState : this._endState;
                var timelineSet = this.getTimelineSet();
                if (timelineSet.room && timelineSet.room.getUnfilteredTimelineSet() === timelineSet) {
                    EventTimeline.setEventMetadata(event, stateContext, atStart);
                    if (event.isState()) {
                        stateContext.setStateEvents([event]);
                        if (!event.sender || event.getType() === "m.room.member" && !atStart) {
                            EventTimeline.setEventMetadata(event, stateContext, atStart);
                        }
                    }
                }
                var insertIndex;
                if (atStart) {
                    insertIndex = 0;
                }
                else {
                    insertIndex = this._events.length;
                }
                this._events.splice(insertIndex, 0, event);
                if (atStart) {
                    this._baseIndex++;
                }
            };
            EventTimeline.setEventMetadata = function (event, stateContext, toStartOfTimeline) {
                event.sender = stateContext.getSentinelMember(event.getSender());
                if (event.getType() === "m.room.member") {
                    event.target = stateContext.getSentinelMember(event.getStateKey());
                }
                if (event.isState()) {
                    if (toStartOfTimeline) {
                        event.forwardLooking = false;
                    }
                }
            };
            EventTimeline.prototype.removeEvent = function (eventId) {
                for (var i = this._events.length - 1; i >= 0; i--) {
                    var ev = this._events[i];
                    if (ev.getId() == eventId) {
                        this._events.splice(i, 1);
                        if (i < this._baseIndex) {
                            this._baseIndex--;
                        }
                        return ev;
                    }
                }
                return null;
            };
            EventTimeline.prototype.toString = function () {
                return this._name;
            };
        }, { "./room-state": 106 }], 102: [function (require, module, exports) {
            "use strict";
            var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
            var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.MatrixEvent = exports.EventStatus = void 0;
            var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
            var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
            var _events = require("events");
            var utils = _interopRequireWildcard(require("../utils"));
            var _logger = require("../logger");
            var EventStatus = {
                NOT_SENT: "not_sent",
                ENCRYPTING: "encrypting",
                SENDING: "sending",
                QUEUED: "queued",
                SENT: "sent",
                CANCELLED: "cancelled"
            };
            exports.EventStatus = EventStatus;
            var interns = {};
            function intern(str) {
                if (!interns[str]) {
                    interns[str] = str;
                }
                return interns[str];
            }
            var MatrixEvent = function MatrixEvent(event) {
                ["state_key", "type", "sender", "room_id", "membership"].forEach(function (prop) {
                    if (!event[prop]) {
                        return;
                    }
                    event[prop] = intern(event[prop]);
                });
                ["membership", "avatar_url", "displayname"].forEach(function (prop) {
                    if (!event.content || !event.content[prop]) {
                        return;
                    }
                    event.content[prop] = intern(event.content[prop]);
                });
                ["rel_type"].forEach(function (prop) {
                    if (!event.content || !event.content["m.relates_to"] || !event.content["m.relates_to"][prop]) {
                        return;
                    }
                    event.content["m.relates_to"][prop] = intern(event.content["m.relates_to"][prop]);
                });
                this.event = event || {};
                this.sender = null;
                this.target = null;
                this.status = null;
                this.error = null;
                this.forwardLooking = true;
                this._pushActions = null;
                this._replacingEvent = null;
                this._localRedactionEvent = null;
                this._isCancelled = false;
                this._clearEvent = {};
                this._senderCurve25519Key = null;
                this._claimedEd25519Key = null;
                this._forwardingCurve25519KeyChain = [];
                this._untrusted = null;
                this._decryptionPromise = null;
                this._retryDecryption = false;
                this.verificationRequest = null;
                this._txnId = null;
                this._localTimestamp = Date.now() - this.getAge();
            };
            exports.MatrixEvent = MatrixEvent;
            utils.inherits(MatrixEvent, _events.EventEmitter);
            utils.extend(MatrixEvent.prototype, {
                getId: function getId() {
                    return this.event.event_id;
                },
                getSender: function getSender() {
                    return this.event.sender || this.event.user_id;
                },
                getType: function getType() {
                    return this._clearEvent.type || this.event.type;
                },
                getWireType: function getWireType() {
                    return this.event.type;
                },
                getRoomId: function getRoomId() {
                    return this.event.room_id;
                },
                getTs: function getTs() {
                    return this.event.origin_server_ts;
                },
                getDate: function getDate() {
                    return this.event.origin_server_ts ? new Date(this.event.origin_server_ts) : null;
                },
                getOriginalContent: function getOriginalContent() {
                    if (this._localRedactionEvent) {
                        return {};
                    }
                    return this._clearEvent.content || this.event.content || {};
                },
                getContent: function getContent() {
                    if (this._localRedactionEvent) {
                        return {};
                    }
                    else if (this._replacingEvent) {
                        return this._replacingEvent.getContent()["m.new_content"] || {};
                    }
                    else {
                        return this.getOriginalContent();
                    }
                },
                getWireContent: function getWireContent() {
                    return this.event.content || {};
                },
                getPrevContent: function getPrevContent() {
                    return this.getUnsigned().prev_content || this.event.prev_content || {};
                },
                getDirectionalContent: function getDirectionalContent() {
                    return this.forwardLooking ? this.getContent() : this.getPrevContent();
                },
                getAge: function getAge() {
                    return this.getUnsigned().age || this.event.age;
                },
                getLocalAge: function getLocalAge() {
                    return Date.now() - this._localTimestamp;
                },
                getStateKey: function getStateKey() {
                    return this.event.state_key;
                },
                isState: function isState() {
                    return this.event.state_key !== undefined;
                },
                makeEncrypted: function makeEncrypted(crypto_type, crypto_content, senderCurve25519Key, claimedEd25519Key) {
                    this._clearEvent = {
                        type: this.event.type,
                        content: this.event.content
                    };
                    this.event.type = crypto_type;
                    this.event.content = crypto_content;
                    this._senderCurve25519Key = senderCurve25519Key;
                    this._claimedEd25519Key = claimedEd25519Key;
                },
                isBeingDecrypted: function isBeingDecrypted() {
                    return this._decryptionPromise != null;
                },
                isDecryptionFailure: function isDecryptionFailure() {
                    return this._clearEvent && this._clearEvent.content && this._clearEvent.content.msgtype === "m.bad.encrypted";
                },
                attemptDecryption: function () {
                    var _attemptDecryption = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee(crypto, isRetry) {
                        return _regenerator["default"].wrap(function _callee$(_context) {
                            while (1) {
                                switch (_context.prev = _context.next) {
                                    case 0:
                                        if (this.isEncrypted()) {
                                            _context.next = 2;
                                            break;
                                        }
                                        throw new Error("Attempt to decrypt event which isn't encrypted");
                                    case 2:
                                        if (!(this._clearEvent && this._clearEvent.content && this._clearEvent.content.msgtype !== "m.bad.encrypted")) {
                                            _context.next = 4;
                                            break;
                                        }
                                        throw new Error("Attempt to decrypt event which has already been decrypted");
                                    case 4:
                                        if (!this._decryptionPromise) {
                                            _context.next = 8;
                                            break;
                                        }
                                        _logger.logger.log("Event ".concat(this.getId(), " already being decrypted; queueing a retry"));
                                        this._retryDecryption = true;
                                        return _context.abrupt("return", this._decryptionPromise);
                                    case 8:
                                        this._decryptionPromise = this._decryptionLoop(crypto, isRetry);
                                        return _context.abrupt("return", this._decryptionPromise);
                                    case 10:
                                    case "end":
                                        return _context.stop();
                                }
                            }
                        }, _callee, this);
                    }));
                    function attemptDecryption(_x, _x2) {
                        return _attemptDecryption.apply(this, arguments);
                    }
                    return attemptDecryption;
                }(),
                cancelAndResendKeyRequest: function cancelAndResendKeyRequest(crypto, userId) {
                    var wireContent = this.getWireContent();
                    return crypto.requestRoomKey({
                        algorithm: wireContent.algorithm,
                        room_id: this.getRoomId(),
                        session_id: wireContent.session_id,
                        sender_key: wireContent.sender_key
                    }, this.getKeyRequestRecipients(userId), true);
                },
                getKeyRequestRecipients: function getKeyRequestRecipients(userId) {
                    var wireContent = this.getWireContent();
                    var recipients = [{
                            userId: userId,
                            deviceId: '*'
                        }];
                    var sender = this.getSender();
                    if (sender !== userId) {
                        recipients.push({
                            userId: sender,
                            deviceId: wireContent.device_id
                        });
                    }
                    return recipients;
                },
                _decryptionLoop: function () {
                    var _decryptionLoop2 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee2(crypto, isRetry) {
                        var res, err, re;
                        return _regenerator["default"].wrap(function _callee2$(_context2) {
                            while (1) {
                                switch (_context2.prev = _context2.next) {
                                    case 0:
                                        _context2.next = 2;
                                        return Promise.resolve();
                                    case 2:
                                        if (!true) {
                                            _context2.next = 39;
                                            break;
                                        }
                                        this._retryDecryption = false;
                                        res = void 0;
                                        err = void 0;
                                        _context2.prev = 6;
                                        if (crypto) {
                                            _context2.next = 11;
                                            break;
                                        }
                                        res = this._badEncryptedMessage("Encryption not enabled");
                                        _context2.next = 15;
                                        break;
                                    case 11:
                                        _context2.next = 13;
                                        return crypto.decryptEvent(this);
                                    case 13:
                                        res = _context2.sent;
                                        if (isRetry) {
                                            _logger.logger.info("Decrypted event on retry (id=".concat(this.getId(), ")"));
                                        }
                                    case 15:
                                        _context2.next = 31;
                                        break;
                                    case 17:
                                        _context2.prev = 17;
                                        _context2.t0 = _context2["catch"](6);
                                        if (!(_context2.t0.name !== "DecryptionError")) {
                                            _context2.next = 25;
                                            break;
                                        }
                                        re = isRetry ? 're' : '';
                                        _logger.logger.error("Error ".concat(re, "decrypting event ") + "(id=".concat(this.getId(), "): ").concat(_context2.t0.stack || _context2.t0));
                                        this._decryptionPromise = null;
                                        this._retryDecryption = false;
                                        return _context2.abrupt("return");
                                    case 25:
                                        err = _context2.t0;
                                        if (!this._retryDecryption) {
                                            _context2.next = 29;
                                            break;
                                        }
                                        _logger.logger.log("Got error decrypting event (id=".concat(this.getId(), ": ") + "".concat(_context2.t0, "), but retrying"));
                                        return _context2.abrupt("continue", 2);
                                    case 29:
                                        _logger.logger.warn("Error decrypting event (id=".concat(this.getId(), "): ").concat(_context2.t0.detailedString));
                                        res = this._badEncryptedMessage(_context2.t0.message);
                                    case 31:
                                        this._decryptionPromise = null;
                                        this._retryDecryption = false;
                                        this._setClearData(res);
                                        this.setPushActions(null);
                                        this.emit("Event.decrypted", this, err);
                                        return _context2.abrupt("return");
                                    case 39:
                                    case "end":
                                        return _context2.stop();
                                }
                            }
                        }, _callee2, this, [[6, 17]]);
                    }));
                    function _decryptionLoop(_x3, _x4) {
                        return _decryptionLoop2.apply(this, arguments);
                    }
                    return _decryptionLoop;
                }(),
                _badEncryptedMessage: function _badEncryptedMessage(reason) {
                    return {
                        clearEvent: {
                            type: "m.room.message",
                            content: {
                                msgtype: "m.bad.encrypted",
                                body: "** Unable to decrypt: " + reason + " **"
                            }
                        }
                    };
                },
                _setClearData: function _setClearData(decryptionResult) {
                    this._clearEvent = decryptionResult.clearEvent;
                    this._senderCurve25519Key = decryptionResult.senderCurve25519Key || null;
                    this._claimedEd25519Key = decryptionResult.claimedEd25519Key || null;
                    this._forwardingCurve25519KeyChain = decryptionResult.forwardingCurve25519KeyChain || [];
                    this._untrusted = decryptionResult.untrusted || false;
                },
                getClearContent: function getClearContent() {
                    var ev = this._clearEvent;
                    return ev && ev.content ? ev.content : null;
                },
                isEncrypted: function isEncrypted() {
                    return !this.isState() && this.event.type === "m.room.encrypted";
                },
                getSenderKey: function getSenderKey() {
                    return this._senderCurve25519Key;
                },
                getKeysClaimed: function getKeysClaimed() {
                    return {
                        ed25519: this._claimedEd25519Key
                    };
                },
                getClaimedEd25519Key: function getClaimedEd25519Key() {
                    return this._claimedEd25519Key;
                },
                getForwardingCurve25519KeyChain: function getForwardingCurve25519KeyChain() {
                    return this._forwardingCurve25519KeyChain;
                },
                isKeySourceUntrusted: function isKeySourceUntrusted() {
                    return this._untrusted;
                },
                getUnsigned: function getUnsigned() {
                    return this.event.unsigned || {};
                },
                unmarkLocallyRedacted: function unmarkLocallyRedacted() {
                    var value = this._localRedactionEvent;
                    this._localRedactionEvent = null;
                    if (this.event.unsigned) {
                        this.event.unsigned.redacted_because = null;
                    }
                    return !!value;
                },
                markLocallyRedacted: function markLocallyRedacted(redactionEvent) {
                    if (this._localRedactionEvent) {
                        return;
                    }
                    this.emit("Event.beforeRedaction", this, redactionEvent);
                    this._localRedactionEvent = redactionEvent;
                    if (!this.event.unsigned) {
                        this.event.unsigned = {};
                    }
                    this.event.unsigned.redacted_because = redactionEvent.event;
                },
                makeRedacted: function makeRedacted(redaction_event) {
                    if (!redaction_event.event) {
                        throw new Error("invalid redaction_event in makeRedacted");
                    }
                    this._localRedactionEvent = null;
                    this.emit("Event.beforeRedaction", this, redaction_event);
                    this._replacingEvent = null;
                    if (!this.event.unsigned) {
                        this.event.unsigned = {};
                    }
                    this.event.unsigned.redacted_because = redaction_event.event;
                    var key;
                    for (key in this.event) {
                        if (!this.event.hasOwnProperty(key)) {
                            continue;
                        }
                        if (!_REDACT_KEEP_KEY_MAP[key]) {
                            delete this.event[key];
                        }
                    }
                    var keeps = _REDACT_KEEP_CONTENT_MAP[this.getType()] || {};
                    var content = this.getContent();
                    for (key in content) {
                        if (!content.hasOwnProperty(key)) {
                            continue;
                        }
                        if (!keeps[key]) {
                            delete content[key];
                        }
                    }
                },
                isRedacted: function isRedacted() {
                    return Boolean(this.getUnsigned().redacted_because);
                },
                isRedaction: function isRedaction() {
                    return this.getType() === "m.room.redaction";
                },
                getRedactionEvent: function getRedactionEvent() {
                    if (!this.isRedacted())
                        return null;
                    if (this._clearEvent.unsigned) {
                        return this._clearEvent.unsigned.redacted_because;
                    }
                    else if (this.event.unsigned.redacted_because) {
                        return this.event.unsigned.redacted_because;
                    }
                    else {
                        return {};
                    }
                },
                getPushActions: function getPushActions() {
                    return this._pushActions;
                },
                setPushActions: function setPushActions(pushActions) {
                    this._pushActions = pushActions;
                },
                handleRemoteEcho: function handleRemoteEcho(event) {
                    var oldUnsigned = this.getUnsigned();
                    var oldId = this.getId();
                    this.event = event;
                    if (oldUnsigned.redacted_because) {
                        if (!this.event.unsigned) {
                            this.event.unsigned = {};
                        }
                        this.event.unsigned.redacted_because = oldUnsigned.redacted_because;
                    }
                    this.setStatus(null);
                    if (this.getId() !== oldId) {
                        this.emit("Event.localEventIdReplaced", this);
                    }
                },
                isSending: function isSending() {
                    return !!this.status;
                },
                setStatus: function setStatus(status) {
                    this.status = status;
                    this.emit("Event.status", this, status);
                },
                replaceLocalEventId: function replaceLocalEventId(eventId) {
                    this.event.event_id = eventId;
                    this.emit("Event.localEventIdReplaced", this);
                },
                isRelation: function isRelation() {
                    var relType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
                    var content = this.getWireContent();
                    var relation = content && content["m.relates_to"];
                    return relation && relation.rel_type && relation.event_id && (relType && relation.rel_type === relType || !relType);
                },
                getRelation: function getRelation() {
                    if (!this.isRelation()) {
                        return null;
                    }
                    return this.getWireContent()["m.relates_to"];
                },
                makeReplaced: function makeReplaced(newEvent) {
                    if (this.isRedacted() && newEvent) {
                        return;
                    }
                    if (this._replacingEvent !== newEvent) {
                        this._replacingEvent = newEvent;
                        this.emit("Event.replaced", this);
                    }
                },
                getAssociatedStatus: function getAssociatedStatus() {
                    if (this._replacingEvent) {
                        return this._replacingEvent.status;
                    }
                    else if (this._localRedactionEvent) {
                        return this._localRedactionEvent.status;
                    }
                    return this.status;
                },
                getServerAggregatedRelation: function getServerAggregatedRelation(relType) {
                    var relations = this.getUnsigned()["m.relations"];
                    if (relations) {
                        return relations[relType];
                    }
                },
                replacingEventId: function replacingEventId() {
                    var replaceRelation = this.getServerAggregatedRelation("m.replace");
                    if (replaceRelation) {
                        return replaceRelation.event_id;
                    }
                    else if (this._replacingEvent) {
                        return this._replacingEvent.getId();
                    }
                },
                replacingEvent: function replacingEvent() {
                    return this._replacingEvent;
                },
                replacingEventDate: function replacingEventDate() {
                    var replaceRelation = this.getServerAggregatedRelation("m.replace");
                    if (replaceRelation) {
                        var ts = replaceRelation.origin_server_ts;
                        if (Number.isFinite(ts)) {
                            return new Date(ts);
                        }
                    }
                    else if (this._replacingEvent) {
                        return this._replacingEvent.getDate();
                    }
                },
                localRedactionEvent: function localRedactionEvent() {
                    return this._localRedactionEvent;
                },
                getAssociatedId: function getAssociatedId() {
                    var relation = this.getRelation();
                    if (relation) {
                        return relation.event_id;
                    }
                    else if (this.isRedaction()) {
                        return this.event.redacts;
                    }
                },
                hasAssocation: function hasAssocation() {
                    return !!this.getAssociatedId();
                },
                updateAssociatedId: function updateAssociatedId(eventId) {
                    var relation = this.getRelation();
                    if (relation) {
                        relation.event_id = eventId;
                    }
                    else if (this.isRedaction()) {
                        this.event.redacts = eventId;
                    }
                },
                flagCancelled: function flagCancelled() {
                    var cancelled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
                    this._isCancelled = cancelled;
                },
                isCancelled: function isCancelled() {
                    return this._isCancelled;
                },
                toJSON: function toJSON() {
                    var event = {
                        type: this.getType(),
                        sender: this.getSender(),
                        content: this.getContent(),
                        event_id: this.getId(),
                        origin_server_ts: this.getTs(),
                        unsigned: this.getUnsigned(),
                        room_id: this.getRoomId()
                    };
                    if (this.isRedaction()) {
                        event.redacts = this.event.redacts;
                    }
                    if (!this.isEncrypted()) {
                        return event;
                    }
                    return {
                        decrypted: event,
                        encrypted: this.event
                    };
                },
                setVerificationRequest: function setVerificationRequest(request) {
                    this.verificationRequest = request;
                },
                setTxnId: function setTxnId(txnId) {
                    this._txnId = txnId;
                },
                getTxnId: function getTxnId() {
                    return this._txnId;
                }
            });
            var _REDACT_KEEP_KEY_MAP = ['event_id', 'type', 'room_id', 'user_id', 'sender', 'state_key', 'prev_state', 'content', 'unsigned', 'origin_server_ts'].reduce(function (ret, val) {
                ret[val] = 1;
                return ret;
            }, {});
            var _REDACT_KEEP_CONTENT_MAP = {
                'm.room.member': {
                    'membership': 1
                },
                'm.room.create': {
                    'creator': 1
                },
                'm.room.join_rules': {
                    'join_rule': 1
                },
                'm.room.power_levels': {
                    'ban': 1,
                    'events': 1,
                    'events_default': 1,
                    'kick': 1,
                    'redact': 1,
                    'state_default': 1,
                    'users': 1,
                    'users_default': 1
                },
                'm.room.aliases': {
                    'aliases': 1
                }
            };
        }, { "../logger": 97, "../utils": 125, "@babel/runtime/helpers/asyncToGenerator": 5, "@babel/runtime/helpers/interopRequireDefault": 12, "@babel/runtime/helpers/interopRequireWildcard": 13, "@babel/runtime/regenerator": 27, "events": 36 }], 103: [function (require, module, exports) {
            "use strict";
            var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.Group = Group;
            var utils = _interopRequireWildcard(require("../utils"));
            var _events = require("events");
            function Group(groupId) {
                this.groupId = groupId;
                this.name = null;
                this.avatarUrl = null;
                this.myMembership = null;
                this.inviter = null;
            }
            utils.inherits(Group, _events.EventEmitter);
            Group.prototype.setProfile = function (name, avatarUrl) {
                if (this.name === name && this.avatarUrl === avatarUrl)
                    return;
                this.name = name || this.groupId;
                this.avatarUrl = avatarUrl;
                this.emit("Group.profile", this);
            };
            Group.prototype.setMyMembership = function (membership) {
                if (this.myMembership === membership)
                    return;
                this.myMembership = membership;
                this.emit("Group.myMembership", this);
            };
            Group.prototype.setInviter = function (inviter) {
                this.inviter = inviter;
            };
        }, { "../utils": 125, "@babel/runtime/helpers/interopRequireWildcard": 13, "events": 36 }], 104: [function (require, module, exports) {
            "use strict";
            var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.Relations = void 0;
            var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
            var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
            var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
            var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
            var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
            var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
            var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
            var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
            var _events = require("events");
            var _event = require("../models/event");
            var _logger = require("../logger");
            function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) {
                var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor;
                result = Reflect.construct(Super, arguments, NewTarget);
            }
            else {
                result = Super.apply(this, arguments);
            } return (0, _possibleConstructorReturn2["default"])(this, result); }; }
            function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct)
                return false; if (Reflect.construct.sham)
                return false; if (typeof Proxy === "function")
                return true; try {
                Date.prototype.toString.call(Reflect.construct(Date, [], function () { }));
                return true;
            }
            catch (e) {
                return false;
            } }
            var Relations = function (_EventEmitter) {
                (0, _inherits2["default"])(Relations, _EventEmitter);
                var _super = _createSuper(Relations);
                function Relations(relationType, eventType, room) {
                    var _this;
                    (0, _classCallCheck2["default"])(this, Relations);
                    _this = _super.call(this);
                    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_onEventStatus", function (event, status) {
                        if (!event.isSending()) {
                            event.removeListener("Event.status", _this._onEventStatus);
                            return;
                        }
                        if (status !== _event.EventStatus.CANCELLED) {
                            return;
                        }
                        event.removeListener("Event.status", _this._onEventStatus);
                        _this._removeEvent(event);
                    });
                    (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_onBeforeRedaction", function (redactedEvent) {
                        if (!_this._relations.has(redactedEvent)) {
                            return;
                        }
                        _this._relations["delete"](redactedEvent);
                        if (_this.relationType === "m.annotation") {
                            _this._removeAnnotationFromAggregation(redactedEvent);
                        }
                        else if (_this.relationType === "m.replace" && _this._targetEvent) {
                            _this._targetEvent.makeReplaced(_this.getLastReplacement());
                        }
                        redactedEvent.removeListener("Event.beforeRedaction", _this._onBeforeRedaction);
                        _this.emit("Relations.redaction", redactedEvent);
                    });
                    _this.relationType = relationType;
                    _this.eventType = eventType;
                    _this._relations = new Set();
                    _this._annotationsByKey = {};
                    _this._annotationsBySender = {};
                    _this._sortedAnnotationsByKey = [];
                    _this._targetEvent = null;
                    return _this;
                }
                (0, _createClass2["default"])(Relations, [{
                        key: "addEvent",
                        value: function addEvent(event) {
                            if (this._relations.has(event)) {
                                return;
                            }
                            var relation = event.getRelation();
                            if (!relation) {
                                _logger.logger.error("Event must have relation info");
                                return;
                            }
                            var relationType = relation.rel_type;
                            var eventType = event.getType();
                            if (this.relationType !== relationType || this.eventType !== eventType) {
                                _logger.logger.error("Event relation info doesn't match this container");
                                return;
                            }
                            if (event.isSending()) {
                                event.on("Event.status", this._onEventStatus);
                            }
                            this._relations.add(event);
                            if (this.relationType === "m.annotation") {
                                this._addAnnotationToAggregation(event);
                            }
                            else if (this.relationType === "m.replace" && this._targetEvent) {
                                this._targetEvent.makeReplaced(this.getLastReplacement());
                            }
                            event.on("Event.beforeRedaction", this._onBeforeRedaction);
                            this.emit("Relations.add", event);
                        }
                    }, {
                        key: "_removeEvent",
                        value: function _removeEvent(event) {
                            if (!this._relations.has(event)) {
                                return;
                            }
                            var relation = event.getRelation();
                            if (!relation) {
                                _logger.logger.error("Event must have relation info");
                                return;
                            }
                            var relationType = relation.rel_type;
                            var eventType = event.getType();
                            if (this.relationType !== relationType || this.eventType !== eventType) {
                                _logger.logger.error("Event relation info doesn't match this container");
                                return;
                            }
                            this._relations["delete"](event);
                            if (this.relationType === "m.annotation") {
                                this._removeAnnotationFromAggregation(event);
                            }
                            else if (this.relationType === "m.replace" && this._targetEvent) {
                                this._targetEvent.makeReplaced(this.getLastReplacement());
                            }
                            this.emit("Relations.remove", event);
                        }
                    }, {
                        key: "getRelations",
                        value: function getRelations() {
                            return (0, _toConsumableArray2["default"])(this._relations);
                        }
                    }, {
                        key: "_addAnnotationToAggregation",
                        value: function _addAnnotationToAggregation(event) {
                            var _event$getRelation = event.getRelation(), key = _event$getRelation.key;
                            if (!key) {
                                return;
                            }
                            var eventsForKey = this._annotationsByKey[key];
                            if (!eventsForKey) {
                                eventsForKey = this._annotationsByKey[key] = new Set();
                                this._sortedAnnotationsByKey.push([key, eventsForKey]);
                            }
                            eventsForKey.add(event);
                            this._sortedAnnotationsByKey.sort(function (a, b) {
                                var aEvents = a[1];
                                var bEvents = b[1];
                                return bEvents.size - aEvents.size;
                            });
                            var sender = event.getSender();
                            var eventsFromSender = this._annotationsBySender[sender];
                            if (!eventsFromSender) {
                                eventsFromSender = this._annotationsBySender[sender] = new Set();
                            }
                            eventsFromSender.add(event);
                        }
                    }, {
                        key: "_removeAnnotationFromAggregation",
                        value: function _removeAnnotationFromAggregation(event) {
                            var _event$getRelation2 = event.getRelation(), key = _event$getRelation2.key;
                            if (!key) {
                                return;
                            }
                            var eventsForKey = this._annotationsByKey[key];
                            if (eventsForKey) {
                                eventsForKey["delete"](event);
                                this._sortedAnnotationsByKey.sort(function (a, b) {
                                    var aEvents = a[1];
                                    var bEvents = b[1];
                                    return bEvents.size - aEvents.size;
                                });
                            }
                            var sender = event.getSender();
                            var eventsFromSender = this._annotationsBySender[sender];
                            if (eventsFromSender) {
                                eventsFromSender["delete"](event);
                            }
                        }
                    }, {
                        key: "getSortedAnnotationsByKey",
                        value: function getSortedAnnotationsByKey() {
                            if (this.relationType !== "m.annotation") {
                                return null;
                            }
                            return this._sortedAnnotationsByKey;
                        }
                    }, {
                        key: "getAnnotationsBySender",
                        value: function getAnnotationsBySender() {
                            if (this.relationType !== "m.annotation") {
                                return null;
                            }
                            return this._annotationsBySender;
                        }
                    }, {
                        key: "getLastReplacement",
                        value: function getLastReplacement() {
                            var _this2 = this;
                            if (this.relationType !== "m.replace") {
                                return null;
                            }
                            if (!this._targetEvent) {
                                return null;
                            }
                            var replaceRelation = this._targetEvent.getServerAggregatedRelation("m.replace");
                            var minTs = replaceRelation && replaceRelation.origin_server_ts;
                            return this.getRelations().reduce(function (last, event) {
                                if (event.getSender() !== _this2._targetEvent.getSender()) {
                                    return last;
                                }
                                if (minTs && minTs > event.getTs()) {
                                    return last;
                                }
                                if (last && last.getTs() > event.getTs()) {
                                    return last;
                                }
                                return event;
                            }, null);
                        }
                    }, {
                        key: "setTargetEvent",
                        value: function setTargetEvent(event) {
                            if (this._targetEvent) {
                                return;
                            }
                            this._targetEvent = event;
                            if (this.relationType === "m.replace") {
                                var replacement = this.getLastReplacement();
                                if (replacement) {
                                    this._targetEvent.makeReplaced(replacement);
                                }
                            }
                        }
                    }]);
                return Relations;
            }(_events.EventEmitter);
            exports.Relations = Relations;
        }, { "../logger": 97, "../models/event": 102, "@babel/runtime/helpers/assertThisInitialized": 4, "@babel/runtime/helpers/classCallCheck": 6, "@babel/runtime/helpers/createClass": 8, "@babel/runtime/helpers/defineProperty": 9, "@babel/runtime/helpers/getPrototypeOf": 10, "@babel/runtime/helpers/inherits": 11, "@babel/runtime/helpers/interopRequireDefault": 12, "@babel/runtime/helpers/possibleConstructorReturn": 20, "@babel/runtime/helpers/toConsumableArray": 23, "events": 36 }], 105: [function (require, module, exports) {
            "use strict";
            var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.RoomMember = RoomMember;
            var _events = require("events");
            var _contentRepo = require("../content-repo");
            var utils = _interopRequireWildcard(require("../utils"));
            function RoomMember(roomId, userId) {
                this.roomId = roomId;
                this.userId = userId;
                this.typing = false;
                this.name = userId;
                this.rawDisplayName = userId;
                this.powerLevel = 0;
                this.powerLevelNorm = 0;
                this.user = null;
                this.membership = null;
                this.events = {
                    member: null
                };
                this._isOutOfBand = false;
                this._updateModifiedTime();
            }
            utils.inherits(RoomMember, _events.EventEmitter);
            RoomMember.prototype.markOutOfBand = function () {
                this._isOutOfBand = true;
            };
            RoomMember.prototype.isOutOfBand = function () {
                return this._isOutOfBand;
            };
            RoomMember.prototype.setMembershipEvent = function (event, roomState) {
                if (event.getType() !== "m.room.member") {
                    return;
                }
                this._isOutOfBand = false;
                this.events.member = event;
                var oldMembership = this.membership;
                this.membership = event.getDirectionalContent().membership;
                var oldName = this.name;
                this.name = calculateDisplayName(this.userId, event.getDirectionalContent().displayname, roomState);
                this.rawDisplayName = event.getDirectionalContent().displayname || this.userId;
                if (oldMembership !== this.membership) {
                    this._updateModifiedTime();
                    this.emit("RoomMember.membership", event, this, oldMembership);
                }
                if (oldName !== this.name) {
                    this._updateModifiedTime();
                    this.emit("RoomMember.name", event, this, oldName);
                }
            };
            RoomMember.prototype.setPowerLevelEvent = function (powerLevelEvent) {
                if (powerLevelEvent.getType() !== "m.room.power_levels") {
                    return;
                }
                var evContent = powerLevelEvent.getDirectionalContent();
                var maxLevel = evContent.users_default || 0;
                utils.forEach(utils.values(evContent.users), function (lvl) {
                    maxLevel = Math.max(maxLevel, lvl);
                });
                var oldPowerLevel = this.powerLevel;
                var oldPowerLevelNorm = this.powerLevelNorm;
                if (evContent.users && evContent.users[this.userId] !== undefined) {
                    this.powerLevel = evContent.users[this.userId];
                }
                else if (evContent.users_default !== undefined) {
                    this.powerLevel = evContent.users_default;
                }
                else {
                    this.powerLevel = 0;
                }
                this.powerLevelNorm = 0;
                if (maxLevel > 0) {
                    this.powerLevelNorm = this.powerLevel * 100 / maxLevel;
                }
                if (oldPowerLevel !== this.powerLevel || oldPowerLevelNorm !== this.powerLevelNorm) {
                    this._updateModifiedTime();
                    this.emit("RoomMember.powerLevel", powerLevelEvent, this);
                }
            };
            RoomMember.prototype.setTypingEvent = function (event) {
                if (event.getType() !== "m.typing") {
                    return;
                }
                var oldTyping = this.typing;
                this.typing = false;
                var typingList = event.getContent().user_ids;
                if (!utils.isArray(typingList)) {
                    return;
                }
                if (typingList.indexOf(this.userId) !== -1) {
                    this.typing = true;
                }
                if (oldTyping !== this.typing) {
                    this._updateModifiedTime();
                    this.emit("RoomMember.typing", event, this);
                }
            };
            RoomMember.prototype._updateModifiedTime = function () {
                this._modified = Date.now();
            };
            RoomMember.prototype.getLastModifiedTime = function () {
                return this._modified;
            };
            RoomMember.prototype.isKicked = function () {
                return this.membership === "leave" && this.events.member.getSender() !== this.events.member.getStateKey();
            };
            RoomMember.prototype.getDMInviter = function () {
                if (this.events.member) {
                    var memberEvent = this.events.member;
                    var memberContent = memberEvent.getContent();
                    var inviteSender = memberEvent.getSender();
                    if (memberContent.membership === "join") {
                        memberContent = memberEvent.getPrevContent();
                        inviteSender = memberEvent.getUnsigned().prev_sender;
                    }
                    if (memberContent.membership === "invite" && memberContent.is_direct) {
                        return inviteSender;
                    }
                }
            };
            RoomMember.prototype.getAvatarUrl = function (baseUrl, width, height, resizeMethod, allowDefault, allowDirectLinks) {
                if (allowDefault === undefined) {
                    allowDefault = true;
                }
                var rawUrl = this.getMxcAvatarUrl();
                if (!rawUrl && !allowDefault) {
                    return null;
                }
                var httpUrl = (0, _contentRepo.getHttpUriForMxc)(baseUrl, rawUrl, width, height, resizeMethod, allowDirectLinks);
                if (httpUrl) {
                    return httpUrl;
                }
                return null;
            };
            RoomMember.prototype.getMxcAvatarUrl = function () {
                if (this.events.member) {
                    return this.events.member.getDirectionalContent().avatar_url;
                }
                else if (this.user) {
                    return this.user.avatarUrl;
                }
                return null;
            };
            var MXID_PATTERN = /@.+:.+/;
            var LTR_RTL_PATTERN = /[\u200E\u200F\u202A-\u202F]/;
            function calculateDisplayName(selfUserId, displayName, roomState) {
                if (!displayName || displayName === selfUserId) {
                    return selfUserId;
                }
                if (!utils.removeHiddenChars(displayName)) {
                    return selfUserId;
                }
                if (!roomState) {
                    return displayName;
                }
                var disambiguate = MXID_PATTERN.test(displayName);
                if (!disambiguate) {
                    disambiguate = LTR_RTL_PATTERN.test(displayName);
                }
                if (!disambiguate) {
                    var userIds = roomState.getUserIdsWithDisplayName(displayName);
                    disambiguate = userIds.some(function (u) {
                        return u !== selfUserId;
                    });
                }
                if (disambiguate) {
                    return displayName + " (" + selfUserId + ")";
                }
                return displayName;
            }
        }, { "../content-repo": 60, "../utils": 125, "@babel/runtime/helpers/interopRequireWildcard": 13, "events": 36 }], 106: [function (require, module, exports) {
            "use strict";
            var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.RoomState = RoomState;
            var _events = require("events");
            var _roomMember = require("./room-member");
            var _logger = require("../logger");
            var utils = _interopRequireWildcard(require("../utils"));
            var _event = require("../@types/event");
            var OOB_STATUS_NOTSTARTED = 1;
            var OOB_STATUS_INPROGRESS = 2;
            var OOB_STATUS_FINISHED = 3;
            function RoomState(roomId) {
                var oobMemberFlags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
                this.roomId = roomId;
                this.members = {};
                this.events = new Map();
                this.paginationToken = null;
                this._sentinels = {};
                this._updateModifiedTime();
                this._displayNameToUserIds = {};
                this._userIdsToDisplayNames = {};
                this._tokenToInvite = {};
                this._joinedMemberCount = null;
                this._summaryJoinedMemberCount = null;
                this._invitedMemberCount = null;
                this._summaryInvitedMemberCount = null;
                if (!oobMemberFlags) {
                    oobMemberFlags = {
                        status: OOB_STATUS_NOTSTARTED
                    };
                }
                this._oobMemberFlags = oobMemberFlags;
            }
            utils.inherits(RoomState, _events.EventEmitter);
            RoomState.prototype.getJoinedMemberCount = function () {
                if (this._summaryJoinedMemberCount !== null) {
                    return this._summaryJoinedMemberCount;
                }
                if (this._joinedMemberCount === null) {
                    this._joinedMemberCount = this.getMembers().reduce(function (count, m) {
                        return m.membership === 'join' ? count + 1 : count;
                    }, 0);
                }
                return this._joinedMemberCount;
            };
            RoomState.prototype.setJoinedMemberCount = function (count) {
                this._summaryJoinedMemberCount = count;
            };
            RoomState.prototype.getInvitedMemberCount = function () {
                if (this._summaryInvitedMemberCount !== null) {
                    return this._summaryInvitedMemberCount;
                }
                if (this._invitedMemberCount === null) {
                    this._invitedMemberCount = this.getMembers().reduce(function (count, m) {
                        return m.membership === 'invite' ? count + 1 : count;
                    }, 0);
                }
                return this._invitedMemberCount;
            };
            RoomState.prototype.setInvitedMemberCount = function (count) {
                this._summaryInvitedMemberCount = count;
            };
            RoomState.prototype.getMembers = function () {
                return utils.values(this.members);
            };
            RoomState.prototype.getMembersExcept = function (excludedIds) {
                return utils.values(this.members).filter(function (m) {
                    return !excludedIds.includes(m.userId);
                });
            };
            RoomState.prototype.getMember = function (userId) {
                return this.members[userId] || null;
            };
            RoomState.prototype.getSentinelMember = function (userId) {
                if (!userId)
                    return null;
                var sentinel = this._sentinels[userId];
                if (sentinel === undefined) {
                    sentinel = new _roomMember.RoomMember(this.roomId, userId);
                    var member = this.members[userId];
                    if (member) {
                        sentinel.setMembershipEvent(member.events.member, this);
                    }
                    this._sentinels[userId] = sentinel;
                }
                return sentinel;
            };
            RoomState.prototype.getStateEvents = function (eventType, stateKey) {
                if (!this.events.has(eventType)) {
                    return stateKey === undefined ? [] : null;
                }
                if (stateKey === undefined) {
                    return Array.from(this.events.get(eventType).values());
                }
                var event = this.events.get(eventType).get(stateKey);
                return event ? event : null;
            };
            RoomState.prototype.clone = function () {
                var copy = new RoomState(this.roomId, this._oobMemberFlags);
                var status = this._oobMemberFlags.status;
                this._oobMemberFlags.status = OOB_STATUS_NOTSTARTED;
                Array.from(this.events.values()).forEach(function (eventsByStateKey) {
                    copy.setStateEvents(Array.from(eventsByStateKey.values()));
                });
                this._oobMemberFlags.status = status;
                if (this._summaryInvitedMemberCount !== null) {
                    copy.setInvitedMemberCount(this.getInvitedMemberCount());
                }
                if (this._summaryJoinedMemberCount !== null) {
                    copy.setJoinedMemberCount(this.getJoinedMemberCount());
                }
                if (this._oobMemberFlags.status == OOB_STATUS_FINISHED) {
                    this.getMembers().forEach(function (member) {
                        if (member.isOutOfBand()) {
                            var copyMember = copy.getMember(member.userId);
                            copyMember.markOutOfBand();
                        }
                    });
                }
                return copy;
            };
            RoomState.prototype.setUnknownStateEvents = function (events) {
                var _this = this;
                var unknownStateEvents = events.filter(function (event) {
                    return !_this.events.has(event.getType()) || !_this.events.get(event.getType()).has(event.getStateKey());
                });
                this.setStateEvents(unknownStateEvents);
            };
            RoomState.prototype.setStateEvents = function (stateEvents) {
                var self = this;
                this._updateModifiedTime();
                utils.forEach(stateEvents, function (event) {
                    if (event.getRoomId() !== self.roomId) {
                        return;
                    }
                    if (!event.isState()) {
                        return;
                    }
                    var lastStateEvent = self._getStateEventMatching(event);
                    self._setStateEvent(event);
                    if (event.getType() === "m.room.member") {
                        _updateDisplayNameCache(self, event.getStateKey(), event.getContent().displayname);
                        _updateThirdPartyTokenCache(self, event);
                    }
                    self.emit("RoomState.events", event, self, lastStateEvent);
                });
                utils.forEach(stateEvents, function (event) {
                    if (event.getRoomId() !== self.roomId) {
                        return;
                    }
                    if (!event.isState()) {
                        return;
                    }
                    if (event.getType() === "m.room.member") {
                        var userId = event.getStateKey();
                        if (event.getContent().membership === "leave" || event.getContent().membership === "ban") {
                            event.getContent().avatar_url = event.getContent().avatar_url || event.getPrevContent().avatar_url;
                            event.getContent().displayname = event.getContent().displayname || event.getPrevContent().displayname;
                        }
                        var member = self._getOrCreateMember(userId, event);
                        member.setMembershipEvent(event, self);
                        self._updateMember(member);
                        self.emit("RoomState.members", event, self, member);
                    }
                    else if (event.getType() === "m.room.power_levels") {
                        var members = utils.values(self.members);
                        utils.forEach(members, function (member) {
                            member.setPowerLevelEvent(event);
                            self.emit("RoomState.members", event, self, member);
                        });
                        self._sentinels = {};
                    }
                });
            };
            RoomState.prototype._getOrCreateMember = function (userId, event) {
                var member = this.members[userId];
                if (!member) {
                    member = new _roomMember.RoomMember(this.roomId, userId);
                    this.members[userId] = member;
                    this.emit("RoomState.newMember", event, this, member);
                }
                return member;
            };
            RoomState.prototype._setStateEvent = function (event) {
                if (!this.events.has(event.getType())) {
                    this.events.set(event.getType(), new Map());
                }
                this.events.get(event.getType()).set(event.getStateKey(), event);
            };
            RoomState.prototype._getStateEventMatching = function (event) {
                if (!this.events.has(event.getType()))
                    return null;
                return this.events.get(event.getType()).get(event.getStateKey());
            };
            RoomState.prototype._updateMember = function (member) {
                var pwrLvlEvent = this.getStateEvents("m.room.power_levels", "");
                if (pwrLvlEvent) {
                    member.setPowerLevelEvent(pwrLvlEvent);
                }
                delete this._sentinels[member.userId];
                this.members[member.userId] = member;
                this._joinedMemberCount = null;
                this._invitedMemberCount = null;
            };
            RoomState.prototype.needsOutOfBandMembers = function () {
                return this._oobMemberFlags.status === OOB_STATUS_NOTSTARTED;
            };
            RoomState.prototype.markOutOfBandMembersStarted = function () {
                if (this._oobMemberFlags.status !== OOB_STATUS_NOTSTARTED) {
                    return;
                }
                this._oobMemberFlags.status = OOB_STATUS_INPROGRESS;
            };
            RoomState.prototype.markOutOfBandMembersFailed = function () {
                if (this._oobMemberFlags.status !== OOB_STATUS_INPROGRESS) {
                    return;
                }
                this._oobMemberFlags.status = OOB_STATUS_NOTSTARTED;
            };
            RoomState.prototype.clearOutOfBandMembers = function () {
                var _this2 = this;
                var count = 0;
                Object.keys(this.members).forEach(function (userId) {
                    var member = _this2.members[userId];
                    if (member.isOutOfBand()) {
                        ++count;
                        delete _this2.members[userId];
                    }
                });
                _logger.logger.log("LL: RoomState removed ".concat(count, " members..."));
                this._oobMemberFlags.status = OOB_STATUS_NOTSTARTED;
            };
            RoomState.prototype.setOutOfBandMembers = function (stateEvents) {
                var _this3 = this;
                _logger.logger.log("LL: RoomState about to set ".concat(stateEvents.length, " OOB members ..."));
                if (this._oobMemberFlags.status !== OOB_STATUS_INPROGRESS) {
                    return;
                }
                _logger.logger.log("LL: RoomState put in OOB_STATUS_FINISHED state ...");
                this._oobMemberFlags.status = OOB_STATUS_FINISHED;
                stateEvents.forEach(function (e) {
                    return _this3._setOutOfBandMember(e);
                });
            };
            RoomState.prototype._setOutOfBandMember = function (stateEvent) {
                if (stateEvent.getType() !== 'm.room.member') {
                    return;
                }
                var userId = stateEvent.getStateKey();
                var existingMember = this.getMember(userId);
                if (existingMember && !existingMember.isOutOfBand()) {
                    return;
                }
                var member = this._getOrCreateMember(userId, stateEvent);
                member.setMembershipEvent(stateEvent, this);
                member.markOutOfBand();
                _updateDisplayNameCache(this, member.userId, member.name);
                this._setStateEvent(stateEvent);
                this._updateMember(member);
                this.emit("RoomState.members", stateEvent, this, member);
            };
            RoomState.prototype.setTypingEvent = function (event) {
                utils.forEach(utils.values(this.members), function (member) {
                    member.setTypingEvent(event);
                });
            };
            RoomState.prototype.getInviteForThreePidToken = function (token) {
                return this._tokenToInvite[token] || null;
            };
            RoomState.prototype._updateModifiedTime = function () {
                this._modified = Date.now();
            };
            RoomState.prototype.getLastModifiedTime = function () {
                return this._modified;
            };
            RoomState.prototype.getUserIdsWithDisplayName = function (displayName) {
                return this._displayNameToUserIds[utils.removeHiddenChars(displayName)] || [];
            };
            RoomState.prototype.maySendRedactionForEvent = function (mxEvent, userId) {
                var member = this.getMember(userId);
                if (!member || member.membership === 'leave')
                    return false;
                if (mxEvent.status || mxEvent.isRedacted())
                    return false;
                var canRedact = this.maySendEvent("m.room.redaction", userId);
                if (mxEvent.getSender() === userId)
                    return canRedact;
                return this._hasSufficientPowerLevelFor('redact', member.powerLevel);
            };
            RoomState.prototype._hasSufficientPowerLevelFor = function (action, powerLevel) {
                var powerLevelsEvent = this.getStateEvents('m.room.power_levels', '');
                var powerLevels = {};
                if (powerLevelsEvent) {
                    powerLevels = powerLevelsEvent.getContent();
                }
                var requiredLevel = 50;
                if (utils.isNumber(powerLevels[action])) {
                    requiredLevel = powerLevels[action];
                }
                return powerLevel >= requiredLevel;
            };
            RoomState.prototype.maySendMessage = function (userId) {
                return this._maySendEventOfType('m.room.message', userId, false);
            };
            RoomState.prototype.maySendEvent = function (eventType, userId) {
                return this._maySendEventOfType(eventType, userId, false);
            };
            RoomState.prototype.mayClientSendStateEvent = function (stateEventType, cli) {
                if (cli.isGuest()) {
                    return false;
                }
                return this.maySendStateEvent(stateEventType, cli.credentials.userId);
            };
            RoomState.prototype.maySendStateEvent = function (stateEventType, userId) {
                return this._maySendEventOfType(stateEventType, userId, true);
            };
            RoomState.prototype._maySendEventOfType = function (eventType, userId, state) {
                var power_levels_event = this.getStateEvents('m.room.power_levels', '');
                var power_levels;
                var events_levels = {};
                var state_default = 0;
                var events_default = 0;
                var powerLevel = 0;
                if (power_levels_event) {
                    power_levels = power_levels_event.getContent();
                    events_levels = power_levels.events || {};
                    if (Number.isFinite(power_levels.state_default)) {
                        state_default = power_levels.state_default;
                    }
                    else {
                        state_default = 50;
                    }
                    var userPowerLevel = power_levels.users && power_levels.users[userId];
                    if (Number.isFinite(userPowerLevel)) {
                        powerLevel = userPowerLevel;
                    }
                    else if (Number.isFinite(power_levels.users_default)) {
                        powerLevel = power_levels.users_default;
                    }
                    if (Number.isFinite(power_levels.events_default)) {
                        events_default = power_levels.events_default;
                    }
                }
                var required_level = state ? state_default : events_default;
                if (Number.isFinite(events_levels[eventType])) {
                    required_level = events_levels[eventType];
                }
                return powerLevel >= required_level;
            };
            RoomState.prototype.mayTriggerNotifOfType = function (notifLevelKey, userId) {
                var member = this.getMember(userId);
                if (!member) {
                    return false;
                }
                var powerLevelsEvent = this.getStateEvents('m.room.power_levels', '');
                var notifLevel = 50;
                if (powerLevelsEvent && powerLevelsEvent.getContent() && powerLevelsEvent.getContent().notifications && utils.isNumber(powerLevelsEvent.getContent().notifications[notifLevelKey])) {
                    notifLevel = powerLevelsEvent.getContent().notifications[notifLevelKey];
                }
                return member.powerLevel >= notifLevel;
            };
            RoomState.prototype.getJoinRule = function () {
                var joinRuleEvent = this.getStateEvents(_event.EventType.RoomJoinRules, "");
                var joinRuleContent = joinRuleEvent ? joinRuleEvent.getContent() : {};
                return joinRuleContent["join_rule"] || "invite";
            };
            function _updateThirdPartyTokenCache(roomState, memberEvent) {
                if (!memberEvent.getContent().third_party_invite) {
                    return;
                }
                var token = (memberEvent.getContent().third_party_invite.signed || {}).token;
                if (!token) {
                    return;
                }
                var threePidInvite = roomState.getStateEvents("m.room.third_party_invite", token);
                if (!threePidInvite) {
                    return;
                }
                roomState._tokenToInvite[token] = memberEvent;
            }
            function _updateDisplayNameCache(roomState, userId, displayName) {
                var oldName = roomState._userIdsToDisplayNames[userId];
                delete roomState._userIdsToDisplayNames[userId];
                if (oldName) {
                    var strippedOldName = utils.removeHiddenChars(oldName);
                    var existingUserIds = roomState._displayNameToUserIds[strippedOldName];
                    if (existingUserIds) {
                        var filteredUserIDs = existingUserIds.filter(function (id) {
                            return id !== userId;
                        });
                        roomState._displayNameToUserIds[strippedOldName] = filteredUserIDs;
                    }
                }
                roomState._userIdsToDisplayNames[userId] = displayName;
                var strippedDisplayname = displayName && utils.removeHiddenChars(displayName);
                if (strippedDisplayname) {
                    if (!roomState._displayNameToUserIds[strippedDisplayname]) {
                        roomState._displayNameToUserIds[strippedDisplayname] = [];
                    }
                    roomState._displayNameToUserIds[strippedDisplayname].push(userId);
                }
            }
        }, { "../@types/event": 53, "../logger": 97, "../utils": 125, "./room-member": 105, "@babel/runtime/helpers/interopRequireWildcard": 13, "events": 36 }], 107: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.RoomSummary = RoomSummary;
            function RoomSummary(roomId, info) {
                this.roomId = roomId;
                this.info = info;
            }
        }, {}], 108: [function (require, module, exports) {
            "use strict";
            var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
            var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.Room = Room;
            var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
            var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
            var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
            var _events = require("events");
            var _eventTimelineSet = require("./event-timeline-set");
            var _eventTimeline = require("./event-timeline");
            var _contentRepo = require("../content-repo");
            var utils = _interopRequireWildcard(require("../utils"));
            var _event = require("./event");
            var _roomMember = require("./room-member");
            var _roomSummary = require("./room-summary");
            var _logger = require("../logger");
            var _ReEmitter = require("../ReEmitter");
            var _event2 = require("../@types/event");
            function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
                if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                    if (it)
                        o = it;
                    var i = 0;
                    var F = function F() { };
                    return { s: F, n: function n() { if (i >= o.length)
                            return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try {
                    if (!normalCompletion && it["return"] != null)
                        it["return"]();
                }
                finally {
                    if (didErr)
                        throw err;
                } } }; }
            function _unsupportedIterableToArray(o, minLen) { if (!o)
                return; if (typeof o === "string")
                return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor)
                n = o.constructor.name; if (n === "Map" || n === "Set")
                return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return _arrayLikeToArray(o, minLen); }
            function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length)
                len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
            } return arr2; }
            var KNOWN_SAFE_ROOM_VERSION = '6';
            var SAFE_ROOM_VERSIONS = ['1', '2', '3', '4', '5', '6'];
            function synthesizeReceipt(userId, event, receiptType) {
                var fakeReceipt = {
                    content: {},
                    type: "m.receipt",
                    room_id: event.getRoomId()
                };
                fakeReceipt.content[event.getId()] = {};
                fakeReceipt.content[event.getId()][receiptType] = {};
                fakeReceipt.content[event.getId()][receiptType][userId] = {
                    ts: event.getTs()
                };
                return new _event.MatrixEvent(fakeReceipt);
            }
            function Room(roomId, client, myUserId, opts) {
                opts = opts || {};
                opts.pendingEventOrdering = opts.pendingEventOrdering || "chronological";
                this.setMaxListeners(100);
                this.reEmitter = new _ReEmitter.ReEmitter(this);
                if (["chronological", "detached"].indexOf(opts.pendingEventOrdering) === -1) {
                    throw new Error("opts.pendingEventOrdering MUST be either 'chronological' or " + "'detached'. Got: '" + opts.pendingEventOrdering + "'");
                }
                this.myUserId = myUserId;
                this.roomId = roomId;
                this.name = roomId;
                this.tags = {};
                this.accountData = {};
                this.summary = null;
                this.storageToken = opts.storageToken;
                this._opts = opts;
                this._txnToEvent = {};
                this._receipts = {};
                this._receiptCacheByEventId = {};
                this._realReceipts = {};
                this._notificationCounts = {};
                this._timelineSets = [new _eventTimelineSet.EventTimelineSet(this, opts)];
                this.reEmitter.reEmit(this.getUnfilteredTimelineSet(), ["Room.timeline", "Room.timelineReset"]);
                this._fixUpLegacyTimelineFields();
                this._filteredTimelineSets = {};
                if (this._opts.pendingEventOrdering == "detached") {
                    this._pendingEventList = [];
                }
                this._blacklistUnverifiedDevices = null;
                this._selfMembership = null;
                this._summaryHeroes = null;
                this._client = client;
                if (!this._opts.lazyLoadMembers) {
                    this._membersPromise = Promise.resolve();
                }
                else {
                    this._membersPromise = null;
                }
            }
            utils.inherits(Room, _events.EventEmitter);
            Room.prototype.getVersion = function () {
                var createEvent = this.currentState.getStateEvents("m.room.create", "");
                if (!createEvent) {
                    _logger.logger.warn("Room " + this.roomId + " does not have an m.room.create event");
                    return '1';
                }
                var ver = createEvent.getContent()['room_version'];
                if (ver === undefined)
                    return '1';
                return ver;
            };
            Room.prototype.shouldUpgradeToVersion = function () {
                if (!SAFE_ROOM_VERSIONS.includes(this.getVersion())) {
                    return KNOWN_SAFE_ROOM_VERSION;
                }
                return null;
            };
            Room.prototype.getRecommendedVersion = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee() {
                var capabilities, versionCap, _iterator, _step, safeVer, result, caps;
                return _regenerator["default"].wrap(function _callee$(_context) {
                    while (1) {
                        switch (_context.prev = _context.next) {
                            case 0:
                                _context.next = 2;
                                return this._client.getCapabilities();
                            case 2:
                                capabilities = _context.sent;
                                versionCap = capabilities["m.room_versions"];
                                if (!versionCap) {
                                    versionCap = {
                                        "default": KNOWN_SAFE_ROOM_VERSION,
                                        available: {}
                                    };
                                    _iterator = _createForOfIteratorHelper(SAFE_ROOM_VERSIONS);
                                    try {
                                        for (_iterator.s(); !(_step = _iterator.n()).done;) {
                                            safeVer = _step.value;
                                            versionCap.available[safeVer] = "stable";
                                        }
                                    }
                                    catch (err) {
                                        _iterator.e(err);
                                    }
                                    finally {
                                        _iterator.f();
                                    }
                                }
                                result = this._checkVersionAgainstCapability(versionCap);
                                if (!(result.urgent && result.needsUpgrade)) {
                                    _context.next = 18;
                                    break;
                                }
                                _logger.logger.warn("Refreshing room version capability because the server looks " + "to be supporting a newer room version we don't know about.");
                                _context.next = 10;
                                return this._client.getCapabilities(true);
                            case 10:
                                caps = _context.sent;
                                versionCap = caps["m.room_versions"];
                                if (versionCap) {
                                    _context.next = 17;
                                    break;
                                }
                                _logger.logger.warn("No room version capability - assuming upgrade required.");
                                return _context.abrupt("return", result);
                            case 17:
                                result = this._checkVersionAgainstCapability(versionCap);
                            case 18:
                                return _context.abrupt("return", result);
                            case 19:
                            case "end":
                                return _context.stop();
                        }
                    }
                }, _callee, this);
            }));
            Room.prototype._checkVersionAgainstCapability = function (versionCap) {
                var currentVersion = this.getVersion();
                _logger.logger.log("[".concat(this.roomId, "] Current version: ").concat(currentVersion));
                _logger.logger.log("[".concat(this.roomId, "] Version capability: "), versionCap);
                var result = {
                    version: currentVersion,
                    needsUpgrade: false,
                    urgent: false
                };
                if (currentVersion === versionCap["default"])
                    return result;
                var stableVersions = Object.keys(versionCap.available).filter(function (v) {
                    return versionCap.available[v] === 'stable';
                });
                if (!stableVersions.includes(currentVersion)) {
                    result.version = versionCap["default"];
                    result.needsUpgrade = true;
                    result.urgent = !!this.getVersion().match(/^[0-9]+[0-9.]*$/g);
                    if (result.urgent) {
                        _logger.logger.warn("URGENT upgrade required on ".concat(this.roomId));
                    }
                    else {
                        _logger.logger.warn("Non-urgent upgrade required on ".concat(this.roomId));
                    }
                    return result;
                }
                return result;
            };
            Room.prototype.userMayUpgradeRoom = function (userId) {
                return this.currentState.maySendStateEvent("m.room.tombstone", userId);
            };
            Room.prototype.getPendingEvents = function () {
                if (this._opts.pendingEventOrdering !== "detached") {
                    throw new Error("Cannot call getPendingEvents with pendingEventOrdering == " + this._opts.pendingEventOrdering);
                }
                return this._pendingEventList;
            };
            Room.prototype.hasPendingEvent = function (eventId) {
                if (this._opts.pendingEventOrdering !== "detached") {
                    return false;
                }
                return this._pendingEventList.some(function (event) {
                    return event.getId() === eventId;
                });
            };
            Room.prototype.getPendingEvent = function (eventId) {
                if (this._opts.pendingEventOrdering !== "detached") {
                    return null;
                }
                return this._pendingEventList.find(function (event) {
                    return event.getId() === eventId;
                });
            };
            Room.prototype.getLiveTimeline = function () {
                return this.getUnfilteredTimelineSet().getLiveTimeline();
            };
            Room.prototype.getLastActiveTimestamp = function () {
                var timeline = this.getLiveTimeline();
                var events = timeline.getEvents();
                if (events.length) {
                    var lastEvent = events[events.length - 1];
                    return lastEvent.getTs();
                }
                else {
                    return Number.MIN_SAFE_INTEGER;
                }
            };
            Room.prototype.getMyMembership = function () {
                return this._selfMembership;
            };
            Room.prototype.getDMInviter = function () {
                if (this.myUserId) {
                    var me = this.getMember(this.myUserId);
                    if (me) {
                        return me.getDMInviter();
                    }
                }
                if (this._selfMembership === "invite") {
                    var memberCount = this.getInvitedAndJoinedMemberCount();
                    if (memberCount == 2 && this._summaryHeroes.length) {
                        return this._summaryHeroes[0];
                    }
                }
            };
            Room.prototype.guessDMUserId = function () {
                var _this = this;
                var me = this.getMember(this.myUserId);
                if (me) {
                    var inviterId = me.getDMInviter();
                    if (inviterId) {
                        return inviterId;
                    }
                }
                var hasHeroes = Array.isArray(this._summaryHeroes) && this._summaryHeroes.length;
                if (hasHeroes) {
                    return this._summaryHeroes[0];
                }
                var members = this.currentState.getMembers();
                var anyMember = members.find(function (m) {
                    return m.userId !== _this.myUserId;
                });
                if (anyMember) {
                    return anyMember.userId;
                }
                return this.myUserId;
            };
            Room.prototype.getAvatarFallbackMember = function () {
                var _this2 = this;
                var memberCount = this.getInvitedAndJoinedMemberCount();
                if (memberCount > 2) {
                    return;
                }
                var hasHeroes = Array.isArray(this._summaryHeroes) && this._summaryHeroes.length;
                if (hasHeroes) {
                    var availableMember = this._summaryHeroes.map(function (userId) {
                        return _this2.getMember(userId);
                    }).find(function (member) {
                        return !!member;
                    });
                    if (availableMember) {
                        return availableMember;
                    }
                }
                var members = this.currentState.getMembers();
                if (members.length <= 2) {
                    var _availableMember = members.find(function (m) {
                        return m.userId !== _this2.myUserId;
                    });
                    if (_availableMember) {
                        return _availableMember;
                    }
                }
                if (hasHeroes) {
                    var availableUser = this._summaryHeroes.map(function (userId) {
                        return _this2._client.getUser(userId);
                    }).find(function (user) {
                        return !!user;
                    });
                    if (availableUser) {
                        var member = new _roomMember.RoomMember(this.roomId, availableUser.userId);
                        member.user = availableUser;
                        return member;
                    }
                }
            };
            Room.prototype.updateMyMembership = function (membership) {
                var prevMembership = this._selfMembership;
                this._selfMembership = membership;
                if (prevMembership !== membership) {
                    if (membership === "leave") {
                        this._cleanupAfterLeaving();
                    }
                    this.emit("Room.myMembership", this, membership, prevMembership);
                }
            };
            Room.prototype._loadMembersFromServer = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee2() {
                var lastSyncToken, queryString, path, http, response;
                return _regenerator["default"].wrap(function _callee2$(_context2) {
                    while (1) {
                        switch (_context2.prev = _context2.next) {
                            case 0:
                                lastSyncToken = this._client.store.getSyncToken();
                                queryString = utils.encodeParams({
                                    not_membership: "leave",
                                    at: lastSyncToken
                                });
                                path = utils.encodeUri("/rooms/$roomId/members?" + queryString, {
                                    $roomId: this.roomId
                                });
                                http = this._client._http;
                                _context2.next = 6;
                                return http.authedRequest(undefined, "GET", path);
                            case 6:
                                response = _context2.sent;
                                return _context2.abrupt("return", response.chunk);
                            case 8:
                            case "end":
                                return _context2.stop();
                        }
                    }
                }, _callee2, this);
            }));
            Room.prototype._loadMembers = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee3() {
                var fromServer, rawMembersEvents, memberEvents;
                return _regenerator["default"].wrap(function _callee3$(_context3) {
                    while (1) {
                        switch (_context3.prev = _context3.next) {
                            case 0:
                                fromServer = false;
                                _context3.next = 3;
                                return this._client.store.getOutOfBandMembers(this.roomId);
                            case 3:
                                rawMembersEvents = _context3.sent;
                                if (!(rawMembersEvents === null)) {
                                    _context3.next = 10;
                                    break;
                                }
                                fromServer = true;
                                _context3.next = 8;
                                return this._loadMembersFromServer();
                            case 8:
                                rawMembersEvents = _context3.sent;
                                _logger.logger.log("LL: got ".concat(rawMembersEvents.length, " ") + "members from server for room ".concat(this.roomId));
                            case 10:
                                memberEvents = rawMembersEvents.map(this._client.getEventMapper());
                                return _context3.abrupt("return", {
                                    memberEvents: memberEvents,
                                    fromServer: fromServer
                                });
                            case 12:
                            case "end":
                                return _context3.stop();
                        }
                    }
                }, _callee3, this);
            }));
            Room.prototype.loadMembersIfNeeded = function () {
                var _this3 = this;
                if (this._membersPromise) {
                    return this._membersPromise;
                }
                this.currentState.markOutOfBandMembersStarted();
                var inMemoryUpdate = this._loadMembers().then(function (result) {
                    _this3.currentState.setOutOfBandMembers(result.memberEvents);
                    if (_this3._client.isCryptoEnabled() && _this3._client.isRoomEncrypted(_this3.roomId)) {
                        _this3._client._crypto.trackRoomDevices(_this3.roomId);
                    }
                    return result.fromServer;
                })["catch"](function (err) {
                    _this3._membersPromise = null;
                    _this3.currentState.markOutOfBandMembersFailed();
                    throw err;
                });
                inMemoryUpdate.then(function (fromServer) {
                    if (fromServer) {
                        var oobMembers = _this3.currentState.getMembers().filter(function (m) {
                            return m.isOutOfBand();
                        }).map(function (m) {
                            return m.events.member.event;
                        });
                        _logger.logger.log("LL: telling store to write ".concat(oobMembers.length) + " members for room ".concat(_this3.roomId));
                        var store = _this3._client.store;
                        return store.setOutOfBandMembers(_this3.roomId, oobMembers)["catch"](function (err) {
                            _logger.logger.log("LL: storing OOB room members failed, oh well", err);
                        });
                    }
                })["catch"](function (err) {
                    _logger.logger.error(err);
                });
                this._membersPromise = inMemoryUpdate;
                return this._membersPromise;
            };
            Room.prototype.clearLoadedMembersIfNeeded = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee4() {
                return _regenerator["default"].wrap(function _callee4$(_context4) {
                    while (1) {
                        switch (_context4.prev = _context4.next) {
                            case 0:
                                if (!(this._opts.lazyLoadMembers && this._membersPromise)) {
                                    _context4.next = 7;
                                    break;
                                }
                                _context4.next = 3;
                                return this.loadMembersIfNeeded();
                            case 3:
                                _context4.next = 5;
                                return this._client.store.clearOutOfBandMembers(this.roomId);
                            case 5:
                                this.currentState.clearOutOfBandMembers();
                                this._membersPromise = null;
                            case 7:
                            case "end":
                                return _context4.stop();
                        }
                    }
                }, _callee4, this);
            }));
            Room.prototype._cleanupAfterLeaving = function () {
                var _this4 = this;
                this.clearLoadedMembersIfNeeded()["catch"](function (err) {
                    _logger.logger.error("error after clearing loaded members from " + "room ".concat(_this4.roomId, " after leaving"));
                    _logger.logger.log(err);
                });
            };
            Room.prototype.resetLiveTimeline = function (backPaginationToken, forwardPaginationToken) {
                for (var i = 0; i < this._timelineSets.length; i++) {
                    this._timelineSets[i].resetLiveTimeline(backPaginationToken, forwardPaginationToken);
                }
                this._fixUpLegacyTimelineFields();
            };
            Room.prototype._fixUpLegacyTimelineFields = function () {
                this.timeline = this.getLiveTimeline().getEvents();
                this.oldState = this.getLiveTimeline().getState(_eventTimeline.EventTimeline.BACKWARDS);
                this.currentState = this.getLiveTimeline().getState(_eventTimeline.EventTimeline.FORWARDS);
            };
            Room.prototype.hasUnverifiedDevices = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee5() {
                var e2eMembers, _iterator2, _step2, member, devices;
                return _regenerator["default"].wrap(function _callee5$(_context5) {
                    while (1) {
                        switch (_context5.prev = _context5.next) {
                            case 0:
                                if (this._client.isRoomEncrypted(this.roomId)) {
                                    _context5.next = 2;
                                    break;
                                }
                                return _context5.abrupt("return", false);
                            case 2:
                                _context5.next = 4;
                                return this.getEncryptionTargetMembers();
                            case 4:
                                e2eMembers = _context5.sent;
                                _iterator2 = _createForOfIteratorHelper(e2eMembers);
                                _context5.prev = 6;
                                _iterator2.s();
                            case 8:
                                if ((_step2 = _iterator2.n()).done) {
                                    _context5.next = 15;
                                    break;
                                }
                                member = _step2.value;
                                devices = this._client.getStoredDevicesForUser(member.userId);
                                if (!devices.some(function (device) {
                                    return device.isUnverified();
                                })) {
                                    _context5.next = 13;
                                    break;
                                }
                                return _context5.abrupt("return", true);
                            case 13:
                                _context5.next = 8;
                                break;
                            case 15:
                                _context5.next = 20;
                                break;
                            case 17:
                                _context5.prev = 17;
                                _context5.t0 = _context5["catch"](6);
                                _iterator2.e(_context5.t0);
                            case 20:
                                _context5.prev = 20;
                                _iterator2.f();
                                return _context5.finish(20);
                            case 23:
                                return _context5.abrupt("return", false);
                            case 24:
                            case "end":
                                return _context5.stop();
                        }
                    }
                }, _callee5, this, [[6, 17, 20, 23]]);
            }));
            Room.prototype.getTimelineSets = function () {
                return this._timelineSets;
            };
            Room.prototype.getUnfilteredTimelineSet = function () {
                return this._timelineSets[0];
            };
            Room.prototype.getTimelineForEvent = function (eventId) {
                return this.getUnfilteredTimelineSet().getTimelineForEvent(eventId);
            };
            Room.prototype.addTimeline = function () {
                return this.getUnfilteredTimelineSet().addTimeline();
            };
            Room.prototype.findEventById = function (eventId) {
                return this.getUnfilteredTimelineSet().findEventById(eventId);
            };
            Room.prototype.getUnreadNotificationCount = function (type) {
                type = type || 'total';
                return this._notificationCounts[type];
            };
            Room.prototype.setUnreadNotificationCount = function (type, count) {
                this._notificationCounts[type] = count;
            };
            Room.prototype.setSummary = function (summary) {
                var _this5 = this;
                var heroes = summary["m.heroes"];
                var joinedCount = summary["m.joined_member_count"];
                var invitedCount = summary["m.invited_member_count"];
                if (Number.isInteger(joinedCount)) {
                    this.currentState.setJoinedMemberCount(joinedCount);
                }
                if (Number.isInteger(invitedCount)) {
                    this.currentState.setInvitedMemberCount(invitedCount);
                }
                if (Array.isArray(heroes)) {
                    this._summaryHeroes = heroes.filter(function (userId) {
                        return userId !== _this5.myUserId;
                    });
                }
            };
            Room.prototype.setBlacklistUnverifiedDevices = function (value) {
                this._blacklistUnverifiedDevices = value;
            };
            Room.prototype.getBlacklistUnverifiedDevices = function () {
                return this._blacklistUnverifiedDevices;
            };
            Room.prototype.getAvatarUrl = function (baseUrl, width, height, resizeMethod, allowDefault) {
                var roomAvatarEvent = this.currentState.getStateEvents(_event2.EventType.RoomAvatar, "");
                if (allowDefault === undefined) {
                    allowDefault = true;
                }
                if (!roomAvatarEvent && !allowDefault) {
                    return null;
                }
                var mainUrl = roomAvatarEvent ? roomAvatarEvent.getContent().url : null;
                if (mainUrl) {
                    return (0, _contentRepo.getHttpUriForMxc)(baseUrl, mainUrl, width, height, resizeMethod);
                }
                return null;
            };
            Room.prototype.getMxcAvatarUrl = function () {
                var roomAvatarEvent = this.currentState.getStateEvents(_event2.EventType.RoomAvatar, "");
                return roomAvatarEvent ? roomAvatarEvent.getContent().url : null;
            };
            Room.prototype.getAliases = function () {
                var aliasStrings = [];
                var aliasEvents = this.currentState.getStateEvents("m.room.aliases");
                if (aliasEvents) {
                    var _loop = function _loop(i) {
                        var aliasEvent = aliasEvents[i];
                        if (utils.isArray(aliasEvent.getContent().aliases)) {
                            var filteredAliases = aliasEvent.getContent().aliases.filter(function (a) {
                                if (typeof a !== "string")
                                    return false;
                                if (a[0] !== '#')
                                    return false;
                                if (!a.endsWith(":".concat(aliasEvent.getStateKey())))
                                    return false;
                                return true;
                            });
                            Array.prototype.push.apply(aliasStrings, filteredAliases);
                        }
                    };
                    for (var i = 0; i < aliasEvents.length; ++i) {
                        _loop(i);
                    }
                }
                return aliasStrings;
            };
            Room.prototype.getCanonicalAlias = function () {
                var canonicalAlias = this.currentState.getStateEvents("m.room.canonical_alias", "");
                if (canonicalAlias) {
                    return canonicalAlias.getContent().alias || null;
                }
                return null;
            };
            Room.prototype.getAltAliases = function () {
                var canonicalAlias = this.currentState.getStateEvents("m.room.canonical_alias", "");
                if (canonicalAlias) {
                    return canonicalAlias.getContent().alt_aliases || [];
                }
                return [];
            };
            Room.prototype.addEventsToTimeline = function (events, toStartOfTimeline, timeline, paginationToken) {
                timeline.getTimelineSet().addEventsToTimeline(events, toStartOfTimeline, timeline, paginationToken);
            };
            Room.prototype.getMember = function (userId) {
                return this.currentState.getMember(userId);
            };
            Room.prototype.getJoinedMembers = function () {
                return this.getMembersWithMembership("join");
            };
            Room.prototype.getJoinedMemberCount = function () {
                return this.currentState.getJoinedMemberCount();
            };
            Room.prototype.getInvitedMemberCount = function () {
                return this.currentState.getInvitedMemberCount();
            };
            Room.prototype.getInvitedAndJoinedMemberCount = function () {
                return this.getInvitedMemberCount() + this.getJoinedMemberCount();
            };
            Room.prototype.getMembersWithMembership = function (membership) {
                return utils.filter(this.currentState.getMembers(), function (m) {
                    return m.membership === membership;
                });
            };
            Room.prototype.getEncryptionTargetMembers = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee6() {
                var members;
                return _regenerator["default"].wrap(function _callee6$(_context6) {
                    while (1) {
                        switch (_context6.prev = _context6.next) {
                            case 0:
                                _context6.next = 2;
                                return this.loadMembersIfNeeded();
                            case 2:
                                members = this.getMembersWithMembership("join");
                                if (this.shouldEncryptForInvitedMembers()) {
                                    members = members.concat(this.getMembersWithMembership("invite"));
                                }
                                return _context6.abrupt("return", members);
                            case 5:
                            case "end":
                                return _context6.stop();
                        }
                    }
                }, _callee6, this);
            }));
            Room.prototype.shouldEncryptForInvitedMembers = function () {
                var ev = this.currentState.getStateEvents("m.room.history_visibility", "");
                return ev && ev.getContent() && ev.getContent().history_visibility !== "joined";
            };
            Room.prototype.getDefaultRoomName = function (userId) {
                return calculateRoomName(this, userId, true);
            };
            Room.prototype.hasMembershipState = function (userId, membership) {
                var member = this.getMember(userId);
                if (!member) {
                    return false;
                }
                return member.membership === membership;
            };
            Room.prototype.getOrCreateFilteredTimelineSet = function (filter) {
                if (this._filteredTimelineSets[filter.filterId]) {
                    return this._filteredTimelineSets[filter.filterId];
                }
                var opts = Object.assign({
                    filter: filter
                }, this._opts);
                var timelineSet = new _eventTimelineSet.EventTimelineSet(this, opts);
                this.reEmitter.reEmit(timelineSet, ["Room.timeline", "Room.timelineReset"]);
                this._filteredTimelineSets[filter.filterId] = timelineSet;
                this._timelineSets.push(timelineSet);
                var unfilteredLiveTimeline = this.getLiveTimeline();
                unfilteredLiveTimeline.getEvents().forEach(function (event) {
                    timelineSet.addLiveEvent(event);
                });
                var timeline = unfilteredLiveTimeline;
                while (timeline.getNeighbouringTimeline(_eventTimeline.EventTimeline.BACKWARDS)) {
                    timeline = timeline.getNeighbouringTimeline(_eventTimeline.EventTimeline.BACKWARDS);
                }
                timelineSet.getLiveTimeline().setPaginationToken(timeline.getPaginationToken(_eventTimeline.EventTimeline.BACKWARDS), _eventTimeline.EventTimeline.BACKWARDS);
                return timelineSet;
            };
            Room.prototype.removeFilteredTimelineSet = function (filter) {
                var timelineSet = this._filteredTimelineSets[filter.filterId];
                delete this._filteredTimelineSets[filter.filterId];
                var i = this._timelineSets.indexOf(timelineSet);
                if (i > -1) {
                    this._timelineSets.splice(i, 1);
                }
            };
            Room.prototype._addLiveEvent = function (event, duplicateStrategy, fromCache) {
                if (event.isRedaction()) {
                    var redactId = event.event.redacts;
                    var redactedEvent = this.getUnfilteredTimelineSet().findEventById(redactId);
                    if (redactedEvent) {
                        redactedEvent.makeRedacted(event);
                        if (redactedEvent.getStateKey()) {
                            var currentStateEvent = this.currentState.getStateEvents(redactedEvent.getType(), redactedEvent.getStateKey());
                            if (currentStateEvent.getId() === redactedEvent.getId()) {
                                this.currentState.setStateEvents([redactedEvent]);
                            }
                        }
                        this.emit("Room.redaction", event, this);
                    }
                }
                if (event.getUnsigned().transaction_id) {
                    var existingEvent = this._txnToEvent[event.getUnsigned().transaction_id];
                    if (existingEvent) {
                        this._handleRemoteEcho(event, existingEvent);
                        return;
                    }
                }
                for (var i = 0; i < this._timelineSets.length; i++) {
                    this._timelineSets[i].addLiveEvent(event, duplicateStrategy, fromCache);
                }
                if (event.sender && event.getType() !== "m.room.redaction") {
                    this.addReceipt(synthesizeReceipt(event.sender.userId, event, "m.read"), true);
                }
            };
            Room.prototype.addPendingEvent = function (event, txnId) {
                if (event.status !== _event.EventStatus.SENDING) {
                    throw new Error("addPendingEvent called on an event with status " + event.status);
                }
                if (this._txnToEvent[txnId]) {
                    throw new Error("addPendingEvent called on an event with known txnId " + txnId);
                }
                _eventTimeline.EventTimeline.setEventMetadata(event, this.getLiveTimeline().getState(_eventTimeline.EventTimeline.FORWARDS), false);
                this._txnToEvent[txnId] = event;
                if (this._opts.pendingEventOrdering == "detached") {
                    if (this._pendingEventList.some(function (e) {
                        return e.status === _event.EventStatus.NOT_SENT;
                    })) {
                        _logger.logger.warn("Setting event as NOT_SENT due to messages in the same state");
                        event.setStatus(_event.EventStatus.NOT_SENT);
                    }
                    this._pendingEventList.push(event);
                    if (event.isRelation()) {
                        this._aggregateNonLiveRelation(event);
                    }
                    if (event.isRedaction()) {
                        var redactId = event.event.redacts;
                        var redactedEvent = this._pendingEventList && this._pendingEventList.find(function (e) {
                            return e.getId() === redactId;
                        });
                        if (!redactedEvent) {
                            redactedEvent = this.getUnfilteredTimelineSet().findEventById(redactId);
                        }
                        if (redactedEvent) {
                            redactedEvent.markLocallyRedacted(event);
                            this.emit("Room.redaction", event, this);
                        }
                    }
                }
                else {
                    for (var i = 0; i < this._timelineSets.length; i++) {
                        var timelineSet = this._timelineSets[i];
                        if (timelineSet.getFilter()) {
                            if (timelineSet.getFilter().filterRoomTimeline([event]).length) {
                                timelineSet.addEventToTimeline(event, timelineSet.getLiveTimeline(), false);
                            }
                        }
                        else {
                            timelineSet.addEventToTimeline(event, timelineSet.getLiveTimeline(), false);
                        }
                    }
                }
                this.emit("Room.localEchoUpdated", event, this, null, null);
            };
            Room.prototype._aggregateNonLiveRelation = function (event) {
                for (var i = 0; i < this._timelineSets.length; i++) {
                    var timelineSet = this._timelineSets[i];
                    if (timelineSet.getFilter()) {
                        if (timelineSet.getFilter().filterRoomTimeline([event]).length) {
                            timelineSet.aggregateRelations(event);
                        }
                    }
                    else {
                        timelineSet.aggregateRelations(event);
                    }
                }
            };
            Room.prototype._handleRemoteEcho = function (remoteEvent, localEvent) {
                var oldEventId = localEvent.getId();
                var newEventId = remoteEvent.getId();
                var oldStatus = localEvent.status;
                _logger.logger.debug("Got remote echo for event ".concat(oldEventId, " -> ").concat(newEventId, " ") + "old status ".concat(oldStatus));
                delete this._txnToEvent[remoteEvent.getUnsigned().transaction_id];
                if (this._pendingEventList) {
                    utils.removeElement(this._pendingEventList, function (ev) {
                        return ev.getId() == oldEventId;
                    }, false);
                }
                localEvent.handleRemoteEcho(remoteEvent.event);
                for (var i = 0; i < this._timelineSets.length; i++) {
                    var timelineSet = this._timelineSets[i];
                    timelineSet.handleRemoteEcho(localEvent, oldEventId, newEventId);
                }
                this.emit("Room.localEchoUpdated", localEvent, this, oldEventId, oldStatus);
            };
            var ALLOWED_TRANSITIONS = {};
            ALLOWED_TRANSITIONS[_event.EventStatus.ENCRYPTING] = [_event.EventStatus.SENDING, _event.EventStatus.NOT_SENT];
            ALLOWED_TRANSITIONS[_event.EventStatus.SENDING] = [_event.EventStatus.ENCRYPTING, _event.EventStatus.QUEUED, _event.EventStatus.NOT_SENT, _event.EventStatus.SENT];
            ALLOWED_TRANSITIONS[_event.EventStatus.QUEUED] = [_event.EventStatus.SENDING, _event.EventStatus.CANCELLED];
            ALLOWED_TRANSITIONS[_event.EventStatus.SENT] = [];
            ALLOWED_TRANSITIONS[_event.EventStatus.NOT_SENT] = [_event.EventStatus.SENDING, _event.EventStatus.QUEUED, _event.EventStatus.CANCELLED];
            ALLOWED_TRANSITIONS[_event.EventStatus.CANCELLED] = [];
            Room.prototype.updatePendingEvent = function (event, newStatus, newEventId) {
                _logger.logger.log("setting pendingEvent status to ".concat(newStatus, " in ").concat(event.getRoomId(), " ") + "event ID ".concat(event.getId(), " -> ").concat(newEventId));
                if (newStatus == _event.EventStatus.SENT && !newEventId) {
                    throw new Error("updatePendingEvent called with status=SENT, " + "but no new event id");
                }
                if (newStatus == _event.EventStatus.SENT) {
                    var timeline = this.getUnfilteredTimelineSet().eventIdToTimeline(newEventId);
                    if (timeline) {
                        return;
                    }
                }
                var oldStatus = event.status;
                var oldEventId = event.getId();
                if (!oldStatus) {
                    throw new Error("updatePendingEventStatus called on an event which is " + "not a local echo.");
                }
                var allowed = ALLOWED_TRANSITIONS[oldStatus];
                if (!allowed || allowed.indexOf(newStatus) < 0) {
                    throw new Error("Invalid EventStatus transition " + oldStatus + "->" + newStatus);
                }
                event.setStatus(newStatus);
                if (newStatus == _event.EventStatus.SENT) {
                    event.replaceLocalEventId(newEventId);
                    for (var i = 0; i < this._timelineSets.length; i++) {
                        this._timelineSets[i].replaceEventId(oldEventId, newEventId);
                    }
                }
                else if (newStatus == _event.EventStatus.CANCELLED) {
                    if (this._pendingEventList) {
                        var idx = this._pendingEventList.findIndex(function (ev) {
                            return ev.getId() === oldEventId;
                        });
                        if (idx !== -1) {
                            var _this$_pendingEventLi = this._pendingEventList.splice(idx, 1), _this$_pendingEventLi2 = (0, _slicedToArray2["default"])(_this$_pendingEventLi, 1), removedEvent = _this$_pendingEventLi2[0];
                            if (removedEvent.isRedaction()) {
                                this._revertRedactionLocalEcho(removedEvent);
                            }
                        }
                    }
                    this.removeEvent(oldEventId);
                }
                this.emit("Room.localEchoUpdated", event, this, oldEventId, oldStatus);
            };
            Room.prototype._revertRedactionLocalEcho = function (redactionEvent) {
                var redactId = redactionEvent.event.redacts;
                if (!redactId) {
                    return;
                }
                var redactedEvent = this.getUnfilteredTimelineSet().findEventById(redactId);
                if (redactedEvent) {
                    redactedEvent.unmarkLocallyRedacted();
                    this.emit("Room.redactionCancelled", redactionEvent, this);
                    if (redactedEvent.isRelation()) {
                        this._aggregateNonLiveRelation(redactedEvent);
                    }
                }
            };
            Room.prototype.addLiveEvents = function (events, duplicateStrategy, fromCache) {
                var i;
                if (duplicateStrategy && ["replace", "ignore"].indexOf(duplicateStrategy) === -1) {
                    throw new Error("duplicateStrategy MUST be either 'replace' or 'ignore'");
                }
                for (i = 0; i < this._timelineSets.length; i++) {
                    var liveTimeline = this._timelineSets[i].getLiveTimeline();
                    if (liveTimeline.getPaginationToken(_eventTimeline.EventTimeline.FORWARDS)) {
                        throw new Error("live timeline " + i + " is no longer live - it has a pagination token " + "(" + liveTimeline.getPaginationToken(_eventTimeline.EventTimeline.FORWARDS) + ")");
                    }
                    if (liveTimeline.getNeighbouringTimeline(_eventTimeline.EventTimeline.FORWARDS)) {
                        throw new Error("live timeline " + i + " is no longer live - " + "it has a neighbouring timeline");
                    }
                }
                for (i = 0; i < events.length; i++) {
                    this._addLiveEvent(events[i], duplicateStrategy, fromCache);
                }
            };
            Room.prototype.addEphemeralEvents = function (events) {
                var _iterator3 = _createForOfIteratorHelper(events), _step3;
                try {
                    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                        var event = _step3.value;
                        if (event.getType() === 'm.typing') {
                            this.currentState.setTypingEvent(event);
                        }
                        else if (event.getType() === 'm.receipt') {
                            this.addReceipt(event);
                        }
                    }
                }
                catch (err) {
                    _iterator3.e(err);
                }
                finally {
                    _iterator3.f();
                }
            };
            Room.prototype.removeEvents = function (eventIds) {
                for (var i = 0; i < eventIds.length; ++i) {
                    this.removeEvent(eventIds[i]);
                }
            };
            Room.prototype.removeEvent = function (eventId) {
                var removedAny = false;
                for (var i = 0; i < this._timelineSets.length; i++) {
                    var removed = this._timelineSets[i].removeEvent(eventId);
                    if (removed) {
                        if (removed.isRedaction()) {
                            this._revertRedactionLocalEcho(removed);
                        }
                        removedAny = true;
                    }
                }
                return removedAny;
            };
            Room.prototype.recalculate = function () {
                var self = this;
                var membershipEvent = this.currentState.getStateEvents("m.room.member", this.myUserId);
                if (membershipEvent && membershipEvent.getContent().membership === "invite") {
                    var strippedStateEvents = membershipEvent.event.invite_room_state || [];
                    utils.forEach(strippedStateEvents, function (strippedEvent) {
                        var existingEvent = self.currentState.getStateEvents(strippedEvent.type, strippedEvent.state_key);
                        if (!existingEvent) {
                            self.currentState.setStateEvents([new _event.MatrixEvent({
                                    type: strippedEvent.type,
                                    state_key: strippedEvent.state_key,
                                    content: strippedEvent.content,
                                    event_id: "$fake" + Date.now(),
                                    room_id: self.roomId,
                                    user_id: self.myUserId
                                })]);
                        }
                    });
                }
                var oldName = this.name;
                this.name = calculateRoomName(this, this.myUserId);
                this.summary = new _roomSummary.RoomSummary(this.roomId, {
                    title: this.name
                });
                if (oldName !== this.name) {
                    this.emit("Room.name", this);
                }
            };
            Room.prototype.getUsersReadUpTo = function (event) {
                return this.getReceiptsForEvent(event).filter(function (receipt) {
                    return receipt.type === "m.read";
                }).map(function (receipt) {
                    return receipt.userId;
                });
            };
            Room.prototype.getEventReadUpTo = function (userId, ignoreSynthesized) {
                var receipts = this._receipts;
                if (ignoreSynthesized) {
                    receipts = this._realReceipts;
                }
                if (receipts["m.read"] === undefined || receipts["m.read"][userId] === undefined) {
                    return null;
                }
                return receipts["m.read"][userId].eventId;
            };
            Room.prototype.hasUserReadEvent = function (userId, eventId) {
                var readUpToId = this.getEventReadUpTo(userId, false);
                if (readUpToId === eventId)
                    return true;
                if (this.timeline.length && this.timeline[this.timeline.length - 1].getSender() && this.timeline[this.timeline.length - 1].getSender() === userId) {
                    return true;
                }
                for (var i = this.timeline.length - 1; i >= 0; --i) {
                    var ev = this.timeline[i];
                    if (ev.getId() === eventId)
                        return false;
                    if (ev.getId() === readUpToId)
                        return true;
                }
                return false;
            };
            Room.prototype.getReceiptsForEvent = function (event) {
                return this._receiptCacheByEventId[event.getId()] || [];
            };
            Room.prototype.addReceipt = function (event, fake) {
                if (fake === undefined) {
                    fake = false;
                }
                if (!fake) {
                    this._addReceiptsToStructure(event, this._realReceipts);
                }
                this._addReceiptsToStructure(event, this._receipts);
                this._receiptCacheByEventId = this._buildReceiptCache(this._receipts);
                this.emit("Room.receipt", event, this);
            };
            Room.prototype._addReceiptsToStructure = function (event, receipts) {
                var self = this;
                utils.keys(event.getContent()).forEach(function (eventId) {
                    utils.keys(event.getContent()[eventId]).forEach(function (receiptType) {
                        utils.keys(event.getContent()[eventId][receiptType]).forEach(function (userId) {
                            var receipt = event.getContent()[eventId][receiptType][userId];
                            if (!receipts[receiptType]) {
                                receipts[receiptType] = {};
                            }
                            var existingReceipt = receipts[receiptType][userId];
                            if (!existingReceipt) {
                                receipts[receiptType][userId] = {};
                            }
                            else {
                                var ordering = self.getUnfilteredTimelineSet().compareEventOrdering(existingReceipt.eventId, eventId);
                                if (ordering !== null && ordering >= 0) {
                                    return;
                                }
                            }
                            receipts[receiptType][userId] = {
                                eventId: eventId,
                                data: receipt
                            };
                        });
                    });
                });
            };
            Room.prototype._buildReceiptCache = function (receipts) {
                var receiptCacheByEventId = {};
                utils.keys(receipts).forEach(function (receiptType) {
                    utils.keys(receipts[receiptType]).forEach(function (userId) {
                        var receipt = receipts[receiptType][userId];
                        if (!receiptCacheByEventId[receipt.eventId]) {
                            receiptCacheByEventId[receipt.eventId] = [];
                        }
                        receiptCacheByEventId[receipt.eventId].push({
                            userId: userId,
                            type: receiptType,
                            data: receipt.data
                        });
                    });
                });
                return receiptCacheByEventId;
            };
            Room.prototype._addLocalEchoReceipt = function (userId, e, receiptType) {
                this.addReceipt(synthesizeReceipt(userId, e, receiptType), true);
            };
            Room.prototype.addTags = function (event) {
                this.tags = event.getContent().tags || {};
                this.emit("Room.tags", event, this);
            };
            Room.prototype.addAccountData = function (events) {
                for (var i = 0; i < events.length; i++) {
                    var event = events[i];
                    if (event.getType() === "m.tag") {
                        this.addTags(event);
                    }
                    var lastEvent = this.accountData[event.getType()];
                    this.accountData[event.getType()] = event;
                    this.emit("Room.accountData", event, this, lastEvent);
                }
            };
            Room.prototype.getAccountData = function (type) {
                return this.accountData[type];
            };
            Room.prototype.maySendMessage = function () {
                return this.getMyMembership() === 'join' && this.currentState.maySendEvent('m.room.message', this.myUserId);
            };
            Room.prototype.canInvite = function (userId) {
                var canInvite = this.getMyMembership() === "join";
                var powerLevelsEvent = this.currentState.getStateEvents(_event2.EventType.RoomPowerLevels, "");
                var powerLevels = powerLevelsEvent && powerLevelsEvent.getContent();
                var me = this.getMember(userId);
                if (powerLevels && me && powerLevels.invite > me.powerLevel) {
                    canInvite = false;
                }
                return canInvite;
            };
            Room.prototype.getJoinRule = function () {
                return this.currentState.getJoinRule();
            };
            Room.prototype.getType = function () {
                var createEvent = this.currentState.getStateEvents("m.room.create", "");
                if (!createEvent) {
                    _logger.logger.warn("Room " + this.roomId + " does not have an m.room.create event");
                    return undefined;
                }
                return createEvent.getContent()[_event2.RoomCreateTypeField];
            };
            Room.prototype.isSpaceRoom = function () {
                return this.getType() === _event2.RoomType.Space;
            };
            function calculateRoomName(room, userId, ignoreRoomNameEvent) {
                if (!ignoreRoomNameEvent) {
                    var mRoomName = room.currentState.getStateEvents("m.room.name", "");
                    if (mRoomName && mRoomName.getContent() && mRoomName.getContent().name) {
                        return mRoomName.getContent().name;
                    }
                }
                var alias = room.getCanonicalAlias();
                if (!alias) {
                    var aliases = room.getAltAliases();
                    if (aliases.length) {
                        alias = aliases[0];
                    }
                }
                if (alias) {
                    return alias;
                }
                var joinedMemberCount = room.currentState.getJoinedMemberCount();
                var invitedMemberCount = room.currentState.getInvitedMemberCount();
                var inviteJoinCount = joinedMemberCount + invitedMemberCount - 1;
                var otherNames = null;
                if (room._summaryHeroes) {
                    otherNames = room._summaryHeroes.map(function (userId) {
                        var member = room.getMember(userId);
                        return member ? member.name : userId;
                    });
                }
                else {
                    var otherMembers = room.currentState.getMembers().filter(function (m) {
                        return m.userId !== userId && (m.membership === "invite" || m.membership === "join");
                    });
                    otherMembers.sort(function (a, b) {
                        return a.userId.localeCompare(b.userId);
                    });
                    otherMembers = otherMembers.slice(0, 5);
                    otherNames = otherMembers.map(function (m) {
                        return m.name;
                    });
                }
                if (inviteJoinCount) {
                    return memberNamesToRoomName(otherNames, inviteJoinCount);
                }
                var myMembership = room.getMyMembership();
                if (myMembership == 'join') {
                    var thirdPartyInvites = room.currentState.getStateEvents("m.room.third_party_invite");
                    if (thirdPartyInvites && thirdPartyInvites.length) {
                        var thirdPartyNames = thirdPartyInvites.map(function (i) {
                            return i.getContent().display_name;
                        });
                        return "Inviting ".concat(memberNamesToRoomName(thirdPartyNames));
                    }
                }
                var leftNames = otherNames;
                if (!leftNames.length) {
                    leftNames = room.currentState.getMembers().filter(function (m) {
                        return m.userId !== userId && m.membership !== "invite" && m.membership !== "join";
                    }).map(function (m) {
                        return m.name;
                    });
                }
                if (leftNames.length) {
                    return "Empty room (was ".concat(memberNamesToRoomName(leftNames), ")");
                }
                else {
                    return "Empty room";
                }
            }
            function memberNamesToRoomName(names) {
                var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : names.length + 1;
                var countWithoutMe = count - 1;
                if (!names.length) {
                    return "Empty room";
                }
                else if (names.length === 1 && countWithoutMe <= 1) {
                    return names[0];
                }
                else if (names.length === 2 && countWithoutMe <= 2) {
                    return "".concat(names[0], " and ").concat(names[1]);
                }
                else {
                    var plural = countWithoutMe > 1;
                    if (plural) {
                        return "".concat(names[0], " and ").concat(countWithoutMe, " others");
                    }
                    else {
                        return "".concat(names[0], " and 1 other");
                    }
                }
            }
        }, { "../@types/event": 53, "../ReEmitter": 54, "../content-repo": 60, "../logger": 97, "../utils": 125, "./event": 102, "./event-timeline": 101, "./event-timeline-set": 100, "./room-member": 105, "./room-summary": 107, "@babel/runtime/helpers/asyncToGenerator": 5, "@babel/runtime/helpers/interopRequireDefault": 12, "@babel/runtime/helpers/interopRequireWildcard": 13, "@babel/runtime/helpers/slicedToArray": 22, "@babel/runtime/regenerator": 27, "events": 36 }], 109: [function (require, module, exports) {
            "use strict";
            var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.SearchResult = SearchResult;
            var utils = _interopRequireWildcard(require("../utils"));
            var _eventContext = require("./event-context");
            function SearchResult(rank, eventContext) {
                this.rank = rank;
                this.context = eventContext;
            }
            SearchResult.fromJson = function (jsonObj, eventMapper) {
                var jsonContext = jsonObj.context || {};
                var events_before = jsonContext.events_before || [];
                var events_after = jsonContext.events_after || [];
                var context = new _eventContext.EventContext(eventMapper(jsonObj.result));
                context.setPaginateToken(jsonContext.start, true);
                context.addEvents(utils.map(events_before, eventMapper), true);
                context.addEvents(utils.map(events_after, eventMapper), false);
                context.setPaginateToken(jsonContext.end, false);
                return new SearchResult(jsonObj.rank, context);
            };
        }, { "../utils": 125, "./event-context": 99, "@babel/runtime/helpers/interopRequireWildcard": 13 }], 110: [function (require, module, exports) {
            "use strict";
            var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.User = User;
            var utils = _interopRequireWildcard(require("../utils"));
            var _events = require("events");
            function User(userId) {
                this.userId = userId;
                this.presence = "offline";
                this.presenceStatusMsg = null;
                this._unstable_statusMessage = "";
                this.displayName = userId;
                this.rawDisplayName = userId;
                this.avatarUrl = null;
                this.lastActiveAgo = 0;
                this.lastPresenceTs = 0;
                this.currentlyActive = false;
                this.events = {
                    presence: null,
                    profile: null
                };
                this._updateModifiedTime();
            }
            utils.inherits(User, _events.EventEmitter);
            User.prototype.setPresenceEvent = function (event) {
                if (event.getType() !== "m.presence") {
                    return;
                }
                var firstFire = this.events.presence === null;
                this.events.presence = event;
                var eventsToFire = [];
                if (event.getContent().presence !== this.presence || firstFire) {
                    eventsToFire.push("User.presence");
                }
                if (event.getContent().avatar_url && event.getContent().avatar_url !== this.avatarUrl) {
                    eventsToFire.push("User.avatarUrl");
                }
                if (event.getContent().displayname && event.getContent().displayname !== this.displayName) {
                    eventsToFire.push("User.displayName");
                }
                if (event.getContent().currently_active !== undefined && event.getContent().currently_active !== this.currentlyActive) {
                    eventsToFire.push("User.currentlyActive");
                }
                this.presence = event.getContent().presence;
                eventsToFire.push("User.lastPresenceTs");
                if (event.getContent().status_msg) {
                    this.presenceStatusMsg = event.getContent().status_msg;
                }
                if (event.getContent().displayname) {
                    this.displayName = event.getContent().displayname;
                }
                if (event.getContent().avatar_url) {
                    this.avatarUrl = event.getContent().avatar_url;
                }
                this.lastActiveAgo = event.getContent().last_active_ago;
                this.lastPresenceTs = Date.now();
                this.currentlyActive = event.getContent().currently_active;
                this._updateModifiedTime();
                for (var i = 0; i < eventsToFire.length; i++) {
                    this.emit(eventsToFire[i], event, this);
                }
            };
            User.prototype.setDisplayName = function (name) {
                var oldName = this.displayName;
                if (typeof name === "string") {
                    this.displayName = name;
                }
                else {
                    this.displayName = undefined;
                }
                if (name !== oldName) {
                    this._updateModifiedTime();
                }
            };
            User.prototype.setRawDisplayName = function (name) {
                if (typeof name === "string") {
                    this.rawDisplayName = name;
                }
                else {
                    this.rawDisplayName = undefined;
                }
            };
            User.prototype.setAvatarUrl = function (url) {
                var oldUrl = this.avatarUrl;
                this.avatarUrl = url;
                if (url !== oldUrl) {
                    this._updateModifiedTime();
                }
            };
            User.prototype._updateModifiedTime = function () {
                this._modified = Date.now();
            };
            User.prototype.getLastModifiedTime = function () {
                return this._modified;
            };
            User.prototype.getLastActiveTs = function () {
                return this.lastPresenceTs - this.lastActiveAgo;
            };
            User.prototype._unstable_updateStatusMessage = function (event) {
                if (!event.getContent())
                    this._unstable_statusMessage = "";
                else
                    this._unstable_statusMessage = event.getContent()["status"];
                this._updateModifiedTime();
                this.emit("User._unstable_statusMessage", this);
            };
        }, { "../utils": 125, "@babel/runtime/helpers/interopRequireWildcard": 13, "events": 36 }], 111: [function (require, module, exports) {
            "use strict";
            var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.PushProcessor = PushProcessor;
            var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
            var _utils = require("./utils");
            var _logger = require("./logger");
            function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
                if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                    if (it)
                        o = it;
                    var i = 0;
                    var F = function F() { };
                    return { s: F, n: function n() { if (i >= o.length)
                            return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try {
                    if (!normalCompletion && it["return"] != null)
                        it["return"]();
                }
                finally {
                    if (didErr)
                        throw err;
                } } }; }
            function _unsupportedIterableToArray(o, minLen) { if (!o)
                return; if (typeof o === "string")
                return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor)
                n = o.constructor.name; if (n === "Map" || n === "Set")
                return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return _arrayLikeToArray(o, minLen); }
            function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length)
                len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
            } return arr2; }
            var RULEKINDS_IN_ORDER = ['override', 'content', 'room', 'sender', 'underride'];
            var DEFAULT_OVERRIDE_RULES = [{
                    rule_id: ".m.rule.tombstone",
                    "default": true,
                    enabled: true,
                    conditions: [{
                            kind: "event_match",
                            key: "type",
                            pattern: "m.room.tombstone"
                        }, {
                            kind: "event_match",
                            key: "state_key",
                            pattern: ""
                        }],
                    actions: ["notify", {
                            set_tweak: "highlight",
                            value: true
                        }]
                }, {
                    rule_id: ".m.rule.reaction",
                    "default": true,
                    enabled: true,
                    conditions: [{
                            kind: "event_match",
                            key: "type",
                            pattern: "m.reaction"
                        }],
                    actions: ["dont_notify"]
                }];
            function PushProcessor(client) {
                var _this = this;
                var cachedGlobToRegex = {};
                var matchingRuleFromKindSet = function matchingRuleFromKindSet(ev, kindset) {
                    for (var ruleKindIndex = 0; ruleKindIndex < RULEKINDS_IN_ORDER.length; ++ruleKindIndex) {
                        var kind = RULEKINDS_IN_ORDER[ruleKindIndex];
                        var ruleset = kindset[kind];
                        if (!ruleset) {
                            continue;
                        }
                        for (var ruleIndex = 0; ruleIndex < ruleset.length; ++ruleIndex) {
                            var rule = ruleset[ruleIndex];
                            if (!rule.enabled) {
                                continue;
                            }
                            var rawrule = templateRuleToRaw(kind, rule);
                            if (!rawrule) {
                                continue;
                            }
                            if (_this.ruleMatchesEvent(rawrule, ev)) {
                                rule.kind = kind;
                                return rule;
                            }
                        }
                    }
                    return null;
                };
                var templateRuleToRaw = function templateRuleToRaw(kind, tprule) {
                    var rawrule = {
                        'rule_id': tprule.rule_id,
                        'actions': tprule.actions,
                        'conditions': []
                    };
                    switch (kind) {
                        case 'underride':
                        case 'override':
                            rawrule.conditions = tprule.conditions;
                            break;
                        case 'room':
                            if (!tprule.rule_id) {
                                return null;
                            }
                            rawrule.conditions.push({
                                'kind': 'event_match',
                                'key': 'room_id',
                                'value': tprule.rule_id
                            });
                            break;
                        case 'sender':
                            if (!tprule.rule_id) {
                                return null;
                            }
                            rawrule.conditions.push({
                                'kind': 'event_match',
                                'key': 'user_id',
                                'value': tprule.rule_id
                            });
                            break;
                        case 'content':
                            if (!tprule.pattern) {
                                return null;
                            }
                            rawrule.conditions.push({
                                'kind': 'event_match',
                                'key': 'content.body',
                                'pattern': tprule.pattern
                            });
                            break;
                    }
                    return rawrule;
                };
                var eventFulfillsCondition = function eventFulfillsCondition(cond, ev) {
                    var condition_functions = {
                        "event_match": eventFulfillsEventMatchCondition,
                        "contains_display_name": eventFulfillsDisplayNameCondition,
                        "room_member_count": eventFulfillsRoomMemberCountCondition,
                        "sender_notification_permission": eventFulfillsSenderNotifPermCondition
                    };
                    if (condition_functions[cond.kind]) {
                        return condition_functions[cond.kind](cond, ev);
                    }
                    return false;
                };
                var eventFulfillsSenderNotifPermCondition = function eventFulfillsSenderNotifPermCondition(cond, ev) {
                    var notifLevelKey = cond['key'];
                    if (!notifLevelKey) {
                        return false;
                    }
                    var room = client.getRoom(ev.getRoomId());
                    if (!room || !room.currentState) {
                        return false;
                    }
                    return room.currentState.mayTriggerNotifOfType(notifLevelKey, ev.getSender());
                };
                var eventFulfillsRoomMemberCountCondition = function eventFulfillsRoomMemberCountCondition(cond, ev) {
                    if (!cond.is) {
                        return false;
                    }
                    var room = client.getRoom(ev.getRoomId());
                    if (!room || !room.currentState || !room.currentState.members) {
                        return false;
                    }
                    var memberCount = room.currentState.getJoinedMemberCount();
                    var m = cond.is.match(/^([=<>]*)([0-9]*)$/);
                    if (!m) {
                        return false;
                    }
                    var ineq = m[1];
                    var rhs = parseInt(m[2]);
                    if (isNaN(rhs)) {
                        return false;
                    }
                    switch (ineq) {
                        case '':
                        case '==':
                            return memberCount == rhs;
                        case '<':
                            return memberCount < rhs;
                        case '>':
                            return memberCount > rhs;
                        case '<=':
                            return memberCount <= rhs;
                        case '>=':
                            return memberCount >= rhs;
                        default:
                            return false;
                    }
                };
                var eventFulfillsDisplayNameCondition = function eventFulfillsDisplayNameCondition(cond, ev) {
                    var content = ev.getContent();
                    if (ev.isEncrypted() && ev.getClearContent()) {
                        content = ev.getClearContent();
                    }
                    if (!content || !content.body || typeof content.body != 'string') {
                        return false;
                    }
                    var room = client.getRoom(ev.getRoomId());
                    if (!room || !room.currentState || !room.currentState.members || !room.currentState.getMember(client.credentials.userId)) {
                        return false;
                    }
                    var displayName = room.currentState.getMember(client.credentials.userId).name;
                    var pat = new RegExp("(^|\\W)" + (0, _utils.escapeRegExp)(displayName) + "(\\W|$)", 'i');
                    return content.body.search(pat) > -1;
                };
                var eventFulfillsEventMatchCondition = function eventFulfillsEventMatchCondition(cond, ev) {
                    if (!cond.key) {
                        return false;
                    }
                    var val = valueForDottedKey(cond.key, ev);
                    if (typeof val !== 'string') {
                        return false;
                    }
                    if (cond.value) {
                        return cond.value === val;
                    }
                    var regex;
                    if (cond.key == 'content.body') {
                        regex = createCachedRegex('(^|\\W)', cond.pattern, '(\\W|$)');
                    }
                    else {
                        regex = createCachedRegex('^', cond.pattern, '$');
                    }
                    return !!val.match(regex);
                };
                var createCachedRegex = function createCachedRegex(prefix, glob, suffix) {
                    if (cachedGlobToRegex[glob]) {
                        return cachedGlobToRegex[glob];
                    }
                    cachedGlobToRegex[glob] = new RegExp(prefix + (0, _utils.globToRegexp)(glob) + suffix, 'i');
                    return cachedGlobToRegex[glob];
                };
                var valueForDottedKey = function valueForDottedKey(key, ev) {
                    var parts = key.split('.');
                    var val;
                    var firstPart = parts[0];
                    if (firstPart === 'content') {
                        val = ev.getContent();
                        parts.shift();
                    }
                    else if (firstPart === 'type') {
                        val = ev.getType();
                        parts.shift();
                    }
                    else {
                        val = ev.event;
                    }
                    while (parts.length > 0) {
                        var thisPart = parts.shift();
                        if ((0, _utils.isNullOrUndefined)(val[thisPart])) {
                            return null;
                        }
                        val = val[thisPart];
                    }
                    return val;
                };
                var matchingRuleForEventWithRulesets = function matchingRuleForEventWithRulesets(ev, rulesets) {
                    if (!rulesets) {
                        return null;
                    }
                    if (ev.getSender() === client.credentials.userId) {
                        return null;
                    }
                    return matchingRuleFromKindSet(ev, rulesets.global);
                };
                var pushActionsForEventAndRulesets = function pushActionsForEventAndRulesets(ev, rulesets) {
                    var rule = matchingRuleForEventWithRulesets(ev, rulesets);
                    if (!rule) {
                        return {};
                    }
                    var actionObj = PushProcessor.actionListToActionsObject(rule.actions);
                    if (actionObj.tweaks.highlight === undefined) {
                        actionObj.tweaks.highlight = rule.kind == 'content';
                    }
                    return actionObj;
                };
                this.ruleMatchesEvent = function (rule, ev) {
                    var ret = true;
                    for (var i = 0; i < rule.conditions.length; ++i) {
                        var cond = rule.conditions[i];
                        ret &= eventFulfillsCondition(cond, ev);
                    }
                    return ret;
                };
                this.actionsForEvent = function (ev) {
                    return pushActionsForEventAndRulesets(ev, client.pushRules);
                };
                this.getPushRuleById = function (ruleId) {
                    for (var _i = 0, _arr = ['global']; _i < _arr.length; _i++) {
                        var scope = _arr[_i];
                        if (client.pushRules[scope] === undefined)
                            continue;
                        var _iterator = _createForOfIteratorHelper(RULEKINDS_IN_ORDER), _step;
                        try {
                            for (_iterator.s(); !(_step = _iterator.n()).done;) {
                                var kind = _step.value;
                                if (client.pushRules[scope][kind] === undefined)
                                    continue;
                                var _iterator2 = _createForOfIteratorHelper(client.pushRules[scope][kind]), _step2;
                                try {
                                    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                                        var rule = _step2.value;
                                        if (rule.rule_id === ruleId)
                                            return rule;
                                    }
                                }
                                catch (err) {
                                    _iterator2.e(err);
                                }
                                finally {
                                    _iterator2.f();
                                }
                            }
                        }
                        catch (err) {
                            _iterator.e(err);
                        }
                        finally {
                            _iterator.f();
                        }
                    }
                    return null;
                };
            }
            PushProcessor.actionListToActionsObject = function (actionlist) {
                var actionobj = {
                    'notify': false,
                    'tweaks': {}
                };
                for (var i = 0; i < actionlist.length; ++i) {
                    var action = actionlist[i];
                    if (action === 'notify') {
                        actionobj.notify = true;
                    }
                    else if ((0, _typeof2["default"])(action) === 'object') {
                        if (action.value === undefined) {
                            action.value = true;
                        }
                        actionobj.tweaks[action.set_tweak] = action.value;
                    }
                }
                return actionobj;
            };
            PushProcessor.rewriteDefaultRules = function (incomingRules) {
                var newRules = JSON.parse(JSON.stringify(incomingRules));
                if (!newRules)
                    newRules = {};
                if (!newRules.global)
                    newRules.global = {};
                if (!newRules.global.override)
                    newRules.global.override = [];
                var globalOverrides = newRules.global.override;
                var _iterator3 = _createForOfIteratorHelper(DEFAULT_OVERRIDE_RULES), _step3;
                try {
                    var _loop = function _loop() {
                        var override = _step3.value;
                        var existingRule = globalOverrides.find(function (r) {
                            return r.rule_id === override.rule_id;
                        });
                        if (existingRule) {
                            existingRule["default"] = override["default"];
                            existingRule.conditions = override.conditions;
                            existingRule.actions = override.actions;
                        }
                        else {
                            var ruleId = override.rule_id;
                            _logger.logger.warn("Adding default global override for ".concat(ruleId));
                            globalOverrides.push(override);
                        }
                    };
                    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                        _loop();
                    }
                }
                catch (err) {
                    _iterator3.e(err);
                }
                finally {
                    _iterator3.f();
                }
                return newRules;
            };
        }, { "./logger": 97, "./utils": 125, "@babel/runtime/helpers/interopRequireDefault": 12, "@babel/runtime/helpers/typeof": 24 }], 112: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", { value: true });
            exports.randomUppercaseString = exports.randomLowercaseString = exports.randomString = void 0;
            const LOWERCASE = "abcdefghijklmnopqrstuvwxyz";
            const UPPERCASE = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
            const DIGITS = "0123456789";
            function randomString(len) {
                return randomStringFrom(len, UPPERCASE + LOWERCASE + DIGITS);
            }
            exports.randomString = randomString;
            function randomLowercaseString(len) {
                return randomStringFrom(len, LOWERCASE);
            }
            exports.randomLowercaseString = randomLowercaseString;
            function randomUppercaseString(len) {
                return randomStringFrom(len, UPPERCASE);
            }
            exports.randomUppercaseString = randomUppercaseString;
            function randomStringFrom(len, chars) {
                let ret = "";
                for (let i = 0; i < len; ++i) {
                    ret += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return ret;
            }
        }, {}], 113: [function (require, module, exports) {
            (function (global) {
                (function () {
                    "use strict";
                    Object.defineProperty(exports, "__esModule", {
                        value: true
                    });
                    exports.setNow = setNow;
                    exports.setTimeout = setTimeout;
                    exports.clearTimeout = clearTimeout;
                    var _logger = require("./logger");
                    var TIMER_CHECK_PERIOD_MS = 1000;
                    var _count = 0;
                    var _realCallbackKey;
                    var _callbackList = [];
                    var debuglog = function debuglog() { };
                    function setNow(f) {
                        _now = f || Date.now;
                    }
                    var _now = Date.now;
                    function setTimeout(func, delayMs) {
                        delayMs = delayMs || 0;
                        if (delayMs < 0) {
                            delayMs = 0;
                        }
                        var params = Array.prototype.slice.call(arguments, 2);
                        var runAt = _now() + delayMs;
                        var key = _count++;
                        debuglog("setTimeout: scheduling cb", key, "at", runAt, "(delay", delayMs, ")");
                        var data = {
                            runAt: runAt,
                            func: func,
                            params: params,
                            key: key
                        };
                        var idx = binarySearch(_callbackList, function (el) {
                            return el.runAt - runAt;
                        });
                        _callbackList.splice(idx, 0, data);
                        _scheduleRealCallback();
                        return key;
                    }
                    function clearTimeout(key) {
                        if (_callbackList.length === 0) {
                            return;
                        }
                        var i;
                        for (i = 0; i < _callbackList.length; i++) {
                            var cb = _callbackList[i];
                            if (cb.key == key) {
                                _callbackList.splice(i, 1);
                                break;
                            }
                        }
                        if (i === 0) {
                            _scheduleRealCallback();
                        }
                    }
                    function _scheduleRealCallback() {
                        if (_realCallbackKey) {
                            global.clearTimeout(_realCallbackKey);
                        }
                        var first = _callbackList[0];
                        if (!first) {
                            debuglog("_scheduleRealCallback: no more callbacks, not rescheduling");
                            return;
                        }
                        var now = _now();
                        var delayMs = Math.min(first.runAt - now, TIMER_CHECK_PERIOD_MS);
                        debuglog("_scheduleRealCallback: now:", now, "delay:", delayMs);
                        _realCallbackKey = global.setTimeout(_runCallbacks, delayMs);
                    }
                    function _runCallbacks() {
                        var cb;
                        var now = _now();
                        debuglog("_runCallbacks: now:", now);
                        var callbacksToRun = [];
                        while (true) {
                            var first = _callbackList[0];
                            if (!first || first.runAt > now) {
                                break;
                            }
                            cb = _callbackList.shift();
                            debuglog("_runCallbacks: popping", cb.key);
                            callbacksToRun.push(cb);
                        }
                        _scheduleRealCallback();
                        for (var i = 0; i < callbacksToRun.length; i++) {
                            cb = callbacksToRun[i];
                            try {
                                cb.func.apply(global, cb.params);
                            }
                            catch (e) {
                                _logger.logger.error("Uncaught exception in callback function", e.stack || e);
                            }
                        }
                    }
                    function binarySearch(array, func) {
                        var min = 0;
                        var max = array.length;
                        while (min < max) {
                            var mid = min + max >> 1;
                            var res = func(array[mid]);
                            if (res > 0) {
                                max = mid;
                            }
                            else {
                                min = mid + 1;
                            }
                        }
                        return min;
                    }
                }).call(this);
            }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, { "./logger": 97 }], 114: [function (require, module, exports) {
            "use strict";
            var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.MatrixScheduler = MatrixScheduler;
            var utils = _interopRequireWildcard(require("./utils"));
            var _logger = require("./logger");
            var DEBUG = false;
            function MatrixScheduler(retryAlgorithm, queueAlgorithm) {
                this.retryAlgorithm = retryAlgorithm || MatrixScheduler.RETRY_BACKOFF_RATELIMIT;
                this.queueAlgorithm = queueAlgorithm || MatrixScheduler.QUEUE_MESSAGES;
                this._queues = {};
                this._activeQueues = [];
                this._procFn = null;
            }
            MatrixScheduler.prototype.getQueueForEvent = function (event) {
                var name = this.queueAlgorithm(event);
                if (!name || !this._queues[name]) {
                    return null;
                }
                return utils.map(this._queues[name], function (obj) {
                    return obj.event;
                });
            };
            MatrixScheduler.prototype.removeEventFromQueue = function (event) {
                var name = this.queueAlgorithm(event);
                if (!name || !this._queues[name]) {
                    return false;
                }
                var removed = false;
                utils.removeElement(this._queues[name], function (element) {
                    if (element.event.getId() === event.getId()) {
                        removed = true;
                        return true;
                    }
                });
                return removed;
            };
            MatrixScheduler.prototype.setProcessFunction = function (fn) {
                this._procFn = fn;
                _startProcessingQueues(this);
            };
            MatrixScheduler.prototype.queueEvent = function (event) {
                var queueName = this.queueAlgorithm(event);
                if (!queueName) {
                    return null;
                }
                if (!this._queues[queueName]) {
                    this._queues[queueName] = [];
                }
                var defer = utils.defer();
                this._queues[queueName].push({
                    event: event,
                    defer: defer,
                    attempts: 0
                });
                debuglog("Queue algorithm dumped event %s into queue '%s'", event.getId(), queueName);
                _startProcessingQueues(this);
                return defer.promise;
            };
            MatrixScheduler.RETRY_BACKOFF_RATELIMIT = function (event, attempts, err) {
                if (err.httpStatus === 400 || err.httpStatus === 403 || err.httpStatus === 401) {
                    return -1;
                }
                if (err.cors === "rejected") {
                    return -1;
                }
                if (err.name === "M_TOO_LARGE") {
                    return -1;
                }
                if (err.name === "M_LIMIT_EXCEEDED") {
                    var waitTime = err.data.retry_after_ms;
                    if (waitTime > 0) {
                        return waitTime;
                    }
                }
                if (attempts > 4) {
                    return -1;
                }
                return 1000 * Math.pow(2, attempts);
            };
            MatrixScheduler.QUEUE_MESSAGES = function (event) {
                if (event.getType() === "m.room.message" || event.hasAssocation()) {
                    return "message";
                }
                return null;
            };
            function _startProcessingQueues(scheduler) {
                if (!scheduler._procFn) {
                    return;
                }
                utils.forEach(utils.filter(utils.keys(scheduler._queues), function (queueName) {
                    return scheduler._activeQueues.indexOf(queueName) === -1 && scheduler._queues[queueName].length > 0;
                }), function (queueName) {
                    scheduler._activeQueues.push(queueName);
                    debuglog("Spinning up queue: '%s'", queueName);
                    _processQueue(scheduler, queueName);
                });
            }
            function _processQueue(scheduler, queueName) {
                var obj = _peekNextEvent(scheduler, queueName);
                if (!obj) {
                    var index = scheduler._activeQueues.indexOf(queueName);
                    if (index >= 0) {
                        scheduler._activeQueues.splice(index, 1);
                    }
                    debuglog("Stopping queue '%s' as it is now empty", queueName);
                    return;
                }
                debuglog("Queue '%s' has %s pending events", queueName, scheduler._queues[queueName].length);
                Promise.resolve().then(function () {
                    return scheduler._procFn(obj.event);
                }).then(function (res) {
                    _removeNextEvent(scheduler, queueName);
                    debuglog("Queue '%s' sent event %s", queueName, obj.event.getId());
                    obj.defer.resolve(res);
                    _processQueue(scheduler, queueName);
                }, function (err) {
                    obj.attempts += 1;
                    var waitTimeMs = scheduler.retryAlgorithm(obj.event, obj.attempts, err);
                    debuglog("retry(%s) err=%s event_id=%s waitTime=%s", obj.attempts, err, obj.event.getId(), waitTimeMs);
                    if (waitTimeMs === -1) {
                        debuglog("Queue '%s' giving up on event %s", queueName, obj.event.getId());
                        _removeNextEvent(scheduler, queueName);
                        obj.defer.reject(err);
                        _processQueue(scheduler, queueName);
                    }
                    else {
                        setTimeout(function () {
                            _processQueue(scheduler, queueName);
                        }, waitTimeMs);
                    }
                });
            }
            function _peekNextEvent(scheduler, queueName) {
                var queue = scheduler._queues[queueName];
                if (!utils.isArray(queue)) {
                    return null;
                }
                return queue[0];
            }
            function _removeNextEvent(scheduler, queueName) {
                var queue = scheduler._queues[queueName];
                if (!utils.isArray(queue)) {
                    return null;
                }
                return queue.shift();
            }
            function debuglog() {
                if (DEBUG) {
                    _logger.logger.log.apply(_logger.logger, arguments);
                }
            }
        }, { "./logger": 97, "./utils": 125, "@babel/runtime/helpers/interopRequireWildcard": 13 }], 115: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.SERVICE_TYPES = void 0;
            var SERVICE_TYPES = Object.freeze({
                IS: 'SERVICE_TYPE_IS',
                IM: 'SERVICE_TYPE_IM'
            });
            exports.SERVICE_TYPES = SERVICE_TYPES;
        }, {}], 116: [function (require, module, exports) {
            "use strict";
            var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
            var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.LocalIndexedDBStoreBackend = LocalIndexedDBStoreBackend;
            var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
            var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
            var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
            var _syncAccumulator = require("../sync-accumulator");
            var utils = _interopRequireWildcard(require("../utils"));
            var IndexedDBHelpers = _interopRequireWildcard(require("../indexeddb-helpers"));
            var _logger = require("../logger");
            function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
                if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                    if (it)
                        o = it;
                    var i = 0;
                    var F = function F() { };
                    return { s: F, n: function n() { if (i >= o.length)
                            return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try {
                    if (!normalCompletion && it["return"] != null)
                        it["return"]();
                }
                finally {
                    if (didErr)
                        throw err;
                } } }; }
            function _unsupportedIterableToArray(o, minLen) { if (!o)
                return; if (typeof o === "string")
                return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor)
                n = o.constructor.name; if (n === "Map" || n === "Set")
                return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return _arrayLikeToArray(o, minLen); }
            function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length)
                len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
            } return arr2; }
            var VERSION = 3;
            function createDatabase(db) {
                db.createObjectStore("users", {
                    keyPath: ["userId"]
                });
                db.createObjectStore("accountData", {
                    keyPath: ["type"]
                });
                db.createObjectStore("sync", {
                    keyPath: ["clobber"]
                });
            }
            function upgradeSchemaV2(db) {
                var oobMembersStore = db.createObjectStore("oob_membership_events", {
                    keyPath: ["room_id", "state_key"]
                });
                oobMembersStore.createIndex("room", "room_id");
            }
            function upgradeSchemaV3(db) {
                db.createObjectStore("client_options", {
                    keyPath: ["clobber"]
                });
            }
            function selectQuery(store, keyRange, resultMapper) {
                var query = store.openCursor(keyRange);
                return new Promise(function (resolve, reject) {
                    var results = [];
                    query.onerror = function (event) {
                        reject(new Error("Query failed: " + event.target.errorCode));
                    };
                    query.onsuccess = function (event) {
                        var cursor = event.target.result;
                        if (!cursor) {
                            resolve(results);
                            return;
                        }
                        results.push(resultMapper(cursor));
                        cursor["continue"]();
                    };
                });
            }
            function txnAsPromise(txn) {
                return new Promise(function (resolve, reject) {
                    txn.oncomplete = function (event) {
                        resolve(event);
                    };
                    txn.onerror = function (event) {
                        reject(event.target.error);
                    };
                });
            }
            function reqAsEventPromise(req) {
                return new Promise(function (resolve, reject) {
                    req.onsuccess = function (event) {
                        resolve(event);
                    };
                    req.onerror = function (event) {
                        reject(event.target.error);
                    };
                });
            }
            function reqAsPromise(req) {
                return new Promise(function (resolve, reject) {
                    req.onsuccess = function () {
                        return resolve(req);
                    };
                    req.onerror = function (err) {
                        return reject(err);
                    };
                });
            }
            function reqAsCursorPromise(req) {
                return reqAsEventPromise(req).then(function (event) {
                    return event.target.result;
                });
            }
            function LocalIndexedDBStoreBackend(indexedDBInterface, dbName) {
                this.indexedDB = indexedDBInterface;
                this._dbName = "matrix-js-sdk:" + (dbName || "default");
                this.db = null;
                this._disconnected = true;
                this._syncAccumulator = new _syncAccumulator.SyncAccumulator();
                this._isNewlyCreated = false;
            }
            LocalIndexedDBStoreBackend.exists = function (indexedDB, dbName) {
                dbName = "matrix-js-sdk:" + (dbName || "default");
                return IndexedDBHelpers.exists(indexedDB, dbName);
            };
            LocalIndexedDBStoreBackend.prototype = {
                connect: function connect() {
                    var _this = this;
                    if (!this._disconnected) {
                        _logger.logger.log("LocalIndexedDBStoreBackend.connect: already connected or connecting");
                        return Promise.resolve();
                    }
                    this._disconnected = false;
                    _logger.logger.log("LocalIndexedDBStoreBackend.connect: connecting...");
                    var req = this.indexedDB.open(this._dbName, VERSION);
                    req.onupgradeneeded = function (ev) {
                        var db = ev.target.result;
                        var oldVersion = ev.oldVersion;
                        _logger.logger.log("LocalIndexedDBStoreBackend.connect: upgrading from ".concat(oldVersion));
                        if (oldVersion < 1) {
                            _this._isNewlyCreated = true;
                            createDatabase(db);
                        }
                        if (oldVersion < 2) {
                            upgradeSchemaV2(db);
                        }
                        if (oldVersion < 3) {
                            upgradeSchemaV3(db);
                        }
                    };
                    req.onblocked = function () {
                        _logger.logger.log("can't yet open LocalIndexedDBStoreBackend because it is open elsewhere");
                    };
                    _logger.logger.log("LocalIndexedDBStoreBackend.connect: awaiting connection...");
                    return reqAsEventPromise(req).then(function (ev) {
                        _logger.logger.log("LocalIndexedDBStoreBackend.connect: connected");
                        _this.db = ev.target.result;
                        _this.db.onversionchange = function () {
                            _this.db.close();
                        };
                        return _this._init();
                    });
                },
                isNewlyCreated: function isNewlyCreated() {
                    return Promise.resolve(this._isNewlyCreated);
                },
                _init: function _init() {
                    var _this2 = this;
                    return Promise.all([this._loadAccountData(), this._loadSyncData()]).then(function (_ref) {
                        var _ref2 = (0, _slicedToArray2["default"])(_ref, 2), accountData = _ref2[0], syncData = _ref2[1];
                        _logger.logger.log("LocalIndexedDBStoreBackend: loaded initial data");
                        _this2._syncAccumulator.accumulate({
                            next_batch: syncData.nextBatch,
                            rooms: syncData.roomsData,
                            groups: syncData.groupsData,
                            account_data: {
                                events: accountData
                            }
                        }, true);
                    });
                },
                getOutOfBandMembers: function getOutOfBandMembers(roomId) {
                    var _this3 = this;
                    return new Promise(function (resolve, reject) {
                        var tx = _this3.db.transaction(["oob_membership_events"], "readonly");
                        var store = tx.objectStore("oob_membership_events");
                        var roomIndex = store.index("room");
                        var range = IDBKeyRange.only(roomId);
                        var request = roomIndex.openCursor(range);
                        var membershipEvents = [];
                        var oobWritten = false;
                        request.onsuccess = function (event) {
                            var cursor = event.target.result;
                            if (!cursor) {
                                if (!membershipEvents.length && !oobWritten) {
                                    return resolve(null);
                                }
                                return resolve(membershipEvents);
                            }
                            var record = cursor.value;
                            if (record.oob_written) {
                                oobWritten = true;
                            }
                            else {
                                membershipEvents.push(record);
                            }
                            cursor["continue"]();
                        };
                        request.onerror = function (err) {
                            reject(err);
                        };
                    }).then(function (events) {
                        _logger.logger.log("LL: got ".concat(events && events.length) + " membershipEvents from storage for room ".concat(roomId, " ..."));
                        return events;
                    });
                },
                setOutOfBandMembers: function () {
                    var _setOutOfBandMembers = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee(roomId, membershipEvents) {
                        var tx, store, markerObject;
                        return _regenerator["default"].wrap(function _callee$(_context) {
                            while (1) {
                                switch (_context.prev = _context.next) {
                                    case 0:
                                        _logger.logger.log("LL: backend about to store ".concat(membershipEvents.length) + " members for ".concat(roomId));
                                        tx = this.db.transaction(["oob_membership_events"], "readwrite");
                                        store = tx.objectStore("oob_membership_events");
                                        membershipEvents.forEach(function (e) {
                                            store.put(e);
                                        });
                                        markerObject = {
                                            room_id: roomId,
                                            oob_written: true,
                                            state_key: 0
                                        };
                                        store.put(markerObject);
                                        _context.next = 8;
                                        return txnAsPromise(tx);
                                    case 8:
                                        _logger.logger.log("LL: backend done storing for ".concat(roomId, "!"));
                                    case 9:
                                    case "end":
                                        return _context.stop();
                                }
                            }
                        }, _callee, this);
                    }));
                    function setOutOfBandMembers(_x, _x2) {
                        return _setOutOfBandMembers.apply(this, arguments);
                    }
                    return setOutOfBandMembers;
                }(),
                clearOutOfBandMembers: function () {
                    var _clearOutOfBandMembers = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee2(roomId) {
                        var readTx, store, roomIndex, roomRange, minStateKeyProm, maxStateKeyProm, _yield$Promise$all, _yield$Promise$all2, minStateKey, maxStateKey, writeTx, writeStore, membersKeyRange;
                        return _regenerator["default"].wrap(function _callee2$(_context2) {
                            while (1) {
                                switch (_context2.prev = _context2.next) {
                                    case 0:
                                        readTx = this.db.transaction(["oob_membership_events"], "readonly");
                                        store = readTx.objectStore("oob_membership_events");
                                        roomIndex = store.index("room");
                                        roomRange = IDBKeyRange.only(roomId);
                                        minStateKeyProm = reqAsCursorPromise(roomIndex.openKeyCursor(roomRange, "next")).then(function (cursor) {
                                            return cursor && cursor.primaryKey[1];
                                        });
                                        maxStateKeyProm = reqAsCursorPromise(roomIndex.openKeyCursor(roomRange, "prev")).then(function (cursor) {
                                            return cursor && cursor.primaryKey[1];
                                        });
                                        _context2.next = 8;
                                        return Promise.all([minStateKeyProm, maxStateKeyProm]);
                                    case 8:
                                        _yield$Promise$all = _context2.sent;
                                        _yield$Promise$all2 = (0, _slicedToArray2["default"])(_yield$Promise$all, 2);
                                        minStateKey = _yield$Promise$all2[0];
                                        maxStateKey = _yield$Promise$all2[1];
                                        writeTx = this.db.transaction(["oob_membership_events"], "readwrite");
                                        writeStore = writeTx.objectStore("oob_membership_events");
                                        membersKeyRange = IDBKeyRange.bound([roomId, minStateKey], [roomId, maxStateKey]);
                                        _logger.logger.log("LL: Deleting all users + marker in storage for " + "room ".concat(roomId, ", with key range:"), [roomId, minStateKey], [roomId, maxStateKey]);
                                        _context2.next = 18;
                                        return reqAsPromise(writeStore["delete"](membersKeyRange));
                                    case 18:
                                    case "end":
                                        return _context2.stop();
                                }
                            }
                        }, _callee2, this);
                    }));
                    function clearOutOfBandMembers(_x3) {
                        return _clearOutOfBandMembers.apply(this, arguments);
                    }
                    return clearOutOfBandMembers;
                }(),
                clearDatabase: function clearDatabase() {
                    var _this4 = this;
                    return new Promise(function (resolve, reject) {
                        _logger.logger.log("Removing indexeddb instance: ".concat(_this4._dbName));
                        var req = _this4.indexedDB.deleteDatabase(_this4._dbName);
                        req.onblocked = function () {
                            _logger.logger.log("can't yet delete indexeddb ".concat(_this4._dbName) + " because it is open elsewhere");
                        };
                        req.onerror = function (ev) {
                            _logger.logger.warn("unable to delete js-sdk store indexeddb: ".concat(ev.target.error));
                            resolve();
                        };
                        req.onsuccess = function () {
                            _logger.logger.log("Removed indexeddb instance: ".concat(_this4._dbName));
                            resolve();
                        };
                    });
                },
                getSavedSync: function getSavedSync(copy) {
                    if (copy === undefined)
                        copy = true;
                    var data = this._syncAccumulator.getJSON();
                    if (!data.nextBatch)
                        return Promise.resolve(null);
                    if (copy) {
                        return Promise.resolve(utils.deepCopy(data));
                    }
                    else {
                        return Promise.resolve(data);
                    }
                },
                getNextBatchToken: function getNextBatchToken() {
                    return Promise.resolve(this._syncAccumulator.getNextBatchToken());
                },
                setSyncData: function setSyncData(syncData) {
                    var _this5 = this;
                    return Promise.resolve().then(function () {
                        _this5._syncAccumulator.accumulate(syncData);
                    });
                },
                syncToDatabase: function syncToDatabase(userTuples) {
                    var syncData = this._syncAccumulator.getJSON(true);
                    return Promise.all([this._persistUserPresenceEvents(userTuples), this._persistAccountData(syncData.accountData), this._persistSyncData(syncData.nextBatch, syncData.roomsData, syncData.groupsData)]);
                },
                _persistSyncData: function _persistSyncData(nextBatch, roomsData, groupsData) {
                    var _this6 = this;
                    _logger.logger.log("Persisting sync data up to", nextBatch);
                    return utils.promiseTry(function () {
                        var txn = _this6.db.transaction(["sync"], "readwrite");
                        var store = txn.objectStore("sync");
                        store.put({
                            clobber: "-",
                            nextBatch: nextBatch,
                            roomsData: roomsData,
                            groupsData: groupsData
                        });
                        return txnAsPromise(txn);
                    });
                },
                _persistAccountData: function _persistAccountData(accountData) {
                    var _this7 = this;
                    return utils.promiseTry(function () {
                        var txn = _this7.db.transaction(["accountData"], "readwrite");
                        var store = txn.objectStore("accountData");
                        for (var i = 0; i < accountData.length; i++) {
                            store.put(accountData[i]);
                        }
                        return txnAsPromise(txn);
                    });
                },
                _persistUserPresenceEvents: function _persistUserPresenceEvents(tuples) {
                    var _this8 = this;
                    return utils.promiseTry(function () {
                        var txn = _this8.db.transaction(["users"], "readwrite");
                        var store = txn.objectStore("users");
                        var _iterator = _createForOfIteratorHelper(tuples), _step;
                        try {
                            for (_iterator.s(); !(_step = _iterator.n()).done;) {
                                var tuple = _step.value;
                                store.put({
                                    userId: tuple[0],
                                    event: tuple[1]
                                });
                            }
                        }
                        catch (err) {
                            _iterator.e(err);
                        }
                        finally {
                            _iterator.f();
                        }
                        return txnAsPromise(txn);
                    });
                },
                getUserPresenceEvents: function getUserPresenceEvents() {
                    var _this9 = this;
                    return utils.promiseTry(function () {
                        var txn = _this9.db.transaction(["users"], "readonly");
                        var store = txn.objectStore("users");
                        return selectQuery(store, undefined, function (cursor) {
                            return [cursor.value.userId, cursor.value.event];
                        });
                    });
                },
                _loadAccountData: function _loadAccountData() {
                    var _this10 = this;
                    _logger.logger.log("LocalIndexedDBStoreBackend: loading account data...");
                    return utils.promiseTry(function () {
                        var txn = _this10.db.transaction(["accountData"], "readonly");
                        var store = txn.objectStore("accountData");
                        return selectQuery(store, undefined, function (cursor) {
                            return cursor.value;
                        }).then(function (result) {
                            _logger.logger.log("LocalIndexedDBStoreBackend: loaded account data");
                            return result;
                        });
                    });
                },
                _loadSyncData: function _loadSyncData() {
                    var _this11 = this;
                    _logger.logger.log("LocalIndexedDBStoreBackend: loading sync data...");
                    return utils.promiseTry(function () {
                        var txn = _this11.db.transaction(["sync"], "readonly");
                        var store = txn.objectStore("sync");
                        return selectQuery(store, undefined, function (cursor) {
                            return cursor.value;
                        }).then(function (results) {
                            _logger.logger.log("LocalIndexedDBStoreBackend: loaded sync data");
                            if (results.length > 1) {
                                _logger.logger.warn("loadSyncData: More than 1 sync row found.");
                            }
                            return results.length > 0 ? results[0] : {};
                        });
                    });
                },
                getClientOptions: function getClientOptions() {
                    var _this12 = this;
                    return Promise.resolve().then(function () {
                        var txn = _this12.db.transaction(["client_options"], "readonly");
                        var store = txn.objectStore("client_options");
                        return selectQuery(store, undefined, function (cursor) {
                            if (cursor.value && cursor.value && cursor.value.options) {
                                return cursor.value.options;
                            }
                        }).then(function (results) {
                            return results[0];
                        });
                    });
                },
                storeClientOptions: function () {
                    var _storeClientOptions = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee3(options) {
                        var txn, store;
                        return _regenerator["default"].wrap(function _callee3$(_context3) {
                            while (1) {
                                switch (_context3.prev = _context3.next) {
                                    case 0:
                                        txn = this.db.transaction(["client_options"], "readwrite");
                                        store = txn.objectStore("client_options");
                                        store.put({
                                            clobber: "-",
                                            options: options
                                        });
                                        _context3.next = 5;
                                        return txnAsPromise(txn);
                                    case 5:
                                    case "end":
                                        return _context3.stop();
                                }
                            }
                        }, _callee3, this);
                    }));
                    function storeClientOptions(_x4) {
                        return _storeClientOptions.apply(this, arguments);
                    }
                    return storeClientOptions;
                }()
            };
        }, { "../indexeddb-helpers": 95, "../logger": 97, "../sync-accumulator": 122, "../utils": 125, "@babel/runtime/helpers/asyncToGenerator": 5, "@babel/runtime/helpers/interopRequireDefault": 12, "@babel/runtime/helpers/interopRequireWildcard": 13, "@babel/runtime/helpers/slicedToArray": 22, "@babel/runtime/regenerator": 27 }], 117: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.RemoteIndexedDBStoreBackend = RemoteIndexedDBStoreBackend;
            var _logger = require("../logger");
            var _utils = require("../utils");
            function RemoteIndexedDBStoreBackend(workerScript, dbName, workerApi) {
                this._workerScript = workerScript;
                this._dbName = dbName;
                this._workerApi = workerApi;
                this._worker = null;
                this._nextSeq = 0;
                this._inFlight = {};
                this._startPromise = null;
            }
            RemoteIndexedDBStoreBackend.prototype = {
                connect: function connect() {
                    var _this = this;
                    return this._ensureStarted().then(function () {
                        return _this._doCmd('connect');
                    });
                },
                clearDatabase: function clearDatabase() {
                    var _this2 = this;
                    return this._ensureStarted().then(function () {
                        return _this2._doCmd('clearDatabase');
                    });
                },
                isNewlyCreated: function isNewlyCreated() {
                    return this._doCmd('isNewlyCreated');
                },
                getSavedSync: function getSavedSync() {
                    return this._doCmd('getSavedSync');
                },
                getNextBatchToken: function getNextBatchToken() {
                    return this._doCmd('getNextBatchToken');
                },
                setSyncData: function setSyncData(syncData) {
                    return this._doCmd('setSyncData', [syncData]);
                },
                syncToDatabase: function syncToDatabase(users) {
                    return this._doCmd('syncToDatabase', [users]);
                },
                getOutOfBandMembers: function getOutOfBandMembers(roomId) {
                    return this._doCmd('getOutOfBandMembers', [roomId]);
                },
                setOutOfBandMembers: function setOutOfBandMembers(roomId, membershipEvents) {
                    return this._doCmd('setOutOfBandMembers', [roomId, membershipEvents]);
                },
                clearOutOfBandMembers: function clearOutOfBandMembers(roomId) {
                    return this._doCmd('clearOutOfBandMembers', [roomId]);
                },
                getClientOptions: function getClientOptions() {
                    return this._doCmd('getClientOptions');
                },
                storeClientOptions: function storeClientOptions(options) {
                    return this._doCmd('storeClientOptions', [options]);
                },
                getUserPresenceEvents: function getUserPresenceEvents() {
                    return this._doCmd('getUserPresenceEvents');
                },
                _ensureStarted: function _ensureStarted() {
                    if (this._startPromise === null) {
                        this._worker = new this._workerApi(this._workerScript);
                        this._worker.onmessage = this._onWorkerMessage.bind(this);
                        this._startPromise = this._doCmd('_setupWorker', [this._dbName]).then(function () {
                            _logger.logger.log("IndexedDB worker is ready");
                        });
                    }
                    return this._startPromise;
                },
                _doCmd: function _doCmd(cmd, args) {
                    var _this3 = this;
                    return Promise.resolve().then(function () {
                        var seq = _this3._nextSeq++;
                        var def = (0, _utils.defer)();
                        _this3._inFlight[seq] = def;
                        _this3._worker.postMessage({
                            command: cmd,
                            seq: seq,
                            args: args
                        });
                        return def.promise;
                    });
                },
                _onWorkerMessage: function _onWorkerMessage(ev) {
                    var msg = ev.data;
                    if (msg.command == 'cmd_success' || msg.command == 'cmd_fail') {
                        if (msg.seq === undefined) {
                            _logger.logger.error("Got reply from worker with no seq");
                            return;
                        }
                        var def = this._inFlight[msg.seq];
                        if (def === undefined) {
                            _logger.logger.error("Got reply for unknown seq " + msg.seq);
                            return;
                        }
                        delete this._inFlight[msg.seq];
                        if (msg.command == 'cmd_success') {
                            def.resolve(msg.result);
                        }
                        else {
                            var error = new Error(msg.error.message);
                            error.name = msg.error.name;
                            def.reject(error);
                        }
                    }
                    else {
                        _logger.logger.warn("Unrecognised message from worker: " + msg);
                    }
                }
            };
        }, { "../logger": 97, "../utils": 125 }], 118: [function (require, module, exports) {
            (function (global) {
                (function () {
                    "use strict";
                    var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
                    var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
                    Object.defineProperty(exports, "__esModule", {
                        value: true
                    });
                    exports.IndexedDBStore = IndexedDBStore;
                    var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
                    var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
                    var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
                    var _memory = require("./memory");
                    var utils = _interopRequireWildcard(require("../utils"));
                    var _events = require("events");
                    var _indexeddbLocalBackend = require("./indexeddb-local-backend.js");
                    var _indexeddbRemoteBackend = require("./indexeddb-remote-backend.js");
                    var _user = require("../models/user");
                    var _event = require("../models/event");
                    var _logger = require("../logger");
                    function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
                        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                            if (it)
                                o = it;
                            var i = 0;
                            var F = function F() { };
                            return { s: F, n: function n() { if (i >= o.length)
                                    return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F };
                        }
                        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                    } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try {
                            if (!normalCompletion && it["return"] != null)
                                it["return"]();
                        }
                        finally {
                            if (didErr)
                                throw err;
                        } } }; }
                    function _unsupportedIterableToArray(o, minLen) { if (!o)
                        return; if (typeof o === "string")
                        return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor)
                        n = o.constructor.name; if (n === "Map" || n === "Set")
                        return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                        return _arrayLikeToArray(o, minLen); }
                    function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length)
                        len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) {
                        arr2[i] = arr[i];
                    } return arr2; }
                    var WRITE_DELAY_MS = 1000 * 60 * 5;
                    function IndexedDBStore(opts) {
                        _memory.MemoryStore.call(this, opts);
                        if (!opts.indexedDB) {
                            throw new Error('Missing required option: indexedDB');
                        }
                        if (opts.workerScript) {
                            var workerApi = opts.workerApi;
                            if (!workerApi) {
                                workerApi = global.Worker;
                            }
                            this.backend = new _indexeddbRemoteBackend.RemoteIndexedDBStoreBackend(opts.workerScript, opts.dbName, workerApi);
                        }
                        else {
                            this.backend = new _indexeddbLocalBackend.LocalIndexedDBStoreBackend(opts.indexedDB, opts.dbName);
                        }
                        this.startedUp = false;
                        this._syncTs = 0;
                        this._userModifiedMap = {};
                    }
                    utils.inherits(IndexedDBStore, _memory.MemoryStore);
                    utils.extend(IndexedDBStore.prototype, _events.EventEmitter.prototype);
                    IndexedDBStore.exists = function (indexedDB, dbName) {
                        return _indexeddbLocalBackend.LocalIndexedDBStoreBackend.exists(indexedDB, dbName);
                    };
                    IndexedDBStore.prototype.startup = function () {
                        var _this = this;
                        if (this.startedUp) {
                            _logger.logger.log("IndexedDBStore.startup: already started");
                            return Promise.resolve();
                        }
                        _logger.logger.log("IndexedDBStore.startup: connecting to backend");
                        return this.backend.connect().then(function () {
                            _logger.logger.log("IndexedDBStore.startup: loading presence events");
                            return _this.backend.getUserPresenceEvents();
                        }).then(function (userPresenceEvents) {
                            _logger.logger.log("IndexedDBStore.startup: processing presence events");
                            userPresenceEvents.forEach(function (_ref) {
                                var _ref2 = (0, _slicedToArray2["default"])(_ref, 2), userId = _ref2[0], rawEvent = _ref2[1];
                                var u = new _user.User(userId);
                                if (rawEvent) {
                                    u.setPresenceEvent(new _event.MatrixEvent(rawEvent));
                                }
                                _this._userModifiedMap[u.userId] = u.getLastModifiedTime();
                                _this.storeUser(u);
                            });
                        });
                    };
                    IndexedDBStore.prototype.getSavedSync = degradable(function () {
                        return this.backend.getSavedSync();
                    }, "getSavedSync");
                    IndexedDBStore.prototype.isNewlyCreated = degradable(function () {
                        return this.backend.isNewlyCreated();
                    }, "isNewlyCreated");
                    IndexedDBStore.prototype.getSavedSyncToken = degradable(function () {
                        return this.backend.getNextBatchToken();
                    }, "getSavedSyncToken"),
                        IndexedDBStore.prototype.deleteAllData = degradable(function () {
                            _memory.MemoryStore.prototype.deleteAllData.call(this);
                            return this.backend.clearDatabase().then(function () {
                                _logger.logger.log("Deleted indexeddb data.");
                            }, function (err) {
                                _logger.logger.error("Failed to delete indexeddb data: ".concat(err));
                                throw err;
                            });
                        });
                    IndexedDBStore.prototype.wantsSave = function () {
                        var now = Date.now();
                        return now - this._syncTs > WRITE_DELAY_MS;
                    };
                    IndexedDBStore.prototype.save = function (force) {
                        if (force || this.wantsSave()) {
                            return this._reallySave();
                        }
                        return Promise.resolve();
                    };
                    IndexedDBStore.prototype._reallySave = degradable(function () {
                        this._syncTs = Date.now();
                        var userTuples = [];
                        var _iterator = _createForOfIteratorHelper(this.getUsers()), _step;
                        try {
                            for (_iterator.s(); !(_step = _iterator.n()).done;) {
                                var u = _step.value;
                                if (this._userModifiedMap[u.userId] === u.getLastModifiedTime())
                                    continue;
                                if (!u.events.presence)
                                    continue;
                                userTuples.push([u.userId, u.events.presence.event]);
                                this._userModifiedMap[u.userId] = u.getLastModifiedTime();
                            }
                        }
                        catch (err) {
                            _iterator.e(err);
                        }
                        finally {
                            _iterator.f();
                        }
                        return this.backend.syncToDatabase(userTuples);
                    });
                    IndexedDBStore.prototype.setSyncData = degradable(function (syncData) {
                        return this.backend.setSyncData(syncData);
                    }, "setSyncData");
                    IndexedDBStore.prototype.getOutOfBandMembers = degradable(function (roomId) {
                        return this.backend.getOutOfBandMembers(roomId);
                    }, "getOutOfBandMembers");
                    IndexedDBStore.prototype.setOutOfBandMembers = degradable(function (roomId, membershipEvents) {
                        _memory.MemoryStore.prototype.setOutOfBandMembers.call(this, roomId, membershipEvents);
                        return this.backend.setOutOfBandMembers(roomId, membershipEvents);
                    }, "setOutOfBandMembers");
                    IndexedDBStore.prototype.clearOutOfBandMembers = degradable(function (roomId) {
                        _memory.MemoryStore.prototype.clearOutOfBandMembers.call(this);
                        return this.backend.clearOutOfBandMembers(roomId);
                    }, "clearOutOfBandMembers");
                    IndexedDBStore.prototype.getClientOptions = degradable(function () {
                        return this.backend.getClientOptions();
                    }, "getClientOptions");
                    IndexedDBStore.prototype.storeClientOptions = degradable(function (options) {
                        _memory.MemoryStore.prototype.storeClientOptions.call(this, options);
                        return this.backend.storeClientOptions(options);
                    }, "storeClientOptions");
                    function degradable(func, fallback) {
                        return (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee() {
                            var _len, args, _key, _MemoryStore$prototyp, _args = arguments;
                            return _regenerator["default"].wrap(function _callee$(_context) {
                                while (1) {
                                    switch (_context.prev = _context.next) {
                                        case 0:
                                            for (_len = _args.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                                                args[_key] = _args[_key];
                                            }
                                            _context.prev = 1;
                                            _context.next = 4;
                                            return func.call.apply(func, [this].concat(args));
                                        case 4:
                                            return _context.abrupt("return", _context.sent);
                                        case 7:
                                            _context.prev = 7;
                                            _context.t0 = _context["catch"](1);
                                            _logger.logger.error("IndexedDBStore failure, degrading to MemoryStore", _context.t0);
                                            this.emit("degraded", _context.t0);
                                            _context.prev = 11;
                                            _logger.logger.log("IndexedDBStore trying to delete degraded data");
                                            _context.next = 15;
                                            return this.backend.clearDatabase();
                                        case 15:
                                            _logger.logger.log("IndexedDBStore delete after degrading succeeeded");
                                            _context.next = 21;
                                            break;
                                        case 18:
                                            _context.prev = 18;
                                            _context.t1 = _context["catch"](11);
                                            _logger.logger.warn("IndexedDBStore delete after degrading failed", _context.t1);
                                        case 21:
                                            Object.setPrototypeOf(this, _memory.MemoryStore.prototype);
                                            if (!fallback) {
                                                _context.next = 26;
                                                break;
                                            }
                                            _context.next = 25;
                                            return (_MemoryStore$prototyp = _memory.MemoryStore.prototype[fallback]).call.apply(_MemoryStore$prototyp, [this].concat(args));
                                        case 25:
                                            return _context.abrupt("return", _context.sent);
                                        case 26:
                                        case "end":
                                            return _context.stop();
                                    }
                                }
                            }, _callee, this, [[1, 7], [11, 18]]);
                        }));
                    }
                }).call(this);
            }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, { "../logger": 97, "../models/event": 102, "../models/user": 110, "../utils": 125, "./indexeddb-local-backend.js": 116, "./indexeddb-remote-backend.js": 117, "./memory": 119, "@babel/runtime/helpers/asyncToGenerator": 5, "@babel/runtime/helpers/interopRequireDefault": 12, "@babel/runtime/helpers/interopRequireWildcard": 13, "@babel/runtime/helpers/slicedToArray": 22, "@babel/runtime/regenerator": 27, "events": 36 }], 119: [function (require, module, exports) {
            "use strict";
            var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.MemoryStore = MemoryStore;
            var _user = require("../models/user");
            var utils = _interopRequireWildcard(require("../utils"));
            function isValidFilterId(filterId) {
                var isValidStr = typeof filterId === "string" && !!filterId && filterId !== "undefined" &&
                    filterId !== "null";
                return isValidStr || typeof filterId === "number";
            }
            function MemoryStore(opts) {
                opts = opts || {};
                this.rooms = {};
                this.groups = {};
                this.users = {};
                this.syncToken = null;
                this.filters = {};
                this.accountData = {};
                this.localStorage = opts.localStorage;
                this._oobMembers = {};
                this._clientOptions = {};
            }
            MemoryStore.prototype = {
                getSyncToken: function getSyncToken() {
                    return this.syncToken;
                },
                isNewlyCreated: function isNewlyCreated() {
                    return Promise.resolve(true);
                },
                setSyncToken: function setSyncToken(token) {
                    this.syncToken = token;
                },
                storeGroup: function storeGroup(group) {
                    this.groups[group.groupId] = group;
                },
                getGroup: function getGroup(groupId) {
                    return this.groups[groupId] || null;
                },
                getGroups: function getGroups() {
                    return utils.values(this.groups);
                },
                storeRoom: function storeRoom(room) {
                    this.rooms[room.roomId] = room;
                    room.currentState.on("RoomState.members", this._onRoomMember.bind(this));
                    var self = this;
                    room.currentState.getMembers().forEach(function (m) {
                        self._onRoomMember(null, room.currentState, m);
                    });
                },
                _onRoomMember: function _onRoomMember(event, state, member) {
                    if (member.membership === "invite") {
                        return;
                    }
                    var user = this.users[member.userId] || new _user.User(member.userId);
                    if (member.name) {
                        user.setDisplayName(member.name);
                        if (member.events.member) {
                            user.setRawDisplayName(member.events.member.getDirectionalContent().displayname);
                        }
                    }
                    if (member.events.member && member.events.member.getContent().avatar_url) {
                        user.setAvatarUrl(member.events.member.getContent().avatar_url);
                    }
                    this.users[user.userId] = user;
                },
                getRoom: function getRoom(roomId) {
                    return this.rooms[roomId] || null;
                },
                getRooms: function getRooms() {
                    return utils.values(this.rooms);
                },
                removeRoom: function removeRoom(roomId) {
                    if (this.rooms[roomId]) {
                        this.rooms[roomId].removeListener("RoomState.members", this._onRoomMember);
                    }
                    delete this.rooms[roomId];
                },
                getRoomSummaries: function getRoomSummaries() {
                    return utils.map(utils.values(this.rooms), function (room) {
                        return room.summary;
                    });
                },
                storeUser: function storeUser(user) {
                    this.users[user.userId] = user;
                },
                getUser: function getUser(userId) {
                    return this.users[userId] || null;
                },
                getUsers: function getUsers() {
                    return utils.values(this.users);
                },
                scrollback: function scrollback(room, limit) {
                    return [];
                },
                storeEvents: function storeEvents(room, events, token, toStart) {
                },
                storeFilter: function storeFilter(filter) {
                    if (!filter) {
                        return;
                    }
                    if (!this.filters[filter.userId]) {
                        this.filters[filter.userId] = {};
                    }
                    this.filters[filter.userId][filter.filterId] = filter;
                },
                getFilter: function getFilter(userId, filterId) {
                    if (!this.filters[userId] || !this.filters[userId][filterId]) {
                        return null;
                    }
                    return this.filters[userId][filterId];
                },
                getFilterIdByName: function getFilterIdByName(filterName) {
                    if (!this.localStorage) {
                        return null;
                    }
                    var key = "mxjssdk_memory_filter_" + filterName;
                    try {
                        var value = this.localStorage.getItem(key);
                        if (isValidFilterId(value)) {
                            return value;
                        }
                    }
                    catch (e) { }
                    return null;
                },
                setFilterIdByName: function setFilterIdByName(filterName, filterId) {
                    if (!this.localStorage) {
                        return;
                    }
                    var key = "mxjssdk_memory_filter_" + filterName;
                    try {
                        if (isValidFilterId(filterId)) {
                            this.localStorage.setItem(key, filterId);
                        }
                        else {
                            this.localStorage.removeItem(key);
                        }
                    }
                    catch (e) { }
                },
                storeAccountDataEvents: function storeAccountDataEvents(events) {
                    var self = this;
                    events.forEach(function (event) {
                        self.accountData[event.getType()] = event;
                    });
                },
                getAccountData: function getAccountData(eventType) {
                    return this.accountData[eventType];
                },
                setSyncData: function setSyncData(syncData) {
                    return Promise.resolve();
                },
                wantsSave: function wantsSave() {
                    return false;
                },
                save: function save(force) { },
                startup: function startup() {
                    return Promise.resolve();
                },
                getSavedSync: function getSavedSync() {
                    return Promise.resolve(null);
                },
                getSavedSyncToken: function getSavedSyncToken() {
                    return Promise.resolve(null);
                },
                deleteAllData: function deleteAllData() {
                    this.rooms = {};
                    this.users = {};
                    this.syncToken = null;
                    this.filters = {};
                    this.accountData = {};
                    return Promise.resolve();
                },
                getOutOfBandMembers: function getOutOfBandMembers(roomId) {
                    return Promise.resolve(this._oobMembers[roomId] || null);
                },
                setOutOfBandMembers: function setOutOfBandMembers(roomId, membershipEvents) {
                    this._oobMembers[roomId] = membershipEvents;
                    return Promise.resolve();
                },
                clearOutOfBandMembers: function clearOutOfBandMembers() {
                    this._oobMembers = {};
                    return Promise.resolve();
                },
                getClientOptions: function getClientOptions() {
                    return Promise.resolve(this._clientOptions);
                },
                storeClientOptions: function storeClientOptions(options) {
                    this._clientOptions = Object.assign({}, options);
                    return Promise.resolve();
                }
            };
        }, { "../models/user": 110, "../utils": 125, "@babel/runtime/helpers/interopRequireWildcard": 13 }], 120: [function (require, module, exports) {
            "use strict";
            var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.WebStorageSessionStore = WebStorageSessionStore;
            var utils = _interopRequireWildcard(require("../../utils"));
            var _logger = require("../../logger");
            function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
                if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                    if (it)
                        o = it;
                    var i = 0;
                    var F = function F() { };
                    return { s: F, n: function n() { if (i >= o.length)
                            return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try {
                    if (!normalCompletion && it["return"] != null)
                        it["return"]();
                }
                finally {
                    if (didErr)
                        throw err;
                } } }; }
            function _unsupportedIterableToArray(o, minLen) { if (!o)
                return; if (typeof o === "string")
                return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor)
                n = o.constructor.name; if (n === "Map" || n === "Set")
                return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return _arrayLikeToArray(o, minLen); }
            function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length)
                len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
            } return arr2; }
            var DEBUG = false;
            var E2E_PREFIX = "session.e2e.";
            function WebStorageSessionStore(webStore) {
                this.store = webStore;
                if (!utils.isFunction(webStore.getItem) || !utils.isFunction(webStore.setItem) || !utils.isFunction(webStore.removeItem) || !utils.isFunction(webStore.key) || typeof webStore.length !== 'number') {
                    throw new Error("Supplied webStore does not meet the WebStorage API interface");
                }
            }
            WebStorageSessionStore.prototype = {
                removeEndToEndAccount: function removeEndToEndAccount() {
                    this.store.removeItem(KEY_END_TO_END_ACCOUNT);
                },
                getEndToEndAccount: function getEndToEndAccount() {
                    return this.store.getItem(KEY_END_TO_END_ACCOUNT);
                },
                getAllEndToEndDevices: function getAllEndToEndDevices() {
                    var prefix = keyEndToEndDevicesForUser('');
                    var devices = {};
                    for (var i = 0; i < this.store.length; ++i) {
                        var key = this.store.key(i);
                        var userId = key.substr(prefix.length);
                        if (key.startsWith(prefix))
                            devices[userId] = getJsonItem(this.store, key);
                    }
                    return devices;
                },
                getEndToEndDeviceTrackingStatus: function getEndToEndDeviceTrackingStatus() {
                    return getJsonItem(this.store, KEY_END_TO_END_DEVICE_LIST_TRACKING_STATUS);
                },
                getEndToEndDeviceSyncToken: function getEndToEndDeviceSyncToken() {
                    return getJsonItem(this.store, KEY_END_TO_END_DEVICE_SYNC_TOKEN);
                },
                removeEndToEndDeviceData: function removeEndToEndDeviceData() {
                    removeByPrefix(this.store, keyEndToEndDevicesForUser(''));
                    removeByPrefix(this.store, KEY_END_TO_END_DEVICE_LIST_TRACKING_STATUS);
                    removeByPrefix(this.store, KEY_END_TO_END_DEVICE_SYNC_TOKEN);
                },
                getEndToEndSessions: function getEndToEndSessions(deviceKey) {
                    return getJsonItem(this.store, keyEndToEndSessions(deviceKey));
                },
                getAllEndToEndSessions: function getAllEndToEndSessions() {
                    var deviceKeys = getKeysWithPrefix(this.store, keyEndToEndSessions(''));
                    var results = {};
                    var _iterator = _createForOfIteratorHelper(deviceKeys), _step;
                    try {
                        for (_iterator.s(); !(_step = _iterator.n()).done;) {
                            var k = _step.value;
                            var unprefixedKey = k.substr(keyEndToEndSessions('').length);
                            results[unprefixedKey] = getJsonItem(this.store, k);
                        }
                    }
                    catch (err) {
                        _iterator.e(err);
                    }
                    finally {
                        _iterator.f();
                    }
                    return results;
                },
                removeAllEndToEndSessions: function removeAllEndToEndSessions() {
                    removeByPrefix(this.store, keyEndToEndSessions(''));
                },
                getAllEndToEndInboundGroupSessionKeys: function getAllEndToEndInboundGroupSessionKeys() {
                    var prefix = E2E_PREFIX + 'inboundgroupsessions/';
                    var result = [];
                    for (var i = 0; i < this.store.length; i++) {
                        var key = this.store.key(i);
                        if (!key.startsWith(prefix)) {
                            continue;
                        }
                        result.push({
                            senderKey: key.substr(prefix.length, 43),
                            sessionId: key.substr(prefix.length + 44)
                        });
                    }
                    return result;
                },
                getEndToEndInboundGroupSession: function getEndToEndInboundGroupSession(senderKey, sessionId) {
                    var key = keyEndToEndInboundGroupSession(senderKey, sessionId);
                    return this.store.getItem(key);
                },
                removeAllEndToEndInboundGroupSessions: function removeAllEndToEndInboundGroupSessions() {
                    removeByPrefix(this.store, E2E_PREFIX + 'inboundgroupsessions/');
                },
                getAllEndToEndRooms: function getAllEndToEndRooms() {
                    var roomKeys = getKeysWithPrefix(this.store, keyEndToEndRoom(''));
                    var results = {};
                    var _iterator2 = _createForOfIteratorHelper(roomKeys), _step2;
                    try {
                        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                            var k = _step2.value;
                            var unprefixedKey = k.substr(keyEndToEndRoom('').length);
                            results[unprefixedKey] = getJsonItem(this.store, k);
                        }
                    }
                    catch (err) {
                        _iterator2.e(err);
                    }
                    finally {
                        _iterator2.f();
                    }
                    return results;
                },
                removeAllEndToEndRooms: function removeAllEndToEndRooms() {
                    removeByPrefix(this.store, keyEndToEndRoom(''));
                },
                setLocalTrustedBackupPubKey: function setLocalTrustedBackupPubKey(pubkey) {
                    this.store.setItem(KEY_END_TO_END_TRUSTED_BACKUP_PUBKEY, pubkey);
                },
                getLocalTrustedBackupPubKey: function getLocalTrustedBackupPubKey() {
                    return this.store.getItem(KEY_END_TO_END_TRUSTED_BACKUP_PUBKEY);
                }
            };
            var KEY_END_TO_END_ACCOUNT = E2E_PREFIX + "account";
            var KEY_END_TO_END_DEVICE_SYNC_TOKEN = E2E_PREFIX + "device_sync_token";
            var KEY_END_TO_END_DEVICE_LIST_TRACKING_STATUS = E2E_PREFIX + "device_tracking";
            var KEY_END_TO_END_TRUSTED_BACKUP_PUBKEY = E2E_PREFIX + "trusted_backup_pubkey";
            function keyEndToEndDevicesForUser(userId) {
                return E2E_PREFIX + "devices/" + userId;
            }
            function keyEndToEndSessions(deviceKey) {
                return E2E_PREFIX + "sessions/" + deviceKey;
            }
            function keyEndToEndInboundGroupSession(senderKey, sessionId) {
                return E2E_PREFIX + "inboundgroupsessions/" + senderKey + "/" + sessionId;
            }
            function keyEndToEndRoom(roomId) {
                return E2E_PREFIX + "rooms/" + roomId;
            }
            function getJsonItem(store, key) {
                try {
                    return JSON.parse(store.getItem(key));
                }
                catch (e) {
                    debuglog("Failed to get key %s: %s", key, e);
                    debuglog(e.stack);
                }
                return null;
            }
            function getKeysWithPrefix(store, prefix) {
                var results = [];
                for (var i = 0; i < store.length; ++i) {
                    var key = store.key(i);
                    if (key.startsWith(prefix))
                        results.push(key);
                }
                return results;
            }
            function removeByPrefix(store, prefix) {
                var toRemove = [];
                for (var i = 0; i < store.length; ++i) {
                    var key = store.key(i);
                    if (key.startsWith(prefix))
                        toRemove.push(key);
                }
                for (var _i = 0, _toRemove = toRemove; _i < _toRemove.length; _i++) {
                    var _key = _toRemove[_i];
                    store.removeItem(_key);
                }
            }
            function debuglog() {
                if (DEBUG) {
                    _logger.logger.log.apply(_logger.logger, arguments);
                }
            }
        }, { "../../logger": 97, "../../utils": 125, "@babel/runtime/helpers/interopRequireWildcard": 13 }], 121: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.StubStore = StubStore;
            function StubStore() {
                this.fromToken = null;
            }
            StubStore.prototype = {
                isNewlyCreated: function isNewlyCreated() {
                    return Promise.resolve(true);
                },
                getSyncToken: function getSyncToken() {
                    return this.fromToken;
                },
                setSyncToken: function setSyncToken(token) {
                    this.fromToken = token;
                },
                storeGroup: function storeGroup(group) { },
                getGroup: function getGroup(groupId) {
                    return null;
                },
                getGroups: function getGroups() {
                    return [];
                },
                storeRoom: function storeRoom(room) { },
                getRoom: function getRoom(roomId) {
                    return null;
                },
                getRooms: function getRooms() {
                    return [];
                },
                removeRoom: function removeRoom(roomId) {
                    return;
                },
                getRoomSummaries: function getRoomSummaries() {
                    return [];
                },
                storeUser: function storeUser(user) { },
                getUser: function getUser(userId) {
                    return null;
                },
                getUsers: function getUsers() {
                    return [];
                },
                scrollback: function scrollback(room, limit) {
                    return [];
                },
                storeEvents: function storeEvents(room, events, token, toStart) { },
                storeFilter: function storeFilter(filter) { },
                getFilter: function getFilter(userId, filterId) {
                    return null;
                },
                getFilterIdByName: function getFilterIdByName(filterName) {
                    return null;
                },
                setFilterIdByName: function setFilterIdByName(filterName, filterId) { },
                storeAccountDataEvents: function storeAccountDataEvents(events) { },
                getAccountData: function getAccountData(eventType) { },
                setSyncData: function setSyncData(syncData) {
                    return Promise.resolve();
                },
                wantsSave: function wantsSave() {
                    return false;
                },
                save: function save() { },
                startup: function startup() {
                    return Promise.resolve();
                },
                getSavedSync: function getSavedSync() {
                    return Promise.resolve(null);
                },
                getSavedSyncToken: function getSavedSyncToken() {
                    return Promise.resolve(null);
                },
                deleteAllData: function deleteAllData() {
                    return Promise.resolve();
                },
                getOutOfBandMembers: function getOutOfBandMembers() {
                    return Promise.resolve(null);
                },
                setOutOfBandMembers: function setOutOfBandMembers() {
                    return Promise.resolve();
                },
                clearOutOfBandMembers: function clearOutOfBandMembers() {
                    return Promise.resolve();
                },
                getClientOptions: function getClientOptions() {
                    return Promise.resolve();
                },
                storeClientOptions: function storeClientOptions() {
                    return Promise.resolve();
                }
            };
        }, {}], 122: [function (require, module, exports) {
            "use strict";
            var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.SyncAccumulator = void 0;
            var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
            var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
            var _logger = require("./logger");
            var _utils = require("./utils");
            var SyncAccumulator = function () {
                function SyncAccumulator(opts) {
                    (0, _classCallCheck2["default"])(this, SyncAccumulator);
                    opts = opts || {};
                    opts.maxTimelineEntries = opts.maxTimelineEntries || 50;
                    this.opts = opts;
                    this.accountData = {};
                    this.inviteRooms = {};
                    this.joinRooms = {};
                    this.nextBatch = null;
                    this.groups = {
                        invite: {},
                        join: {},
                        leave: {}
                    };
                }
                (0, _createClass2["default"])(SyncAccumulator, [{
                        key: "accumulate",
                        value: function accumulate(syncResponse, fromDatabase) {
                            this._accumulateRooms(syncResponse, fromDatabase);
                            this._accumulateGroups(syncResponse);
                            this._accumulateAccountData(syncResponse);
                            this.nextBatch = syncResponse.next_batch;
                        }
                    }, {
                        key: "_accumulateAccountData",
                        value: function _accumulateAccountData(syncResponse) {
                            var _this = this;
                            if (!syncResponse.account_data || !syncResponse.account_data.events) {
                                return;
                            }
                            syncResponse.account_data.events.forEach(function (e) {
                                _this.accountData[e.type] = e;
                            });
                        }
                    }, {
                        key: "_accumulateRooms",
                        value: function _accumulateRooms(syncResponse, fromDatabase) {
                            var _this2 = this;
                            if (!syncResponse.rooms) {
                                return;
                            }
                            if (syncResponse.rooms.invite) {
                                Object.keys(syncResponse.rooms.invite).forEach(function (roomId) {
                                    _this2._accumulateRoom(roomId, "invite", syncResponse.rooms.invite[roomId], fromDatabase);
                                });
                            }
                            if (syncResponse.rooms.join) {
                                Object.keys(syncResponse.rooms.join).forEach(function (roomId) {
                                    _this2._accumulateRoom(roomId, "join", syncResponse.rooms.join[roomId], fromDatabase);
                                });
                            }
                            if (syncResponse.rooms.leave) {
                                Object.keys(syncResponse.rooms.leave).forEach(function (roomId) {
                                    _this2._accumulateRoom(roomId, "leave", syncResponse.rooms.leave[roomId], fromDatabase);
                                });
                            }
                        }
                    }, {
                        key: "_accumulateRoom",
                        value: function _accumulateRoom(roomId, category, data, fromDatabase) {
                            switch (category) {
                                case "invite":
                                    this._accumulateInviteState(roomId, data);
                                    break;
                                case "join":
                                    if (this.inviteRooms[roomId]) {
                                        delete this.inviteRooms[roomId];
                                    }
                                    this._accumulateJoinState(roomId, data, fromDatabase);
                                    break;
                                case "leave":
                                    if (this.inviteRooms[roomId]) {
                                        delete this.inviteRooms[roomId];
                                    }
                                    else {
                                        delete this.joinRooms[roomId];
                                    }
                                    break;
                                default:
                                    _logger.logger.error("Unknown cateogory: ", category);
                            }
                        }
                    }, {
                        key: "_accumulateInviteState",
                        value: function _accumulateInviteState(roomId, data) {
                            if (!data.invite_state || !data.invite_state.events) {
                                return;
                            }
                            if (!this.inviteRooms[roomId]) {
                                this.inviteRooms[roomId] = {
                                    invite_state: data.invite_state
                                };
                                return;
                            }
                            var currentData = this.inviteRooms[roomId];
                            data.invite_state.events.forEach(function (e) {
                                var hasAdded = false;
                                for (var i = 0; i < currentData.invite_state.events.length; i++) {
                                    var current = currentData.invite_state.events[i];
                                    if (current.type === e.type && current.state_key == e.state_key) {
                                        currentData.invite_state.events[i] = e;
                                        hasAdded = true;
                                    }
                                }
                                if (!hasAdded) {
                                    currentData.invite_state.events.push(e);
                                }
                            });
                        }
                    }, {
                        key: "_accumulateJoinState",
                        value: function _accumulateJoinState(roomId, data, fromDatabase) {
                            if (!this.joinRooms[roomId]) {
                                this.joinRooms[roomId] = {
                                    _currentState: Object.create(null),
                                    _timeline: [],
                                    _accountData: Object.create(null),
                                    _unreadNotifications: {},
                                    _summary: {},
                                    _readReceipts: {}
                                };
                            }
                            var currentData = this.joinRooms[roomId];
                            if (data.account_data && data.account_data.events) {
                                data.account_data.events.forEach(function (e) {
                                    currentData._accountData[e.type] = e;
                                });
                            }
                            if (data.unread_notifications) {
                                currentData._unreadNotifications = data.unread_notifications;
                            }
                            if (data.summary) {
                                var HEROES_KEY = "m.heroes";
                                var INVITED_COUNT_KEY = "m.invited_member_count";
                                var JOINED_COUNT_KEY = "m.joined_member_count";
                                var acc = currentData._summary;
                                var sum = data.summary;
                                acc[HEROES_KEY] = sum[HEROES_KEY] || acc[HEROES_KEY];
                                acc[JOINED_COUNT_KEY] = sum[JOINED_COUNT_KEY] || acc[JOINED_COUNT_KEY];
                                acc[INVITED_COUNT_KEY] = sum[INVITED_COUNT_KEY] || acc[INVITED_COUNT_KEY];
                            }
                            if (data.ephemeral && data.ephemeral.events) {
                                data.ephemeral.events.forEach(function (e) {
                                    if (e.type !== "m.receipt" || !e.content) {
                                        return;
                                    }
                                    Object.keys(e.content).forEach(function (eventId) {
                                        if (!e.content[eventId]["m.read"]) {
                                            return;
                                        }
                                        Object.keys(e.content[eventId]["m.read"]).forEach(function (userId) {
                                            currentData._readReceipts[userId] = {
                                                data: e.content[eventId]["m.read"][userId],
                                                eventId: eventId
                                            };
                                        });
                                    });
                                });
                            }
                            if (data.timeline && data.timeline.limited) {
                                currentData._timeline = [];
                            }
                            if (data.state && data.state.events) {
                                data.state.events.forEach(function (e) {
                                    setState(currentData._currentState, e);
                                });
                            }
                            if (data.timeline && data.timeline.events) {
                                data.timeline.events.forEach(function (e, index) {
                                    setState(currentData._currentState, e);
                                    var transformedEvent;
                                    if (!fromDatabase) {
                                        transformedEvent = Object.assign({}, e);
                                        if (transformedEvent.unsigned !== undefined) {
                                            transformedEvent.unsigned = Object.assign({}, transformedEvent.unsigned);
                                        }
                                        var age = e.unsigned ? e.unsigned.age : e.age;
                                        if (age !== undefined)
                                            transformedEvent._localTs = Date.now() - age;
                                    }
                                    else {
                                        transformedEvent = e;
                                    }
                                    currentData._timeline.push({
                                        event: transformedEvent,
                                        token: index === 0 ? data.timeline.prev_batch : null
                                    });
                                });
                            }
                            if (currentData._timeline.length > this.opts.maxTimelineEntries) {
                                var startIndex = currentData._timeline.length - this.opts.maxTimelineEntries;
                                for (var i = startIndex; i < currentData._timeline.length; i++) {
                                    if (currentData._timeline[i].token) {
                                        currentData._timeline = currentData._timeline.slice(i, currentData._timeline.length);
                                        break;
                                    }
                                }
                            }
                        }
                    }, {
                        key: "_accumulateGroups",
                        value: function _accumulateGroups(syncResponse) {
                            var _this3 = this;
                            if (!syncResponse.groups) {
                                return;
                            }
                            if (syncResponse.groups.invite) {
                                Object.keys(syncResponse.groups.invite).forEach(function (groupId) {
                                    _this3._accumulateGroup(groupId, "invite", syncResponse.groups.invite[groupId]);
                                });
                            }
                            if (syncResponse.groups.join) {
                                Object.keys(syncResponse.groups.join).forEach(function (groupId) {
                                    _this3._accumulateGroup(groupId, "join", syncResponse.groups.join[groupId]);
                                });
                            }
                            if (syncResponse.groups.leave) {
                                Object.keys(syncResponse.groups.leave).forEach(function (groupId) {
                                    _this3._accumulateGroup(groupId, "leave", syncResponse.groups.leave[groupId]);
                                });
                            }
                        }
                    }, {
                        key: "_accumulateGroup",
                        value: function _accumulateGroup(groupId, category, data) {
                            for (var _i = 0, _arr = ['invite', 'join', 'leave']; _i < _arr.length; _i++) {
                                var cat = _arr[_i];
                                delete this.groups[cat][groupId];
                            }
                            this.groups[category][groupId] = data;
                        }
                    }, {
                        key: "getJSON",
                        value: function getJSON(forDatabase) {
                            var _this4 = this;
                            var data = {
                                join: {},
                                invite: {},
                                leave: {}
                            };
                            Object.keys(this.inviteRooms).forEach(function (roomId) {
                                data.invite[roomId] = _this4.inviteRooms[roomId];
                            });
                            Object.keys(this.joinRooms).forEach(function (roomId) {
                                var roomData = _this4.joinRooms[roomId];
                                var roomJson = {
                                    ephemeral: {
                                        events: []
                                    },
                                    account_data: {
                                        events: []
                                    },
                                    state: {
                                        events: []
                                    },
                                    timeline: {
                                        events: [],
                                        prev_batch: null
                                    },
                                    unread_notifications: roomData._unreadNotifications,
                                    summary: roomData._summary
                                };
                                Object.keys(roomData._accountData).forEach(function (evType) {
                                    roomJson.account_data.events.push(roomData._accountData[evType]);
                                });
                                var receiptEvent = {
                                    type: "m.receipt",
                                    room_id: roomId,
                                    content: {}
                                };
                                Object.keys(roomData._readReceipts).forEach(function (userId) {
                                    var receiptData = roomData._readReceipts[userId];
                                    if (!receiptEvent.content[receiptData.eventId]) {
                                        receiptEvent.content[receiptData.eventId] = {
                                            "m.read": {}
                                        };
                                    }
                                    receiptEvent.content[receiptData.eventId]["m.read"][userId] = receiptData.data;
                                });
                                if (Object.keys(receiptEvent.content).length > 0) {
                                    roomJson.ephemeral.events.push(receiptEvent);
                                }
                                roomData._timeline.forEach(function (msgData) {
                                    if (!roomJson.timeline.prev_batch) {
                                        if (!msgData.token) {
                                            return;
                                        }
                                        roomJson.timeline.prev_batch = msgData.token;
                                    }
                                    var transformedEvent;
                                    if (!forDatabase && msgData.event._localTs) {
                                        transformedEvent = Object.assign({}, msgData.event);
                                        if (transformedEvent.unsigned !== undefined) {
                                            transformedEvent.unsigned = Object.assign({}, transformedEvent.unsigned);
                                        }
                                        delete transformedEvent._localTs;
                                        transformedEvent.unsigned = transformedEvent.unsigned || {};
                                        transformedEvent.unsigned.age = Date.now() - msgData.event._localTs;
                                    }
                                    else {
                                        transformedEvent = msgData.event;
                                    }
                                    roomJson.timeline.events.push(transformedEvent);
                                });
                                var rollBackState = Object.create(null);
                                for (var i = roomJson.timeline.events.length - 1; i >= 0; i--) {
                                    var timelineEvent = roomJson.timeline.events[i];
                                    if (timelineEvent.state_key === null || timelineEvent.state_key === undefined) {
                                        continue;
                                    }
                                    var prevStateEvent = (0, _utils.deepCopy)(timelineEvent);
                                    if (prevStateEvent.unsigned) {
                                        if (prevStateEvent.unsigned.prev_content) {
                                            prevStateEvent.content = prevStateEvent.unsigned.prev_content;
                                        }
                                        if (prevStateEvent.unsigned.prev_sender) {
                                            prevStateEvent.sender = prevStateEvent.unsigned.prev_sender;
                                        }
                                    }
                                    setState(rollBackState, prevStateEvent);
                                }
                                Object.keys(roomData._currentState).forEach(function (evType) {
                                    Object.keys(roomData._currentState[evType]).forEach(function (stateKey) {
                                        var ev = roomData._currentState[evType][stateKey];
                                        if (rollBackState[evType] && rollBackState[evType][stateKey]) {
                                            ev = rollBackState[evType][stateKey];
                                        }
                                        roomJson.state.events.push(ev);
                                    });
                                });
                                data.join[roomId] = roomJson;
                            });
                            var accData = [];
                            Object.keys(this.accountData).forEach(function (evType) {
                                accData.push(_this4.accountData[evType]);
                            });
                            return {
                                nextBatch: this.nextBatch,
                                roomsData: data,
                                groupsData: this.groups,
                                accountData: accData
                            };
                        }
                    }, {
                        key: "getNextBatchToken",
                        value: function getNextBatchToken() {
                            return this.nextBatch;
                        }
                    }]);
                return SyncAccumulator;
            }();
            exports.SyncAccumulator = SyncAccumulator;
            function setState(eventMap, event) {
                if (event.state_key === null || event.state_key === undefined || !event.type) {
                    return;
                }
                if (!eventMap[event.type]) {
                    eventMap[event.type] = Object.create(null);
                }
                eventMap[event.type][event.state_key] = event;
            }
        }, { "./logger": 97, "./utils": 125, "@babel/runtime/helpers/classCallCheck": 6, "@babel/runtime/helpers/createClass": 8, "@babel/runtime/helpers/interopRequireDefault": 12 }], 123: [function (require, module, exports) {
            (function (global) {
                (function () {
                    "use strict";
                    var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
                    var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
                    Object.defineProperty(exports, "__esModule", {
                        value: true
                    });
                    exports.SyncApi = SyncApi;
                    var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
                    var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
                    var _user = require("./models/user");
                    var _room = require("./models/room");
                    var _group = require("./models/group");
                    var utils = _interopRequireWildcard(require("./utils"));
                    var _filter = require("./filter");
                    var _eventTimeline = require("./models/event-timeline");
                    var _pushprocessor = require("./pushprocessor");
                    var _logger = require("./logger");
                    var _errors = require("./errors");
                    function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
                        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                            if (it)
                                o = it;
                            var i = 0;
                            var F = function F() { };
                            return { s: F, n: function n() { if (i >= o.length)
                                    return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F };
                        }
                        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                    } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try {
                            if (!normalCompletion && it["return"] != null)
                                it["return"]();
                        }
                        finally {
                            if (didErr)
                                throw err;
                        } } }; }
                    function _unsupportedIterableToArray(o, minLen) { if (!o)
                        return; if (typeof o === "string")
                        return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor)
                        n = o.constructor.name; if (n === "Map" || n === "Set")
                        return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                        return _arrayLikeToArray(o, minLen); }
                    function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length)
                        len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) {
                        arr2[i] = arr[i];
                    } return arr2; }
                    var DEBUG = true;
                    var BUFFER_PERIOD_MS = 80 * 1000;
                    var FAILED_SYNC_ERROR_THRESHOLD = 3;
                    function getFilterName(userId, suffix) {
                        return "FILTER_SYNC_" + userId + (suffix ? "_" + suffix : "");
                    }
                    function debuglog() {
                        if (!DEBUG) {
                            return;
                        }
                        _logger.logger.log.apply(_logger.logger, arguments);
                    }
                    function SyncApi(client, opts) {
                        this.client = client;
                        opts = opts || {};
                        opts.initialSyncLimit = opts.initialSyncLimit === undefined ? 8 : opts.initialSyncLimit;
                        opts.resolveInvitesToProfiles = opts.resolveInvitesToProfiles || false;
                        opts.pollTimeout = opts.pollTimeout || 30 * 1000;
                        opts.pendingEventOrdering = opts.pendingEventOrdering || "chronological";
                        if (!opts.canResetEntireTimeline) {
                            opts.canResetEntireTimeline = function (roomId) {
                                return false;
                            };
                        }
                        this.opts = opts;
                        this._peekRoom = null;
                        this._currentSyncRequest = null;
                        this._syncState = null;
                        this._syncStateData = null;
                        this._catchingUp = false;
                        this._running = false;
                        this._keepAliveTimer = null;
                        this._connectionReturnedDefer = null;
                        this._notifEvents = [];
                        this._failedSyncCount = 0;
                        this._storeIsInvalid = false;
                        if (client.getNotifTimelineSet()) {
                            client.reEmitter.reEmit(client.getNotifTimelineSet(), ["Room.timeline", "Room.timelineReset"]);
                        }
                    }
                    SyncApi.prototype.createRoom = function (roomId) {
                        var client = this.client;
                        var timelineSupport = client.timelineSupport, unstableClientRelationAggregation = client.unstableClientRelationAggregation;
                        var room = new _room.Room(roomId, client, client.getUserId(), {
                            lazyLoadMembers: this.opts.lazyLoadMembers,
                            pendingEventOrdering: this.opts.pendingEventOrdering,
                            timelineSupport: timelineSupport,
                            unstableClientRelationAggregation: unstableClientRelationAggregation
                        });
                        client.reEmitter.reEmit(room, ["Room.name", "Room.timeline", "Room.redaction", "Room.redactionCancelled", "Room.receipt", "Room.tags", "Room.timelineReset", "Room.localEchoUpdated", "Room.accountData", "Room.myMembership", "Room.replaceEvent"]);
                        this._registerStateListeners(room);
                        return room;
                    };
                    SyncApi.prototype.createGroup = function (groupId) {
                        var client = this.client;
                        var group = new _group.Group(groupId);
                        client.reEmitter.reEmit(group, ["Group.profile", "Group.myMembership"]);
                        client.store.storeGroup(group);
                        return group;
                    };
                    SyncApi.prototype._registerStateListeners = function (room) {
                        var client = this.client;
                        client.reEmitter.reEmit(room.currentState, ["RoomState.events", "RoomState.members", "RoomState.newMember"]);
                        room.currentState.on("RoomState.newMember", function (event, state, member) {
                            member.user = client.getUser(member.userId);
                            client.reEmitter.reEmit(member, ["RoomMember.name", "RoomMember.typing", "RoomMember.powerLevel", "RoomMember.membership"]);
                        });
                    };
                    SyncApi.prototype._deregisterStateListeners = function (room) {
                        room.currentState.removeAllListeners("RoomState.events");
                        room.currentState.removeAllListeners("RoomState.members");
                        room.currentState.removeAllListeners("RoomState.newMember");
                    };
                    SyncApi.prototype.syncLeftRooms = function () {
                        var client = this.client;
                        var self = this;
                        var filter = new _filter.Filter(this.client.credentials.userId);
                        filter.setTimelineLimit(1);
                        filter.setIncludeLeaveRooms(true);
                        var localTimeoutMs = this.opts.pollTimeout + BUFFER_PERIOD_MS;
                        var qps = {
                            timeout: 0
                        };
                        return client.getOrCreateFilter(getFilterName(client.credentials.userId, "LEFT_ROOMS"), filter).then(function (filterId) {
                            qps.filter = filterId;
                            return client._http.authedRequest(undefined, "GET", "/sync", qps, undefined, localTimeoutMs);
                        }).then(function (data) {
                            var leaveRooms = [];
                            if (data.rooms && data.rooms.leave) {
                                leaveRooms = self._mapSyncResponseToRoomArray(data.rooms.leave);
                            }
                            var rooms = [];
                            leaveRooms.forEach(function (leaveObj) {
                                var room = leaveObj.room;
                                rooms.push(room);
                                if (!leaveObj.isBrandNewRoom) {
                                    return;
                                }
                                leaveObj.timeline = leaveObj.timeline || {};
                                var timelineEvents = self._mapSyncEventsFormat(leaveObj.timeline, room);
                                var stateEvents = self._mapSyncEventsFormat(leaveObj.state, room);
                                room.getLiveTimeline().setPaginationToken(leaveObj.timeline.prev_batch, _eventTimeline.EventTimeline.BACKWARDS);
                                self._processRoomEvents(room, stateEvents, timelineEvents);
                                room.recalculate();
                                client.store.storeRoom(room);
                                client.emit("Room", room);
                                self._processEventsForNotifs(room, timelineEvents);
                            });
                            return rooms;
                        });
                    };
                    SyncApi.prototype.peek = function (roomId) {
                        var _this = this;
                        if (this._peekRoom && this._peekRoom.roomId === roomId) {
                            return Promise.resolve(this._peekRoom);
                        }
                        var client = this.client;
                        this._peekRoom = this.createRoom(roomId);
                        return this.client.roomInitialSync(roomId, 20).then(function (response) {
                            response.messages = response.messages || {};
                            response.messages.chunk = response.messages.chunk || [];
                            response.state = response.state || [];
                            var oldStateEvents = utils.map(utils.deepCopy(response.state), client.getEventMapper());
                            var stateEvents = utils.map(response.state, client.getEventMapper());
                            var messages = utils.map(response.messages.chunk, client.getEventMapper());
                            if (response.presence && utils.isArray(response.presence)) {
                                response.presence.map(client.getEventMapper()).forEach(function (presenceEvent) {
                                    var user = client.store.getUser(presenceEvent.getContent().user_id);
                                    if (user) {
                                        user.setPresenceEvent(presenceEvent);
                                    }
                                    else {
                                        user = createNewUser(client, presenceEvent.getContent().user_id);
                                        user.setPresenceEvent(presenceEvent);
                                        client.store.storeUser(user);
                                    }
                                    client.emit("event", presenceEvent);
                                });
                            }
                            if (response.messages.start) {
                                _this._peekRoom.oldState.paginationToken = response.messages.start;
                            }
                            _this._peekRoom.oldState.setStateEvents(oldStateEvents);
                            _this._peekRoom.currentState.setStateEvents(stateEvents);
                            _this._resolveInvites(_this._peekRoom);
                            _this._peekRoom.recalculate();
                            _this._peekRoom.addEventsToTimeline(messages.reverse(), true, _this._peekRoom.getLiveTimeline(), response.messages.start);
                            client.store.storeRoom(_this._peekRoom);
                            client.emit("Room", _this._peekRoom);
                            _this._peekPoll(_this._peekRoom);
                            return _this._peekRoom;
                        });
                    };
                    SyncApi.prototype.stopPeeking = function () {
                        this._peekRoom = null;
                    };
                    SyncApi.prototype._peekPoll = function (peekRoom, token) {
                        if (this._peekRoom !== peekRoom) {
                            debuglog("Stopped peeking in room %s", peekRoom.roomId);
                            return;
                        }
                        var self = this;
                        this.client._http.authedRequest(undefined, "GET", "/events", {
                            room_id: peekRoom.roomId,
                            timeout: 30 * 1000,
                            from: token
                        }, undefined, 50 * 1000).then(function (res) {
                            if (self._peekRoom !== peekRoom) {
                                debuglog("Stopped peeking in room %s", peekRoom.roomId);
                                return;
                            }
                            res.chunk.filter(function (e) {
                                return e.type === "m.presence";
                            }).map(self.client.getEventMapper()).forEach(function (presenceEvent) {
                                var user = self.client.store.getUser(presenceEvent.getContent().user_id);
                                if (user) {
                                    user.setPresenceEvent(presenceEvent);
                                }
                                else {
                                    user = createNewUser(self.client, presenceEvent.getContent().user_id);
                                    user.setPresenceEvent(presenceEvent);
                                    self.client.store.storeUser(user);
                                }
                                self.client.emit("event", presenceEvent);
                            });
                            var events = res.chunk.filter(function (e) {
                                return e.room_id === peekRoom.roomId && e.event_id;
                            }).map(self.client.getEventMapper());
                            peekRoom.addLiveEvents(events);
                            self._peekPoll(peekRoom, res.end);
                        }, function (err) {
                            _logger.logger.error("[%s] Peek poll failed: %s", peekRoom.roomId, err);
                            setTimeout(function () {
                                self._peekPoll(peekRoom, token);
                            }, 30 * 1000);
                        });
                    };
                    SyncApi.prototype.getSyncState = function () {
                        return this._syncState;
                    };
                    SyncApi.prototype.getSyncStateData = function () {
                        return this._syncStateData;
                    };
                    SyncApi.prototype.recoverFromSyncStartupError = function () {
                        var _ref = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee(savedSyncPromise, err) {
                            var keepaliveProm;
                            return _regenerator["default"].wrap(function _callee$(_context) {
                                while (1) {
                                    switch (_context.prev = _context.next) {
                                        case 0:
                                            _context.next = 2;
                                            return savedSyncPromise;
                                        case 2:
                                            keepaliveProm = this._startKeepAlives();
                                            this._updateSyncState("ERROR", {
                                                error: err
                                            });
                                            _context.next = 6;
                                            return keepaliveProm;
                                        case 6:
                                        case "end":
                                            return _context.stop();
                                    }
                                }
                            }, _callee, this);
                        }));
                        return function (_x, _x2) {
                            return _ref.apply(this, arguments);
                        };
                    }();
                    SyncApi.prototype._wasLazyLoadingToggled = function () {
                        var _ref2 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee2(lazyLoadMembers) {
                            var lazyLoadMembersBefore, isStoreNewlyCreated, prevClientOptions;
                            return _regenerator["default"].wrap(function _callee2$(_context2) {
                                while (1) {
                                    switch (_context2.prev = _context2.next) {
                                        case 0:
                                            lazyLoadMembers = !!lazyLoadMembers;
                                            lazyLoadMembersBefore = false;
                                            _context2.next = 4;
                                            return this.client.store.isNewlyCreated();
                                        case 4:
                                            isStoreNewlyCreated = _context2.sent;
                                            if (isStoreNewlyCreated) {
                                                _context2.next = 11;
                                                break;
                                            }
                                            _context2.next = 8;
                                            return this.client.store.getClientOptions();
                                        case 8:
                                            prevClientOptions = _context2.sent;
                                            if (prevClientOptions) {
                                                lazyLoadMembersBefore = !!prevClientOptions.lazyLoadMembers;
                                            }
                                            return _context2.abrupt("return", lazyLoadMembersBefore !== lazyLoadMembers);
                                        case 11:
                                            return _context2.abrupt("return", false);
                                        case 12:
                                        case "end":
                                            return _context2.stop();
                                    }
                                }
                            }, _callee2, this);
                        }));
                        return function (_x3) {
                            return _ref2.apply(this, arguments);
                        };
                    }();
                    SyncApi.prototype._shouldAbortSync = function (error) {
                        if (error.errcode === "M_UNKNOWN_TOKEN") {
                            _logger.logger.warn("Token no longer valid - assuming logout");
                            this.stop();
                            return true;
                        }
                        return false;
                    };
                    SyncApi.prototype.sync = function () {
                        var _this2 = this;
                        var client = this.client;
                        var self = this;
                        this._running = true;
                        if (global.window) {
                            this._onOnlineBound = this._onOnline.bind(this);
                            global.window.addEventListener("online", this._onOnlineBound, false);
                        }
                        var savedSyncPromise = Promise.resolve();
                        var savedSyncToken = null;
                        function getPushRules() {
                            return _getPushRules.apply(this, arguments);
                        }
                        function _getPushRules() {
                            _getPushRules = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee4() {
                                var result;
                                return _regenerator["default"].wrap(function _callee4$(_context4) {
                                    while (1) {
                                        switch (_context4.prev = _context4.next) {
                                            case 0:
                                                _context4.prev = 0;
                                                debuglog("Getting push rules...");
                                                _context4.next = 4;
                                                return client.getPushRules();
                                            case 4:
                                                result = _context4.sent;
                                                debuglog("Got push rules");
                                                client.pushRules = result;
                                                _context4.next = 19;
                                                break;
                                            case 9:
                                                _context4.prev = 9;
                                                _context4.t0 = _context4["catch"](0);
                                                _logger.logger.error("Getting push rules failed", _context4.t0);
                                                if (!self._shouldAbortSync(_context4.t0)) {
                                                    _context4.next = 14;
                                                    break;
                                                }
                                                return _context4.abrupt("return");
                                            case 14:
                                                debuglog("Waiting for saved sync before retrying push rules...");
                                                _context4.next = 17;
                                                return self.recoverFromSyncStartupError(savedSyncPromise, _context4.t0);
                                            case 17:
                                                getPushRules();
                                                return _context4.abrupt("return");
                                            case 19:
                                                checkLazyLoadStatus();
                                            case 20:
                                            case "end":
                                                return _context4.stop();
                                        }
                                    }
                                }, _callee4, null, [[0, 9]]);
                            }));
                            return _getPushRules.apply(this, arguments);
                        }
                        function buildDefaultFilter() {
                            var filter = new _filter.Filter(client.credentials.userId);
                            filter.setTimelineLimit(self.opts.initialSyncLimit);
                            return filter;
                        }
                        var checkLazyLoadStatus = function () {
                            var _ref3 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee3() {
                                var supported, shouldClear, reason, error;
                                return _regenerator["default"].wrap(function _callee3$(_context3) {
                                    while (1) {
                                        switch (_context3.prev = _context3.next) {
                                            case 0:
                                                debuglog("Checking lazy load status...");
                                                if (_this2.opts.lazyLoadMembers && client.isGuest()) {
                                                    _this2.opts.lazyLoadMembers = false;
                                                }
                                                if (!_this2.opts.lazyLoadMembers) {
                                                    _context3.next = 8;
                                                    break;
                                                }
                                                debuglog("Checking server lazy load support...");
                                                _context3.next = 6;
                                                return client.doesServerSupportLazyLoading();
                                            case 6:
                                                supported = _context3.sent;
                                                if (supported) {
                                                    debuglog("Enabling lazy load on sync filter...");
                                                    if (!_this2.opts.filter) {
                                                        _this2.opts.filter = buildDefaultFilter();
                                                    }
                                                    _this2.opts.filter.setLazyLoadMembers(true);
                                                }
                                                else {
                                                    debuglog("LL: lazy loading requested but not supported " + "by server, so disabling");
                                                    _this2.opts.lazyLoadMembers = false;
                                                }
                                            case 8:
                                                debuglog("Checking whether lazy loading has changed in store...");
                                                _context3.next = 11;
                                                return _this2._wasLazyLoadingToggled(_this2.opts.lazyLoadMembers);
                                            case 11:
                                                shouldClear = _context3.sent;
                                                if (!shouldClear) {
                                                    _context3.next = 19;
                                                    break;
                                                }
                                                _this2._storeIsInvalid = true;
                                                reason = _errors.InvalidStoreError.TOGGLED_LAZY_LOADING;
                                                error = new _errors.InvalidStoreError(reason, !!_this2.opts.lazyLoadMembers);
                                                _this2._updateSyncState("ERROR", {
                                                    error: error
                                                });
                                                _logger.logger.warn("InvalidStoreError: store is not usable: stopping sync.");
                                                return _context3.abrupt("return");
                                            case 19:
                                                if (_this2.opts.lazyLoadMembers && _this2.opts.crypto) {
                                                    _this2.opts.crypto.enableLazyLoading();
                                                }
                                                _context3.prev = 20;
                                                debuglog("Storing client options...");
                                                _context3.next = 24;
                                                return _this2.client._storeClientOptions();
                                            case 24:
                                                debuglog("Stored client options");
                                                _context3.next = 31;
                                                break;
                                            case 27:
                                                _context3.prev = 27;
                                                _context3.t0 = _context3["catch"](20);
                                                _logger.logger.error("Storing client options failed", _context3.t0);
                                                throw _context3.t0;
                                            case 31:
                                                getFilter();
                                            case 32:
                                            case "end":
                                                return _context3.stop();
                                        }
                                    }
                                }, _callee3, null, [[20, 27]]);
                            }));
                            return function checkLazyLoadStatus() {
                                return _ref3.apply(this, arguments);
                            };
                        }();
                        function getFilter() {
                            return _getFilter.apply(this, arguments);
                        }
                        function _getFilter() {
                            _getFilter = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee5() {
                                var filter, filterId;
                                return _regenerator["default"].wrap(function _callee5$(_context5) {
                                    while (1) {
                                        switch (_context5.prev = _context5.next) {
                                            case 0:
                                                debuglog("Getting filter...");
                                                if (self.opts.filter) {
                                                    filter = self.opts.filter;
                                                }
                                                else {
                                                    filter = buildDefaultFilter();
                                                }
                                                _context5.prev = 2;
                                                _context5.next = 5;
                                                return client.getOrCreateFilter(getFilterName(client.credentials.userId), filter);
                                            case 5:
                                                filterId = _context5.sent;
                                                _context5.next = 18;
                                                break;
                                            case 8:
                                                _context5.prev = 8;
                                                _context5.t0 = _context5["catch"](2);
                                                _logger.logger.error("Getting filter failed", _context5.t0);
                                                if (!self._shouldAbortSync(_context5.t0)) {
                                                    _context5.next = 13;
                                                    break;
                                                }
                                                return _context5.abrupt("return");
                                            case 13:
                                                debuglog("Waiting for saved sync before retrying filter...");
                                                _context5.next = 16;
                                                return self.recoverFromSyncStartupError(savedSyncPromise, _context5.t0);
                                            case 16:
                                                getFilter();
                                                return _context5.abrupt("return");
                                            case 18:
                                                client.resetNotifTimelineSet();
                                                if (self._currentSyncRequest === null) {
                                                    debuglog("Sending first sync request...");
                                                    self._currentSyncRequest = self._doSyncRequest({
                                                        filterId: filterId
                                                    }, savedSyncToken);
                                                }
                                                debuglog("Waiting for saved sync before starting sync processing...");
                                                _context5.next = 23;
                                                return savedSyncPromise;
                                            case 23:
                                                self._sync({
                                                    filterId: filterId
                                                });
                                            case 24:
                                            case "end":
                                                return _context5.stop();
                                        }
                                    }
                                }, _callee5, null, [[2, 8]]);
                            }));
                            return _getFilter.apply(this, arguments);
                        }
                        if (client.isGuest()) {
                            self._sync({});
                        }
                        else {
                            debuglog("Getting saved sync token...");
                            savedSyncPromise = client.store.getSavedSyncToken().then(function (tok) {
                                debuglog("Got saved sync token");
                                savedSyncToken = tok;
                                debuglog("Getting saved sync...");
                                return client.store.getSavedSync();
                            }).then(function (savedSync) {
                                debuglog("Got reply from saved sync, exists? ".concat(!!savedSync));
                                if (savedSync) {
                                    return self._syncFromCache(savedSync);
                                }
                            })["catch"](function (err) {
                                _logger.logger.error("Getting saved sync failed", err);
                            });
                            getPushRules();
                        }
                    };
                    SyncApi.prototype.stop = function () {
                        debuglog("SyncApi.stop");
                        if (global.window) {
                            global.window.removeEventListener("online", this._onOnlineBound, false);
                            this._onOnlineBound = undefined;
                        }
                        this._running = false;
                        if (this._currentSyncRequest) {
                            this._currentSyncRequest.abort();
                        }
                        if (this._keepAliveTimer) {
                            clearTimeout(this._keepAliveTimer);
                            this._keepAliveTimer = null;
                        }
                    };
                    SyncApi.prototype.retryImmediately = function () {
                        if (!this._connectionReturnedDefer) {
                            return false;
                        }
                        this._startKeepAlives(0);
                        return true;
                    };
                    SyncApi.prototype._syncFromCache = function () {
                        var _ref4 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee6(savedSync) {
                            var nextSyncToken, syncEventData, data;
                            return _regenerator["default"].wrap(function _callee6$(_context6) {
                                while (1) {
                                    switch (_context6.prev = _context6.next) {
                                        case 0:
                                            debuglog("sync(): not doing HTTP hit, instead returning stored /sync data");
                                            nextSyncToken = savedSync.nextBatch;
                                            this.client.store.setSyncToken(nextSyncToken);
                                            syncEventData = {
                                                oldSyncToken: null,
                                                nextSyncToken: nextSyncToken,
                                                catchingUp: false,
                                                fromCache: true
                                            };
                                            data = {
                                                next_batch: nextSyncToken,
                                                rooms: savedSync.roomsData,
                                                groups: savedSync.groupsData,
                                                account_data: {
                                                    events: savedSync.accountData
                                                }
                                            };
                                            _context6.prev = 5;
                                            _context6.next = 8;
                                            return this._processSyncResponse(syncEventData, data);
                                        case 8:
                                            _context6.next = 13;
                                            break;
                                        case 10:
                                            _context6.prev = 10;
                                            _context6.t0 = _context6["catch"](5);
                                            _logger.logger.error("Error processing cached sync", _context6.t0.stack || _context6.t0);
                                        case 13:
                                            if (!this._storeIsInvalid) {
                                                this._updateSyncState("PREPARED", syncEventData);
                                            }
                                        case 14:
                                        case "end":
                                            return _context6.stop();
                                    }
                                }
                            }, _callee6, this, [[5, 10]]);
                        }));
                        return function (_x4) {
                            return _ref4.apply(this, arguments);
                        };
                    }();
                    SyncApi.prototype._sync = function () {
                        var _ref5 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee7(syncOptions) {
                            var client, syncToken, data, syncEventData;
                            return _regenerator["default"].wrap(function _callee7$(_context7) {
                                while (1) {
                                    switch (_context7.prev = _context7.next) {
                                        case 0:
                                            client = this.client;
                                            if (this._running) {
                                                _context7.next = 6;
                                                break;
                                            }
                                            debuglog("Sync no longer running: exiting.");
                                            if (this._connectionReturnedDefer) {
                                                this._connectionReturnedDefer.reject();
                                                this._connectionReturnedDefer = null;
                                            }
                                            this._updateSyncState("STOPPED");
                                            return _context7.abrupt("return");
                                        case 6:
                                            syncToken = client.store.getSyncToken();
                                            _context7.prev = 7;
                                            if (this._currentSyncRequest === null) {
                                                this._currentSyncRequest = this._doSyncRequest(syncOptions, syncToken);
                                            }
                                            _context7.next = 11;
                                            return this._currentSyncRequest;
                                        case 11:
                                            data = _context7.sent;
                                            _context7.next = 18;
                                            break;
                                        case 14:
                                            _context7.prev = 14;
                                            _context7.t0 = _context7["catch"](7);
                                            this._onSyncError(_context7.t0, syncOptions);
                                            return _context7.abrupt("return");
                                        case 18:
                                            _context7.prev = 18;
                                            this._currentSyncRequest = null;
                                            return _context7.finish(18);
                                        case 21:
                                            client.store.setSyncToken(data.next_batch);
                                            this._failedSyncCount = 0;
                                            _context7.next = 25;
                                            return client.store.setSyncData(data);
                                        case 25:
                                            syncEventData = {
                                                oldSyncToken: syncToken,
                                                nextSyncToken: data.next_batch,
                                                catchingUp: this._catchingUp
                                            };
                                            if (!this.opts.crypto) {
                                                _context7.next = 29;
                                                break;
                                            }
                                            _context7.next = 29;
                                            return this.opts.crypto.onSyncWillProcess(syncEventData);
                                        case 29:
                                            _context7.prev = 29;
                                            _context7.next = 32;
                                            return this._processSyncResponse(syncEventData, data);
                                        case 32:
                                            _context7.next = 38;
                                            break;
                                        case 34:
                                            _context7.prev = 34;
                                            _context7.t1 = _context7["catch"](29);
                                            _logger.logger.error("Caught /sync error", _context7.t1.stack || _context7.t1);
                                            this.client.emit("sync.unexpectedError", _context7.t1);
                                        case 38:
                                            syncEventData.catchingUp = this._catchingUp;
                                            if (!syncOptions.hasSyncedBefore) {
                                                this._updateSyncState("PREPARED", syncEventData);
                                                syncOptions.hasSyncedBefore = true;
                                            }
                                            if (!this.opts.crypto) {
                                                _context7.next = 43;
                                                break;
                                            }
                                            _context7.next = 43;
                                            return this.opts.crypto.onSyncCompleted(syncEventData);
                                        case 43:
                                            this._updateSyncState("SYNCING", syncEventData);
                                            if (!client.store.wantsSave()) {
                                                _context7.next = 49;
                                                break;
                                            }
                                            if (!this.opts.crypto) {
                                                _context7.next = 48;
                                                break;
                                            }
                                            _context7.next = 48;
                                            return this.opts.crypto.saveDeviceList(0);
                                        case 48:
                                            client.store.save();
                                        case 49:
                                            this._sync(syncOptions);
                                        case 50:
                                        case "end":
                                            return _context7.stop();
                                    }
                                }
                            }, _callee7, this, [[7, 14, 18, 21], [29, 34]]);
                        }));
                        return function (_x5) {
                            return _ref5.apply(this, arguments);
                        };
                    }();
                    SyncApi.prototype._doSyncRequest = function (syncOptions, syncToken) {
                        var qps = this._getSyncParams(syncOptions, syncToken);
                        return this.client._http.authedRequest(undefined, "GET", "/sync", qps, undefined, qps.timeout + BUFFER_PERIOD_MS);
                    };
                    SyncApi.prototype._getSyncParams = function (syncOptions, syncToken) {
                        var pollTimeout = this.opts.pollTimeout;
                        if (this.getSyncState() !== 'SYNCING' || this._catchingUp) {
                            this._catchingUp = true;
                            pollTimeout = 0;
                        }
                        var filterId = syncOptions.filterId;
                        if (this.client.isGuest() && !filterId) {
                            filterId = this._getGuestFilter();
                        }
                        var qps = {
                            filter: filterId,
                            timeout: pollTimeout
                        };
                        if (this.opts.disablePresence) {
                            qps.set_presence = "offline";
                        }
                        if (syncToken) {
                            qps.since = syncToken;
                        }
                        else {
                            qps._cacheBuster = Date.now();
                        }
                        if (this.getSyncState() == 'ERROR' || this.getSyncState() == 'RECONNECTING') {
                            qps.timeout = 0;
                        }
                        return qps;
                    };
                    SyncApi.prototype._onSyncError = function (err, syncOptions) {
                        var _this3 = this;
                        if (!this._running) {
                            debuglog("Sync no longer running: exiting");
                            if (this._connectionReturnedDefer) {
                                this._connectionReturnedDefer.reject();
                                this._connectionReturnedDefer = null;
                            }
                            this._updateSyncState("STOPPED");
                            return;
                        }
                        _logger.logger.error("/sync error %s", err);
                        _logger.logger.error(err);
                        if (this._shouldAbortSync(err)) {
                            return;
                        }
                        this._failedSyncCount++;
                        _logger.logger.log('Number of consecutive failed sync requests:', this._failedSyncCount);
                        debuglog("Starting keep-alive");
                        this._startKeepAlives().then(function (connDidFail) {
                            if (connDidFail && _this3.getSyncState() === 'ERROR') {
                                _this3._updateSyncState("CATCHUP", {
                                    oldSyncToken: null,
                                    nextSyncToken: null,
                                    catchingUp: true
                                });
                            }
                            _this3._sync(syncOptions);
                        });
                        this._currentSyncRequest = null;
                        this._updateSyncState(this._failedSyncCount >= FAILED_SYNC_ERROR_THRESHOLD ? "ERROR" : "RECONNECTING", {
                            error: err
                        });
                    };
                    SyncApi.prototype._processSyncResponse = function () {
                        var _ref6 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee10(syncEventData, data) {
                            var client, self, events, prevEventsMap, cancelledKeyVerificationTxns, inviteRooms, joinRooms, leaveRooms, currentCount, unusedFallbackKeys;
                            return _regenerator["default"].wrap(function _callee10$(_context10) {
                                while (1) {
                                    switch (_context10.prev = _context10.next) {
                                        case 0:
                                            client = this.client;
                                            self = this;
                                            if (data.presence && utils.isArray(data.presence.events)) {
                                                data.presence.events.map(client.getEventMapper()).forEach(function (presenceEvent) {
                                                    var user = client.store.getUser(presenceEvent.getSender());
                                                    if (user) {
                                                        user.setPresenceEvent(presenceEvent);
                                                    }
                                                    else {
                                                        user = createNewUser(client, presenceEvent.getSender());
                                                        user.setPresenceEvent(presenceEvent);
                                                        client.store.storeUser(user);
                                                    }
                                                    client.emit("event", presenceEvent);
                                                });
                                            }
                                            if (data.account_data && utils.isArray(data.account_data.events)) {
                                                events = data.account_data.events.map(client.getEventMapper());
                                                prevEventsMap = events.reduce(function (m, c) {
                                                    m[c.getId()] = client.store.getAccountData(c.getType());
                                                    return m;
                                                }, {});
                                                client.store.storeAccountDataEvents(events);
                                                events.forEach(function (accountDataEvent) {
                                                    if (accountDataEvent.getType() === 'm.push_rules') {
                                                        var rules = accountDataEvent.getContent();
                                                        client.pushRules = _pushprocessor.PushProcessor.rewriteDefaultRules(rules);
                                                    }
                                                    var prevEvent = prevEventsMap[accountDataEvent.getId()];
                                                    client.emit("accountData", accountDataEvent, prevEvent);
                                                    return accountDataEvent;
                                                });
                                            }
                                            if (data.to_device && utils.isArray(data.to_device.events) && data.to_device.events.length > 0) {
                                                cancelledKeyVerificationTxns = [];
                                                data.to_device.events.map(client.getEventMapper()).map(function (toDeviceEvent) {
                                                    if (toDeviceEvent.getType() === "m.key.verification.cancel") {
                                                        var txnId = toDeviceEvent.getContent()['transaction_id'];
                                                        if (txnId) {
                                                            cancelledKeyVerificationTxns.push(txnId);
                                                        }
                                                    }
                                                    return toDeviceEvent;
                                                }).forEach(function (toDeviceEvent) {
                                                    var content = toDeviceEvent.getContent();
                                                    if (toDeviceEvent.getType() == "m.room.message" && content.msgtype == "m.bad.encrypted") {
                                                        _logger.logger.log('Ignoring undecryptable to-device event from ' + toDeviceEvent.getSender());
                                                        return;
                                                    }
                                                    if (toDeviceEvent.getType() === "m.key.verification.start" || toDeviceEvent.getType() === "m.key.verification.request") {
                                                        var txnId = content['transaction_id'];
                                                        if (cancelledKeyVerificationTxns.includes(txnId)) {
                                                            toDeviceEvent.flagCancelled();
                                                        }
                                                    }
                                                    client.emit("toDeviceEvent", toDeviceEvent);
                                                });
                                            }
                                            else {
                                                this._catchingUp = false;
                                            }
                                            if (data.groups) {
                                                if (data.groups.invite) {
                                                    this._processGroupSyncEntry(data.groups.invite, 'invite');
                                                }
                                                if (data.groups.join) {
                                                    this._processGroupSyncEntry(data.groups.join, 'join');
                                                }
                                                if (data.groups.leave) {
                                                    this._processGroupSyncEntry(data.groups.leave, 'leave');
                                                }
                                            }
                                            inviteRooms = [];
                                            joinRooms = [];
                                            leaveRooms = [];
                                            if (data.rooms) {
                                                if (data.rooms.invite) {
                                                    inviteRooms = this._mapSyncResponseToRoomArray(data.rooms.invite);
                                                }
                                                if (data.rooms.join) {
                                                    joinRooms = this._mapSyncResponseToRoomArray(data.rooms.join);
                                                }
                                                if (data.rooms.leave) {
                                                    leaveRooms = this._mapSyncResponseToRoomArray(data.rooms.leave);
                                                }
                                            }
                                            this._notifEvents = [];
                                            inviteRooms.forEach(function (inviteObj) {
                                                var room = inviteObj.room;
                                                var stateEvents = self._mapSyncEventsFormat(inviteObj.invite_state, room);
                                                self._processRoomEvents(room, stateEvents);
                                                if (inviteObj.isBrandNewRoom) {
                                                    room.recalculate();
                                                    client.store.storeRoom(room);
                                                    client.emit("Room", room);
                                                }
                                                stateEvents.forEach(function (e) {
                                                    client.emit("event", e);
                                                });
                                                room.updateMyMembership("invite");
                                            });
                                            _context10.next = 14;
                                            return utils.promiseMapSeries(joinRooms, function () {
                                                var _ref7 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee9(joinObj) {
                                                    var room, stateEvents, timelineEvents, ephemeralEvents, accountDataEvents, encrypted, limited, i, eventId, processRoomEvent, _processRoomEvent;
                                                    return _regenerator["default"].wrap(function _callee9$(_context9) {
                                                        while (1) {
                                                            switch (_context9.prev = _context9.next) {
                                                                case 0:
                                                                    _processRoomEvent = function _processRoomEvent3() {
                                                                        _processRoomEvent = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee8(e) {
                                                                            var user;
                                                                            return _regenerator["default"].wrap(function _callee8$(_context8) {
                                                                                while (1) {
                                                                                    switch (_context8.prev = _context8.next) {
                                                                                        case 0:
                                                                                            client.emit("event", e);
                                                                                            if (!(e.isState() && e.getType() == "m.room.encryption" && self.opts.crypto)) {
                                                                                                _context8.next = 4;
                                                                                                break;
                                                                                            }
                                                                                            _context8.next = 4;
                                                                                            return self.opts.crypto.onCryptoEvent(e);
                                                                                        case 4:
                                                                                            if (e.isState() && e.getType() === "im.vector.user_status") {
                                                                                                user = client.store.getUser(e.getStateKey());
                                                                                                if (user) {
                                                                                                    user._unstable_updateStatusMessage(e);
                                                                                                }
                                                                                                else {
                                                                                                    user = createNewUser(client, e.getStateKey());
                                                                                                    user._unstable_updateStatusMessage(e);
                                                                                                    client.store.storeUser(user);
                                                                                                }
                                                                                            }
                                                                                        case 5:
                                                                                        case "end":
                                                                                            return _context8.stop();
                                                                                    }
                                                                                }
                                                                            }, _callee8);
                                                                        }));
                                                                        return _processRoomEvent.apply(this, arguments);
                                                                    };
                                                                    processRoomEvent = function _processRoomEvent2(_x9) {
                                                                        return _processRoomEvent.apply(this, arguments);
                                                                    };
                                                                    room = joinObj.room;
                                                                    stateEvents = self._mapSyncEventsFormat(joinObj.state, room);
                                                                    timelineEvents = self._mapSyncEventsFormat(joinObj.timeline, room);
                                                                    ephemeralEvents = self._mapSyncEventsFormat(joinObj.ephemeral);
                                                                    accountDataEvents = self._mapSyncEventsFormat(joinObj.account_data);
                                                                    if (joinObj.unread_notifications) {
                                                                        room.setUnreadNotificationCount('total', joinObj.unread_notifications.notification_count);
                                                                        encrypted = client.isRoomEncrypted(room.roomId);
                                                                        if (!encrypted || encrypted && room.getUnreadNotificationCount('highlight') <= 0) {
                                                                            room.setUnreadNotificationCount('highlight', joinObj.unread_notifications.highlight_count);
                                                                        }
                                                                    }
                                                                    joinObj.timeline = joinObj.timeline || {};
                                                                    if (!joinObj.isBrandNewRoom) {
                                                                        _context9.next = 13;
                                                                        break;
                                                                    }
                                                                    room.getLiveTimeline().setPaginationToken(joinObj.timeline.prev_batch, _eventTimeline.EventTimeline.BACKWARDS);
                                                                    _context9.next = 27;
                                                                    break;
                                                                case 13:
                                                                    if (!joinObj.timeline.limited) {
                                                                        _context9.next = 27;
                                                                        break;
                                                                    }
                                                                    limited = true;
                                                                    i = timelineEvents.length - 1;
                                                                case 16:
                                                                    if (!(i >= 0)) {
                                                                        _context9.next = 26;
                                                                        break;
                                                                    }
                                                                    eventId = timelineEvents[i].getId();
                                                                    if (!room.getTimelineForEvent(eventId)) {
                                                                        _context9.next = 23;
                                                                        break;
                                                                    }
                                                                    debuglog("Already have event " + eventId + " in limited " + "sync - not resetting");
                                                                    limited = false;
                                                                    timelineEvents.splice(0, i);
                                                                    return _context9.abrupt("break", 26);
                                                                case 23:
                                                                    i--;
                                                                    _context9.next = 16;
                                                                    break;
                                                                case 26:
                                                                    if (limited) {
                                                                        self._deregisterStateListeners(room);
                                                                        room.resetLiveTimeline(joinObj.timeline.prev_batch, self.opts.canResetEntireTimeline(room.roomId) ? null : syncEventData.oldSyncToken);
                                                                        client.resetNotifTimelineSet();
                                                                        self._registerStateListeners(room);
                                                                    }
                                                                case 27:
                                                                    self._processRoomEvents(room, stateEvents, timelineEvents, syncEventData.fromCache);
                                                                    if (joinObj.summary) {
                                                                        room.setSummary(joinObj.summary);
                                                                    }
                                                                    room.addEphemeralEvents(ephemeralEvents);
                                                                    room.addAccountData(accountDataEvents);
                                                                    room.recalculate();
                                                                    if (joinObj.isBrandNewRoom) {
                                                                        client.store.storeRoom(room);
                                                                        client.emit("Room", room);
                                                                    }
                                                                    self._processEventsForNotifs(room, timelineEvents);
                                                                    _context9.next = 36;
                                                                    return utils.promiseMapSeries(stateEvents, processRoomEvent);
                                                                case 36:
                                                                    _context9.next = 38;
                                                                    return utils.promiseMapSeries(timelineEvents, processRoomEvent);
                                                                case 38:
                                                                    ephemeralEvents.forEach(function (e) {
                                                                        client.emit("event", e);
                                                                    });
                                                                    accountDataEvents.forEach(function (e) {
                                                                        client.emit("event", e);
                                                                    });
                                                                    room.updateMyMembership("join");
                                                                case 41:
                                                                case "end":
                                                                    return _context9.stop();
                                                            }
                                                        }
                                                    }, _callee9);
                                                }));
                                                return function (_x8) {
                                                    return _ref7.apply(this, arguments);
                                                };
                                            }());
                                        case 14:
                                            leaveRooms.forEach(function (leaveObj) {
                                                var room = leaveObj.room;
                                                var stateEvents = self._mapSyncEventsFormat(leaveObj.state, room);
                                                var timelineEvents = self._mapSyncEventsFormat(leaveObj.timeline, room);
                                                var accountDataEvents = self._mapSyncEventsFormat(leaveObj.account_data);
                                                self._processRoomEvents(room, stateEvents, timelineEvents);
                                                room.addAccountData(accountDataEvents);
                                                room.recalculate();
                                                if (leaveObj.isBrandNewRoom) {
                                                    client.store.storeRoom(room);
                                                    client.emit("Room", room);
                                                }
                                                self._processEventsForNotifs(room, timelineEvents);
                                                stateEvents.forEach(function (e) {
                                                    client.emit("event", e);
                                                });
                                                timelineEvents.forEach(function (e) {
                                                    client.emit("event", e);
                                                });
                                                accountDataEvents.forEach(function (e) {
                                                    client.emit("event", e);
                                                });
                                                room.updateMyMembership("leave");
                                            });
                                            if (syncEventData.oldSyncToken && this._notifEvents.length) {
                                                this._notifEvents.sort(function (a, b) {
                                                    return a.getTs() - b.getTs();
                                                });
                                                this._notifEvents.forEach(function (event) {
                                                    client.getNotifTimelineSet().addLiveEvent(event);
                                                });
                                            }
                                            if (!data.device_lists) {
                                                _context10.next = 22;
                                                break;
                                            }
                                            if (!this.opts.crypto) {
                                                _context10.next = 22;
                                                break;
                                            }
                                            _context10.next = 20;
                                            return this.opts.crypto.handleDeviceListChanges(syncEventData, data.device_lists);
                                        case 20:
                                            _context10.next = 22;
                                            break;
                                        case 22:
                                            if (this.opts.crypto && data.device_one_time_keys_count) {
                                                currentCount = data.device_one_time_keys_count.signed_curve25519 || 0;
                                                this.opts.crypto.updateOneTimeKeyCount(currentCount);
                                            }
                                            if (this.opts.crypto && data["org.matrix.msc2732.device_unused_fallback_key_types"]) {
                                                unusedFallbackKeys = data["org.matrix.msc2732.device_unused_fallback_key_types"];
                                                this.opts.crypto.setNeedsNewFallback(unusedFallbackKeys instanceof Array && !unusedFallbackKeys.includes("signed_curve25519"));
                                            }
                                        case 24:
                                        case "end":
                                            return _context10.stop();
                                    }
                                }
                            }, _callee10, this);
                        }));
                        return function (_x6, _x7) {
                            return _ref6.apply(this, arguments);
                        };
                    }();
                    SyncApi.prototype._startKeepAlives = function (delay) {
                        if (delay === undefined) {
                            delay = 2000 + Math.floor(Math.random() * 5000);
                        }
                        if (this._keepAliveTimer !== null) {
                            clearTimeout(this._keepAliveTimer);
                        }
                        var self = this;
                        if (delay > 0) {
                            self._keepAliveTimer = setTimeout(self._pokeKeepAlive.bind(self), delay);
                        }
                        else {
                            self._pokeKeepAlive();
                        }
                        if (!this._connectionReturnedDefer) {
                            this._connectionReturnedDefer = utils.defer();
                        }
                        return this._connectionReturnedDefer.promise;
                    };
                    SyncApi.prototype._pokeKeepAlive = function (connDidFail) {
                        if (connDidFail === undefined)
                            connDidFail = false;
                        var self = this;
                        function success() {
                            clearTimeout(self._keepAliveTimer);
                            if (self._connectionReturnedDefer) {
                                self._connectionReturnedDefer.resolve(connDidFail);
                                self._connectionReturnedDefer = null;
                            }
                        }
                        this.client._http.request(undefined, "GET", "/_matrix/client/versions", undefined, undefined, {
                            prefix: '',
                            localTimeoutMs: 15 * 1000
                        }).then(function () {
                            success();
                        }, function (err) {
                            if (err.httpStatus == 400 || err.httpStatus == 404) {
                                self._keepAliveTimer = setTimeout(success, 2000);
                            }
                            else {
                                connDidFail = true;
                                self._keepAliveTimer = setTimeout(self._pokeKeepAlive.bind(self, connDidFail), 5000 + Math.floor(Math.random() * 5000));
                                self._updateSyncState("ERROR", {
                                    error: err
                                });
                            }
                        });
                    };
                    SyncApi.prototype._processGroupSyncEntry = function (groupsSection, sectionName) {
                        for (var _i = 0, _Object$keys = Object.keys(groupsSection); _i < _Object$keys.length; _i++) {
                            var groupId = _Object$keys[_i];
                            var groupInfo = groupsSection[groupId];
                            var group = this.client.store.getGroup(groupId);
                            var isBrandNew = group === null;
                            if (group === null) {
                                group = this.createGroup(groupId);
                            }
                            if (groupInfo.profile) {
                                group.setProfile(groupInfo.profile.name, groupInfo.profile.avatar_url);
                            }
                            if (groupInfo.inviter) {
                                group.setInviter({
                                    userId: groupInfo.inviter
                                });
                            }
                            group.setMyMembership(sectionName);
                            if (isBrandNew) {
                                this.client.emit("Group", group);
                            }
                        }
                    };
                    SyncApi.prototype._mapSyncResponseToRoomArray = function (obj) {
                        var client = this.client;
                        var self = this;
                        return utils.keys(obj).map(function (roomId) {
                            var arrObj = obj[roomId];
                            var room = client.store.getRoom(roomId);
                            var isBrandNewRoom = false;
                            if (!room) {
                                room = self.createRoom(roomId);
                                isBrandNewRoom = true;
                            }
                            arrObj.room = room;
                            arrObj.isBrandNewRoom = isBrandNewRoom;
                            return arrObj;
                        });
                    };
                    SyncApi.prototype._mapSyncEventsFormat = function (obj, room) {
                        if (!obj || !utils.isArray(obj.events)) {
                            return [];
                        }
                        var mapper = this.client.getEventMapper();
                        return obj.events.map(function (e) {
                            if (room) {
                                e.room_id = room.roomId;
                            }
                            return mapper(e);
                        });
                    };
                    SyncApi.prototype._resolveInvites = function (room) {
                        if (!room || !this.opts.resolveInvitesToProfiles) {
                            return;
                        }
                        var client = this.client;
                        room.getMembersWithMembership("invite").forEach(function (member) {
                            if (member._requestedProfileInfo) {
                                return;
                            }
                            member._requestedProfileInfo = true;
                            var user = client.getUser(member.userId);
                            var promise;
                            if (user) {
                                promise = Promise.resolve({
                                    avatar_url: user.avatarUrl,
                                    displayname: user.displayName
                                });
                            }
                            else {
                                promise = client.getProfileInfo(member.userId);
                            }
                            promise.then(function (info) {
                                var inviteEvent = member.events.member;
                                if (inviteEvent.getContent().membership !== "invite") {
                                    return;
                                }
                                inviteEvent.getContent().avatar_url = info.avatar_url;
                                inviteEvent.getContent().displayname = info.displayname;
                                member.setMembershipEvent(inviteEvent, room.currentState);
                            }, function (err) {
                            });
                        });
                    };
                    SyncApi.prototype._processRoomEvents = function (room, stateEventList, timelineEventList, fromCache) {
                        var liveTimeline = room.getLiveTimeline();
                        var timelineWasEmpty = liveTimeline.getEvents().length == 0;
                        if (timelineWasEmpty) {
                            var _iterator = _createForOfIteratorHelper(stateEventList), _step;
                            try {
                                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                                    var ev = _step.value;
                                    this.client.getPushActionsForEvent(ev);
                                }
                            }
                            catch (err) {
                                _iterator.e(err);
                            }
                            finally {
                                _iterator.f();
                            }
                            liveTimeline.initialiseState(stateEventList);
                        }
                        this._resolveInvites(room);
                        room.recalculate();
                        if (!timelineWasEmpty) {
                            room.oldState.setStateEvents(stateEventList || []);
                            room.currentState.setStateEvents(stateEventList || []);
                        }
                        room.addLiveEvents(timelineEventList || [], null, fromCache);
                    };
                    SyncApi.prototype._processEventsForNotifs = function (room, timelineEventList) {
                        if (this.client.getNotifTimelineSet()) {
                            for (var i = 0; i < timelineEventList.length; i++) {
                                var pushActions = this.client.getPushActionsForEvent(timelineEventList[i]);
                                if (pushActions && pushActions.notify && pushActions.tweaks && pushActions.tweaks.highlight) {
                                    this._notifEvents.push(timelineEventList[i]);
                                }
                            }
                        }
                    };
                    SyncApi.prototype._getGuestFilter = function () {
                        var guestRooms = this.client._guestRooms;
                        if (!guestRooms) {
                            return "{}";
                        }
                        return JSON.stringify({
                            room: {
                                timeline: {
                                    limit: 20
                                }
                            }
                        });
                    };
                    SyncApi.prototype._updateSyncState = function (newState, data) {
                        var old = this._syncState;
                        this._syncState = newState;
                        this._syncStateData = data;
                        this.client.emit("sync", this._syncState, old, data);
                    };
                    SyncApi.prototype._onOnline = function () {
                        debuglog("Browser thinks we are back online");
                        this._startKeepAlives(0);
                    };
                    function createNewUser(client, userId) {
                        var user = new _user.User(userId);
                        client.reEmitter.reEmit(user, ["User.avatarUrl", "User.displayName", "User.presence", "User.currentlyActive", "User.lastPresenceTs"]);
                        return user;
                    }
                }).call(this);
            }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, { "./errors": 91, "./filter": 93, "./logger": 97, "./models/event-timeline": 101, "./models/group": 103, "./models/room": 108, "./models/user": 110, "./pushprocessor": 111, "./utils": 125, "@babel/runtime/helpers/asyncToGenerator": 5, "@babel/runtime/helpers/interopRequireDefault": 12, "@babel/runtime/helpers/interopRequireWildcard": 13, "@babel/runtime/regenerator": 27 }], 124: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.TimelineWindow = TimelineWindow;
            exports.TimelineIndex = TimelineIndex;
            var _eventTimeline = require("./models/event-timeline");
            var _logger = require("./logger");
            var DEBUG = false;
            var debuglog = DEBUG ? _logger.logger.log.bind(_logger.logger) : function () { };
            var DEFAULT_PAGINATE_LOOP_LIMIT = 5;
            function TimelineWindow(client, timelineSet, opts) {
                opts = opts || {};
                this._client = client;
                this._timelineSet = timelineSet;
                this._start = null;
                this._end = null;
                this._eventCount = 0;
                this._windowLimit = opts.windowLimit || 1000;
            }
            TimelineWindow.prototype.load = function (initialEventId, initialWindowSize) {
                var self = this;
                initialWindowSize = initialWindowSize || 20;
                var initFields = function initFields(timeline) {
                    var eventIndex;
                    var events = timeline.getEvents();
                    if (!initialEventId) {
                        eventIndex = events.length;
                    }
                    else {
                        for (var i = 0; i < events.length; i++) {
                            if (events[i].getId() == initialEventId) {
                                eventIndex = i;
                                break;
                            }
                        }
                        if (eventIndex === undefined) {
                            throw new Error("getEventTimeline result didn't include requested event");
                        }
                    }
                    var endIndex = Math.min(events.length, eventIndex + Math.ceil(initialWindowSize / 2));
                    var startIndex = Math.max(0, endIndex - initialWindowSize);
                    self._start = new TimelineIndex(timeline, startIndex - timeline.getBaseIndex());
                    self._end = new TimelineIndex(timeline, endIndex - timeline.getBaseIndex());
                    self._eventCount = endIndex - startIndex;
                };
                if (initialEventId) {
                    var timeline = this._timelineSet.getTimelineForEvent(initialEventId);
                    if (timeline) {
                        initFields(timeline);
                        return Promise.resolve(timeline);
                    }
                    var prom = this._client.getEventTimeline(this._timelineSet, initialEventId);
                    return prom.then(initFields);
                }
                else {
                    var tl = this._timelineSet.getLiveTimeline();
                    initFields(tl);
                    return Promise.resolve();
                }
            };
            TimelineWindow.prototype.getTimelineIndex = function (direction) {
                if (direction == _eventTimeline.EventTimeline.BACKWARDS) {
                    return this._start;
                }
                else if (direction == _eventTimeline.EventTimeline.FORWARDS) {
                    return this._end;
                }
                else {
                    throw new Error("Invalid direction '" + direction + "'");
                }
            };
            TimelineWindow.prototype.extend = function (direction, size) {
                var tl = this.getTimelineIndex(direction);
                if (!tl) {
                    debuglog("TimelineWindow: no timeline yet");
                    return false;
                }
                var count = direction == _eventTimeline.EventTimeline.BACKWARDS ? tl.retreat(size) : tl.advance(size);
                if (count) {
                    this._eventCount += count;
                    debuglog("TimelineWindow: increased cap by " + count + " (now " + this._eventCount + ")");
                    var excess = this._eventCount - this._windowLimit;
                    if (excess > 0) {
                        this.unpaginate(excess, direction != _eventTimeline.EventTimeline.BACKWARDS);
                    }
                    return true;
                }
                return false;
            };
            TimelineWindow.prototype.canPaginate = function (direction) {
                var tl = this.getTimelineIndex(direction);
                if (!tl) {
                    debuglog("TimelineWindow: no timeline yet");
                    return false;
                }
                if (direction == _eventTimeline.EventTimeline.BACKWARDS) {
                    if (tl.index > tl.minIndex()) {
                        return true;
                    }
                }
                else {
                    if (tl.index < tl.maxIndex()) {
                        return true;
                    }
                }
                return Boolean(tl.timeline.getNeighbouringTimeline(direction) || tl.timeline.getPaginationToken(direction));
            };
            TimelineWindow.prototype.paginate = function (direction, size, makeRequest, requestLimit) {
                if (makeRequest === undefined) {
                    makeRequest = true;
                }
                if (requestLimit === undefined) {
                    requestLimit = DEFAULT_PAGINATE_LOOP_LIMIT;
                }
                var tl = this.getTimelineIndex(direction);
                if (!tl) {
                    debuglog("TimelineWindow: no timeline yet");
                    return Promise.resolve(false);
                }
                if (tl.pendingPaginate) {
                    return tl.pendingPaginate;
                }
                if (this.extend(direction, size)) {
                    return Promise.resolve(true);
                }
                if (!makeRequest || requestLimit === 0) {
                    return Promise.resolve(false);
                }
                var token = tl.timeline.getPaginationToken(direction);
                if (!token) {
                    debuglog("TimelineWindow: no token");
                    return Promise.resolve(false);
                }
                debuglog("TimelineWindow: starting request");
                var self = this;
                var prom = this._client.paginateEventTimeline(tl.timeline, {
                    backwards: direction == _eventTimeline.EventTimeline.BACKWARDS,
                    limit: size
                })["finally"](function () {
                    tl.pendingPaginate = null;
                }).then(function (r) {
                    debuglog("TimelineWindow: request completed with result " + r);
                    if (!r) {
                        return false;
                    }
                    return self.paginate(direction, size, true, requestLimit - 1);
                });
                tl.pendingPaginate = prom;
                return prom;
            };
            TimelineWindow.prototype.unpaginate = function (delta, startOfTimeline) {
                var tl = startOfTimeline ? this._start : this._end;
                if (delta > this._eventCount || delta < 0) {
                    throw new Error("Attemting to unpaginate " + delta + " events, but " + "only have " + this._eventCount + " in the timeline");
                }
                while (delta > 0) {
                    var count = startOfTimeline ? tl.advance(delta) : tl.retreat(delta);
                    if (count <= 0) {
                        throw new Error("Unable to unpaginate any further, but still have " + this._eventCount + " events");
                    }
                    delta -= count;
                    this._eventCount -= count;
                    debuglog("TimelineWindow.unpaginate: dropped " + count + " (now " + this._eventCount + ")");
                }
            };
            TimelineWindow.prototype.getEvents = function () {
                if (!this._start) {
                    return [];
                }
                var result = [];
                var timeline = this._start.timeline;
                while (true) {
                    var events = timeline.getEvents();
                    var startIndex = 0;
                    var endIndex = events.length;
                    if (timeline === this._start.timeline) {
                        startIndex = this._start.index + timeline.getBaseIndex();
                    }
                    if (timeline === this._end.timeline) {
                        endIndex = this._end.index + timeline.getBaseIndex();
                    }
                    for (var i = startIndex; i < endIndex; i++) {
                        result.push(events[i]);
                    }
                    if (timeline === this._end.timeline) {
                        break;
                    }
                    else {
                        timeline = timeline.getNeighbouringTimeline(_eventTimeline.EventTimeline.FORWARDS);
                    }
                }
                return result;
            };
            function TimelineIndex(timeline, index) {
                this.timeline = timeline;
                this.index = index;
            }
            TimelineIndex.prototype.minIndex = function () {
                return this.timeline.getBaseIndex() * -1;
            };
            TimelineIndex.prototype.maxIndex = function () {
                return this.timeline.getEvents().length - this.timeline.getBaseIndex();
            };
            TimelineIndex.prototype.advance = function (delta) {
                if (!delta) {
                    return 0;
                }
                var cappedDelta;
                if (delta < 0) {
                    cappedDelta = Math.max(delta, this.minIndex() - this.index);
                    if (cappedDelta < 0) {
                        this.index += cappedDelta;
                        return cappedDelta;
                    }
                }
                else {
                    cappedDelta = Math.min(delta, this.maxIndex() - this.index);
                    if (cappedDelta > 0) {
                        this.index += cappedDelta;
                        return cappedDelta;
                    }
                }
                var neighbour = this.timeline.getNeighbouringTimeline(delta < 0 ? _eventTimeline.EventTimeline.BACKWARDS : _eventTimeline.EventTimeline.FORWARDS);
                if (neighbour) {
                    this.timeline = neighbour;
                    if (delta < 0) {
                        this.index = this.maxIndex();
                    }
                    else {
                        this.index = this.minIndex();
                    }
                    debuglog("paginate: switched to new neighbour");
                    return this.advance(delta);
                }
                return 0;
            };
            TimelineIndex.prototype.retreat = function (delta) {
                return this.advance(delta * -1) * -1;
            };
        }, { "./logger": 97, "./models/event-timeline": 101 }], 125: [function (require, module, exports) {
            "use strict";
            var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
                function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
                return new (P || (P = Promise))(function (resolve, reject) {
                    function fulfilled(value) { try {
                        step(generator.next(value));
                    }
                    catch (e) {
                        reject(e);
                    } }
                    function rejected(value) { try {
                        step(generator["throw"](value));
                    }
                    catch (e) {
                        reject(e);
                    } }
                    function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
                    step((generator = generator.apply(thisArg, _arguments || [])).next());
                });
            };
            var __importDefault = (this && this.__importDefault) || function (mod) {
                return (mod && mod.__esModule) ? mod : { "default": mod };
            };
            Object.defineProperty(exports, "__esModule", { value: true });
            exports.getCrypto = exports.setCrypto = exports.promiseTry = exports.promiseMapSeries = exports.defer = exports.isNullOrUndefined = exports.sleep = exports.ensureNoTrailingSlash = exports.globToRegexp = exports.escapeRegExp = exports.removeHiddenChars = exports.isNumber = exports.polyfillSuper = exports.inherits = exports.runPolyfills = exports.extend = exports.deepCompare = exports.deepCopy = exports.checkObjectHasNoAdditionalKeys = exports.checkObjectHasKeys = exports.isArray = exports.isFunction = exports.removeElement = exports.findElement = exports.forEach = exports.values = exports.keys = exports.filter = exports.map = exports.encodeUri = exports.encodeParams = void 0;
            const unhomoglyph_1 = __importDefault(require("unhomoglyph"));
            function encodeParams(params) {
                let qs = "";
                for (const key in params) {
                    if (!params.hasOwnProperty(key)) {
                        continue;
                    }
                    qs += "&" + encodeURIComponent(key) + "=" +
                        encodeURIComponent(params[key]);
                }
                return qs.substring(1);
            }
            exports.encodeParams = encodeParams;
            function encodeUri(pathTemplate, variables) {
                for (const key in variables) {
                    if (!variables.hasOwnProperty(key)) {
                        continue;
                    }
                    pathTemplate = pathTemplate.replace(key, encodeURIComponent(variables[key]));
                }
                return pathTemplate;
            }
            exports.encodeUri = encodeUri;
            function map(array, fn) {
                const results = new Array(array.length);
                for (let i = 0; i < array.length; i++) {
                    results[i] = fn(array[i]);
                }
                return results;
            }
            exports.map = map;
            function filter(array, fn) {
                const results = [];
                for (let i = 0; i < array.length; i++) {
                    if (fn(array[i], i, array)) {
                        results.push(array[i]);
                    }
                }
                return results;
            }
            exports.filter = filter;
            function keys(obj) {
                const result = [];
                for (const key in obj) {
                    if (!obj.hasOwnProperty(key)) {
                        continue;
                    }
                    result.push(key);
                }
                return result;
            }
            exports.keys = keys;
            function values(obj) {
                const result = [];
                for (const key in obj) {
                    if (!obj.hasOwnProperty(key)) {
                        continue;
                    }
                    result.push(obj[key]);
                }
                return result;
            }
            exports.values = values;
            function forEach(array, fn) {
                for (let i = 0; i < array.length; i++) {
                    fn(array[i], i);
                }
            }
            exports.forEach = forEach;
            function findElement(array, fn, reverse) {
                let i;
                if (reverse) {
                    for (i = array.length - 1; i >= 0; i--) {
                        if (fn(array[i], i, array)) {
                            return array[i];
                        }
                    }
                }
                else {
                    for (i = 0; i < array.length; i++) {
                        if (fn(array[i], i, array)) {
                            return array[i];
                        }
                    }
                }
            }
            exports.findElement = findElement;
            function removeElement(array, fn, reverse) {
                let i;
                let removed;
                if (reverse) {
                    for (i = array.length - 1; i >= 0; i--) {
                        if (fn(array[i], i, array)) {
                            removed = array[i];
                            array.splice(i, 1);
                            return removed;
                        }
                    }
                }
                else {
                    for (i = 0; i < array.length; i++) {
                        if (fn(array[i], i, array)) {
                            removed = array[i];
                            array.splice(i, 1);
                            return removed;
                        }
                    }
                }
                return false;
            }
            exports.removeElement = removeElement;
            function isFunction(value) {
                return Object.prototype.toString.call(value) === "[object Function]";
            }
            exports.isFunction = isFunction;
            function isArray(value) {
                return Array.isArray ? Array.isArray(value) :
                    Boolean(value && value.constructor === Array);
            }
            exports.isArray = isArray;
            function checkObjectHasKeys(obj, keys_) {
                for (let i = 0; i < keys_.length; i++) {
                    if (!obj.hasOwnProperty(keys_[i])) {
                        throw new Error("Missing required key: " + keys_[i]);
                    }
                }
            }
            exports.checkObjectHasKeys = checkObjectHasKeys;
            function checkObjectHasNoAdditionalKeys(obj, allowedKeys) {
                for (const key in obj) {
                    if (!obj.hasOwnProperty(key)) {
                        continue;
                    }
                    if (allowedKeys.indexOf(key) === -1) {
                        throw new Error("Unknown key: " + key);
                    }
                }
            }
            exports.checkObjectHasNoAdditionalKeys = checkObjectHasNoAdditionalKeys;
            function deepCopy(obj) {
                return JSON.parse(JSON.stringify(obj));
            }
            exports.deepCopy = deepCopy;
            function deepCompare(x, y) {
                if (x === y) {
                    return true;
                }
                if (typeof x !== typeof y) {
                    return false;
                }
                if (typeof x === 'number' && isNaN(x) && isNaN(y)) {
                    return true;
                }
                if (x === null || y === null) {
                    return x === y;
                }
                if (!(x instanceof Object)) {
                    return false;
                }
                if (x.constructor !== y.constructor || x.prototype !== y.prototype) {
                    return false;
                }
                if (x instanceof RegExp || x instanceof Date) {
                    return x.toString() === y.toString();
                }
                if (x instanceof Array) {
                    if (x.length !== y.length) {
                        return false;
                    }
                    for (let i = 0; i < x.length; i++) {
                        if (!deepCompare(x[i], y[i])) {
                            return false;
                        }
                    }
                }
                else {
                    let p;
                    for (p in y) {
                        if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {
                            return false;
                        }
                    }
                    for (p in y) {
                        if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {
                            return false;
                        }
                        if (!deepCompare(x[p], y[p])) {
                            return false;
                        }
                    }
                }
                return true;
            }
            exports.deepCompare = deepCompare;
            function extend(...restParams) {
                const target = restParams[0] || {};
                for (let i = 1; i < restParams.length; i++) {
                    const source = restParams[i];
                    if (!source)
                        continue;
                    for (const propName in source) {
                        target[propName] = source[propName];
                    }
                }
                return target;
            }
            exports.extend = extend;
            function runPolyfills() {
                if (!Array.prototype.filter) {
                    Array.prototype.filter = function (fun, ...restProps) {
                        if (this === void 0 || this === null) {
                            throw new TypeError();
                        }
                        const t = Object(this);
                        const len = t.length >>> 0;
                        if (typeof fun !== 'function') {
                            throw new TypeError();
                        }
                        const res = [];
                        const thisArg = restProps ? restProps[0] : void 0;
                        for (let i = 0; i < len; i++) {
                            if (i in t) {
                                const val = t[i];
                                if (fun.call(thisArg, val, i, t)) {
                                    res.push(val);
                                }
                            }
                        }
                        return res;
                    };
                }
                if (!Array.prototype.map) {
                    Array.prototype.map = function (callback, thisArg) {
                        let T;
                        let k;
                        if (this === null || this === undefined) {
                            throw new TypeError(' this is null or not defined');
                        }
                        const O = Object(this);
                        const len = O.length >>> 0;
                        if (typeof callback !== 'function') {
                            throw new TypeError(callback + ' is not a function');
                        }
                        if (arguments.length > 1) {
                            T = thisArg;
                        }
                        const A = new Array(len);
                        k = 0;
                        while (k < len) {
                            let kValue;
                            let mappedValue;
                            if (k in O) {
                                kValue = O[k];
                                mappedValue = callback.call(T, kValue, k, O);
                                A[k] = mappedValue;
                            }
                            k++;
                        }
                        return A;
                    };
                }
                if (!Array.prototype.forEach) {
                    Array.prototype.forEach = function (callback, thisArg) {
                        let T;
                        let k;
                        if (this === null || this === undefined) {
                            throw new TypeError(' this is null or not defined');
                        }
                        const O = Object(this);
                        const len = O.length >>> 0;
                        if (typeof callback !== "function") {
                            throw new TypeError(callback + ' is not a function');
                        }
                        if (arguments.length > 1) {
                            T = thisArg;
                        }
                        k = 0;
                        while (k < len) {
                            let kValue;
                            if (k in O) {
                                kValue = O[k];
                                callback.call(T, kValue, k, O);
                            }
                            k++;
                        }
                    };
                }
            }
            exports.runPolyfills = runPolyfills;
            function inherits(ctor, superCtor) {
                ctor.super_ = superCtor;
                ctor.prototype = Object.create(superCtor.prototype, {
                    constructor: {
                        value: ctor,
                        enumerable: false,
                        writable: true,
                        configurable: true,
                    },
                });
            }
            exports.inherits = inherits;
            function polyfillSuper(thisArg, SuperType, ...params) {
                try {
                    SuperType.call(thisArg, ...params);
                }
                catch (e) {
                    const fakeSuper = new SuperType(...params);
                    Object.assign(thisArg, fakeSuper);
                }
            }
            exports.polyfillSuper = polyfillSuper;
            function isNumber(value) {
                return typeof value === 'number' && isFinite(value);
            }
            exports.isNumber = isNumber;
            function removeHiddenChars(str) {
                if (typeof str === "string") {
                    return unhomoglyph_1.default(str.normalize('NFD').replace(removeHiddenCharsRegex, ''));
                }
                return "";
            }
            exports.removeHiddenChars = removeHiddenChars;
            const removeHiddenCharsRegex = /[\u2000-\u200F\u202A-\u202F\u0300-\u036f\uFEFF\s]/g;
            function escapeRegExp(string) {
                return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            }
            exports.escapeRegExp = escapeRegExp;
            function globToRegexp(glob, extended) {
                extended = typeof (extended) === 'boolean' ? extended : true;
                let pat = escapeRegExp(glob);
                pat = pat.replace(/\\\*/g, '.*');
                pat = pat.replace(/\?/g, '.');
                if (extended) {
                    pat = pat.replace(/\\\[(!|)(.*)\\]/g, function (match, p1, p2, offset, string) {
                        const first = p1 && '^' || '';
                        const second = p2.replace(/\\-/, '-');
                        return '[' + first + second + ']';
                    });
                }
                return pat;
            }
            exports.globToRegexp = globToRegexp;
            function ensureNoTrailingSlash(url) {
                if (url && url.endsWith("/")) {
                    return url.substr(0, url.length - 1);
                }
                else {
                    return url;
                }
            }
            exports.ensureNoTrailingSlash = ensureNoTrailingSlash;
            function sleep(ms, value) {
                return new Promise((resolve => {
                    setTimeout(resolve, ms, value);
                }));
            }
            exports.sleep = sleep;
            function isNullOrUndefined(val) {
                return val === null || val === undefined;
            }
            exports.isNullOrUndefined = isNullOrUndefined;
            function defer() {
                let resolve;
                let reject;
                const promise = new Promise((_resolve, _reject) => {
                    resolve = _resolve;
                    reject = _reject;
                });
                return { resolve, reject, promise };
            }
            exports.defer = defer;
            function promiseMapSeries(promises, fn) {
                return __awaiter(this, void 0, void 0, function* () {
                    for (const o of yield promises) {
                        yield fn(yield o);
                    }
                });
            }
            exports.promiseMapSeries = promiseMapSeries;
            function promiseTry(fn) {
                return new Promise((resolve) => resolve(fn()));
            }
            exports.promiseTry = promiseTry;
            let crypto;
            function setCrypto(c) {
                crypto = c;
            }
            exports.setCrypto = setCrypto;
            function getCrypto() {
                return crypto;
            }
            exports.getCrypto = getCrypto;
        }, { "unhomoglyph": 50 }], 126: [function (require, module, exports) {
            "use strict";
            var __createBinding = (this && this.__createBinding) || (Object.create ? (function (o, m, k, k2) {
                if (k2 === undefined)
                    k2 = k;
                Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
            }) : (function (o, m, k, k2) {
                if (k2 === undefined)
                    k2 = k;
                o[k2] = m[k];
            }));
            var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function (o, v) {
                Object.defineProperty(o, "default", { enumerable: true, value: v });
            }) : function (o, v) {
                o["default"] = v;
            });
            var __importStar = (this && this.__importStar) || function (mod) {
                if (mod && mod.__esModule)
                    return mod;
                var result = {};
                if (mod != null)
                    for (var k in mod)
                        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                            __createBinding(result, mod, k);
                __setModuleDefault(result, mod);
                return result;
            };
            var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
                function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
                return new (P || (P = Promise))(function (resolve, reject) {
                    function fulfilled(value) { try {
                        step(generator.next(value));
                    }
                    catch (e) {
                        reject(e);
                    } }
                    function rejected(value) { try {
                        step(generator["throw"](value));
                    }
                    catch (e) {
                        reject(e);
                    } }
                    function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
                    step((generator = generator.apply(thisArg, _arguments || [])).next());
                });
            };
            Object.defineProperty(exports, "__esModule", { value: true });
            exports.createNewMatrixCall = exports.setVideoInput = exports.setAudioInput = exports.setAudioOutput = exports.MatrixCall = exports.CallError = exports.getDesktopCapturerSources = exports.CallErrorCode = exports.CallEvent = exports.CallParty = exports.CallDirection = exports.CallType = exports.CallState = void 0;
            const logger_1 = require("../logger");
            const events_1 = require("events");
            const utils = __importStar(require("../utils"));
            const event_1 = require("../@types/event");
            const randomstring_1 = require("../randomstring");
            var CallState;
            (function (CallState) {
                CallState["Fledgling"] = "fledgling";
                CallState["InviteSent"] = "invite_sent";
                CallState["WaitLocalMedia"] = "wait_local_media";
                CallState["CreateOffer"] = "create_offer";
                CallState["CreateAnswer"] = "create_answer";
                CallState["Connecting"] = "connecting";
                CallState["Connected"] = "connected";
                CallState["Ringing"] = "ringing";
                CallState["Ended"] = "ended";
            })(CallState = exports.CallState || (exports.CallState = {}));
            var CallType;
            (function (CallType) {
                CallType["Voice"] = "voice";
                CallType["Video"] = "video";
            })(CallType = exports.CallType || (exports.CallType = {}));
            var CallDirection;
            (function (CallDirection) {
                CallDirection["Inbound"] = "inbound";
                CallDirection["Outbound"] = "outbound";
            })(CallDirection = exports.CallDirection || (exports.CallDirection = {}));
            var CallParty;
            (function (CallParty) {
                CallParty["Local"] = "local";
                CallParty["Remote"] = "remote";
            })(CallParty = exports.CallParty || (exports.CallParty = {}));
            var CallEvent;
            (function (CallEvent) {
                CallEvent["Hangup"] = "hangup";
                CallEvent["State"] = "state";
                CallEvent["Error"] = "error";
                CallEvent["Replaced"] = "replaced";
                CallEvent["LocalHoldUnhold"] = "local_hold_unhold";
                CallEvent["RemoteHoldUnhold"] = "remote_hold_unhold";
                CallEvent["HoldUnhold"] = "hold_unhold";
            })(CallEvent = exports.CallEvent || (exports.CallEvent = {}));
            var CallErrorCode;
            (function (CallErrorCode) {
                CallErrorCode["UserHangup"] = "user_hangup";
                CallErrorCode["LocalOfferFailed"] = "local_offer_failed";
                CallErrorCode["NoUserMedia"] = "no_user_media";
                CallErrorCode["UnknownDevices"] = "unknown_devices";
                CallErrorCode["SendInvite"] = "send_invite";
                CallErrorCode["CreateAnswer"] = "create_answer";
                CallErrorCode["SendAnswer"] = "send_answer";
                CallErrorCode["SetRemoteDescription"] = "set_remote_description";
                CallErrorCode["SetLocalDescription"] = "set_local_description";
                CallErrorCode["AnsweredElsewhere"] = "answered_elsewhere";
                CallErrorCode["IceFailed"] = "ice_failed";
                CallErrorCode["InviteTimeout"] = "invite_timeout";
                CallErrorCode["Replaced"] = "replaced";
                CallErrorCode["SignallingFailed"] = "signalling_timeout";
            })(CallErrorCode = exports.CallErrorCode || (exports.CallErrorCode = {}));
            var ConstraintsType;
            (function (ConstraintsType) {
                ConstraintsType["Audio"] = "audio";
                ConstraintsType["Video"] = "video";
            })(ConstraintsType || (ConstraintsType = {}));
            const VOIP_PROTO_VERSION = 1;
            const FALLBACK_ICE_SERVER = 'stun:turn.matrix.org';
            const CALL_TIMEOUT_MS = 60000;
            function getDesktopCapturerSources() {
                const options = {
                    thumbnailSize: {
                        height: 176,
                        width: 312,
                    },
                    types: [
                        "screen",
                        "window",
                    ],
                };
                return window.electron.getDesktopCapturerSources(options);
            }
            exports.getDesktopCapturerSources = getDesktopCapturerSources;
            class CallError extends Error {
                constructor(code, msg, err) {
                    super(msg + ": " + err);
                    this.code = code;
                }
            }
            exports.CallError = CallError;
            function genCallID() {
                return Date.now().toString() + randomstring_1.randomString(16);
            }
            class MatrixCall extends events_1.EventEmitter {
                constructor(opts) {
                    super();
                    this.remoteCandidateBuffer = new Map();
                    this.gotUserMediaForInvite = (stream) => __awaiter(this, void 0, void 0, function* () {
                        if (this.successor) {
                            this.successor.gotUserMediaForAnswer(stream);
                            return;
                        }
                        if (this.callHasEnded()) {
                            this.stopAllMedia();
                            return;
                        }
                        this.localAVStream = stream;
                        logger_1.logger.info("Got local AV stream with id " + this.localAVStream.id);
                        this.setState(CallState.CreateOffer);
                        logger_1.logger.debug("gotUserMediaForInvite -> " + this.type);
                        const videoEl = this.getLocalVideoElement();
                        if (videoEl && this.type === CallType.Video) {
                            videoEl.autoplay = true;
                            if (this.screenSharingStream) {
                                logger_1.logger.debug("Setting screen sharing stream to the local video element");
                                videoEl.srcObject = this.screenSharingStream;
                            }
                            else {
                                videoEl.srcObject = stream;
                            }
                            videoEl.muted = true;
                            try {
                                yield videoEl.play();
                            }
                            catch (e) {
                                logger_1.logger.info("Failed to play local video element", e);
                            }
                        }
                        setTracksEnabled(stream.getAudioTracks(), true);
                        for (const audioTrack of stream.getAudioTracks()) {
                            logger_1.logger.info("Adding audio track with id " + audioTrack.id);
                            this.peerConn.addTrack(audioTrack, stream);
                        }
                        for (const videoTrack of (this.screenSharingStream || stream).getVideoTracks()) {
                            logger_1.logger.info("Adding video track with id " + videoTrack.id);
                            this.peerConn.addTrack(videoTrack, stream);
                        }
                    });
                    this.gotUserMediaForAnswer = (stream) => __awaiter(this, void 0, void 0, function* () {
                        if (this.callHasEnded()) {
                            return;
                        }
                        const localVidEl = this.getLocalVideoElement();
                        if (localVidEl && this.type === CallType.Video) {
                            localVidEl.autoplay = true;
                            localVidEl.srcObject = stream;
                            localVidEl.muted = true;
                            try {
                                yield localVidEl.play();
                            }
                            catch (e) {
                                logger_1.logger.info("Failed to play local video element", e);
                            }
                        }
                        this.localAVStream = stream;
                        logger_1.logger.info("Got local AV stream with id " + this.localAVStream.id);
                        setTracksEnabled(stream.getAudioTracks(), true);
                        for (const track of stream.getTracks()) {
                            this.peerConn.addTrack(track, stream);
                        }
                        this.setState(CallState.CreateAnswer);
                        let myAnswer;
                        try {
                            myAnswer = yield this.peerConn.createAnswer();
                        }
                        catch (err) {
                            logger_1.logger.debug("Failed to create answer: ", err);
                            this.terminate(CallParty.Local, CallErrorCode.CreateAnswer, true);
                            return;
                        }
                        try {
                            yield this.peerConn.setLocalDescription(myAnswer);
                            this.setState(CallState.Connecting);
                            yield new Promise(resolve => {
                                setTimeout(resolve, 200);
                            });
                            this.sendAnswer();
                        }
                        catch (err) {
                            logger_1.logger.debug("Error setting local description!", err);
                            this.terminate(CallParty.Local, CallErrorCode.SetLocalDescription, true);
                            return;
                        }
                    });
                    this.gotLocalIceCandidate = (event) => {
                        if (event.candidate) {
                            logger_1.logger.debug("Got local ICE " + event.candidate.sdpMid + " candidate: " +
                                event.candidate.candidate);
                            if (this.callHasEnded())
                                return;
                            if (event.candidate.candidate !== '' || !this.sentEndOfCandidates) {
                                this.queueCandidate(event.candidate);
                                if (event.candidate.candidate === '')
                                    this.sentEndOfCandidates = true;
                            }
                        }
                    };
                    this.onIceGatheringStateChange = (event) => {
                        logger_1.logger.debug("ice gathering state changed to " + this.peerConn.iceGatheringState);
                        if (this.peerConn.iceGatheringState === 'complete' && !this.sentEndOfCandidates) {
                            const c = {
                                candidate: '',
                            };
                            this.queueCandidate(c);
                            this.sentEndOfCandidates = true;
                        }
                    };
                    this.gotLocalOffer = (description) => __awaiter(this, void 0, void 0, function* () {
                        logger_1.logger.debug("Created offer: ", description);
                        if (this.callHasEnded()) {
                            logger_1.logger.debug("Ignoring newly created offer on call ID " + this.callId +
                                " because the call has ended");
                            return;
                        }
                        try {
                            yield this.peerConn.setLocalDescription(description);
                        }
                        catch (err) {
                            logger_1.logger.debug("Error setting local description!", err);
                            this.terminate(CallParty.Local, CallErrorCode.SetLocalDescription, true);
                            return;
                        }
                        if (this.peerConn.iceGatheringState === 'gathering') {
                            yield new Promise(resolve => {
                                setTimeout(resolve, 200);
                            });
                        }
                        if (this.callHasEnded())
                            return;
                        const eventType = this.state === CallState.CreateOffer ? event_1.EventType.CallInvite : event_1.EventType.CallNegotiate;
                        const content = {
                            lifetime: CALL_TIMEOUT_MS,
                        };
                        if (this.state === CallState.CreateOffer) {
                            content.offer = this.peerConn.localDescription;
                        }
                        else {
                            content.description = this.peerConn.localDescription;
                        }
                        if (this.client._supportsCallTransfer) {
                            content.capabilities = {
                                'm.call.transferee': true,
                            };
                        }
                        logger_1.logger.info(`Discarding ${this.candidateSendQueue.length} candidates that will be sent in offer`);
                        this.candidateSendQueue = [];
                        try {
                            yield this.sendVoipEvent(eventType, content);
                        }
                        catch (error) {
                            logger_1.logger.error("Failed to send invite", error);
                            if (error.event)
                                this.client.cancelPendingEvent(error.event);
                            let code = CallErrorCode.SignallingFailed;
                            let message = "Signalling failed";
                            if (this.state === CallState.CreateOffer) {
                                code = CallErrorCode.SendInvite;
                                message = "Failed to send invite";
                            }
                            if (error.name == 'UnknownDeviceError') {
                                code = CallErrorCode.UnknownDevices;
                                message = "Unknown devices present in the room";
                            }
                            this.emit(CallEvent.Error, new CallError(code, message, error));
                            this.terminate(CallParty.Local, code, false);
                            return;
                        }
                        this.sendCandidateQueue();
                        if (this.state === CallState.CreateOffer) {
                            this.inviteOrAnswerSent = true;
                            this.setState(CallState.InviteSent);
                            this.inviteTimeout = setTimeout(() => {
                                this.inviteTimeout = null;
                                if (this.state === CallState.InviteSent) {
                                    this.hangup(CallErrorCode.InviteTimeout, false);
                                }
                            }, CALL_TIMEOUT_MS);
                        }
                    });
                    this.getLocalOfferFailed = (err) => {
                        logger_1.logger.error("Failed to get local offer", err);
                        this.emit(CallEvent.Error, new CallError(CallErrorCode.LocalOfferFailed, "Failed to get local offer!", err));
                        this.terminate(CallParty.Local, CallErrorCode.LocalOfferFailed, false);
                    };
                    this.getUserMediaFailed = (err) => {
                        if (this.successor) {
                            this.successor.getUserMediaFailed(err);
                            return;
                        }
                        logger_1.logger.warn("Failed to get user media - ending call", err);
                        this.emit(CallEvent.Error, new CallError(CallErrorCode.NoUserMedia, "Couldn't start capturing media! Is your microphone set up and " +
                            "does this app have permission?", err));
                        this.terminate(CallParty.Local, CallErrorCode.NoUserMedia, false);
                    };
                    this.onIceConnectionStateChanged = () => {
                        if (this.callHasEnded()) {
                            return;
                        }
                        logger_1.logger.debug("Call ID " + this.callId + ": ICE connection state changed to: " + this.peerConn.iceConnectionState);
                        if (this.peerConn.iceConnectionState == 'connected') {
                            this.setState(CallState.Connected);
                        }
                        else if (this.peerConn.iceConnectionState == 'failed') {
                            this.hangup(CallErrorCode.IceFailed, false);
                        }
                    };
                    this.onSignallingStateChanged = () => {
                        logger_1.logger.debug("call " + this.callId + ": Signalling state changed to: " +
                            this.peerConn.signalingState);
                    };
                    this.onTrack = (ev) => {
                        if (ev.streams.length === 0) {
                            logger_1.logger.warn(`Streamless ${ev.track.kind} found: ignoring.`);
                            return;
                        }
                        if (this.remoteStream && ev.streams[0].id !== this.remoteStream.id) {
                            logger_1.logger.warn(`Ignoring new stream ID ${ev.streams[0].id}: we already have stream ID ${this.remoteStream.id}`);
                            return;
                        }
                        if (!this.remoteStream) {
                            logger_1.logger.info("Got remote stream with id " + ev.streams[0].id);
                        }
                        this.remoteStream = ev.streams[0];
                        logger_1.logger.debug(`Track id ${ev.track.id} of kind ${ev.track.kind} added`);
                        if (ev.track.kind === 'video') {
                            if (this.remoteVideoElement) {
                                this.playRemoteVideo();
                            }
                        }
                        else {
                            if (this.remoteAudioElement)
                                this.playRemoteAudio();
                        }
                    };
                    this.onNegotiationNeeded = () => __awaiter(this, void 0, void 0, function* () {
                        logger_1.logger.info("Negotation is needed!");
                        if (this.state !== CallState.CreateOffer && this.opponentVersion === 0) {
                            logger_1.logger.info("Opponent does not support renegotiation: ignoring negotiationneeded event");
                            return;
                        }
                        this.makingOffer = true;
                        try {
                            const myOffer = yield this.peerConn.createOffer();
                            yield this.gotLocalOffer(myOffer);
                        }
                        catch (e) {
                            this.getLocalOfferFailed(e);
                            return;
                        }
                        finally {
                            this.makingOffer = false;
                        }
                    });
                    this.onHangupReceived = (msg) => {
                        logger_1.logger.debug("Hangup received for call ID " + this.callId);
                        if (this.partyIdMatches(msg) || this.state === CallState.Ringing) {
                            this.terminate(CallParty.Remote, msg.reason || CallErrorCode.UserHangup, true);
                        }
                        else {
                            logger_1.logger.info(`Ignoring message from party ID ${msg.party_id}: our partner is ${this.opponentPartyId}`);
                        }
                    };
                    this.onRejectReceived = (msg) => {
                        logger_1.logger.debug("Reject received for call ID " + this.callId);
                        const shouldTerminate = (([CallState.InviteSent, CallState.Ringing].includes(this.state)) ||
                            this.state === CallState.Fledgling && this.direction === CallDirection.Inbound);
                        if (shouldTerminate) {
                            this.terminate(CallParty.Remote, CallErrorCode.UserHangup, true);
                        }
                        else {
                            logger_1.logger.debug(`Call is in state: ${this.state}: ignoring reject`);
                        }
                    };
                    this.onAnsweredElsewhere = (msg) => {
                        logger_1.logger.debug("Call ID " + this.callId + " answered elsewhere");
                        this.terminate(CallParty.Remote, CallErrorCode.AnsweredElsewhere, true);
                    };
                    this.roomId = opts.roomId;
                    this.client = opts.client;
                    this.type = null;
                    this.forceTURN = opts.forceTURN;
                    this.ourPartyId = this.client.deviceId;
                    this.turnServers = opts.turnServers || [];
                    if (this.turnServers.length === 0 && this.client.isFallbackICEServerAllowed()) {
                        this.turnServers.push({
                            urls: [FALLBACK_ICE_SERVER],
                        });
                    }
                    for (const server of this.turnServers) {
                        utils.checkObjectHasKeys(server, ["urls"]);
                    }
                    this.callId = genCallID();
                    this.state = CallState.Fledgling;
                    this.candidateSendQueue = [];
                    this.candidateSendTries = 0;
                    this.sentEndOfCandidates = false;
                    this.inviteOrAnswerSent = false;
                    this.makingOffer = false;
                    this.remoteOnHold = false;
                    this.unholdingRemote = false;
                    this.micMuted = false;
                    this.vidMuted = false;
                }
                placeVoiceCall() {
                    return __awaiter(this, void 0, void 0, function* () {
                        logger_1.logger.debug("placeVoiceCall");
                        this.checkForErrorListener();
                        const constraints = getUserMediaContraints(ConstraintsType.Audio);
                        yield this.placeCallWithConstraints(constraints);
                        this.type = CallType.Voice;
                    });
                }
                placeVideoCall(remoteVideoElement, localVideoElement) {
                    return __awaiter(this, void 0, void 0, function* () {
                        logger_1.logger.debug("placeVideoCall");
                        this.checkForErrorListener();
                        this.localVideoElement = localVideoElement;
                        this.remoteVideoElement = remoteVideoElement;
                        const constraints = getUserMediaContraints(ConstraintsType.Video);
                        yield this.placeCallWithConstraints(constraints);
                        this.type = CallType.Video;
                    });
                }
                placeScreenSharingCall(remoteVideoElement, localVideoElement, selectDesktopCapturerSource) {
                    var _a;
                    return __awaiter(this, void 0, void 0, function* () {
                        logger_1.logger.debug("placeScreenSharingCall");
                        this.checkForErrorListener();
                        this.localVideoElement = localVideoElement;
                        this.remoteVideoElement = remoteVideoElement;
                        try {
                            const screenshareConstraints = yield getScreenshareContraints(selectDesktopCapturerSource);
                            if (!screenshareConstraints)
                                return;
                            if ((_a = window.electron) === null || _a === void 0 ? void 0 : _a.getDesktopCapturerSources) {
                                logger_1.logger.debug("Getting screen stream using getUserMedia()...");
                                this.screenSharingStream = yield navigator.mediaDevices.getUserMedia(screenshareConstraints);
                            }
                            else {
                                logger_1.logger.debug("Getting screen stream using getDisplayMedia()...");
                                this.screenSharingStream = yield navigator.mediaDevices.getDisplayMedia(screenshareConstraints);
                            }
                            logger_1.logger.debug("Got screen stream, requesting audio stream...");
                            const audioConstraints = getUserMediaContraints(ConstraintsType.Audio);
                            this.placeCallWithConstraints(audioConstraints);
                        }
                        catch (err) {
                            this.emit(CallEvent.Error, new CallError(CallErrorCode.NoUserMedia, "Failed to get screen-sharing stream: ", err));
                        }
                        this.type = CallType.Video;
                    });
                }
                getOpponentMember() {
                    return this.opponentMember;
                }
                opponentCanBeTransferred() {
                    return Boolean(this.opponentCaps && this.opponentCaps["m.call.transferee"]);
                }
                getLocalVideoElement() {
                    return this.localVideoElement;
                }
                getRemoteVideoElement() {
                    return this.remoteVideoElement;
                }
                getRemoteAudioElement() {
                    return this.remoteAudioElement;
                }
                setLocalVideoElement(element) {
                    return __awaiter(this, void 0, void 0, function* () {
                        this.localVideoElement = element;
                        if (element && this.localAVStream && this.type === CallType.Video) {
                            element.autoplay = true;
                            element.srcObject = this.localAVStream;
                            element.muted = true;
                            try {
                                yield element.play();
                            }
                            catch (e) {
                                logger_1.logger.info("Failed to play local video element", e);
                            }
                        }
                    });
                }
                setRemoteVideoElement(element) {
                    if (element === this.remoteVideoElement)
                        return;
                    element.autoplay = true;
                    if (this.remoteAudioElement)
                        element.muted = true;
                    this.remoteVideoElement = element;
                    if (this.remoteStream) {
                        this.playRemoteVideo();
                    }
                }
                setRemoteAudioElement(element) {
                    return __awaiter(this, void 0, void 0, function* () {
                        if (element === this.remoteAudioElement)
                            return;
                        this.remoteAudioElement = element;
                        if (this.remoteStream)
                            this.playRemoteAudio();
                    });
                }
                getCurrentCallStats() {
                    return __awaiter(this, void 0, void 0, function* () {
                        if (this.callHasEnded()) {
                            return this.callStatsAtEnd;
                        }
                        return this.collectCallStats();
                    });
                }
                collectCallStats() {
                    return __awaiter(this, void 0, void 0, function* () {
                        if (!this.peerConn)
                            return;
                        const statsReport = yield this.peerConn.getStats();
                        const stats = [];
                        for (const item of statsReport) {
                            stats.push(item[1]);
                        }
                        return stats;
                    });
                }
                initWithInvite(event) {
                    return __awaiter(this, void 0, void 0, function* () {
                        const invite = event.getContent();
                        this.direction = CallDirection.Inbound;
                        const haveTurnCreds = yield this.client._checkTurnServers();
                        if (!haveTurnCreds) {
                            logger_1.logger.warn("Failed to get TURN credentials! Proceeding with call anyway...");
                        }
                        this.peerConn = this.createPeerConnection();
                        this.chooseOpponent(event);
                        try {
                            yield this.peerConn.setRemoteDescription(invite.offer);
                        }
                        catch (e) {
                            logger_1.logger.debug("Failed to set remote description", e);
                            this.terminate(CallParty.Local, CallErrorCode.SetRemoteDescription, false);
                            return;
                        }
                        if (!this.remoteStream || this.remoteStream.getTracks().length === 0) {
                            logger_1.logger.error("No remote stream or no tracks after setting remote description!");
                            this.terminate(CallParty.Local, CallErrorCode.SetRemoteDescription, false);
                            return;
                        }
                        this.type = this.remoteStream.getTracks().some(t => t.kind === 'video') ? CallType.Video : CallType.Voice;
                        this.setState(CallState.Ringing);
                        if (event.getLocalAge()) {
                            setTimeout(() => {
                                if (this.state == CallState.Ringing) {
                                    logger_1.logger.debug("Call invite has expired. Hanging up.");
                                    this.hangupParty = CallParty.Remote;
                                    this.setState(CallState.Ended);
                                    this.stopAllMedia();
                                    if (this.peerConn.signalingState != 'closed') {
                                        this.peerConn.close();
                                    }
                                    this.emit(CallEvent.Hangup);
                                }
                            }, invite.lifetime - event.getLocalAge());
                        }
                    });
                }
                initWithHangup(event) {
                    this.setState(CallState.Ended);
                }
                answer() {
                    return __awaiter(this, void 0, void 0, function* () {
                        if (this.inviteOrAnswerSent) {
                            return;
                        }
                        logger_1.logger.debug(`Answering call ${this.callId} of type ${this.type}`);
                        if (!this.localAVStream && !this.waitForLocalAVStream) {
                            const constraints = getUserMediaContraints(this.type == CallType.Video ?
                                ConstraintsType.Video :
                                ConstraintsType.Audio);
                            logger_1.logger.log("Getting user media with constraints", constraints);
                            this.setState(CallState.WaitLocalMedia);
                            this.waitForLocalAVStream = true;
                            try {
                                const mediaStream = yield navigator.mediaDevices.getUserMedia(constraints);
                                this.waitForLocalAVStream = false;
                                this.gotUserMediaForAnswer(mediaStream);
                            }
                            catch (e) {
                                this.getUserMediaFailed(e);
                                return;
                            }
                        }
                        else if (this.localAVStream) {
                            this.gotUserMediaForAnswer(this.localAVStream);
                        }
                        else if (this.waitForLocalAVStream) {
                            this.setState(CallState.WaitLocalMedia);
                        }
                    });
                }
                replacedBy(newCall) {
                    logger_1.logger.debug(this.callId + " being replaced by " + newCall.callId);
                    if (this.state === CallState.WaitLocalMedia) {
                        logger_1.logger.debug("Telling new call to wait for local media");
                        newCall.waitForLocalAVStream = true;
                    }
                    else if (this.state === CallState.CreateOffer) {
                        logger_1.logger.debug("Handing local stream to new call");
                        newCall.gotUserMediaForAnswer(this.localAVStream);
                        delete (this.localAVStream);
                    }
                    else if (this.state === CallState.InviteSent) {
                        logger_1.logger.debug("Handing local stream to new call");
                        newCall.gotUserMediaForAnswer(this.localAVStream);
                        delete (this.localAVStream);
                    }
                    newCall.localVideoElement = this.localVideoElement;
                    newCall.remoteVideoElement = this.remoteVideoElement;
                    newCall.remoteAudioElement = this.remoteAudioElement;
                    this.successor = newCall;
                    this.emit(CallEvent.Replaced, newCall);
                    this.hangup(CallErrorCode.Replaced, true);
                }
                hangup(reason, suppressEvent) {
                    if (this.callHasEnded())
                        return;
                    logger_1.logger.debug("Ending call " + this.callId);
                    this.terminate(CallParty.Local, reason, !suppressEvent);
                    const content = {};
                    if (reason !== CallErrorCode.UserHangup)
                        content['reason'] = reason;
                    this.sendVoipEvent(event_1.EventType.CallHangup, {});
                }
                reject() {
                    if (this.state !== CallState.Ringing) {
                        throw Error("Call must be in 'ringing' state to reject!");
                    }
                    if (this.opponentVersion < 1) {
                        logger_1.logger.info(`Opponent version is less than 1 (${this.opponentVersion}): sending hangup instead of reject`);
                        this.hangup(CallErrorCode.UserHangup, true);
                        return;
                    }
                    logger_1.logger.debug("Rejecting call: " + this.callId);
                    this.terminate(CallParty.Local, CallErrorCode.UserHangup, true);
                    this.sendVoipEvent(event_1.EventType.CallReject, {});
                }
                setLocalVideoMuted(muted) {
                    this.vidMuted = muted;
                    this.updateMuteStatus();
                }
                isLocalVideoMuted() {
                    return this.vidMuted;
                }
                setMicrophoneMuted(muted) {
                    this.micMuted = muted;
                    this.updateMuteStatus();
                }
                isMicrophoneMuted() {
                    return this.micMuted;
                }
                isRemoteOnHold() {
                    return this.remoteOnHold;
                }
                setRemoteOnHold(onHold) {
                    if (this.isRemoteOnHold() === onHold)
                        return;
                    this.remoteOnHold = onHold;
                    if (!onHold)
                        this.unholdingRemote = true;
                    for (const tranceiver of this.peerConn.getTransceivers()) {
                        tranceiver.direction = onHold ? 'inactive' : 'sendrecv';
                    }
                    this.updateMuteStatus();
                    if (!onHold) {
                        this.playRemoteAudio();
                    }
                    this.emit(CallEvent.RemoteHoldUnhold, this.remoteOnHold);
                }
                isLocalOnHold() {
                    if (this.state !== CallState.Connected)
                        return false;
                    if (this.unholdingRemote)
                        return false;
                    let callOnHold = true;
                    for (const tranceiver of this.peerConn.getTransceivers()) {
                        const trackOnHold = ['inactive', 'recvonly'].includes(tranceiver.currentDirection);
                        if (!trackOnHold)
                            callOnHold = false;
                    }
                    return callOnHold;
                }
                sendDtmfDigit(digit) {
                    for (const sender of this.peerConn.getSenders()) {
                        if (sender.track.kind === 'audio' && sender.dtmf) {
                            sender.dtmf.insertDTMF(digit);
                            return;
                        }
                    }
                    throw new Error("Unable to find a track to send DTMF on");
                }
                updateMuteStatus() {
                    if (!this.localAVStream) {
                        return;
                    }
                    const micShouldBeMuted = this.micMuted || this.remoteOnHold;
                    setTracksEnabled(this.localAVStream.getAudioTracks(), !micShouldBeMuted);
                    const vidShouldBeMuted = this.vidMuted || this.remoteOnHold;
                    setTracksEnabled(this.localAVStream.getVideoTracks(), !vidShouldBeMuted);
                    if (this.remoteOnHold) {
                        if (this.remoteAudioElement && this.remoteAudioElement.srcObject === this.remoteStream) {
                            this.remoteAudioElement.muted = true;
                        }
                        else if (this.remoteVideoElement && this.remoteVideoElement.srcObject === this.remoteStream) {
                            this.remoteVideoElement.muted = true;
                        }
                    }
                    else {
                        this.playRemoteAudio();
                    }
                }
                sendAnswer() {
                    return __awaiter(this, void 0, void 0, function* () {
                        const answerContent = {
                            answer: {
                                sdp: this.peerConn.localDescription.sdp,
                                type: this.peerConn.localDescription.type,
                            },
                        };
                        if (this.client._supportsCallTransfer) {
                            answerContent.capabilities = {
                                'm.call.transferee': true,
                            };
                        }
                        logger_1.logger.info(`Discarding ${this.candidateSendQueue.length} candidates that will be sent in answer`);
                        this.candidateSendQueue = [];
                        try {
                            yield this.sendVoipEvent(event_1.EventType.CallAnswer, answerContent);
                            this.inviteOrAnswerSent = true;
                        }
                        catch (error) {
                            this.setState(CallState.Ringing);
                            this.client.cancelPendingEvent(error.event);
                            let code = CallErrorCode.SendAnswer;
                            let message = "Failed to send answer";
                            if (error.name == 'UnknownDeviceError') {
                                code = CallErrorCode.UnknownDevices;
                                message = "Unknown devices present in the room";
                            }
                            this.emit(CallEvent.Error, new CallError(code, message, error));
                            throw error;
                        }
                        this.sendCandidateQueue();
                    });
                }
                onRemoteIceCandidatesReceived(ev) {
                    if (this.callHasEnded()) {
                        return;
                    }
                    const cands = ev.getContent().candidates;
                    if (!cands) {
                        logger_1.logger.info("Ignoring candidates event with no candidates!");
                        return;
                    }
                    const fromPartyId = ev.getContent().version === 0 ? null : ev.getContent().party_id || null;
                    if (this.opponentPartyId === undefined) {
                        logger_1.logger.info(`Bufferring ${cands.length} candidates until we pick an opponent`);
                        const bufferedCands = this.remoteCandidateBuffer.get(fromPartyId) || [];
                        bufferedCands.push(...cands);
                        this.remoteCandidateBuffer.set(fromPartyId, bufferedCands);
                        return;
                    }
                    if (!this.partyIdMatches(ev.getContent())) {
                        logger_1.logger.info(`Ignoring candidates from party ID ${ev.getContent().party_id}: ` +
                            `we have chosen party ID ${this.opponentPartyId}`);
                        return;
                    }
                    this.addIceCandidates(cands);
                }
                onAnswerReceived(event) {
                    return __awaiter(this, void 0, void 0, function* () {
                        if (this.callHasEnded()) {
                            return;
                        }
                        if (this.opponentPartyId !== undefined) {
                            logger_1.logger.info(`Ignoring answer from party ID ${event.getContent().party_id}: ` +
                                `we already have an answer/reject from ${this.opponentPartyId}`);
                            return;
                        }
                        this.chooseOpponent(event);
                        this.setState(CallState.Connecting);
                        try {
                            yield this.peerConn.setRemoteDescription(event.getContent().answer);
                        }
                        catch (e) {
                            logger_1.logger.debug("Failed to set remote description", e);
                            this.terminate(CallParty.Local, CallErrorCode.SetRemoteDescription, false);
                            return;
                        }
                        if (this.opponentPartyId !== null) {
                            try {
                                yield this.sendVoipEvent(event_1.EventType.CallSelectAnswer, {
                                    selected_party_id: this.opponentPartyId,
                                });
                            }
                            catch (err) {
                                logger_1.logger.warn("Failed to send select_answer event", err);
                            }
                        }
                    });
                }
                onSelectAnswerReceived(event) {
                    return __awaiter(this, void 0, void 0, function* () {
                        if (this.direction !== CallDirection.Inbound) {
                            logger_1.logger.warn("Got select_answer for an outbound call: ignoring");
                            return;
                        }
                        const selectedPartyId = event.getContent().selected_party_id;
                        if (selectedPartyId === undefined || selectedPartyId === null) {
                            logger_1.logger.warn("Got nonsensical select_answer with null/undefined selected_party_id: ignoring");
                            return;
                        }
                        if (selectedPartyId !== this.ourPartyId) {
                            logger_1.logger.info(`Got select_answer for party ID ${selectedPartyId}: we are party ID ${this.ourPartyId}.`);
                            this.terminate(CallParty.Remote, CallErrorCode.AnsweredElsewhere, true);
                        }
                    });
                }
                onNegotiateReceived(event) {
                    return __awaiter(this, void 0, void 0, function* () {
                        const description = event.getContent().description;
                        if (!description || !description.sdp || !description.type) {
                            logger_1.logger.info("Ignoring invalid m.call.negotiate event");
                            return;
                        }
                        const polite = this.direction === CallDirection.Inbound;
                        const offerCollision = ((description.type === 'offer') &&
                            (this.makingOffer || this.peerConn.signalingState != 'stable'));
                        this.ignoreOffer = !polite && offerCollision;
                        if (this.ignoreOffer) {
                            logger_1.logger.info("Ignoring colliding negotiate event because we're impolite");
                            return;
                        }
                        const prevLocalOnHold = this.isLocalOnHold();
                        if (description.type === 'answer') {
                            this.unholdingRemote = false;
                        }
                        try {
                            yield this.peerConn.setRemoteDescription(description);
                            if (description.type === 'offer') {
                                for (const tranceiver of this.peerConn.getTransceivers()) {
                                    tranceiver.direction = this.isRemoteOnHold() ? 'inactive' : 'sendrecv';
                                }
                                const localDescription = yield this.peerConn.createAnswer();
                                yield this.peerConn.setLocalDescription(localDescription);
                                for (const tranceiver of this.peerConn.getTransceivers()) {
                                    tranceiver.direction = tranceiver.currentDirection;
                                }
                                this.sendVoipEvent(event_1.EventType.CallNegotiate, {
                                    description: this.peerConn.localDescription,
                                });
                            }
                        }
                        catch (err) {
                            logger_1.logger.warn("Failed to complete negotiation", err);
                        }
                        const newLocalOnHold = this.isLocalOnHold();
                        if (prevLocalOnHold !== newLocalOnHold) {
                            this.emit(CallEvent.LocalHoldUnhold, newLocalOnHold);
                            this.emit(CallEvent.HoldUnhold, newLocalOnHold);
                        }
                    });
                }
                callHasEnded() {
                    return this.state === CallState.Ended;
                }
                playRemoteAudio() {
                    return __awaiter(this, void 0, void 0, function* () {
                        if (this.remoteVideoElement)
                            this.remoteVideoElement.muted = true;
                        this.remoteAudioElement.muted = false;
                        this.remoteAudioElement.srcObject = this.remoteStream;
                        try {
                            if (audioOutput) {
                                logger_1.logger.info("Setting audio sink to " + audioOutput + ", was " + this.remoteAudioElement.sinkId);
                                yield this.remoteAudioElement.setSinkId(audioOutput);
                            }
                        }
                        catch (e) {
                            logger_1.logger.warn("Couldn't set requested audio output device: using default", e);
                        }
                        try {
                            yield this.remoteAudioElement.play();
                        }
                        catch (e) {
                            logger_1.logger.error("Failed to play remote audio element", e);
                        }
                    });
                }
                playRemoteVideo() {
                    return __awaiter(this, void 0, void 0, function* () {
                        this.remoteVideoElement.srcObject = this.remoteStream;
                        logger_1.logger.info("playing remote video. stream active? " + this.remoteStream.active);
                        try {
                            yield this.remoteVideoElement.play();
                        }
                        catch (e) {
                            logger_1.logger.info("Failed to play remote video element", e);
                        }
                    });
                }
                setState(state) {
                    const oldState = this.state;
                    this.state = state;
                    this.emit(CallEvent.State, state, oldState);
                }
                sendVoipEvent(eventType, content) {
                    return this.client.sendEvent(this.roomId, eventType, Object.assign({}, content, {
                        version: VOIP_PROTO_VERSION,
                        call_id: this.callId,
                        party_id: this.ourPartyId,
                    }));
                }
                queueCandidate(content) {
                    this.candidateSendQueue.push(content);
                    if (this.state === CallState.Ringing || !this.inviteOrAnswerSent)
                        return;
                    const delay = this.direction === CallDirection.Inbound ? 500 : 2000;
                    if (this.candidateSendTries === 0) {
                        setTimeout(() => {
                            this.sendCandidateQueue();
                        }, delay);
                    }
                }
                transfer(targetUserId, targetRoomId) {
                    return __awaiter(this, void 0, void 0, function* () {
                        const profileInfo = yield this.client.getProfileInfo(targetUserId);
                        const replacementId = genCallID();
                        const body = {
                            replacement_id: genCallID(),
                            target_user: {
                                id: targetUserId,
                                display_name: profileInfo.display_name,
                                avatar_url: profileInfo.avatar_url,
                            },
                            create_call: replacementId,
                        };
                        if (targetRoomId)
                            body.target_room = targetRoomId;
                        return this.sendVoipEvent(event_1.EventType.CallReplaces, body);
                    });
                }
                terminate(hangupParty, hangupReason, shouldEmit) {
                    return __awaiter(this, void 0, void 0, function* () {
                        if (this.callHasEnded())
                            return;
                        this.callStatsAtEnd = yield this.collectCallStats();
                        if (this.inviteTimeout) {
                            clearTimeout(this.inviteTimeout);
                            this.inviteTimeout = null;
                        }
                        const remoteVid = this.getRemoteVideoElement();
                        const remoteAud = this.getRemoteAudioElement();
                        const localVid = this.getLocalVideoElement();
                        if (remoteVid) {
                            remoteVid.pause();
                            remoteVid.srcObject = null;
                        }
                        if (remoteAud) {
                            remoteAud.pause();
                            remoteAud.srcObject = null;
                            try {
                                yield this.remoteAudioElement.setSinkId('');
                            }
                            catch (e) {
                                logger_1.logger.warn("Failed to set sink ID back to default");
                            }
                        }
                        if (localVid) {
                            localVid.pause();
                            localVid.srcObject = null;
                        }
                        this.hangupParty = hangupParty;
                        this.hangupReason = hangupReason;
                        this.setState(CallState.Ended);
                        this.stopAllMedia();
                        if (this.peerConn && this.peerConn.signalingState !== 'closed') {
                            this.peerConn.close();
                        }
                        if (shouldEmit) {
                            this.emit(CallEvent.Hangup, this);
                        }
                    });
                }
                stopAllMedia() {
                    logger_1.logger.debug(`stopAllMedia (stream=${this.localAVStream})`);
                    if (this.localAVStream) {
                        for (const track of this.localAVStream.getTracks()) {
                            track.stop();
                        }
                    }
                    if (this.screenSharingStream) {
                        for (const track of this.screenSharingStream.getTracks()) {
                            track.stop();
                        }
                    }
                    if (this.remoteStream) {
                        for (const track of this.remoteStream.getTracks()) {
                            track.stop();
                        }
                    }
                }
                checkForErrorListener() {
                    if (this.listeners("error").length === 0) {
                        throw new Error("You MUST attach an error listener using call.on('error', function() {})");
                    }
                }
                sendCandidateQueue() {
                    return __awaiter(this, void 0, void 0, function* () {
                        if (this.candidateSendQueue.length === 0) {
                            return;
                        }
                        const cands = this.candidateSendQueue;
                        this.candidateSendQueue = [];
                        ++this.candidateSendTries;
                        const content = {
                            candidates: cands,
                        };
                        logger_1.logger.debug("Attempting to send " + cands.length + " candidates");
                        try {
                            yield this.sendVoipEvent(event_1.EventType.CallCandidates, content);
                        }
                        catch (error) {
                            if (error.event)
                                this.client.cancelPendingEvent(error.event);
                            this.candidateSendQueue.push(...cands);
                            if (this.candidateSendTries > 5) {
                                logger_1.logger.debug("Failed to send candidates on attempt " + this.candidateSendTries +
                                    ". Giving up on this call.", error);
                                const code = CallErrorCode.SignallingFailed;
                                const message = "Signalling failed";
                                this.emit(CallEvent.Error, new CallError(code, message, error));
                                this.hangup(code, false);
                                return;
                            }
                            const delayMs = 500 * Math.pow(2, this.candidateSendTries);
                            ++this.candidateSendTries;
                            logger_1.logger.debug("Failed to send candidates. Retrying in " + delayMs + "ms", error);
                            setTimeout(() => {
                                this.sendCandidateQueue();
                            }, delayMs);
                        }
                    });
                }
                placeCallWithConstraints(constraints) {
                    return __awaiter(this, void 0, void 0, function* () {
                        logger_1.logger.log("Getting user media with constraints", constraints);
                        this.client._callEventHandler.calls.set(this.callId, this);
                        this.setState(CallState.WaitLocalMedia);
                        this.direction = CallDirection.Outbound;
                        this.config = constraints;
                        const haveTurnCreds = yield this.client._checkTurnServers();
                        if (!haveTurnCreds) {
                            logger_1.logger.warn("Failed to get TURN credentials! Proceeding with call anyway...");
                        }
                        this.peerConn = this.createPeerConnection();
                        try {
                            const mediaStream = yield navigator.mediaDevices.getUserMedia(constraints);
                            this.gotUserMediaForInvite(mediaStream);
                        }
                        catch (e) {
                            this.getUserMediaFailed(e);
                            return;
                        }
                    });
                }
                createPeerConnection() {
                    const pc = new window.RTCPeerConnection({
                        iceTransportPolicy: this.forceTURN ? 'relay' : undefined,
                        iceServers: this.turnServers,
                        iceCandidatePoolSize: this.client._iceCandidatePoolSize,
                    });
                    pc.addEventListener('iceconnectionstatechange', this.onIceConnectionStateChanged);
                    pc.addEventListener('signalingstatechange', this.onSignallingStateChanged);
                    pc.addEventListener('icecandidate', this.gotLocalIceCandidate);
                    pc.addEventListener('icegatheringstatechange', this.onIceGatheringStateChange);
                    pc.addEventListener('track', this.onTrack);
                    pc.addEventListener('negotiationneeded', this.onNegotiationNeeded);
                    return pc;
                }
                partyIdMatches(msg) {
                    const msgPartyId = msg.version === 0 ? null : msg.party_id || null;
                    return msgPartyId === this.opponentPartyId;
                }
                chooseOpponent(ev) {
                    const msg = ev.getContent();
                    this.opponentVersion = msg.version;
                    if (this.opponentVersion === 0) {
                        this.opponentPartyId = null;
                    }
                    else {
                        this.opponentPartyId = msg.party_id || null;
                    }
                    this.opponentCaps = msg.capabilities || {};
                    this.opponentMember = ev.sender;
                    const bufferedCands = this.remoteCandidateBuffer.get(this.opponentPartyId);
                    if (bufferedCands) {
                        logger_1.logger.info(`Adding ${bufferedCands.length} buffered candidates for opponent ${this.opponentPartyId}`);
                        this.addIceCandidates(bufferedCands);
                    }
                    this.remoteCandidateBuffer = null;
                }
                addIceCandidates(cands) {
                    for (const cand of cands) {
                        if ((cand.sdpMid === null || cand.sdpMid === undefined) &&
                            (cand.sdpMLineIndex === null || cand.sdpMLineIndex === undefined)) {
                            logger_1.logger.debug("Ignoring remote ICE candidate with no sdpMid or sdpMLineIndex");
                            return;
                        }
                        logger_1.logger.debug("Got remote ICE " + cand.sdpMid + " candidate: " + cand.candidate);
                        try {
                            this.peerConn.addIceCandidate(cand);
                        }
                        catch (err) {
                            if (!this.ignoreOffer) {
                                logger_1.logger.info("Failed to add remore ICE candidate", err);
                            }
                        }
                    }
                }
            }
            exports.MatrixCall = MatrixCall;
            function setTracksEnabled(tracks, enabled) {
                for (let i = 0; i < tracks.length; i++) {
                    tracks[i].enabled = enabled;
                }
            }
            function getUserMediaContraints(type) {
                const isWebkit = !!navigator.webkitGetUserMedia;
                switch (type) {
                    case ConstraintsType.Audio: {
                        return {
                            audio: {
                                deviceId: audioInput ? { ideal: audioInput } : undefined,
                            },
                            video: false,
                        };
                    }
                    case ConstraintsType.Video: {
                        return {
                            audio: {
                                deviceId: audioInput ? { ideal: audioInput } : undefined,
                            }, video: {
                                deviceId: videoInput ? { ideal: videoInput } : undefined,
                                width: isWebkit ? { exact: 640 } : { ideal: 640 },
                                height: isWebkit ? { exact: 360 } : { ideal: 360 },
                            },
                        };
                    }
                }
            }
            function getScreenshareContraints(selectDesktopCapturerSource) {
                var _a;
                return __awaiter(this, void 0, void 0, function* () {
                    if (((_a = window.electron) === null || _a === void 0 ? void 0 : _a.getDesktopCapturerSources) && selectDesktopCapturerSource) {
                        logger_1.logger.debug("Electron getDesktopCapturerSources() is available...");
                        const selectedSource = yield selectDesktopCapturerSource();
                        if (!selectedSource)
                            return null;
                        return {
                            audio: false,
                            video: {
                                mandatory: {
                                    chromeMediaSource: "desktop",
                                    chromeMediaSourceId: selectedSource.id,
                                },
                            },
                        };
                    }
                    else {
                        logger_1.logger.debug("Electron desktopCapturer is not available...");
                        return {
                            audio: false,
                            video: true,
                        };
                    }
                });
            }
            let audioOutput;
            let audioInput;
            let videoInput;
            function setAudioOutput(deviceId) { audioOutput = deviceId; }
            exports.setAudioOutput = setAudioOutput;
            function setAudioInput(deviceId) { audioInput = deviceId; }
            exports.setAudioInput = setAudioInput;
            function setVideoInput(deviceId) { videoInput = deviceId; }
            exports.setVideoInput = setVideoInput;
            function createNewMatrixCall(client, roomId, options) {
                if (typeof (window) === 'undefined' || typeof (document) === 'undefined') {
                    return null;
                }
                try {
                    const supported = Boolean(window.RTCPeerConnection || window.RTCSessionDescription ||
                        window.RTCIceCandidate || navigator.mediaDevices);
                    if (!supported) {
                        logger_1.logger.error("WebRTC is not supported in this browser / environment");
                        return null;
                    }
                }
                catch (e) {
                    logger_1.logger.error("Exception thrown when trying to access WebRTC", e);
                    return null;
                }
                const optionsForceTURN = options ? options.forceTURN : false;
                const opts = {
                    client: client,
                    roomId: roomId,
                    turnServers: client.getTurnServers(),
                    forceTURN: client._forceTURN || optionsForceTURN,
                };
                const call = new MatrixCall(opts);
                client.reEmitter.reEmit(call, Object.values(CallEvent));
                return call;
            }
            exports.createNewMatrixCall = createNewMatrixCall;
        }, { "../@types/event": 53, "../logger": 97, "../randomstring": 112, "../utils": 125, "events": 36 }], 127: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", { value: true });
            exports.CallEventHandler = void 0;
            const logger_1 = require("../logger");
            const call_1 = require("./call");
            const event_1 = require("../@types/event");
            const RING_GRACE_PERIOD = 3000;
            class CallEventHandler {
                constructor(client) {
                    this.evaluateEventBuffer = () => {
                        if (this.client.getSyncState() === "SYNCING") {
                            if (this.callEventBuffer.some((e) => e.isBeingDecrypted()))
                                return;
                            const ignoreCallIds = new Set();
                            for (const ev of this.callEventBuffer) {
                                if (ev.getType() === event_1.EventType.CallAnswer ||
                                    ev.getType() === event_1.EventType.CallHangup) {
                                    ignoreCallIds.add(ev.getContent().call_id);
                                }
                            }
                            for (const e of this.callEventBuffer) {
                                if (e.getType() === event_1.EventType.CallInvite &&
                                    ignoreCallIds.has(e.getContent().call_id)) {
                                    continue;
                                }
                                try {
                                    this.handleCallEvent(e);
                                }
                                catch (e) {
                                    logger_1.logger.error("Caught exception handling call event", e);
                                }
                            }
                            this.callEventBuffer = [];
                        }
                    };
                    this.onEvent = (event) => {
                        if (event.getType().indexOf("m.call.") === 0 || event.isBeingDecrypted()) {
                            this.callEventBuffer.push(event);
                        }
                        if (event.isBeingDecrypted() || event.isDecryptionFailure()) {
                            event.once("Event.decrypted", () => {
                                if (event.getType().indexOf("m.call.") === -1)
                                    return;
                                if (this.callEventBuffer.includes(event)) {
                                    this.evaluateEventBuffer();
                                }
                                else {
                                    try {
                                        this.handleCallEvent(event);
                                    }
                                    catch (e) {
                                        logger_1.logger.error("Caught exception handling call event", e);
                                    }
                                }
                            });
                        }
                    };
                    this.client = client;
                    this.calls = new Map();
                    this.callEventBuffer = [];
                    this.candidateEventsByCall = new Map();
                    this.client.on("sync", this.evaluateEventBuffer);
                    this.client.on("event", this.onEvent);
                }
                stop() {
                    this.client.removeListener("sync", this.evaluateEventBuffer);
                    this.client.removeListener("event", this.onEvent);
                }
                handleCallEvent(event) {
                    const content = event.getContent();
                    let call = content.call_id ? this.calls.get(content.call_id) : undefined;
                    if (event.getType() === event_1.EventType.CallInvite) {
                        if (event.getSender() === this.client.credentials.userId) {
                            return;
                        }
                        if (event.getLocalAge() > content.lifetime - RING_GRACE_PERIOD) {
                            return;
                        }
                        if (call && call.state === call_1.CallState.Ended) {
                            return;
                        }
                        if (call) {
                            logger_1.logger.log(`WARN: Already have a MatrixCall with id ${content.call_id} but got an ` +
                                `invite. Clobbering.`);
                        }
                        const timeUntilTurnCresExpire = this.client.getTurnServersExpiry() - Date.now();
                        logger_1.logger.info("Current turn creds expire in " + timeUntilTurnCresExpire + " ms");
                        call = call_1.createNewMatrixCall(this.client, event.getRoomId(), {
                            forceTURN: this.client._forceTURN,
                        });
                        if (!call) {
                            logger_1.logger.log("Incoming call ID " + content.call_id + " but this client " +
                                "doesn't support WebRTC");
                            return;
                        }
                        call.callId = content.call_id;
                        call.initWithInvite(event);
                        this.calls.set(call.callId, call);
                        if (this.candidateEventsByCall.get(call.callId)) {
                            for (const ev of this.candidateEventsByCall.get(call.callId)) {
                                call.onRemoteIceCandidatesReceived(ev);
                            }
                        }
                        let existingCall;
                        for (const thisCall of this.calls.values()) {
                            const isCalling = [call_1.CallState.WaitLocalMedia, call_1.CallState.CreateOffer, call_1.CallState.InviteSent].includes(thisCall.state);
                            if (call.roomId === thisCall.roomId &&
                                thisCall.direction === call_1.CallDirection.Outbound &&
                                isCalling) {
                                existingCall = thisCall;
                                break;
                            }
                        }
                        if (existingCall) {
                            if (existingCall.state === call_1.CallState.WaitLocalMedia ||
                                existingCall.state === call_1.CallState.CreateOffer ||
                                existingCall.callId > call.callId) {
                                logger_1.logger.log("Glare detected: answering incoming call " + call.callId +
                                    " and canceling outgoing call " + existingCall.callId);
                                existingCall.replacedBy(call);
                                call.answer();
                            }
                            else {
                                logger_1.logger.log("Glare detected: rejecting incoming call " + call.callId +
                                    " and keeping outgoing call " + existingCall.callId);
                                call.hangup(call_1.CallErrorCode.Replaced, true);
                            }
                        }
                        else {
                            this.client.emit("Call.incoming", call);
                        }
                    }
                    else if (event.getType() === event_1.EventType.CallAnswer) {
                        if (!call) {
                            return;
                        }
                        if (event.getSender() === this.client.credentials.userId) {
                            if (call.state === call_1.CallState.Ringing) {
                                call.onAnsweredElsewhere(content);
                            }
                        }
                        else {
                            call.onAnswerReceived(event);
                        }
                    }
                    else if (event.getType() === event_1.EventType.CallCandidates) {
                        if (event.getSender() === this.client.credentials.userId) {
                            return;
                        }
                        if (!call) {
                            if (!this.candidateEventsByCall.has(content.call_id)) {
                                this.candidateEventsByCall.set(content.call_id, []);
                            }
                            this.candidateEventsByCall.get(content.call_id).push(event);
                        }
                        else {
                            call.onRemoteIceCandidatesReceived(event);
                        }
                    }
                    else if ([event_1.EventType.CallHangup, event_1.EventType.CallReject].includes(event.getType())) {
                        if (!call) {
                            call = call_1.createNewMatrixCall(this.client, event.getRoomId());
                            if (call) {
                                call.callId = content.call_id;
                                call.initWithHangup(event);
                                this.calls.set(content.call_id, call);
                            }
                        }
                        else {
                            if (call.state !== call_1.CallState.Ended) {
                                if (event.getType() === event_1.EventType.CallHangup) {
                                    call.onHangupReceived(content);
                                }
                                else {
                                    call.onRejectReceived(content);
                                }
                                this.calls.delete(content.call_id);
                            }
                        }
                    }
                    else if (event.getType() === event_1.EventType.CallSelectAnswer) {
                        if (!call)
                            return;
                        if (event.getContent().party_id === call.ourPartyId) {
                            return;
                        }
                        call.onSelectAnswerReceived(event);
                    }
                    else if (event.getType() === event_1.EventType.CallNegotiate) {
                        if (!call)
                            return;
                        if (event.getContent().party_id === call.ourPartyId) {
                            return;
                        }
                        call.onNegotiateReceived(event);
                    }
                }
            }
            exports.CallEventHandler = CallEventHandler;
        }, { "../@types/event": 53, "../logger": 97, "./call": 126 }] }, {}, [57]);
//# sourceMappingURL=browser-matrix.js.map